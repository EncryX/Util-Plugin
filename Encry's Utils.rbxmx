<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX3C62E9FCC9C64B048B9A8BB885218180">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">Encry&apos;s Utils</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX25790DCA0ECE47458F0FE55C53D1FFBC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">init</string>
				<token name="RunContext">3</token>
				<string name="ScriptGuid">{6F9AD9B9-B2D0-479B-80E8-E2295E3429E6}</string>
				<ProtectedString name="Source"><![CDATA[local toolbar = plugin:CreateToolbar("Encry's Utils")
local StudioService = game:GetService("StudioService")
local TweenService = game:GetService("TweenService")

local Resources = script.Parent:FindFirstChild("Resources")
if not Resources then
	local RestartButton = toolbar:CreateButton(
		"Util (Needs restart)",
		"Resources folder not found",
		"rbxassetid://138336801576694"
	)
	return
end

local successVersionChecker, VersionChecker = pcall(function()
	return require(Resources.Util.VersionChecker)
end)

if not successVersionChecker then
	local RestartButton = toolbar:CreateButton(
		"Util (Needs restart)",
		"Failed to load VersionChecker: " .. tostring(VersionChecker),
		"rbxassetid://93200537889042"
	)
	return
end

local versionChecker = VersionChecker.new(plugin)
local needsRestart, restartReason = versionChecker:checkRestartRequired()

local success, loadedModules = pcall(function()
	local ConnectionUtil = require(Resources.Util.ConnectionUtil)
	local GUI = Resources.GUI
	local Templates = Resources.Templates
	local Inserts = Resources.Inserts

	local SettingsManager = require(Resources.Util.SettingsManager)
	local InstancesManager = require(Resources.Util.InstancesManager)
	local PathChangerManager = require(Resources.Util.PathChangerManager)
	local MagicSelectManager = require(Resources.Util.MagicSelectManager)

	return {
		Resources = Resources,
		ConnectionUtil = ConnectionUtil,
		GUI = GUI,
		Templates = Templates,
		Inserts = Inserts,
		SettingsManager = SettingsManager,
		InstancesManager = InstancesManager,
		PathChangerManager = PathChangerManager,
		MagicSelectManager = MagicSelectManager
	}
end)

if needsRestart or not success then
	local finalReason = restartReason
	if not success then
		finalReason = "Module loading failed: " .. tostring(loadedModules)
		if needsRestart then
			finalReason = restartReason .. " Also: " .. finalReason
		end
	end

	local RestartButton = toolbar:CreateButton(
		"Util (Needs restart)",
		finalReason,
		"rbxassetid://93200537889042"
	)
	return
end

local ConnectionUtil = loadedModules.ConnectionUtil
local GUI = loadedModules.GUI
local Templates = loadedModules.Templates
local Inserts = loadedModules.Inserts
local SettingsManager = loadedModules.SettingsManager
local InstancesManager = loadedModules.InstancesManager
local PathChangerManager = loadedModules.PathChangerManager
local MagicSelectManager = loadedModules.MagicSelectManager

local conn = ConnectionUtil.new()

local PluginButton = toolbar:CreateButton(
	"Util",
	"Open Encry's Utils",
	"rbxassetid://138336801576694"
)

PluginButton.ClickableWhenViewportHidden = true

local function createInsertsDockInfo()
	return DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Float,
		false,
		false,
		900,
		400,
		900,
		400
	)
end

local PluginWidget = plugin:CreateDockWidgetPluginGui("Inserts", createInsertsDockInfo())
PluginWidget.Title = "Utils"
PluginWidget.Name = "Encry's Utils"

local newGUI = GUI.main_frame:Clone()
newGUI.Parent = PluginWidget

local settingsManager = SettingsManager.new(plugin)
local instancesManager = InstancesManager.new(newGUI, Templates, Inserts, Resources, conn, settingsManager)
local pathChangerManager = PathChangerManager.new(newGUI, Resources, conn, plugin)
local magicSelectManager = MagicSelectManager.new(newGUI, conn, plugin)

local animInfo = TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
local buttonAnimInfo = TweenInfo.new(0.2, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)

local function setupButtonAnimations()
	local setupButtons = {}

	local function setupButton(button)
		if not (button:IsA("ImageButton") or button:IsA("TextButton")) then return end
		if setupButtons[button] then return end

		setupButtons[button] = true

		local stroke = button:FindFirstChild("stroke") or button:FindFirstChildWhichIsA("UIStroke")

		local originalTransparency = button.BackgroundTransparency
		local originalStrokeThickness = stroke and stroke.Thickness or 0

		button.MouseEnter:Connect(function()
			TweenService:Create(button, buttonAnimInfo, {
				BackgroundTransparency = math.max(originalTransparency - 0.1, 0)
			}):Play()

			if stroke then
				TweenService:Create(stroke, buttonAnimInfo, {Thickness = originalStrokeThickness + 2}):Play()
			end
		end)

		button.MouseButton1Down:Connect(function()
			TweenService:Create(button, buttonAnimInfo, {
				BackgroundTransparency = math.max(originalTransparency - 0.2, 0)
			}):Play()

			if stroke then
				TweenService:Create(stroke, buttonAnimInfo, {Thickness = originalStrokeThickness + 3}):Play()
			end
		end)

		button.MouseButton1Up:Connect(function()
			TweenService:Create(button, buttonAnimInfo, {
				BackgroundTransparency = math.max(originalTransparency - 0.1, 0)
			}):Play()

			if stroke then
				TweenService:Create(stroke, buttonAnimInfo, {Thickness = originalStrokeThickness + 2}):Play()
			end
		end)

		button.MouseLeave:Connect(function()
			TweenService:Create(button, buttonAnimInfo, {
				BackgroundTransparency = originalTransparency
			}):Play()

			if stroke then
				TweenService:Create(stroke, buttonAnimInfo, {Thickness = originalStrokeThickness}):Play()
			end
		end)
	end

	local function scanForButtons(container)
		for _, descendant in pairs(container:GetDescendants()) do
			if descendant:IsA("ImageButton") or descendant:IsA("TextButton") then
				setupButton(descendant)
			end
		end
	end

	scanForButtons(newGUI)

	newGUI.DescendantAdded:Connect(function(descendant)
		if descendant:IsA("ImageButton") or descendant:IsA("TextButton") then
			task.wait(0.1)
			setupButton(descendant)
		end
	end)

	newGUI.DescendantRemoving:Connect(function(descendant)
		if setupButtons[descendant] then
			setupButtons[descendant] = nil
		end
	end)
end

local function animateFrameIn(frame)
	frame.Position = UDim2.new(0.5, 0, 1.5, 0)
	frame.Visible = true
	TweenService:Create(frame, animInfo, {
		Position = UDim2.new(0.5, 0, 0.5, 0)
	}):Play()
end

local function animateFrameOut(frame, callback)
	local tween = TweenService:Create(frame, animInfo, {
		Position = UDim2.new(0.5, 0, -0.5, 0)
	})
	tween.Completed:Connect(function()
		frame.Visible = false
		frame.Position = UDim2.new(0.5, 0, 0.5, 0)
		if callback then callback() end
	end)
	tween:Play()
end

local function resetGUI()
	if newGUI:FindFirstChild("button_container") then
		newGUI.button_container.Visible = true
		newGUI.button_container.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("insets_frame") then
		newGUI.insets_frame.Visible = false
		newGUI.insets_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("instance_frame") then
		newGUI.instance_frame.Visible = false
		newGUI.instance_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("path_changer_frame") then
		newGUI.path_changer_frame.Visible = false
		newGUI.path_changer_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("magic_select_frame") then
		newGUI.magic_select_frame.Visible = false
		newGUI.magic_select_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("settings_frame") then
		newGUI.settings_frame.Visible = false
		newGUI.settings_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end
end

if newGUI.button_container and newGUI.button_container:FindFirstChild("scroll") then
	local scroll = newGUI.button_container.scroll

	if scroll:FindFirstChild("open_inserts") then
		conn:trackConnection("ChangeOpenInsertsGUI",
			scroll.open_inserts.MouseButton1Down:Connect(function()
				animateFrameOut(newGUI.button_container, function()
					animateFrameIn(newGUI.insets_frame)
					instancesManager:refreshInsertsList()
				end)

				conn:trackConnection("InsertsGoBack",
					newGUI.insets_frame.go_back.MouseButton1Down:Connect(function()
						animateFrameOut(newGUI.insets_frame, function()
							animateFrameIn(newGUI.button_container)
						end)
					end)
				)
			end)    
		)
	end

	if scroll:FindFirstChild("change_path") then
		conn:trackConnection("ChangePathGUI",
			scroll.change_path.MouseButton1Down:Connect(function()
				animateFrameOut(newGUI.button_container, function()
					animateFrameIn(newGUI.path_changer_frame)
					pathChangerManager:initialize()
				end)

				conn:trackConnection("PathGoBack",
					newGUI.path_changer_frame.go_back.MouseButton1Down:Connect(function()
						animateFrameOut(newGUI.path_changer_frame, function()
							pathChangerManager:cancelSelection()
							animateFrameIn(newGUI.button_container)
						end)
					end)
				)
			end)    
		)
	end

	if scroll:FindFirstChild("open_magic_select") then
		conn:trackConnection("OpenMagicSelectGUI",
			scroll.open_magic_select.MouseButton1Down:Connect(function()
				animateFrameOut(newGUI.button_container, function()
					animateFrameIn(newGUI.magic_select_frame)
					magicSelectManager:initialize()
				end)

				conn:trackConnection("MagicSelectGoBack",
					newGUI.magic_select_frame.buttons_container.go_back.MouseButton1Down:Connect(function()
						animateFrameOut(newGUI.magic_select_frame, function()
							magicSelectManager:cancelSelection()
							animateFrameIn(newGUI.button_container)
						end)
					end)
				)
			end)    
		)
	end

	if scroll:FindFirstChild("open_settings") then
		conn:trackConnection("OpenSettingsGUI",
			scroll.open_settings.MouseButton1Down:Connect(function()
				animateFrameOut(newGUI.button_container, function()
					animateFrameIn(newGUI.settings_frame)
					settingsManager:initialize(newGUI, conn)
				end)

				conn:trackConnection("SettingsGoBack",
					newGUI.settings_frame.buttons_container.go_back.MouseButton1Down:Connect(function()
						animateFrameOut(newGUI.settings_frame, function()
							animateFrameIn(newGUI.button_container)
						end)
					end)
				)
			end)    
		)
	end
end

conn:trackConnection("pluginWidget", 
	PluginButton.Click:Connect(function()
		PluginWidget.Enabled = not PluginWidget.Enabled
		if PluginWidget.Enabled then
			resetGUI()
			instancesManager:refreshInsertsList()
		end
	end)    
)

conn:trackConnection("PluginWidgetClosed",
	PluginWidget:GetPropertyChangedSignal("Enabled"):Connect(function()
		if not PluginWidget.Enabled then
			resetGUI()
			pathChangerManager:cancelSelection()
			magicSelectManager:cancelSelection()
		end
	end)
)

conn:trackConnection("UnloadPlugin",
	plugin.Unloading:Connect(function()
		resetGUI()
		pathChangerManager:cancelSelection()
		magicSelectManager:cancelSelection()
		conn:disconnectAll()
	end)    
)

setupButtonAnimations()
resetGUI()]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX4E5A24E2B2394A57B3F726135B585BB1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Resources</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX234A4B63B44F41398AA02027A8FD9A9F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">GUI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Frame" referent="RBX01C28F32B5E1422D8B56814E8C3307C5">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">main_frame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX2E08ED8053BE462380C033B452F2C371">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">path_changer_frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="ImageButton" referent="RBXEEAB902E006F413188D580EC37F518FE">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">false</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">1</int>
								<bool name="Modal">false</bool>
								<string name="Name">change_path</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.499808043</XS>
									<XO>0</XO>
									<YS>0.498027623</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="PressHapticEffect">null</Ref>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.834260106</XS>
									<XO>0</XO>
									<YS>0.381447732</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIPadding" referent="RBX18EC8900F0674D7A840DC0A10CFD2A9F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBXF7AD5889A26C4FF8858F528E9C906FC9">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<token name="StrokeSizingMode">0</token>
									<BinaryString name="Tags"></BinaryString>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXEE31FC1231E24553B16003175803FA4E">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">label</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Change Insert Path</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">45</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX729E75CFFE4E4EA99CF0FAC74381C42F">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>1</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">value</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">ServerStorage</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">46</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.5</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">1</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBX40AA2BFE16CA48B890C35C7BA25529FC">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">header</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.120315582</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Change Path Window</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="ImageButton" referent="RBXB25E0A5E17AE44D189EB74FA47EB7971">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">false</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">2</int>
								<bool name="Modal">false</bool>
								<string name="Name">go_back</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.497149825</XS>
									<XO>0</XO>
									<YS>0.877712011</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="PressHapticEffect">null</Ref>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.365140051</XS>
									<XO>0</XO>
									<YS>0.1368718</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIPadding" referent="RBX15988A2DDA8D4308AC403F3D870AE05A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBXD7375D213ED84550BAAC643C7C453F9D">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<token name="StrokeSizingMode">0</token>
									<BinaryString name="Tags"></BinaryString>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXA5A6F84126C846328F6843D6EE7E174B">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">label</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1.00319493</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Go Back</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">39</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBXFF145051B3F348599CDA4A24F3943D84">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">button_container</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="UIPadding" referent="RBX12D21E06A0FC4D6B8F20EF8035A936AE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">padding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>50</O>
								</UDim>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX23CA414004854616849106D1A1CA194E">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">header</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Selection Window</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="ScrollingFrame" referent="RBX876BFF5038CB427D83D2F875726EF793">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticCanvasSize">2</token>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">true</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<string name="Name">scroll</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>100</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0.5</float>
								<int name="ScrollBarThickness">2</int>
								<token name="ScrollingDirection">2</token>
								<bool name="ScrollingEnabled">true</bool>
								<bool name="Selectable">true</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-20</XO>
									<YS>1</YS>
									<YO>-110</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIListLayout" referent="RBX59BDC0E9A54640D1B20D6B0302D8080B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">list</string>
									<UDim name="Padding">
										<S>0</S>
										<O>10</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">1</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
								</Properties>
							</Item>
							<Item class="UIPadding" referent="RBX95005B81B3534B4D812E9CF1F1588FD2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX7B7E0F5AA47B4B8FA6BF2D8ABC2B322E">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">5</int>
									<bool name="Modal">false</bool>
									<string name="Name">open_inserts</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIStroke" referent="RBXF3C7630049C245C7B1348765CADD41AC">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXA93159E17BD54B2499775B9C3F5F4339">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Inserts</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBX426BE60BC1C848648983C106C724D3A1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBX0FA06574E11944C5BB280AEBD916B211">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://12967375842</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0.5</float>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">icon</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">0</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>20</XO>
											<YS>0</YS>
											<YO>20</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBXA812C916BA474207817080566BBA7E22">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<bool name="Modal">false</bool>
									<string name="Name">change_path</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBX7A1B0AF1F4AD4B4AB77C23BF03FFF472">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX39052ED0D6DE450B9607A4B4E69BE96B">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX9823289A381446FCA2A973B7E89CE97A">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Change Insert Path</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXEB14F97EC951499D98D9EECD53827916">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">value</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">ServerStorage</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX58113F6DD14949C1A36D497CA7069966">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<bool name="Modal">false</bool>
									<string name="Name">open_magic_select</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBXAA472E52457147EDB9BE26F33965FBD7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX727D9B1446EE489F84EA91508C6EDC34">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX4053E8952C384619A2131CE39C99755E">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Magic Select Tool</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBX4C01E8827E4B4150B8A494895E99DF86">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://11432864143</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0.5</float>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">icon</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">0</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>20</XO>
											<YS>0</YS>
											<YO>20</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="TextLabel" referent="RBX39A5D83675074888BF83A179D2F40B17">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">999999999</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">WARNING</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0.134166673</XS>
										<XO>0</XO>
										<YS>0.530973434</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.731666684</XS>
										<XO>0</XO>
										<YS>0.0532386787</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">DISCLAIMER: !!! I AM NOT THE COPYRIGHT OWNER OF MOST OF THESE ASSETS !!!</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>0</G>
										<B>0.0156862754</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX461D0FD356024E91A67C2E6B0AF51964">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">5</int>
									<bool name="Modal">false</bool>
									<string name="Name">open_settings</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIStroke" referent="RBX36980709C14F400DA7C20C3C6935317C">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX6B2BA8D6738449E6A46F2B83836DDA47">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Settings</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBX0B83168F85C44640ACB8676B39027AA8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBX29B7D384424F45DFA8EA0D3F957DDB09">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://11293977610</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0.5</float>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">icon</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">0</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>20</XO>
											<YS>0</YS>
											<YO>20</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX1BF42766438E4F40982AD5E11E10FE98">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">magic_select_frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="TextLabel" referent="RBXC7C956D5C3D1462EA918AD09CE2004E3">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">header</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.0946745574</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Magic Select</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="ScrollingFrame" referent="RBXBFC3D18CD254472A870004DA424C2494">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticCanvasSize">2</token>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">true</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<string name="Name">settings_container</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.142011806</YS>
									<YO>100</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0.5</float>
								<int name="ScrollBarThickness">2</int>
								<token name="ScrollingDirection">2</token>
								<bool name="ScrollingEnabled">true</bool>
								<bool name="Selectable">true</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-20</XO>
									<YS>0.563928306</YS>
									<YO>-110</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIPadding" referent="RBX98474A6B9E364AC98EAF1E03950D49E8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX50B7294129D44E56A72D1746DF3E99BA">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">5</int>
									<bool name="Modal">false</bool>
									<string name="Name">by_color</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIStroke" referent="RBXB1C6DFDF2281413E8A6AFE5F7CC0A2A6">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX5E18935459FE40378FFEC1DEAB0CDD22">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Filter By Object Color (BaseParts only)</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBXB8A40AF8E1614FE9B388659A85341B41">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX8AE3FA75EB73467A8D77B8B6761D09EF">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">value</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX2E336D76E4F7416E972B40491AF05AC5">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<bool name="Modal">false</bool>
									<string name="Name">by_class</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBX8EED3B24DADB489F8D40C3E20C058191">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX1F8A49A4BCE546CBA319894421CB02EC">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX7DB90A5194784B9D82FCE6A8FC70FBC0">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Filter By Object Class</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXB571B37792BC42D7BB5EB6884046DD4B">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">value</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBXB4B5A51A7B414CCC898C0D9B5E8F8A83">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<bool name="Modal">false</bool>
									<string name="Name">by_name</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBX6FEBD5AA7A4747D6BEE4D41A4B1C6E7E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX650BBF5DEE0445DDA6241B3FBDD1E725">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX330594C9358842B59850D9F12615283D">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Filter By Object Name</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXB8E45E4FB215417AA3A5A3D8B7BF27BF">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">value</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBXBDC76683FFD5474CB1CF7FFE5325CB00">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<bool name="Modal">false</bool>
									<string name="Name">by_parent</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBXA2EE23F1563D42F49E5AB8910E41DC54">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBXD8E12DBEA469486CA2509B9C0BC74568">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX178AC7A77C754F49BFB8A13EE71C4384">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Filter By Object Parent</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX8AC698DC66BB4A49AA51088A746D15A4">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">value</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="UIGridLayout" referent="RBXC11196BD124B439F8F5D32A5704BC8E6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<UDim2 name="CellPadding">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<UDim2 name="CellSize">
										<XS>0.49000001</XS>
										<XO>0</XO>
										<YS>0.25</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">0</token>
									<int name="FillDirectionMaxCells">0</int>
									<token name="HorizontalAlignment">1</token>
									<string name="Name">UIGridLayout</string>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="StartCorner">0</token>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">1</token>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBXD5A9D7C805EE4356B5ADF8590D557F1E">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">buttons_container</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.858974338</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>832</XO>
									<YS>0</YS>
									<YO>120</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIListLayout" referent="RBX92DDF1D45617494D8D44AC176A8E3AEA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0</S>
										<O>10</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">0</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX19291978C66D42A78F21D2FBE8DD237C">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<bool name="Modal">false</bool>
									<string name="Name">go_back</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.915187359</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBX10FAE097515C47B582A905DAF828F4CA">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBXC572D8FC93E641DDB239DE212F845187">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXA2BB9BD18E9C4585807B87F7DD413E2D">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Go Back</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBXE7515BC4311A4A72B2439852379D3545">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<bool name="Modal">false</bool>
									<string name="Name">select</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.786982238</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBX56B69D3BC92A4D73B89A7F6CDF12A958">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX54174F953DF2437091ACF6F957459D63">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXE916C5AF453340FA97751F8EDE72DFEB">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Start Selecting</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBXD5D38B787BC3440CA8FE149659991EBE">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">false</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<Ref name="HoverHapticEffect">null</Ref>
							<Content name="HoverImage"><null></null></Content>
							<Content name="Image"><url>rbxassetid://14407899530</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0.730000019</float>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<bool name="Modal">false</bool>
							<string name="Name">background</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="PressHapticEffect">null</Ref>
							<Content name="PressedImage"><null></null></Content>
							<token name="ResampleMode">0</token>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Visible">true</bool>
							<int name="ZIndex">0</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX50468D3B8C4E49B6A3A3059AB646FE27">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">settings_frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="TextLabel" referent="RBXE7CFE337958E4C94ACD394BF1B0BDFF0">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">header</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.0946745574</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Settings Window</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="ScrollingFrame" referent="RBXFF4BEE3D56F346F5BA1608E5787BA46A">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticCanvasSize">2</token>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">true</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<string name="Name">settings_container</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.0374752842</YS>
									<YO>100</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0.5</float>
								<int name="ScrollBarThickness">2</int>
								<token name="ScrollingDirection">2</token>
								<bool name="ScrollingEnabled">true</bool>
								<bool name="Selectable">true</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-20</XO>
									<YS>0.733553588</YS>
									<YO>-110</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIPadding" referent="RBXB50CDB320209498FA58F65CA2DED3418">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX995FDE09CCDA451B98D4B8F4FD909081">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<bool name="Modal">false</bool>
									<string name="Name">EnablePrints</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBXEFBF3BF408C4400CAE97E894D8E5DB86">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX8210495146A24C90AB3C0CDF3406D28E">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX51D858929D924F73B24DF7ACDC8E3DFE">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Enable Print Comments</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXB5A18515A7E342A48B4BD9352FD6C5E6">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">value</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="UIGridLayout" referent="RBXB9D1BF9A96254A7C8953DCA2144652EA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<UDim2 name="CellPadding">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<UDim2 name="CellSize">
										<XS>0.49000001</XS>
										<XO>0</XO>
										<YS>0.25</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">0</token>
									<int name="FillDirectionMaxCells">0</int>
									<token name="HorizontalAlignment">1</token>
									<string name="Name">UIGridLayout</string>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="StartCorner">0</token>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">1</token>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBX6B271C03647949F88517DC544130AEBB">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">buttons_container</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.858974338</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>832</XO>
									<YS>0</YS>
									<YO>120</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIListLayout" referent="RBX11DD78490C75416A868834B0300393E0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0</S>
										<O>10</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">0</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX649DFDA68FB64F739E4F815A5707B550">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<bool name="Modal">false</bool>
									<string name="Name">go_back</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.915187359</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBX38391AE1DFA94A6C83ECA35D6F9F104A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX7FBCEE00D6684B19BA2A7C849639F5E9">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX509B7573360146DD896191D4452F26DA">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Go Back</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBXFD74300E85CF42A9A1FF385B8631C718">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">instance_frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX21EBC286339244F99D5B0E7C54374E79">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxassetid://12246187856</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">instance_thumbnail</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.0797970146</XS>
									<XO>0</XO>
									<YS>0.857284248</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.0719818845</XS>
									<XO>0</XO>
									<YS>0.177514821</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UICorner" referent="RBX511AB91D2899472389A4D6401A0153C1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<UDim name="CornerRadius">
										<S>1</S>
										<O>0</O>
									</UDim>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UICorner</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIAspectRatioConstraint" referent="RBXC5A15E3E93B14E4AA151B68C23F66996">
								<Properties>
									<float name="AspectRatio">0.983752429</float>
									<token name="AspectType">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="DominantAxis">0</token>
									<string name="Name">UIAspectRatioConstraint</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ScrollingFrame" referent="RBXAF1ADE34AEF04CC596C6ED2866A353A1">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticCanvasSize">2</token>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0.75</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">true</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<string name="Name">info_container</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.500622213</XS>
									<XO>0</XO>
									<YS>0.454018265</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0</float>
								<int name="ScrollBarThickness">6</int>
								<token name="ScrollingDirection">4</token>
								<bool name="ScrollingEnabled">true</bool>
								<bool name="Selectable">true</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.912003815</XS>
									<XO>0</XO>
									<YS>0.490385652</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
								<token name="VerticalScrollBarInset">1</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIListLayout" referent="RBX6159E0C862CF455197E6F124A174C537">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">1</token>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">1</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
								</Properties>
							</Item>
							<Item class="UICorner" referent="RBX7E4EC629B5EF47AAB4AB3DFD401E0985">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<UDim name="CornerRadius">
										<S>0</S>
										<O>12</O>
									</UDim>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UICorner</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIPadding" referent="RBX602AAE4481D74C019AB8EDC5534D9514">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIPadding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBX8D130FD1CE1648B7BB3E42E299C2B7DD">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">header</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0.500813007</XS>
									<XO>0</XO>
									<YS>0.0571992099</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">InsertName</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX7FADD5D0CC044F1F8F17309F14C85701">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">buttons_container</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.858974338</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>832</XO>
									<YS>0</YS>
									<YO>120</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="ImageButton" referent="RBXEFC6D23FACAC45008744C3269A89FA7C">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<bool name="Modal">false</bool>
									<string name="Name">go_back</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.915187359</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBX368FDE5CE3C241948EA05DCB79AEB8B5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX62813CE6B6F841D6A8BF620053A658F9">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX99B371A427DE4DF0B2CCB5FC0DC3C895">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Go Back</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX49E2AA26B63F498AAB50717F89156BCC">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">false</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<bool name="Modal">false</bool>
									<string name="Name">insert_button</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.656850934</XS>
										<XO>0</XO>
										<YS>0.25</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="PressHapticEffect">null</Ref>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663701892</XS>
										<XO>0</XO>
										<YS>0.341666669</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIPadding" referent="RBX375C5941B50B4C33ABD4000C0C77FFFB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBXBCB2071E85054EDCBFC8BBF64F2679C1">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<token name="StrokeSizingMode">0</token>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX648FD5D36469479EB56117A782E7492D">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">label</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Insert</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="UIListLayout" referent="RBX545DA775C7D84903A72B03BC7D26F53D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0</S>
										<O>10</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">0</token>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX82EDBE93018B42DEAA8DFBD090BC6DC1">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">insets_frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="ScrollingFrame" referent="RBX3B241804B7FF4CA89B477CAF232DD343">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticCanvasSize">2</token>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0.75</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">true</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<string name="Name">inserts_container</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.499990642</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0</float>
								<int name="ScrollBarThickness">6</int>
								<token name="ScrollingDirection">4</token>
								<bool name="ScrollingEnabled">true</bool>
								<bool name="Selectable">true</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.845473051</XS>
									<XO>0</XO>
									<YS>0.579668581</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIGridLayout" referent="RBX0BB00C7FC18949969116D273613D8CA0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<UDim2 name="CellPadding">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<UDim2 name="CellSize">
										<XS>0.245000005</XS>
										<XO>0</XO>
										<YS>0.449999988</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="DefinesCapabilities">false</bool>
									<token name="FillDirection">0</token>
									<int name="FillDirectionMaxCells">0</int>
									<token name="HorizontalAlignment">1</token>
									<string name="Name">UIGridLayout</string>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="StartCorner">0</token>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">1</token>
								</Properties>
							</Item>
							<Item class="UIPadding" referent="RBX6B6A8EEAB34B47A9A8A54B4ABE522D9F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIPadding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>0</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>0</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UICorner" referent="RBX5227DBC724C04E37897DE8FCF202B432">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<UDim name="CornerRadius">
										<S>0</S>
										<O>12</O>
									</UDim>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UICorner</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ImageButton" referent="RBX94A0E9D99AB2435998353E46FE5E3AB5">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">false</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">2</int>
								<bool name="Modal">false</bool>
								<string name="Name">go_back</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.499592841</XS>
									<XO>0</XO>
									<YS>0.911242604</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="PressHapticEffect">null</Ref>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.445114046</XS>
									<XO>0</XO>
									<YS>0.099999994</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIPadding" referent="RBX524EB55081B4498F8961478D33363984">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBXA784B37988824772BB80EE66475CE3EB">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<token name="StrokeSizingMode">0</token>
									<BinaryString name="Tags"></BinaryString>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXE99A9E707D184015B6DF448EF1C76226">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">label</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1.00319493</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Go Back</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">39</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBXF91DD1968E1C46459ED88871528C702B">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">header</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0.500813007</XS>
									<XO>0</XO>
									<YS>0.0276134126</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Inserts Window</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX18D8233521E54D2BBF24D0EDEC096A98">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Inserts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX5D3E5563FE6946ABA6ED6BF8223F23CF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">BloodEngine</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX676006D30A28444CAA7C6F5B659A7CD5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BloodEngine</string>
							<string name="ScriptGuid">{A0182363-4FCD-4E79-B4B2-E1D2D6378E50}</string>
							<ProtectedString name="Source"><![CDATA[--[[
  @ Writer: @Smileeiles
  @ Version: v1.1.3
  @ Description:
     A droplet emitter system,
     used to emit droplets from a specified origin point.

     These droplets are then given a velocity,
     and upon landing on a surface, transform into pools.

     This process can be customized to suit various needs and genres.
]]

-- Essential definitions
local Operator = require(script.Operator)
local Settings = require(script.Settings)
local Functions = require(script.Functions)

-- Globals
local Unpack = table.unpack

-- Class definition
local BloodEngine = {}
BloodEngine.__index = BloodEngine

--[[
  Class constructor, constructs the class
  including other properties/variables.
]]
function BloodEngine.new(Data: Settings.Class)
	local self = setmetatable({}, BloodEngine)
	return self, self:Initialize(Data)
end

--[[
  Immediately called after the construction of the class,
  defines properties/variables for after-construction
]]
function BloodEngine:Initialize(Data: {})
	Functions.MultiInsert(self, {
		ActiveHandler = Settings.new(Data or {}),
		ActiveEngine = function()
			return Operator.new(self)
		end,
	})
end

--[[
  Emitter, emits droplets based on given amount,
  origin & direction.

  This is utilized when you prefer
  not to create a loop just for the
  purpose of emitting a few droplets.
]]
function BloodEngine:EmitAmount(Origin: Vector3 | BasePart, Direction: Vector3, Amount: number, Data: Settings.Class?)
	-- Class definitions
	local Handler: Settings.Class = self.ActiveHandler

	-- Variable definitions
	local DropletDelay = Handler.DropletDelay

	for _ = 1, Amount, 1 do
		-- Define variables for later use
		local DelayTime = Functions.NextNumber(Unpack(DropletDelay))

		-- Emit a droplet in the specified direction & origin
		self:Emit(Origin, Direction, Data)

		-- Delays the next droplet to be emitted
		task.wait(DelayTime)
	end
end

--[[
  EmitOnce, a variant of the Emit method; emits a single droplet.
  Unlike Emit, which uses a loop to emit multiple droplets,
  EmitOnce only emits one droplet per call.

  This is useful when you want to control the emission
  loop externally.
]]
function BloodEngine:Emit(Origin: Vector3 | BasePart, Direction: Vector3, Data: Settings.Class?)
	-- Class definitions
	local Engine: Operator.Class = self.ActiveEngine

	-- Variable definitions
	Origin = typeof(Origin) == "Instance" and Origin.Position or Origin
	Direction = Direction or Functions.GetVector({ -10, 10 }) / 10

	-- Emit a single droplet
	Engine:Emit(Origin, Direction, Data)
end

--[[
  GetSettings, returns all the settings of the
  current class instance.

  Use this function when you want to access
  the settings for external handling of the system.
]]
function BloodEngine:GetSettings(): Settings.Class
	-- Class definitions
	local Handler: Settings.Class = self.ActiveHandler

	-- Export settings
	return Handler
end

--[[
  UpdateSettings, updates the settings of the
  current class instance.

  It uses the `Handler:UpdateSettings()`, which
  uses the given `Data` array/table to update individual settings.
]]
function BloodEngine:UpdateSettings(Data: Settings.Class)
	-- Class definitions
	local Handler: Settings.Class = self.ActiveHandler

	-- Update the settings
	Handler:UpdateSettings(Data)
end

--[[
	Destroy, destroys anything associated 
	with the settings/handler and the operator/engine.
	
	Use this function when there is no longer a use
	for the created engine. (Like when a character dies, etc.)
]]
function BloodEngine:Destroy()
	-- Class definitions
	local Handler: Settings.Class = self.ActiveHandler
	local Engine: Operator.Class = self.ActiveEngine
	
	-- Destroy the handler & engine
	self.Handler = nil
	Engine:Destroy()
	self.Engine = nil
	
	-- Nullify/replace all the Engine methods
	self.UpdateSettings = Functions.Replacement
	self.GetSettings = Functions.Replacement
	
	self.EmitAmount = Functions.Replacement
	self.Emit = Functions.Replacement
end

-- Exports the class
return BloodEngine
]]></ProtectedString>
							<int64 name="SourceAssetId">82208816003099</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX86BD09AFEC33401F9374C5883FF8F49C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Operator</string>
								<string name="ScriptGuid">{6CCDC616-D18D-46B3-83B7-A1A1FC69CF03}</string>
								<ProtectedString name="Source"><![CDATA[--[[
  @ Description:
    This is the operator of the base system/class,
    it manages the functionality of the droplets,
    the events of the casts, the limit and such.
]]

-- Variable definitions
local ParentClass = script.Parent
local Assets = ParentClass.Assets

-- Asset definitions
local Sounds = Assets.Sounds
local Essentials = Assets.Essentials
local Meshes = Assets.Meshes

-- Sound definitions
local EndFolder = Sounds.End:GetChildren()
local StartFolder = Sounds.Start:GetChildren()

-- Essential definitions
local Functions = require(ParentClass.Functions)
local PartCache = require(Essentials.PartCache)
local Settings = require(ParentClass.Settings)
local FastCast = require(Essentials.FastCast)

-- Globals
local Unpack = table.unpack

-- Constants definition
local TypeAttribute = "Type"
local DecayAttribute = "Decaying"
local ExpandAttribute = "Expanding"
local MeshMap = {
	Default = Meshes.Droplet,
	Decal = Meshes.Decal,
}

-- Type definitions
type Connections = { RBXScriptConnection }

-- Class definition
local Operator = {}
Operator.__index = Operator

--[[
  Class constructor, constructs the class
  including other properties/variables.
]]
function Operator.new(Class)
	local self = setmetatable({
		Handler = Class.ActiveHandler,
	}, Operator)

	return self, self:Initialize(), self:InitializeCast()
end

--[[
  Immediately called after the construction of the class,
  defines properties/variables for after-construction
]]
function Operator:Initialize()
	-- Variable definitions
	local Handler: Settings.Class = self.Handler
	local FolderName: string = Handler.FolderName

	-- Essential definitions
	local Type = Handler.Type
	local Limit = Handler.Limit
	local CastParams = Handler.RaycastParams

	local Folder = Functions.GetFolder(FolderName)
	local Object = Functions.GetDroplet(Handler.SplashName)

	-- Class definitions
	local Cache = PartCache.new(Object, Limit, Folder)
	
	-- Insert variables
	Functions.MultiInsert(self, {
		Registry = {},
		Connections = {},
		
		Droplet = Object,
		Cache = Cache,
		Container = Folder,
		Caster = FastCast.new(),
		Behavior = function()
			return Functions.SetupBehavior(Cache, CastParams)
		end,
	})
end

--[[
  The Cast-Setup, which is executed immediately
  following the Initialization of the class.

  It efficiently manages events
  associated with the Caster.
]]
function Operator:InitializeCast()
	-- Self definitions
	local Connections: Connections = self.Connections
	local Caster: FastCast.Class = self.Caster
	local Handler: Settings.Class = self.Handler
	local Container: Folder = self.Container

	-- Event definitions
	local LengthChanged = Caster.LengthChanged
	local RayHit = Caster.RayHit

	-- Caster Listeners
	Functions.Connect(LengthChanged:Connect(function(_, Origin, Direction, Length, _, Object: BasePart)
		if not Object then
			return
		end

		-- 3D Definition
		local ObjectSize = Object.Size
		local ObjectLength = ObjectSize.Z / 2

		local Offset = CFrame.new(0, 0, -(Length - ObjectLength))

		local GoalCFrame = CFrame.new(Origin, Origin + Direction):ToWorldSpace(Offset)

		-- Update properties
		Object.CFrame = GoalCFrame
	end), Connections)
	
	Functions.Connect(RayHit:Connect(function(_, RaycastResult: RaycastResult, Velocity, Object: BasePart?)
		if not Object then
			return nil
		end

		-- Options definitions
		local RegistryData = self.Registry[Object] or Handler
		local Size = RegistryData.StartingSize
		local SizeRange = RegistryData.DefaultSize
		local YRange = RegistryData.YSize
		local Distance = RegistryData.Distance
		local Expansion = RegistryData.Expansion
		local IsDecal = RegistryData.Type == "Decal"

		-- Variable definitions
		local CastInstance = RaycastResult.Instance
		local Position = RaycastResult.Position
		local Normal = RaycastResult.Normal

		local VectorSize, SizeY = Functions.GetVector(SizeRange), Functions.NextNumber(table.unpack(YRange))
		local GoalSize = Functions.RefineVectors(IsDecal, Vector3.new(VectorSize.X, VectorSize.Y / 4, VectorSize.X))

		local GoalAngles = Functions.GetAngles(IsDecal, IsDecal)
		local GoalCFrame = Functions.GetCFrame(Position, Normal, IsDecal) * GoalAngles

		local ClosestPart = Functions.GetClosest(Object, Distance, Container)

		local ExpansionLogic = (
			Expansion
				and ClosestPart
				and not ClosestPart:GetAttribute(DecayAttribute)
				and not ClosestPart:GetAttribute(ExpandAttribute)
				and ClosestPart:GetAttribute(TypeAttribute) == RegistryData.Type
		)

		-- Clear the registry entry
		self.Registry[Object] = nil

		-- Evaluates if the droplet is close to another pool, if so, expand.
		if ExpansionLogic then
			self:Expanse(Object, ClosestPart, Velocity, GoalSize, RegistryData)
			return nil
		end

		-- Update properties
		Object.Anchored = true
		Object.Size = Size
		Object.CFrame = GoalCFrame
		Object.Transparency = Functions.NextNumber(Unpack(RegistryData.DefaultTransparency))

		--[[
     		Transitions the droplet into a pool,
      		then handles its later functionality.
        	(Decay, Sounds, etc...)
    	]]
		Functions.CreateTween(Object, RegistryData.Tweens.Landed, { Size = GoalSize }):Play()

		self:HandleDroplet(Object, RegistryData)
		self:HitEffects(Object, Velocity, RegistryData)
		Functions.Weld(CastInstance, Object)

		return nil
	end), Connections)
end

--[[
	Destroys PartCache, FastCast, 
	and all the droplets associated with this engine/operator.
]]
function Operator:Destroy()
	-- Self definitions
	local Connections: Connections = self.Connections
	local Cache: PartCache.Class = self.Cache
	local Caster: FastCast.Class = self.Caster
	local Container: Folder = self.Container
	
	-- Destroy classes
	Cache:Dispose()
	table.clear(Caster)
	
	Functions.DisconnectAll(Connections)
	table.clone(Connections)
	
	-- Destroy main container
	if Container then
		Container:Destroy()
	end
	
	-- Null everything, making the operator unusable
	self.Connections = nil
	self.Container = nil
	self.Cache = nil
	self.Caster = nil
end

--[[
  Emitter, emits a certain amount of droplets,
  at a certain point of origin, with a certain given direction.
]]
function Operator:Emit(Origin: Vector3, Direction: Vector3, Data: Settings.Class?)
	-- Class definitions
	local Caster: FastCast.Class = self.Caster
	local Behavior: FastCast.Behavior = self.Behavior
	local Cache: PartCache.Class = self.Cache
	local Handler: Settings.Class = self.Handler
	
	-- Create a clone of the default settings, and apply specific settings if provided
	local Clone = table.clone(Handler)
	Clone:UpdateSettings(Data or {})
	Data = Clone

	-- Variable definitions
	local IsDecal = Data.Type == "Decal"
	local DropletVelocity = Data.DropletVelocity
	local Velocity = Functions.NextNumber(Unpack(DropletVelocity)) * 10

	local RandomOffset = Data.RandomOffset
	local OffsetRange = Data.OffsetRange
	local Position = Functions.GetVector(OffsetRange) / 10

	-- Final definitions
	local FinalPosition = Origin + Vector3.new(Position.X, 0, Position.Z)
	local FinalStart = (RandomOffset and FinalPosition or Origin)

	if #Cache.Open <= 0 then
		return
	end

	-- Caster definitions, fire the caster with given arguments
	local ActiveDroplet = Caster:Fire(FinalStart, Direction, Velocity, Behavior)

	local RayInfo = ActiveDroplet.RayInfo
	local Droplet: MeshPart = RayInfo.CosmeticBulletObject
	
	-- Update the mesh's look and color
	Droplet:ApplyMesh(MeshMap[Data.Type])
	Droplet.Color = Data.DropletColor
	
	-- Assign the registry entry and update the attributes
	self.Registry[Droplet] = Data
	Droplet:SetAttribute(TypeAttribute, Data.Type)
	Droplet:SetAttribute(DecayAttribute, false)
	Droplet:SetAttribute(ExpandAttribute, false)
	
	-- Execute essential functions
	self:UpdateDroplet(Droplet, Data)
	Functions.PlaySound(Functions.GetRandom(StartFolder), Droplet)
end

--[[
  A small function, designed to update the properties
  of a recently emitted droplet.
]]
function Operator:UpdateDroplet(Object: BasePart, Data: Settings.Class)
	-- Variable definitions
	local DropletTrail = Data.Trail
	local DropletVisible = Data.DropletVisible
	local IsDecal = Data.Type == "Decal"

	-- Object definitions
	local Trail = Object:FindFirstChildOfClass("Trail")

	-- Update Object properties
	Object.Transparency = DropletVisible and 0 or 1
	Trail.Enabled = DropletTrail

	-- Execute essential functions
	Functions.ApplyDecal(Object, IsDecal)
end

--[[
  Handles the given droplet/object after
  it landed on a surface.
]]
function Operator:HandleDroplet(Object: BasePart, Data: Settings.Class)
	-- Object definitions
	local Trail = Object:FindFirstChildOfClass("Trail")

	-- Variable definitions
	local Tweens = Data.Tweens
	local DecayDelay = Data.DecayDelay

	local DecayInfo = Tweens.Decay
	local DecayTime = Functions.NextNumber(Unpack(DecayDelay))

	local ScaleDown = Data.ScaleDown
	local FinalSize = ScaleDown and Vector3.new(0.01, 0.01, 0.01) or Object.Size

	-- Tween definitions
	local DecayTween = Functions.CreateTween(Object, DecayInfo, { Transparency = 1, Size = FinalSize })

	-- Update Droplet properties
	Trail.Enabled = false

	-- Listeners
	DecayTween.Completed:Connect(function()
		DecayTween:Destroy()
		Object:SetAttribute("Decaying", nil)
		self:ReturnDroplet(Object)
	end)

	-- Reset the droplet after the given DecayDelay has passed
	task.delay(DecayTime, function()
		DecayTween:Play()
		Object:SetAttribute("Decaying", true)
	end)
end

--[[
  HitEffects, a sequence of effects to enhance
  the visuals of the droplet->pool
]]
function Operator:HitEffects(Object, Velocity: Vector3, Data: Settings.Class)
	-- Variable definitions
	local SplashName = Data.SplashName
	local SplashAmount = Data.SplashAmount
	local SplashByVelocity = Data.SplashByVelocity
	local Divider = Data.VelocityDivider
	local IsDecal = Data.Type == "Decal"

	local Magnitude = Velocity.Magnitude
	local FinalVelocity = Magnitude / Divider
	local FinalAmount = (SplashByVelocity and FinalVelocity or Functions.NextNumber(Unpack(SplashAmount)))
	local Splash: Attachment = Object:FindFirstChild(SplashName)

	-- Execute essential functions
	Splash.Orientation = Vector3.new(0, 0, IsDecal and 0 or 180)
	Functions.PlaySound(Functions.GetRandom(EndFolder), Object)
	Functions.EmitParticles(Splash, FinalAmount)
end

--[[
	Simulates the pool expansion
	effect when a droplet is near
	a pool.

	It checks the distance between
	a threshold, then triggers changes
	on the droplet & pool.
]]
function Operator:Expanse(
	Object: BasePart,
	ClosestPart: BasePart,
	Velocity: Vector3, 
	Size: Vector3, 
	Data: Settings.Class
)
	-- Variable definitions
	local Divider = Data.ExpanseDivider
	local MaximumSize = Data.MaximumSize
	local IsDecal = Data.Type == "Decal"

	-- Info definitions
	local Tweens = Data.Tweens
	local Expand = Tweens.Expand

	-- Value definitions
	local PoolSize = ClosestPart.Size
	local FinalVelocity = Velocity / 20
	local GoalSize = Vector3.new(Size.X, Size.Y / Divider, Size.Z) / Divider

	local FirstSize = Functions.RefineVectors(
		IsDecal,
		Vector3.new(PoolSize.X - FinalVelocity.Z, PoolSize.Y + FinalVelocity.Y, PoolSize.Z - FinalVelocity.Z)
	)

	local LastSize = Vector3.new(PoolSize.X, PoolSize.Y, PoolSize.Z) + GoalSize

	local FinalSize = (LastSize.X < MaximumSize and LastSize or PoolSize)

	-- Update properties
	ClosestPart:SetAttribute("Expanding", true)
	ClosestPart.Size = FirstSize

	-- Transition to Expanded size
	local Tween = Functions.CreateTween(ClosestPart, Expand, { Size = FinalSize })

	Tween:Play()
	Tween.Completed:Connect(function()
		ClosestPart:SetAttribute("Expanding", nil)
		Tween:Destroy()
	end)

	-- Execute essential functions
	Functions.PlaySound(Functions.GetRandom(EndFolder), ClosestPart)
	self:ReturnDroplet(Object)
end

--[[
  Resets the given droplet/pool,
  then returns it to the Cache.
]]
function Operator:ReturnDroplet(Object: Instance)
	-- Self definitions
	local Cache: PartCache.Class = self.Cache
	local Template: Instance = self.Droplet

	-- Execute essential functions
	Functions.ResetDroplet(Object, Template)
	Cache:ReturnPart(Object) -- Ignore, ReturnPart exists
end

-- Exports the class
export type Class = typeof(Operator.new(...))

return Operator
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3D52F28015B640D1B99C420BA7E94742">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Settings</string>
								<string name="ScriptGuid">{E7CA2315-0CFC-48C6-8153-E38DC899E75A}</string>
								<ProtectedString name="Source"><![CDATA[--[[
  @ Description:
    A class that handles settings,
    a group of keys that have an assigned value.
]]

-- Class definition
local Settings = {}
Settings.__index = Settings

--[[
  Class constructor, constructs the class
  including other properties/variables.
]]
function Settings.new(Data: {})
	local self = setmetatable({
		FolderName = "Droplets", -- Specifies the name of the folder containing the droplets.
		Type = "Default", -- Defines the droplet type. It can be either "Default" (Sphere) or "Decal".
		Limit = 500, -- Sets the maximum number of droplets that can be created.
		Filter = {}, -- An array/table of instances that should be ignored during droplet collision.
		
		YSize = { 0.1, 0.175 }, -- Specifices the range of the thickness/flatness/depth of the pool. Lesser is flatter.
		DefaultSize = { 0.4, 0.7 }, -- Specifies the default size range of a pool.
		DefaultTransparency = { 0.3, 0.4 }, -- Specifies the default transparency range of a pool.
		StartingSize = Vector3.new(0.1, 0.3, 0.1), -- Sets the initial size of the droplets upon landing.
		ScaleDown = true, -- Determines whether the pool should scale down when decaying.

		DropletDelay = { 0.01, 0.03 }, -- Sets the delay between emitting droplets in a loop (for the EmitAmount method).
		DropletVelocity = { 1, 2 }, -- Controls the velocity of the emitted droplet.
		DropletVisible = false, -- Determines if the droplet is visible upon emission.
		DropletColor = Color3.fromRGB(103, 0, 0), -- Determines the color of the emitted droplet.

		RandomOffset = true, -- Determines whether a droplet should spawn at a random offset from a given position.
		OffsetRange = { -5, 5 }, -- Specifies the offset range for the position vectors.

		SplashName = "Impact", -- The name of the attachment that releases particles on surface contact.
		SplashAmount = { 5, 10 }, -- Sets the number of particles to emit upon impact.
		SplashByVelocity = true, -- If true, sets the number of particles based on the velocity of the droplet.
		VelocityDivider = 8, -- Controls how much the velocity can affect the splash amount, Higher values reduce the effect.

		Expansion = true, -- Determines whether a pool can expand when a droplet lands on it.
		Distance = 0.2, -- Sets the distance (in studs) within which the droplet should check for nearby pools
		ExpanseDivider = 3, -- Controls how much a pool's size can increase. Higher values reduce the increase.
		MaximumSize = 0.7, -- Sets the maximum size a pool can reach.

		Trail = true, -- Controls the visibility of the trail during droplet emission.
		DecayDelay = { 10, 15 }, -- Sets the delay before the droplet decays and recycles

		-- Contains all the tweens used by the module
		Tweens = {
			Landed = TweenInfo.new(0.5, Enum.EasingStyle.Cubic), -- Used for when a droplet has landed on a surface.
			Decay = TweenInfo.new(1, Enum.EasingStyle.Cubic), -- Used for when a droplet is decaying.
			Expand = TweenInfo.new(0.5, Enum.EasingStyle.Cubic), -- Used for when a droplet is expanding (Pool Expansion).
		},
	}, Settings)

	-- Fill the default settings with values from the Data array
	for Setting, Value in Data do
		if Setting == "Tweens" then
			for Tween, Info in Value do
				self.Tweens[Tween] = Info
			end

			continue
		end

		self[Setting] = Value
	end

	return self, self:CreateParams()
end

--[[
  Updates settings with values from the provided array.
]]
function Settings:UpdateSettings(Data: {})
	-- Variable definitions
	local Filter = self.Filter
	local Params = self.RaycastParams

	for Setting, Value in Data do
		self[Setting] = Value
	end

	-- Update Param properties
	Params.FilterDescendantsInstances = Filter
end

--[[
	Manages the instantiation of the RaycastParams
	aswell as the configuration of the filter.
]]
function Settings:CreateParams()
	-- Variable definitions
	local Filter = self.Filter
	local Params = RaycastParams.new()

	-- Update Params properties
	Params.FilterType = Enum.RaycastFilterType.Exclude
	Params.FilterDescendantsInstances = Filter

	-- Assign Params as a self value
	self.RaycastParams = Params
end

-- Exports the class and its type
export type Class = typeof(Settings.new(...))

return Settings
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC04492834BBA4A0FBBE441201D3E32A5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Functions</string>
								<string name="ScriptGuid">{498FFD67-E4F4-4741-A934-C4D561A9FAA9}</string>
								<ProtectedString name="Source"><![CDATA[--[[
  @Description: Contains a list of useful functions.
]]

local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

-- Variable definitions
local ParentClass = script.Parent
local Assets = ParentClass.Assets

-- Asset definitions
local Images = Assets.Images
local Essentials = Assets.Essentials
local Effects = Assets.Effects

-- Effect definitions
local TrailEffects = Effects.Trail
local ImpactEffects = Effects.Impact

-- Essential definitions
local FastCast = require(Essentials.FastCast)
local Random = Random.new()

-- Globals
local Unpack = table.unpack
local Decals = Images:GetChildren()

-- Module definition
local Functions = {}

-- Variable definitions
local Properties = {
	"Size",
	"Transparency",
	"Anchored",
}

--[[
  A shorter way of doing:
  ```lua
    typeof(Variable) == "Type"
  ```
]]
function Functions.IsOfType(Any, Type: string)
	return typeof(Any) == Type
end

--[[
  Allows the ability to insert an array of
   variables efficently onto a table.
]]
function Functions.MultiInsert(List: {}, Variables: {})
	for Key, Variable in Variables do
		--[[
      Executes the variable if it's a function,
      It is expected to return a variable to later assign.
    ]]
		if Functions.IsOfType(Variable, "function") then
			Variable = Variable()
		end

		-- Adds in the variable with a key
		if Functions.IsOfType(Key, "string") then
			List[Key] = Variable
		end

		-- Adds in the variable without a key
		table.insert(List, Variable)
	end
end

--[[
  Returns the name of the specified function
  within the classs metatable.
]]
function Functions.GetFunctionName(Function, Table)
	for Name, AltFunction in Table do
		return AltFunction == Function and Name
	end

	return nil
end

--[[
  Sets up a `CastBehavior` for later use,
  then returns it.
]]
function Functions.SetupBehavior(Cache, CastParams): FastCast.Behavior
	-- Define Variables
	local Behavior = FastCast.newBehavior()
	local Gravity = Workspace.Gravity

	-- Update Behavior properties
	Behavior.Acceleration = Vector3.new(0, -Gravity, 0)
	Behavior.MaxDistance = 500
	Behavior.RaycastParams = CastParams
	Behavior.CosmeticBulletProvider = Cache

	-- Export behavior
	return Behavior
end

--[[
	Clones and parents Droplet effects from a template part.
]]
function Functions.CreateEffects(Parent: MeshPart, ImpactName: string)
	-- Variable definitions
	local Trail = TrailEffects:Clone()
	
	local Attachment0 = Instance.new("Attachment")
	local Attachment1 = Instance.new("Attachment")
	local ImpactAttachment = Instance.new("Attachment")
	
	-- Update Trail-related properties
	Trail.Attachment0 = Attachment0
	Trail.Attachment1 = Attachment1
	
	Attachment1.Position = Vector3.new(0.037, 0, 0)
	Attachment0.Name = "Attachment0"
	Attachment1.Name = "Attachment1"
	
	Attachment0.Parent = Parent
	Attachment1.Parent = Parent
	Trail.Parent = Parent

	-- Update Impact-related properties
	for _, Effect in ipairs(ImpactEffects:GetChildren()) do
		local Clone = Effect:Clone()
		Clone.Parent = ImpactAttachment
	end
	
	ImpactAttachment.Name = ImpactName
	ImpactAttachment.Parent = Parent
	ImpactAttachment.Orientation = Vector3.new(0, 0, 0)
end

--[[
	Returns an empty object template that's going to be used as a droplet.
]]
function Functions.GetDroplet(ImpactName: string, IsDecal: boolean): {}
	-- Variable definitions
	local Droplet = Instance.new("MeshPart")
	
	-- Update properties
	Droplet.Size = Vector3.new(0.1, 0.1, 0.1)
	Droplet.Transparency = 0.25
	Droplet.Material = Enum.Material.Glass
	
	Droplet.Anchored = false
	Droplet.CanCollide = false
	Droplet.CanQuery = false
	Droplet.CanTouch = false
	
	-- Export droplet
	Functions.CreateEffects(Droplet, ImpactName)
	return Droplet
end

--[[
  Returns a folder that handles droplets; If it doesn't exist,
  make a new one in Workspace.Terrain.
]]
function Functions.GetFolder(Name: string): Folder
	-- Variable definitons
	local Terrain = Workspace.Terrain
	local DropletsFolder = (Terrain:FindFirstChild(Name) or Instance.new("Folder"))

	-- Update properties
	DropletsFolder.Name = Name
	DropletsFolder.Parent = Terrain

	-- Export folder
	return DropletsFolder
end

--[[
  Returns a Vector3, given the array range.
]]
function Functions.GetVector(Range: {})
	-- Vector definition
	local Vector = Vector3.new(
		Random:NextNumber(Unpack(Range)),
		Random:NextNumber(Unpack(Range)),
		Random:NextNumber(Unpack(Range))
	)

	-- Export position with applied offset
	return Vector
end

--[[
  NextNumber; Uses a global Random class,
  this is done for efficency.
]]
function Functions.NextNumber(Minimum, Maximum): number
	return Random:NextNumber(Minimum, Maximum)
end

--[[
  An efficent way of doing TweenService:Create(...)
]]
function Functions.CreateTween(Object: Instance, Info: TweenInfo, Goal: {}): Tween
	-- Export tween
	return TweenService:Create(Object, Info, Goal)
end

--[[
  Plays a sound in the given parent,
  used to play `End` & `Start` sounds.
]]
function Functions.PlaySound(Sound: Sound, Parent: Instance)
	if not Sound then
		return
	end

	local SoundClone = Sound:Clone()
	SoundClone.Parent = Parent

	SoundClone.Ended:Connect(function()
		SoundClone:Destroy()
	end)

	SoundClone:Play()
end

--[[
  Returns a random value/object from the
  given table.
]]
function Functions.GetRandom(Table: {})
	return #Table > 0 and Table[math.random(1, #Table)]
end

--[[
  Resets the properties of the given droplet,
  used to return pools to be recycled.
]]
function Functions.ResetDroplet(Object: Instance, Original: Instance)
	-- Variable definitions
	local Decal = Object:FindFirstChildOfClass("SurfaceAppearance")
	local Weld = Object:FindFirstChildOfClass("WeldConstraint")
	local Trail = Object:FindFirstChildOfClass("Trail")

	-- Reset all properties
	for _, Property: string in Properties do
		Object[Property] = Original[Property]
	end

	-- Update outsider properties
	if Trail then
		Trail.Enabled = false
	end

	if Weld then
		Weld:Destroy()
	end

	if Decal then
		Decal:Destroy()
	end

	-- Export object
	return Object
end

--[[
	Manages the sequence of decals;
	initiates only when the Type is designated as Decals.
]]
function Functions.ApplyDecal(Object: Instance, IsDecal: boolean)
	if not IsDecal then
		return
	end

	-- Variable definitions
	local Decal: SurfaceAppearance = Functions.GetRandom(Decals):Clone()

	-- Update Decal properties
	Decal.Parent = Object
end

--[[
	Emits particles by looping
	through an attachment's children; emitting a specific
	amount of them using the given amount.
]]
function Functions.EmitParticles(Attachment: Attachment, Amount: number)
	-- Variable definitions
	local Particles = Attachment:GetChildren()

	-- Emits particles
	for _, Particle: ParticleEmitter in Particles do
		if not Particle:IsA("ParticleEmitter") then
			continue
		end

		Particle:Emit(Amount)
	end
end

--[[
	Returns the closest part within a given distance.
]]
function Functions.GetClosest(Origin: BasePart, Magnitude: number, Ancestor): BasePart
	-- Variable definitions
	local Children = Ancestor:GetChildren()
	local ClosestPart = nil
	local MinimumDistance = math.huge

	for _, Part: BasePart in Children do
		local Distance = (Origin.Position - Part.Position).Magnitude

		local Logic = (not Part.Anchored and Origin ~= Part and Distance < Magnitude and Distance < MinimumDistance)

		if not Logic then
			continue
		end

		MinimumDistance = Distance
		ClosestPart = Part
	end

	-- Export closest part
	return ClosestPart
end

--[[
	Provides the target angles; utilized to
	assign the orientation to base position or CFrame.
]]
function Functions.GetAngles(IsDecal: boolean, RandomAngles: boolean): CFrame
	-- Variable definitions
	local RandomAngle = Functions.NextNumber(0, 180)
	local AngleX = (IsDecal and -math.pi / 2 or math.pi / 2)
	local AngleY = (RandomAngles and RandomAngle or 0)

	-- Export angles
	return CFrame.Angles(AngleX, AngleY, 0)
end

--[[
	Delievers the target position; serves
	as a foundation that is subsequently
	applied with an orientation.
]]
function Functions.GetCFrame(Position: Vector3, Normal: Vector3, IsDecal: boolean): CFrame
	-- Variable definitions
	local DecalOffset = (IsDecal and (Normal / 76) or Vector3.zero)

	local Base = (Position + DecalOffset)

	local Target = (Position + Normal)

	-- Export cframe
	return CFrame.new(Base, Target)
end

--[[
	Refines the components of the given
	Vector3; utilized to implement modifications
	based on factors.
]]
function Functions.RefineVectors(IsDecal: boolean, VectorData: Vector3)
	local YVector = (IsDecal and 0 or VectorData.Y)

	return Vector3.new(VectorData.X, YVector, VectorData.Z)
end

--[[
  Weld, creates a WeldConstraint between two parts
   (Part0 and Part1).
]]
function Functions.Weld(Part0: BasePart, Part1: BasePart): WeldConstraint
	-- Variable definitions
	local Weld = Instance.new("WeldConstraint")

	-- Update Part properties
	Part1.Anchored = false

	-- Update Weld properties
	Weld.Parent = Part1
	Weld.Part0 = Part0
	Weld.Part1 = Part1

	-- Export weld
	return Weld
end

--[[
	Adds a connection to a table that holds connections.
]]
function Functions.Connect(Connection: RBXScriptConnection, Holder: { RBXScriptConnection })
	-- Update table
	table.insert(Holder, Connection)
end

--[[
	Destroys and disconnects all the connections 
	in a table that holds connections.
]]
function Functions.DisconnectAll(Holder: { RBXScriptConnection })
	-- Disconnect and destroy connections in Holder
	for Index, Connection: RBXScriptConnection in Holder do
		Connection:Disconnect()
		Holder[Index] = nil
	end
end

--[[
	Basic function used to replace the initial module methods,
	therefore avoiding errors after deletion of the module.
]]
function Functions.Replacement()
	warn("BLOOD-ENGINE - Attempt to call a deleted function.")
end

return Functions
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX9886F3802A5C45779B7F88C4CD402D1C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Assets</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX84E256BA79A5475ABD3288D72E9D7EAB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Sounds</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX86DA025875414F8F9602D5BCB4FA2413">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Start</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBXE57C111AEF344815B5FA81E517605DAE">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">End</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Sound" referent="RBXB6D030FA19094B53B79561502EA65FCF">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 3 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181422</url></Content>
											<int64 name="SourceAssetId">9114181422</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBXDF32E9B4A471457798BB3FC4A2C29A87">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 5 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181479</url></Content>
											<int64 name="SourceAssetId">9114181479</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX25FE05D7DFBD4AF29373C75E08948208">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 26 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114182396</url></Content>
											<int64 name="SourceAssetId">9114182396</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX3344B5AA2E46472781956E72E0D0D9B2">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 4 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181407</url></Content>
											<int64 name="SourceAssetId">9114181407</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBXF60DA08890D349609793A6EFCB69169E">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 1 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181256</url></Content>
											<int64 name="SourceAssetId">9114181256</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX45DE68E7134A4E9FA42EDA2EC984D7AE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 12 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181846</url></Content>
											<int64 name="SourceAssetId">9114181846</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBXFAAD43E757ED4AD9B334879D5FB8C742">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 27 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114182402</url></Content>
											<int64 name="SourceAssetId">9114182402</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX426D514109D1460899C5B8523F0816AE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 19 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114182048</url></Content>
											<int64 name="SourceAssetId">9114182048</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX0D3A01006B72460F8C7EC4FC29F941E5">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 10 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181708</url></Content>
											<int64 name="SourceAssetId">9114181708</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBXB87F2660B9804264AA09D5163246DE29">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 40 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114183047</url></Content>
											<int64 name="SourceAssetId">9114183047</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX1EEF8D498F4D4FE98B308C7E8A6F8297">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 9 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181703</url></Content>
											<int64 name="SourceAssetId">9114181703</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBXF611B13DEDC443A09A8755C21DD02C14">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 7 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181526</url></Content>
											<int64 name="SourceAssetId">9114181526</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBXF9565D87FD36491C989D0FE41B9F7429">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 14 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181955</url></Content>
											<int64 name="SourceAssetId">9114181955</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX85D8B8D3D4804163A5DE2CFCE25FFD37">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<string name="Name">Drip Slapping 17 (SFX)</string>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114182055</url></Content>
											<int64 name="SourceAssetId">9114182055</int64>
											<BinaryString name="Tags"></BinaryString>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX97501FC0E19B4D33A17B4242FC1EE00E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Essentials</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX1C8A2BEC3E8C4967B91C3F445A01CD81">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">PartCache</string>
										<string name="ScriptGuid">{C6AEEBA7-9DD9-4C95-8650-5977F69D4EF7}</string>
										<ProtectedString name="Source"><![CDATA[--!strict

--[[
	PartCache V4.0 by Xan the Dragon // Eti the Spirit -- RBX 18406183
	Update V4.0 has added Luau Strong Type Enforcement.
	
	Creating parts is laggy, especially if they are supposed to be there for a split second and/or need to be made frequently.
	This module aims to resolve this lag by pre-creating the parts and CFraming them to a location far away and out of sight.
	When necessary, the user can get one of these parts and CFrame it to where they need, then return it to the cache when they are done with it.
	
	According to someone instrumental in Roblox's backend technology, zeuxcg (https://devforum.roblox.com/u/zeuxcg/summary)...
		>> CFrame is currently the only "fast" property in that you can change it every frame without really heavy code kicking in. Everything else is expensive.
		
		- https://devforum.roblox.com/t/event-that-fires-when-rendering-finishes/32954/19
	
	This alone should ensure the speed granted by this module.
		
		
	HOW TO USE THIS MODULE:
	
	Look at the bottom of my thread for an API! https://devforum.roblox.com/t/partcache-for-all-your-quick-part-creation-needs/246641
--]]
local table = require(script:WaitForChild("Table"))

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local PartCacheStatic = {}
PartCacheStatic.__index = PartCacheStatic
PartCacheStatic.__type = "PartCache" -- For compatibility with TypeMarshaller

-- TYPE DEFINITION: Part Cache Instance
export type PartCache = {
	Open: { [number]: BasePart },
	InUse: { [number]: BasePart },
	CurrentCacheParent: Instance,
	Template: BasePart,
	ExpansionSize: number,
}

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------

-- A CFrame that's really far away. Ideally. You are free to change this as needed.
local CF_REALLY_FAR_AWAY = CFrame.new(0, 10e8, 0)

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE =
	"Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-----------------------------------------------------------
------------------------ UTILITIES ------------------------
-----------------------------------------------------------

--Similar to assert but warns instead of errors.
local function assertwarn(requirement: boolean, messageIfNotMet: string)
	if requirement == false then
		warn(messageIfNotMet)
	end
end

--Dupes a part from the template.
local function MakeFromTemplate(template: BasePart, currentCacheParent: Instance): BasePart
	local part: BasePart = template:Clone()
	-- ^ Ignore W000 type mismatch between Instance and BasePart. False alert.

	part.CFrame = CF_REALLY_FAR_AWAY
	part.Anchored = true
	part.Parent = currentCacheParent
	return part
end

function PartCacheStatic.new(template: BasePart, numPrecreatedParts: number?, currentCacheParent: Instance?): PartCache
	local newNumPrecreatedParts: number = numPrecreatedParts or 5
	local newCurrentCacheParent: Instance = currentCacheParent or workspace

	--PrecreatedParts value.
	--Same thing. Ensure it's a number, ensure it's not negative, warn if it's really huge or 0.
	assert(numPrecreatedParts > 0, "PrecreatedParts can not be negative!")
	assertwarn(
		numPrecreatedParts ~= 0,
		"PrecreatedParts is 0! This may have adverse effects when initially using the cache."
	)
	assertwarn(
		template.Archivable,
		"The template's Archivable property has been set to false, which prevents it from being cloned. It will temporarily be set to true."
	)

	local oldArchivable = template.Archivable
	template.Archivable = true
	local newTemplate: BasePart = template:Clone()
	-- ^ Ignore W000 type mismatch between Instance and BasePart. False alert.

	template.Archivable = oldArchivable
	template = newTemplate

	local object: PartCache = {
		Open = {},
		InUse = {},
		CurrentCacheParent = newCurrentCacheParent,
		Template = template,
		ExpansionSize = 10,
	}
	setmetatable(object, PartCacheStatic)

	-- Below: Ignore type mismatch nil | number and the nil | Instance mismatch on the table.insert line.
	for _ = 1, newNumPrecreatedParts do
		table.insert(object.Open, MakeFromTemplate(template, object.CurrentCacheParent))
	end
	object.Template.Parent = nil

	return object
	-- ^ Ignore mismatch here too
end

-- Gets a part from the cache, or creates one if no more are available.
function PartCacheStatic:GetPart(): BasePart
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("GetPart", "PartCache.new"))

	if #self.Open == 0 then
		warn(
			"No parts available in the cache! Creating ["
				.. self.ExpansionSize
				.. "] new part instance(s) - this amount can be edited by changing the ExpansionSize property of the PartCache instance... (This cache now contains a grand total of "
				.. tostring(#self.Open + #self.InUse + self.ExpansionSize)
				.. " parts.)"
		)
		for i = 1, self.ExpansionSize, 1 do
			table.insert(self.Open, MakeFromTemplate(self.Template, self.CurrentCacheParent))
		end
	end
	local part = self.Open[#self.Open]
	self.Open[#self.Open] = nil
	table.insert(self.InUse, part)
	return part
end

-- Returns a part to the cache.
function PartCacheStatic:ReturnPart(part: BasePart)
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("ReturnPart", "PartCache.new"))

	local index = table.indexOf(self.InUse, part)
	if index ~= nil then
		table.remove(self.InUse, index)
		table.insert(self.Open, part)
		part.CFrame = CF_REALLY_FAR_AWAY
		part.Anchored = true
	else
		error(
			'Attempted to return part "'
				.. part.Name
				.. '" ('
				.. part:GetFullName()
				.. ") to the cache, but it's not in-use! Did you call this on the wrong part?"
		)
	end
end

-- Sets the parent of all cached parts.
function PartCacheStatic:SetCacheParent(newParent: Instance)
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("SetCacheParent", "PartCache.new"))
	assert(
		newParent:IsDescendantOf(workspace) or newParent == workspace,
		"Cache parent is not a descendant of Workspace! Parts should be kept where they will remain in the visible world."
	)

	self.CurrentCacheParent = newParent
	for i = 1, #self.Open do
		self.Open[i].Parent = newParent
	end
	for i = 1, #self.InUse do
		self.InUse[i].Parent = newParent
	end
end

-- Adds numParts more parts to the cache.
function PartCacheStatic:Expand(numParts: number): ()
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("Expand", "PartCache.new"))
	if numParts == nil then
		numParts = self.ExpansionSize
	end

	for i = 1, numParts do
		table.insert(self.Open, MakeFromTemplate(self.Template, self.CurrentCacheParent))
	end
end

-- Destroys this cache entirely. Use this when you don't need this cache object anymore.
function PartCacheStatic:Dispose()
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("Dispose", "PartCache.new"))
	for i = 1, #self.Open do
		self.Open[i]:Destroy()
	end
	for i = 1, #self.InUse do
		self.InUse[i]:Destroy()
	end
	self.Template:Destroy()
	self.Open = {}
	self.InUse = {}
	self.CurrentCacheParent = nil

	self.GetPart = nil
	self.ReturnPart = nil
	self.SetCacheParent = nil
	self.Expand = nil
	self.Dispose = nil
end

export type Class = typeof(PartCacheStatic.new(...))

return PartCacheStatic
]]></ProtectedString>
										<int64 name="SourceAssetId">2904807375</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX986BF0C68E74429D913AA04C6D0B729D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Table</string>
											<string name="ScriptGuid">{258BAD04-B404-41C0-A1BA-7EDAD3609E86}</string>
											<ProtectedString name="Source"><![CDATA[--!nocheck
--^ It works. Just get the type checker to shut up so that people don't send bug reports :P

--[[
	To use: local table = require(this)
	(Yes, override table.)

	Written by EtiTheSpirit. Adds custom functions to the `table` value provided by roblox (in normal cases, this would simply modify `table`, but Roblox has disabled that so we need to use a proxy)
	
	CHANGES:
		3 December 2019 @ 11:07 PM CST:
			+ Added table.join
			
			
		21 November 2019 @ 6:50 PM CST:
			+ Added new method bodies to skip/take using Luau's new methods. Drastic speed increases achieved. CREDITS: Halalaluyafail3 (See https://devforum.roblox.com/t/sandboxed-table-system-add-custom-methods-to-table/391177/12?u=etithespirit)
			+ Added table.retrieve as proposed by ^ under the name "table.range" as this name relays what it does a bit better, I think.
			+ Added table.skipAndTake as an alias method.

--]]

local RNG = Random.new()
local Table = {}

for index, value in pairs(table) do
	Table[index] = value
end

-- Returns true if the table contains the specified value.
Table.contains = function (tbl, value)
	return Table.indexOf(tbl, value) ~= nil -- This is kind of cheatsy but it promises the best performance.
end

-- A combo of table.find and table.keyOf -- This first attempts to find the ordinal index of your value, then attempts to find the lookup key if it can't find an ordinal index.
Table.indexOf = function (tbl, value)
	local fromFind = table.find(tbl, value)
	if fromFind then return fromFind end
	
	return Table.keyOf(tbl, value)
end

-- Returns the key of the specified value, or nil if it could not be found. Unlike IndexOf, this searches every key in the table, not just ordinal indices (arrays)
-- This is inherently slower due to how lookups work, so if your table is structured like an array, use table.find
Table.keyOf = function (tbl, value)
	for index, obj in pairs(tbl) do
		if obj == value then
			return index
		end
	end
	return nil
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Skips *n* objects in the table, and returns a new table that contains indices (n + 1) to (end of table)
Table.skip = function (tbl, n)
	return table.move(tbl, n+1, #tbl, 1, table.create(#tbl-n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes *n* objects from a table and returns a new table only containing those objects.
Table.take = function (tbl, n)
	return table.move(tbl, 1, n, 1, table.create(n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes the range of entries in this table in the range [start, finish] and returns that range as a table.
Table.range = function (tbl, start, finish)
	return table.move(tbl, start, finish, 1, table.create(finish - start + 1))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). An alias that calls table.skip(skip), and then takes [take] entries from the resulting table.
Table.skipAndTake = function (tbl, skip, take)
	return table.move(tbl, skip + 1, skip + take, 1, table.create(take))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Selects a random object out of tbl
Table.random = function (tbl)
	return tbl[RNG:NextInteger(1, #tbl)]
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Merges tbl0 and tbl1 together.
Table.join = function (tbl0, tbl1)
	local nt = table.create(#tbl0 + #tbl1)
	local t2 = table.move(tbl0, 1, #tbl0, 1, nt)
	return table.move(tbl1, 1, #tbl1, #tbl0 + 1, nt)
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Removes the specified object from this array.
Table.removeObject = function (tbl, obj)
	local index = Table.indexOf(tbl, obj)
	if index then
		table.remove(tbl, index)
	end
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Allocates a new table by getting the length of the current table and increasing its capacity by the specified amount.
-- This uses Roblox's table.create function.
Table.expand = function (tbl, byAmount)
	if (byAmount < 0) then
		error("Cannot expand a table by a negative amount of objects.")
	end
	
	local newtbl = table.create(#tbl + byAmount)
	for i = 1, #tbl do
		newtbl[i] = tbl[i]
	end
	return newtbl
end

return Table]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBX3FA77680EB6F421F8CECD5090E2FBB77">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">FastCast</string>
										<string name="ScriptGuid">{02E171E0-99B0-4684-8FC8-EFF92A64BCC6}</string>
										<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:

--[[
	Written by Eti the Spirit (18406183)
	
		The latest patch notes can be located here (and do note, the version at the top of this script might be outdated. I have a thing for forgetting to change it):
		>	https://etithespirit.github.io/FastCastAPIDocs/changelog
		
		*** If anything is broken, please don't hesitate to message me! ***
		
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		
		YOU SHOULD ONLY CREATE ONE CASTER PER GUN.
		YOU SHOULD >>>NEVER<<< CREATE A NEW CASTER EVERY TIME THE GUN NEEDS TO BE FIRED.
		
		A caster (created with FastCast.new()) represents a "gun".
		When you consider a gun, you think of stats like accuracy, bullet speed, etc. This is the info a caster stores. 
	
	--
	
	This is a library used to create hitscan-based guns that simulate projectile physics.
	
	This means:
		- You don't have to worry about bullet lag / jittering
		- You don't have to worry about keeping bullets at a low speed due to physics being finnicky between clients
		- You don't have to worry about misfires in bullet's Touched event (e.g. where it may going so fast that it doesn't register)
		
	Hitscan-based guns are commonly seen in the form of laser beams, among other things. Hitscan simply raycasts out to a target
	and says whether it hit or not.
	
	Unfortunately, while reliable in terms of saying if something got hit or not, this method alone cannot be used if you wish
	to implement bullet travel time into a weapon. As a result of that, I made this library - an excellent remedy to this dilemma.
	
	FastCast is intended to be require()'d once in a script, as you can create as many casters as you need with FastCast.new()
	This is generally handy since you can store settings and information in these casters, and even send them out to other scripts via events
	for use.
	
	Remember -- A "Caster" represents an entire gun (or whatever is launching your projectiles), *NOT* the individual bullets.
	Make the caster once, then use the caster to fire your bullets. Do not make a caster for each bullet.
--]]

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local FastCast = {}
FastCast.DebugLogging = false
FastCast.VisualizeCasts = false
FastCast.__index = FastCast
FastCast.__type = "FastCast" -- For compatibility with TypeMarshaller

-- Extra stuff
FastCast.HighFidelityBehavior = {
	Default = 1,
	Always = 3
}

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------
local ActiveCastStatic = require(script.ActiveCast)
local Signal = require(script.Signal)
local table = require(script.Table)

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-- The name of the folder containing the 3D GUI elements for visualizing casts.
local FC_VIS_OBJ_NAME = "FastCastVisualizationObjects"

-- Format params: N/A
local ERR_OBJECT_DISPOSED = "This Caster has been disposed. It can no longer be used."

-----------------------------------------------------------
--------------------- TYPE DEFINITION ---------------------
-----------------------------------------------------------

-- This will inject all types into this context.
local TypeDefs = require(script.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

-----------------------------------------------------------
----------------------- STATIC CODE -----------------------
-----------------------------------------------------------

-- Tell the ActiveCast factory module what FastCast actually *is*.
ActiveCastStatic.SetStaticFastCastReference(FastCast)

-----------------------------------------------------------
------------------------- EXPORTS -------------------------
-----------------------------------------------------------

-- Constructor.
function FastCast.new()
	return setmetatable({
		LengthChanged = Signal.new("LengthChanged"),
		RayHit = Signal.new("RayHit"),
		RayPierced = Signal.new("RayPierced"),
		CastTerminating = Signal.new("CastTerminating"),
		WorldRoot = workspace
	}, FastCast)
end

-- Create a new ray info object.
-- This is just a utility alias with some extra type checking.
function FastCast.newBehavior(): FastCastBehavior
	-- raycastParams, maxDistance, acceleration, canPierceFunction, cosmeticBulletTemplate, cosmeticBulletContainer, autoIgnoreBulletContainer
	return {
		Parallel = false,
		RaycastParams = nil,
		Acceleration = Vector3.new(),
		MaxDistance = 1000,
		CanPierceFunction = nil,
		HighFidelityBehavior = FastCast.HighFidelityBehavior.Default,
		HighFidelitySegmentSize = 0.5,
		CosmeticBulletTemplate = nil,
		CosmeticBulletProvider = nil,
		CosmeticBulletContainer = nil,
		AutoIgnoreContainer = true
	}
end

local DEFAULT_DATA_PACKET = FastCast.newBehavior()
function FastCast:Fire(origin: Vector3, direction: Vector3, velocity: Vector3 | number, castDataPacket: FastCastBehavior?): ActiveCast
	if castDataPacket == nil then castDataPacket = DEFAULT_DATA_PACKET end
	
	local cast = ActiveCastStatic.new(self, origin, direction, velocity, castDataPacket)
	cast.RayInfo.WorldRoot = self.WorldRoot
	return cast
end

-- Export
export type Class = typeof(FastCast.new())
export type Behavior = typeof(FastCast.newBehavior())
return FastCast]]></ProtectedString>
										<int64 name="SourceAssetId">4453855787</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX15B4EC649A4642788CAD67F9F5458126">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Table</string>
											<string name="ScriptGuid">{88B98C7E-B97A-49A7-AF5F-48E6A0151625}</string>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- shut up jesser

--[[
	To use: local table = require(this)
	(Yes, override table.)

	Written by EtiTheSpirit. Adds custom functions to the `table` value provided by roblox (in normal cases, this would simply modify `table`, but Roblox has disabled that so we need to use a proxy)
	
	CHANGES:
		3 December 2019 @ 11:07 PM CST:
			+ Added table.join
			
			
		21 November 2019 @ 6:50 PM CST:
			+ Added new method bodies to skip/take using Luau's new methods. Drastic speed increases achieved. CREDITS: Halalaluyafail3 (See https://devforum.roblox.com/t/sandboxed-table-system-add-custom-methods-to-table/391177/12?u=etithespirit)
			+ Added table.retrieve as proposed by ^ under the name "table.range" as this name relays what it does a bit better, I think.
			+ Added table.skipAndTake as an alias method.

--]]

local RNG = Random.new()
local RobloxTable = table
local Table = {}

-- Returns true if the table contains the specified value.
Table.contains = function (tbl, value)
	return Table.indexOf(tbl, value) ~= nil -- This is kind of cheatsy but it promises the best performance.
end

-- A combo of table.find and table.keyOf -- This first attempts to find the ordinal index of your value, then attempts to find the lookup key if it can't find an ordinal index.
Table.indexOf = function (tbl, value)
	local fromFind = table.find(tbl, value)
	if fromFind then return fromFind end
	
	return Table.keyOf(tbl, value)
end

-- Returns the key of the specified value, or nil if it could not be found. Unlike IndexOf, this searches every key in the table, not just ordinal indices (arrays)
-- This is inherently slower due to how lookups work, so if your table is structured like an array, use table.find
Table.keyOf = function (tbl, value)
	for index, obj in pairs(tbl) do
		if obj == value then
			return index
		end
	end
	return nil
end

-- Only works on ordinal. yada yada.
Table.insertAndGetIndexOf = function (tbl, value)
	tbl[#tbl + 1] = value
	return #tbl
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Skips *n* objects in the table, and returns a new table that contains indices (n + 1) to (end of table)
Table.skip = function (tbl, n)
	return table.move(tbl, n+1, #tbl, 1, table.create(#tbl-n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes *n* objects from a table and returns a new table only containing those objects.
Table.take = function (tbl, n)
	return table.move(tbl, 1, n, 1, table.create(n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes the range of entries in this table in the range [start, finish] and returns that range as a table.
Table.range = function (tbl, start, finish)
	return table.move(tbl, start, finish, 1, table.create(finish - start + 1))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). An alias that calls table.skip(skip), and then takes [take] entries from the resulting table.
Table.skipAndTake = function (tbl, skip, take)
	return table.move(tbl, skip + 1, skip + take, 1, table.create(take))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Selects a random object out of tbl
Table.random = function (tbl)
	return tbl[RNG:NextInteger(1, #tbl)]
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Merges tbl0 and tbl1 together.
Table.join = function (tbl0, tbl1)
	local nt = table.create(#tbl0 + #tbl1)
	local t2 = table.move(tbl0, 1, #tbl0, 1, nt)
	return table.move(tbl1, 1, #tbl1, #tbl0 + 1, nt)
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Removes the specified object from this array.
Table.removeObject = function (tbl, obj)
	local index = Table.indexOf(tbl, obj)
	if index then
		table.remove(tbl, index)
	end
end

return setmetatable({}, {
	__index = function(tbl, index)
		if Table[index] ~= nil then
			return Table[index]
		else
			return RobloxTable[index]
		end
	end;

	__newindex = function(tbl, index, value)
		error("Add new table entries by editing the Module itself.")
	end;
})]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXD9178E10F49C416584205639874CF531">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">ActiveCast</string>
											<string name="ScriptGuid">{DCDF577C-5426-4EA5-9CD7-D15FC061ED8F}</string>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:
-- ActiveCast class type.
-- The ActiveCast type represents a currently running cast.


-----------------------------------------------------------
--------------------- TYPE DEFINITION ---------------------
-----------------------------------------------------------

-- This will inject all types into this context.
local TypeDefs = require(script.Parent.TypeDefinitions)

type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

local typeof = require(script.Parent.TypeMarshaller)

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local ActiveCastStatic = {}
ActiveCastStatic.__index = ActiveCastStatic
ActiveCastStatic.__type = "ActiveCast" -- For compatibility with TypeMarshaller

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------
local RunService = game:GetService("RunService")
local table = require(script.Parent.Table)
local FastCast = nil -- Static reference to the FastCast static module.

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-- The name of the folder containing the 3D GUI elements for visualizing casts in debug mode.
local FC_VIS_OBJ_NAME = "FastCastVisualizationObjects"

-- Format params: N/A
local ERR_OBJECT_DISPOSED = "This ActiveCast has been terminated. It can no longer be used."

-- If pierce callback has to run more than this many times, it will register a hit and stop calculating pierces.
-- This only applies for repeated piercings, e.g. the amount of parts that fit within the space of a single cast segment (NOT the whole bullet's trajectory over its entire lifetime)
local MAX_PIERCE_TEST_COUNT = 100

-----------------------------------------------------------
------------------------ UTILITIES ------------------------
-----------------------------------------------------------

-- Looks for a folder within workspace.Terrain that contains elements to visualize casts.
local function GetFastCastVisualizationContainer(): Instance
	local fcVisualizationObjects = workspace.Terrain:FindFirstChild(FC_VIS_OBJ_NAME)
	if fcVisualizationObjects ~= nil then
		return fcVisualizationObjects
	end
	
	fcVisualizationObjects = Instance.new("Folder")
	fcVisualizationObjects.Name = FC_VIS_OBJ_NAME
	fcVisualizationObjects.Archivable = false -- TODO: Keep this as-is? You can't copy/paste it if this is false. I have it false so that it doesn't linger in studio if you save with the debug data in there.
	fcVisualizationObjects.Parent = workspace.Terrain
	return fcVisualizationObjects
end

-----------------------------------------------------------
------------------------ DEBUGGING ------------------------
-----------------------------------------------------------

-- Print that runs only if debug mode is active.
local function PrintDebug(message: string)
	if FastCast.DebugLogging == true then
		print(message)
	end
end

-- Visualizes a ray. This will not run if FastCast.VisualizeCasts is false.
function DbgVisualizeSegment(castStartCFrame: CFrame, castLength: number): ConeHandleAdornment?
	if FastCast.VisualizeCasts ~= true then return nil end
	local adornment = Instance.new("ConeHandleAdornment")
	adornment.Adornee = workspace.Terrain
	adornment.CFrame = castStartCFrame
	adornment.Height = castLength
	adornment.Color3 = Color3.new()
	adornment.Radius = 0.25
	adornment.Transparency = 0.5
	adornment.Parent = GetFastCastVisualizationContainer()
	return adornment
end

-- Visualizes an impact. This will not run if FastCast.VisualizeCasts is false.
function DbgVisualizeHit(atCF: CFrame, wasPierce: boolean): SphereHandleAdornment?
	if FastCast.VisualizeCasts ~= true then return nil end
	local adornment = Instance.new("SphereHandleAdornment")
	adornment.Adornee = workspace.Terrain
	adornment.CFrame = atCF
	adornment.Radius = 0.4
	adornment.Transparency = 0.25
	adornment.Color3 = (wasPierce == false) and Color3.new(0.2, 1, 0.5) or Color3.new(1, 0.2, 0.2)
	adornment.Parent = GetFastCastVisualizationContainer()
	return adornment
end

-----------------------------------------------------------
------------------------ CORE CODE ------------------------
-----------------------------------------------------------

-- Thanks to zoebasil for supplying the velocity and position functions below. (I've modified these functions)
-- I was having a huge issue trying to get it to work and I had overcomplicated a bunch of stuff.
-- GetPositionAtTime is used in physically simulated rays (Where Caster.HasPhysics == true or the specific Fire has a specified acceleration).
-- This returns the location that the bullet will be at when you specify the amount of time the bullet has existed, the original location of the bullet, and the velocity it was launched with.
local function GetPositionAtTime(time: number, origin: Vector3, initialVelocity: Vector3, acceleration: Vector3): Vector3
	local force = Vector3.new((acceleration.X * time^2) / 2,(acceleration.Y * time^2) / 2, (acceleration.Z * time^2) / 2)
	return origin + (initialVelocity * time) + force
end

-- A variant of the function above that returns the velocity at a given point in time.
local function GetVelocityAtTime(time: number, initialVelocity: Vector3, acceleration: Vector3): Vector3
	return initialVelocity + acceleration * time
end

local function GetTrajectoryInfo(cast: ActiveCast, index: number): {[number]: Vector3}
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local trajectories = cast.StateInfo.Trajectories
	local trajectory = trajectories[index]
	local duration = trajectory.EndTime - trajectory.StartTime
	
	local origin = trajectory.Origin
	local vel = trajectory.InitialVelocity
	local accel = trajectory.Acceleration
	
	return {GetPositionAtTime(duration, origin, vel, accel), GetVelocityAtTime(duration, vel, accel)}
end

local function GetLatestTrajectoryEndInfo(cast: ActiveCast): {[number]: Vector3}
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	return GetTrajectoryInfo(cast, #cast.StateInfo.Trajectories)
end

local function CloneCastParams(params: RaycastParams): RaycastParams
	local clone = RaycastParams.new()
	clone.CollisionGroup = params.CollisionGroup
	clone.FilterType = params.FilterType
	clone.FilterDescendantsInstances = params.FilterDescendantsInstances
	clone.IgnoreWater = params.IgnoreWater
	return clone
end

local function SendRayHit(cast: ActiveCast, resultOfCast: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
	cast.Caster.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
end

local function SendRayPierced(cast: ActiveCast, resultOfCast: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
	cast.Caster.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
end

local function SendLengthChanged(cast: ActiveCast, lastPoint: Vector3, rayDir: Vector3, rayDisplacement: number, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)
	cast.Caster.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)
end

-- Simulate a raycast by one tick.
local function SimulateCast(cast: ActiveCast, delta: number, expectingShortCall: boolean)
	
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	PrintDebug("Casting for frame.")
	local latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]
	
	local origin = latestTrajectory.Origin
	local totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	local initialVelocity = latestTrajectory.InitialVelocity
	local acceleration = latestTrajectory.Acceleration
	
	local lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
	local lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)
	local lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	
	cast.StateInfo.TotalRuntime += delta
	
	-- Recalculate this.
	totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	
	local currentTarget = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
	local segmentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration) 
	local totalDisplacement = currentTarget - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.
	
	local rayDir = totalDisplacement.Unit * segmentVelocity.Magnitude * delta
	local targetWorldRoot = cast.RayInfo.WorldRoot
	local resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)
	
	local point = currentTarget
	local part: Instance? = nil
	local material = Enum.Material.Air
	local normal = Vector3.new()
	
	if (resultOfCast ~= nil) then
		point = resultOfCast.Position
		part = resultOfCast.Instance
		material = resultOfCast.Material
		normal = resultOfCast.Normal
	end
	
	local rayDisplacement = (point - lastPoint).Magnitude
	-- For clarity -- totalDisplacement is how far the ray would have traveled if it hit nothing,
	-- and rayDisplacement is how far the ray really traveled (which will be identical to totalDisplacement if it did indeed hit nothing)
	
	SendLengthChanged(cast, lastPoint, rayDir.Unit, rayDisplacement, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
	cast.StateInfo.DistanceCovered += rayDisplacement
	
	local rayVisualization: ConeHandleAdornment? = nil
	if (delta > 0) then
		rayVisualization = DbgVisualizeSegment(CFrame.new(lastPoint, lastPoint + rayDir), rayDisplacement)
	end
	
	
	-- HIT DETECTED. Handle all that garbage, and also handle behaviors 1 and 2 (default behavior, go high res when hit) if applicable.
	-- CAST BEHAVIOR 2 IS HANDLED IN THE CODE THAT CALLS THIS FUNCTION.
	--task.synchronize()
	
	if part and part ~= cast.RayInfo.CosmeticBulletObject then
		local start = tick()
		PrintDebug("Hit something, testing now.")
		
		-- SANITY CHECK: Don't allow the user to yield or run otherwise extensive code that takes longer than one frame/heartbeat to execute.
		if (cast.RayInfo.CanPierceCallback ~= nil) then
			if expectingShortCall == false then
				if (cast.StateInfo.IsActivelySimulatingPierce) then
					cast:Terminate()
					error("ERROR: The latest call to CanPierceCallback took too long to complete! This cast is going to suffer desyncs which WILL cause unexpected behavior and errors. Please fix your performance problems, or remove statements that yield (e.g. wait() calls)")
					-- Use error. This should absolutely abort the cast.
				end
			end
			-- expectingShortCall is used to determine if we are doing a forced resolution increase, in which case this will be called several times in a single frame, which throws this error.
			cast.StateInfo.IsActivelySimulatingPierce = true
		end
		------------------------------
		
		if cast.RayInfo.CanPierceCallback == nil or (cast.RayInfo.CanPierceCallback ~= nil and cast.RayInfo.CanPierceCallback(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject) == false) then
			PrintDebug("Piercing function is nil or it returned FALSE to not pierce this hit.")
			cast.StateInfo.IsActivelySimulatingPierce = false
			
			if (cast.StateInfo.HighFidelityBehavior == 2 and latestTrajectory.Acceleration ~= Vector3.new() and cast.StateInfo.HighFidelitySegmentSize ~= 0) then
				cast.StateInfo.CancelHighResCast = false -- Reset this here.
				
				if cast.StateInfo.IsActivelyResimulating then
					cast:Terminate()
					error("Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.")
				end
				

				cast.StateInfo.IsActivelyResimulating = true
				
				-- This is a physics based cast and it needs to be recalculated.
				PrintDebug("Hit was registered, but recalculation is on for physics based casts. Recalculating to verify a real hit...")
				
				-- Split this ray segment into smaller segments of a given size.
				-- In 99% of cases, it won't divide evently (e.g. I have a distance of 1.25 and I want to divide into 0.1 -- that won't work)
				-- To fix this, the segments need to be stretched slightly to fill the space (rather than having a single shorter segment at the end)
				
				local numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments
				local numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments
				local realSegmentLength = rayDisplacement / numSegmentsReal -- this spits out 0.51, which isn't exact to the defined 0.5, but it's close
				
				-- Now the real hard part is converting this to time.
				local timeIncrement = delta / numSegmentsReal
				for segmentIndex = 1, numSegmentsReal do
					if cast.StateInfo.CancelHighResCast then
						cast.StateInfo.CancelHighResCast = false
						break
					end
					
					local subPosition = GetPositionAtTime(lastDelta + (timeIncrement * segmentIndex), origin, initialVelocity, acceleration)
					local subVelocity = GetVelocityAtTime(lastDelta + (timeIncrement * segmentIndex), initialVelocity, acceleration) 
					local subRayDir = subVelocity * delta
					local subResult = targetWorldRoot:Raycast(subPosition, subRayDir, cast.RayInfo.Parameters)
					
					local subDisplacement = (subPosition - (subPosition + subVelocity)).Magnitude
					
					if (subResult ~= nil) then
						local subDisplacement = (subPosition - subResult.Position).Magnitude
						local dbgSeg = DbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)
						if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059) end
						
						if cast.RayInfo.CanPierceCallback == nil or (cast.RayInfo.CanPierceCallback ~= nil and cast.RayInfo.CanPierceCallback(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject) == false) then
							-- Still hit even at high res
							cast.StateInfo.IsActivelyResimulating = false
							
							SendRayHit(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject)
							cast:Terminate()
							local vis = DbgVisualizeHit(CFrame.new(point), false)
							if (vis ~= nil) then vis.Color3 = Color3.new(0.0588235, 0.87451, 1) end
							return
						else
							-- Recalculating hit something pierceable instead.
							SendRayPierced(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject) -- This may result in CancelHighResCast being set to true.
							local vis = DbgVisualizeHit(CFrame.new(point), true)
							if (vis ~= nil) then vis.Color3 = Color3.new(1, 0.113725, 0.588235) end
							if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.305882, 0.243137, 0.329412) end
						end
					else
						local dbgSeg = DbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)
						if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059) end
						
					end
				end
				
				-- If the script makes it here, then it wasn't a real hit (higher resolution revealed that the low-res hit was faulty)
				-- Just let it keep going.
				cast.StateInfo.IsActivelyResimulating = false
			elseif (cast.StateInfo.HighFidelityBehavior ~= 1 and cast.StateInfo.HighFidelityBehavior ~= 3) then
				cast:Terminate()
				error("Invalid value " .. (cast.StateInfo.HighFidelityBehavior) .. " for HighFidelityBehavior.")
			else
				-- This is not a physics cast, or recalculation is off.
				PrintDebug("Hit was successful. Terminating.")
				SendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				cast:Terminate()
				DbgVisualizeHit(CFrame.new(point), false)
				return
			end
		else
			PrintDebug("Piercing function returned TRUE to pierce this part.")
			if rayVisualization ~= nil then
				rayVisualization.Color3 = Color3.new(0.4, 0.05, 0.05) -- Turn it red to signify that the cast was scrapped.
			end
			DbgVisualizeHit(CFrame.new(point), true)
			
			local params = cast.RayInfo.Parameters
			local alteredParts = {}
			local currentPierceTestCount = 0
			local originalFilter = params.FilterDescendantsInstances
			local brokeFromSolidObject = false
			while true do
				-- So now what I need to do is redo this entire cast, just with the new filter list
								
				-- Catch case: Is it terrain?
				if resultOfCast.Instance:IsA("Terrain") then
					if material == Enum.Material.Water then
						-- Special case: Pierced on water?
						cast:Terminate()
						error("Do not add Water as a piercable material. If you need to pierce water, set cast.RayInfo.Parameters.IgnoreWater = true instead", 0)
					end
					warn("WARNING: The pierce callback for this cast returned TRUE on Terrain! This can cause severely adverse effects.")
				end
				
				if params.FilterType == Enum.RaycastFilterType.Blacklist then
					-- blacklist
					-- DO NOT DIRECTLY TABLE.INSERT ON THE PROPERTY
					local filter = params.FilterDescendantsInstances
					table.insert(filter, resultOfCast.Instance)
					table.insert(alteredParts, resultOfCast.Instance)
					params.FilterDescendantsInstances = filter
				else
					-- whitelist
					-- method implemeneted by custom table system
					-- DO NOT DIRECTLY TABLE.REMOVEOBJECT ON THE PROPERTY
					local filter = params.FilterDescendantsInstances
					table.removeObject(filter, resultOfCast.Instance)
					table.insert(alteredParts, resultOfCast.Instance)
					params.FilterDescendantsInstances = filter
				end
				
				SendRayPierced(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				
				-- List has been updated, so let's cast again.
				resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, params)
				
				-- No hit? No simulation. Break.
				if resultOfCast == nil then
					break
				end
				
				if currentPierceTestCount >= MAX_PIERCE_TEST_COUNT then
					warn("WARNING: Exceeded maximum pierce test budget for a single ray segment (attempted to test the same segment " .. MAX_PIERCE_TEST_COUNT .. " times!)")
					break
				end
				currentPierceTestCount = currentPierceTestCount + 1;
				
				if cast.RayInfo.CanPierceCallback(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject) == false then
					brokeFromSolidObject = true
					break
				end
			end
			
			-- Restore the filter to its default state.
			cast.RayInfo.Parameters.FilterDescendantsInstances = originalFilter
			cast.StateInfo.IsActivelySimulatingPierce = false
			
			if brokeFromSolidObject then
				-- We actually hit something while testing.
				PrintDebug("Broke because the ray hit something solid (" .. tostring(resultOfCast.Instance) .. ") while testing for a pierce. Terminating the cast.")
				SendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				cast:Terminate()
				DbgVisualizeHit(CFrame.new(resultOfCast.Position), false)
				return
			end
			
			-- And exit the function here too.
		end
	end
	
	if (cast.StateInfo.DistanceCovered >= cast.RayInfo.MaxDistance) then
		-- SendRayHit(cast, nil, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
		cast:Terminate()
		DbgVisualizeHit(CFrame.new(currentTarget), false)
	end
end

-----------------------------------------------------------
------------------------- EXPORTS -------------------------
-----------------------------------------------------------

-- Ctor
function ActiveCastStatic.new(caster: Caster, origin: Vector3, direction: Vector3, velocity: Vector3 | number, castDataPacket: FastCastBehavior): ActiveCast
	if typeof(velocity) == "number" then
		velocity = direction.Unit * velocity
	end	
	
	if (castDataPacket.HighFidelitySegmentSize <= 0) then
		error("Cannot set FastCastBehavior.HighFidelitySegmentSize <= 0!", 0)
	end
	
	-- Basic setup
	local cast = {
		Caster = caster,
		
		-- Data that keeps track of what's going on as well as edits we might make during runtime.
		StateInfo = {
			UpdateConnection = nil,
			Paused = false,
			TotalRuntime = 0,
			DistanceCovered = 0,
			HighFidelitySegmentSize = castDataPacket.HighFidelitySegmentSize,
			HighFidelityBehavior = castDataPacket.HighFidelityBehavior,
			IsActivelySimulatingPierce = false,
			IsActivelyResimulating = false,
			CancelHighResCast = false,
			Trajectories = {
				{
					StartTime = 0,
					EndTime = -1,
					Origin = origin,
					InitialVelocity = velocity,
					Acceleration = castDataPacket.Acceleration
				}
			}
		},
		
		-- Information pertaining to actual raycasting.
		RayInfo = {
			Parameters = castDataPacket.RaycastParams,
			WorldRoot = workspace,
			MaxDistance = castDataPacket.MaxDistance or 1000,
			CosmeticBulletObject = castDataPacket.CosmeticBulletTemplate, -- This is intended. We clone it a smidge of the way down.
			CanPierceCallback = castDataPacket.CanPierceFunction
		},
		
		UserData = {}
	}
	
	if cast.StateInfo.HighFidelityBehavior == 2 then
		cast.StateInfo.HighFidelityBehavior = 3
	end
	
	
	if cast.RayInfo.Parameters ~= nil then
		cast.RayInfo.Parameters = CloneCastParams(cast.RayInfo.Parameters)
	else
		cast.RayInfo.Parameters = RaycastParams.new()
	end

	local usingProvider = false
	if castDataPacket.CosmeticBulletProvider == nil then
		-- The provider is nil. Use a cosmetic object clone.
		if cast.RayInfo.CosmeticBulletObject ~= nil then
			cast.RayInfo.CosmeticBulletObject = cast.RayInfo.CosmeticBulletObject:Clone()
			cast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)
			cast.RayInfo.CosmeticBulletObject.Parent = castDataPacket.CosmeticBulletContainer
		end
	else
		-- The provider is not nil.
		-- Is it what we want?
		if typeof(castDataPacket.CosmeticBulletProvider) == "PartCache" then
			-- this modded version of typeof is implemented up top.
			-- Aside from that, yes, it's a part cache. Good to go!
			
			if cast.RayInfo.CosmeticBulletObject ~= nil then
				-- They also set the template. Not good. Warn + clear this up.
				warn("Do not define FastCastBehavior.CosmeticBulletTemplate and FastCastBehavior.CosmeticBulletProvider at the same time! The provider will be used, and CosmeticBulletTemplate will be set to nil.")
				cast.RayInfo.CosmeticBulletObject = nil
				castDataPacket.CosmeticBulletTemplate = nil
			end

			cast.RayInfo.CosmeticBulletObject = castDataPacket.CosmeticBulletProvider:GetPart()
			cast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)
			usingProvider = true
		else
			warn("FastCastBehavior.CosmeticBulletProvider was not an instance of the PartCache module (an external/separate model)! Are you inputting an instance created via PartCache.new? If so, are you on the latest version of PartCache? Setting FastCastBehavior.CosmeticBulletProvider to nil.")
			castDataPacket.CosmeticBulletProvider = nil
		end
	end

	local targetContainer: Instance;
	if usingProvider then
		targetContainer = castDataPacket.CosmeticBulletProvider.CurrentCacheParent
	else
		targetContainer = castDataPacket.CosmeticBulletContainer
	end
	
	if castDataPacket.AutoIgnoreContainer == true and targetContainer ~= nil then
		local ignoreList = cast.RayInfo.Parameters.FilterDescendantsInstances
		if table.find(ignoreList, targetContainer) == nil then
			table.insert(ignoreList, targetContainer)
			cast.RayInfo.Parameters.FilterDescendantsInstances = ignoreList
		end
	end
	
	local event
	if RunService:IsClient() then
		event = RunService.RenderStepped
	else
		event = RunService.Heartbeat
	end
	
	setmetatable(cast, ActiveCastStatic)
	
	local function Stepped(delta)
		if cast.StateInfo.Paused then return end

		PrintDebug("Casting for frame.")
		local latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]
		if (cast.StateInfo.HighFidelityBehavior == 3 and latestTrajectory.Acceleration ~= Vector3.new() and cast.StateInfo.HighFidelitySegmentSize > 0) then

			local timeAtStart = tick()

			if cast.StateInfo.IsActivelyResimulating then
				cast:Terminate()
				error("Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.")
			end

			cast.StateInfo.IsActivelyResimulating = true

			-- Actually want to calculate this early to find displacement
			local origin = latestTrajectory.Origin
			local totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
			local initialVelocity = latestTrajectory.InitialVelocity
			local acceleration = latestTrajectory.Acceleration

			local lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
			local lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)
			local lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime

			cast.StateInfo.TotalRuntime += delta

			-- Recalculate this.
			totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime

			local currentPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
			local currentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration) 
			local totalDisplacement = currentPoint - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.

			local rayDir = totalDisplacement.Unit * currentVelocity.Magnitude * delta
			local targetWorldRoot = cast.RayInfo.WorldRoot
			local resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)

			local point = currentPoint

			if (resultOfCast ~= nil) then
				point = resultOfCast.Position
			end

			local rayDisplacement = (point - lastPoint).Magnitude

			-- Now undo this. The line below in the for loop will add this time back gradually.
			cast.StateInfo.TotalRuntime -= delta

			-- And now that we have displacement, we can calculate segment size.
			local numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments
			local numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments
			if (numSegmentsReal == 0) then
				numSegmentsReal = 1
			end

			local timeIncrement = delta / numSegmentsReal

			for segmentIndex = 1, numSegmentsReal do
				if getmetatable(cast) == nil then return end -- Could have been disposed.
				if cast.StateInfo.CancelHighResCast then
					cast.StateInfo.CancelHighResCast = false
					break
				end
				PrintDebug("[" .. segmentIndex .. "] Subcast of time increment " .. timeIncrement)
				SimulateCast(cast, timeIncrement, true)
			end

			if getmetatable(cast) == nil then return end -- Could have been disposed.
			cast.StateInfo.IsActivelyResimulating = false

			if (tick() - timeAtStart) > 0.016 * 5 then
				warn("Extreme cast lag encountered! Consider increasing HighFidelitySegmentSize.")
			end
		else
			SimulateCast(cast, delta, false)
		end
	end
	
	cast.StateInfo.UpdateConnection = (
		castDataPacket.Parallel and event:ConnectParallel(Stepped) 
		or event:Connect(Stepped)
	)
	
	return cast
end

function ActiveCastStatic.SetStaticFastCastReference(ref)
	FastCast = ref
end

---- GETTERS AND SETTERS ----

local function ModifyTransformation(cast: ActiveCast, velocity: Vector3?, acceleration: Vector3?, position: Vector3?)
	local trajectories = cast.StateInfo.Trajectories
	local lastTrajectory = trajectories[#trajectories]
	
	-- NEW BEHAVIOR: Don't create a new trajectory if we haven't even used the current one.
	if lastTrajectory.StartTime == cast.StateInfo.TotalRuntime then
		-- This trajectory is fresh out of the box. Let's just change it since it hasn't actually affected the cast yet, so changes won't have adverse effects.
		if (velocity == nil) then
			velocity = lastTrajectory.InitialVelocity
		end
		if (acceleration == nil) then
			acceleration = lastTrajectory.Acceleration
		end
		if (position == nil) then
			position = lastTrajectory.Origin
		end	
		
		lastTrajectory.Origin = position
		lastTrajectory.InitialVelocity = velocity
		lastTrajectory.Acceleration = acceleration
	else
		-- The latest trajectory is done. Set its end time and get its location. 
		lastTrajectory.EndTime = cast.StateInfo.TotalRuntime
		
		local point, velAtPoint = unpack(GetLatestTrajectoryEndInfo(cast))
		
		if (velocity == nil) then
			velocity = velAtPoint
		end
		if (acceleration == nil) then
			acceleration = lastTrajectory.Acceleration
		end
		if (position == nil) then
			position = point
		end	
		table.insert(cast.StateInfo.Trajectories, {
			StartTime = cast.StateInfo.TotalRuntime,
			EndTime = -1,
			Origin = position,
			InitialVelocity = velocity,
			Acceleration = acceleration
		})
		cast.StateInfo.CancelHighResCast = true
	end
end

function ActiveCastStatic:SetVelocity(velocity: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, velocity, nil, nil)
end

function ActiveCastStatic:SetAcceleration(acceleration: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, nil, acceleration, nil)
end

function ActiveCastStatic:SetPosition(position: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, nil, nil, position)
end

function ActiveCastStatic:GetVelocity(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return GetVelocityAtTime(self.StateInfo.TotalRuntime - currentTrajectory.StartTime, currentTrajectory.InitialVelocity, currentTrajectory.Acceleration)
end

function ActiveCastStatic:GetAcceleration(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return currentTrajectory.Acceleration
end

function ActiveCastStatic:GetPosition(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return GetPositionAtTime(self.StateInfo.TotalRuntime - currentTrajectory.StartTime, currentTrajectory.Origin, currentTrajectory.InitialVelocity, currentTrajectory.Acceleration)
end

---- ARITHMETIC ----

function ActiveCastStatic:AddVelocity(velocity: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetVelocity(self:GetVelocity() + velocity)
end

function ActiveCastStatic:AddAcceleration(acceleration: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetAcceleration(self:GetAcceleration() + acceleration)
end

function ActiveCastStatic:AddPosition(position: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetPosition(self:GetPosition() + position)
end

---- STATE MODIFICATION ----

function ActiveCastStatic:Pause()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Pause", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self.StateInfo.Paused = true
end

function ActiveCastStatic:Resume()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Resume", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self.StateInfo.Paused = false
end

function ActiveCastStatic:Terminate()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Terminate", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	
	-- First: Set EndTime on the latest trajectory since it is now done simulating.
	local trajectories = self.StateInfo.Trajectories
	local lastTrajectory = trajectories[#trajectories]
	lastTrajectory.EndTime = self.StateInfo.TotalRuntime
	
	-- Disconnect the update connection.
	self.StateInfo.UpdateConnection:Disconnect()
	
	-- Now fire CastTerminating
	self.Caster.CastTerminating:FireSync(self)
	
	-- And now set the update connection object to nil.
	self.StateInfo.UpdateConnection = nil
	
	-- And nuke everything in the table + clear the metatable.
	self.Caster = nil
	self.StateInfo = nil
	self.RayInfo = nil
	self.UserData = nil
	setmetatable(self, nil)
end

return ActiveCastStatic]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXAA7F6C6DB5A047C0B43358D79478C24D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Signal</string>
											<string name="ScriptGuid">{306C00AD-6266-4E19-882A-6AA6AC09EF5A}</string>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:

-- A new implementation of RBXScriptSignal that uses proper Lua OOP.
-- This was explicitly made to transport other OOP objects.
-- I would be using BindableEvents, but they don't like cyclic tables (part of OOP objects with __index)

-- Inject types
local TypeDefs = require(script.Parent.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

local TestService = game:GetService("TestService")
local table = require(script.Parent.Table)

local SignalStatic = {}
SignalStatic.__index = SignalStatic
SignalStatic.__type = "Signal" -- For compatibility with TypeMarshaller
local ConnectionStatic = {}
ConnectionStatic.__index = ConnectionStatic
ConnectionStatic.__type = "SignalConnection" -- For compatibility with TypeMarshaller

export type Signal = {
	Name: string,
	Connections: {[number]: Connection},
	YieldingThreads: {[number]: BindableEvent}
}

export type Connection = {
	Signal: Signal?,
	Delegate: any,
	Index: number	
}

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

function SignalStatic.new(signalName: string): Signal
	local signalObj: Signal = {
		Name = signalName,
		Connections = {},
		YieldingThreads = {}
	}
	return setmetatable(signalObj, SignalStatic)
end

local function NewConnection(sig: Signal, func: any): Connection 
	local connectionObj: Connection = {
		Signal = sig,
		Delegate = func,
		Index = -1
	}
	return setmetatable(connectionObj, ConnectionStatic)
end

local function ThreadAndReportError(delegate: any, args: GenericTable, handlerName: string)
	local thread = coroutine.create(function ()
		delegate(unpack(args))
	end)
	local success, msg = coroutine.resume(thread)
	if not success then 
		-- For the love of god roblox PLEASE add the ability to customize message type in output statements.
		-- This "testservice" garbage at the start of my message is annoying as all hell.
		TestService:Error(string.format("Exception thrown in your %s event handler: %s", handlerName, msg))
		TestService:Checkpoint(debug.traceback(thread))
	end
end

function SignalStatic:Connect(func)
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Connect", "Signal.new()"))
	local connection = NewConnection(self, func)
	connection.Index = #self.Connections + 1
	table.insert(self.Connections, connection.Index, connection)
	return connection
end

function SignalStatic:Fire(...)
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Fire", "Signal.new()"))
	local args = table.pack(...)
	local allCons = self.Connections
	local yieldingThreads = self.YieldingThreads
	for index = 1, #allCons do
		local connection = allCons[index]
		if connection.Delegate ~= nil then
			-- Catch case for disposed signals.
			ThreadAndReportError(connection.Delegate, args, connection.Signal.Name)
		end
	end
	for index = 1, #yieldingThreads do
		local thread = yieldingThreads[index]
		if thread ~= nil then
			coroutine.resume(thread, ...)
		end
	end
end

function SignalStatic:FireSync(...)
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("FireSync", "Signal.new()"))
	local args = table.pack(...)
	local allCons = self.Connections
	local yieldingThreads = self.YieldingThreads
	for index = 1, #allCons do
		local connection = allCons[index]
		if connection.Delegate ~= nil then
			-- Catch case for disposed signals.
			connection.Delegate(unpack(args))
		end
	end
	for index = 1, #yieldingThreads do
		local thread = yieldingThreads[index]
		if thread ~= nil then
			coroutine.resume(thread, ...)
		end
	end
end

function SignalStatic:Wait()
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Wait", "Signal.new()"))
	local args = {}
	local thread = coroutine.running()
	table.insert(self.YieldingThreads, thread)
	args = { coroutine.yield() }
	table.removeObject(self.YieldingThreads, thread)
	return unpack(args)
end

function SignalStatic:Dispose()
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Dispose", "Signal.new()"))
	local allCons = self.Connections
	for index = 1, #allCons do
		allCons[index]:Disconnect()
	end
	self.Connections = {}
	setmetatable(self, nil)
end

function ConnectionStatic:Disconnect()
	assert(getmetatable(self) == ConnectionStatic, ERR_NOT_INSTANCE:format("Disconnect", "private function NewConnection()"))
	table.remove(self.Signal.Connections, self.Index)
	self.SignalStatic = nil
	self.Delegate = nil
	self.YieldingThreads = {}
	self.Index = -1
	setmetatable(self, nil)
end

return SignalStatic]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXEBD0F156AE8844EEBBC3C9FB12727D7C">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">TypeDefinitions</string>
											<string name="ScriptGuid">{B3CCFD84-69CA-4D7E-B937-D45D5E54CD1F}</string>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:

-- Defines all FC types.
-- Any script that requires this will have these types defined.

--[[
local TypeDefs = require(script.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast
--]]

-- Represents the function to determine piercing.
export type CanPierceFunction = (ActiveCast, RaycastResult, Vector3) -> boolean

-- Represents any table.
export type GenericTable = {[any]: any}

-- Represents a Caster :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caster/
export type Caster = {
	WorldRoot: WorldRoot,
	LengthChanged: RBXScriptSignal,
	RayHit: RBXScriptSignal,
	RayPierced: RBXScriptSignal,
	CastTerminating: RBXScriptSignal,
	Fire: (Vector3, Vector3, Vector3 | number, FastCastBehavior) -> ()
}

-- Represents a FastCastBehavior :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/fcbehavior/
export type FastCastBehavior = {
	RaycastParams: RaycastParams?,
	MaxDistance: number,
	Acceleration: Vector3,
	HighFidelityBehavior: number,
	HighFidelitySegmentSize: number,
	CosmeticBulletTemplate: Instance?,
	CosmeticBulletProvider: any, -- Intended to be a PartCache. Dictated via TypeMarshaller.
	CosmeticBulletContainer: Instance?,
	AutoIgnoreContainer: boolean,
	CanPierceFunction: CanPierceFunction
}

-- Represents a CastTrajectory :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/casttrajectory/
export type CastTrajectory = {
	StartTime: number,
	EndTime: number,
	Origin: Vector3,
	InitialVelocity: Vector3,
	Acceleration: Vector3
}

-- Represents a CastStateInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caststateinfo/
export type CastStateInfo = {
	UpdateConnection: RBXScriptSignal,
	HighFidelityBehavior: number,
	HighFidelitySegmentSize: number,
	Paused: boolean,
	TotalRuntime: number,
	DistanceCovered: number,
	IsActivelySimulatingPierce: boolean,
	IsActivelyResimulating: boolean,
	CancelHighResCast: boolean,
	Trajectories: {[number]: CastTrajectory}
}

-- Represents a CastRayInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/castrayinfo/
export type CastRayInfo = {
	Parameters: RaycastParams,
	WorldRoot: WorldRoot,
	MaxDistance: number,
	CosmeticBulletObject: Instance?,
	CanPierceCallback: CanPierceFunction
}

-- Represents an ActiveCast :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/activecast/
export type ActiveCast = {
	Caster: Caster,
	StateInfo: CastStateInfo,
	RayInfo: CastRayInfo,
	UserData: {[any]: any}
}

return {}]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX27096B016FD24D13B4FD535ED7C5D355">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">TypeMarshaller</string>
											<string name="ScriptGuid">{5D6235A5-6E22-471B-AC66-35ED84A887DB}</string>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:

local oldtypeof = typeof
local function typeof(objIn: any): string
	local objType = oldtypeof(objIn)
	if objType ~= "table" then return objType end

	-- Could be a custom type if it's a table.
	local meta = getmetatable(objIn)
	if oldtypeof(meta) ~= "table" then return objType end

	-- Has a metatable that's an exposed table.
	local customType: string? = meta["__type"] -- I want to mandate that this is a string.
	if customType == nil then return objType end

	-- Has a type field
	return customType
end

return typeof]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX09312DD44888486A9E49AE1AB1C20E78">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Images</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="SurfaceAppearance" referent="RBX07D57AE2E5CD414EB51847F08617FC93">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561421714</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">1</string>
										<Content name="NormalMap"><url>rbxassetid://12137136475</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137137560</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX38EA27F6B7334A5DB174B323968B74F3">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420596</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">2</string>
										<Content name="NormalMap"><url>rbxassetid://12137285211</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137290262</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBXC5675E2425684EC5A07C5DD4E396FBB7">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420659</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">3</string>
										<Content name="NormalMap"><url>rbxassetid://12137296940</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137300478</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX43162A86290C418A88068BCF88C1E016">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420780</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">4</string>
										<Content name="NormalMap"><url>rbxassetid://12137181243</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137193326</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX18AFFF372093495AA809B01682FF05D7">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420978</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">5</string>
										<Content name="NormalMap"><url>rbxassetid://12137213848</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137214405</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX44A05FD6C9794269AF025C3251269E31">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561421515</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">7</string>
										<Content name="NormalMap"><url>rbxassetid://12137159043</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137165483</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX097C1D27A19A4B2EB331F6E57C1E2BC9">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561421428</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">8</string>
										<Content name="NormalMap"><url>rbxassetid://12137127341</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137131420</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX53CE71C548C04304983BC3AEC87382BC">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561421069</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">9</string>
										<Content name="NormalMap"><url>rbxassetid://12137219586</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137222458</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX3C96282F04F64481BB30E61B9C46E288">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561419931</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">10</string>
										<Content name="NormalMap"><url>rbxassetid://12137249682</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137250443</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBXC6FC62D399234D55B51011EDFF5B80A8">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420882</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">11</string>
										<Content name="NormalMap"><url>rbxassetid://12137197518</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137209199</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX0259C8A40290481D9311A56BB4D83E57">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420185</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">12</string>
										<Content name="NormalMap"><url>rbxassetid://12137261860</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137263961</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX18D6ECA6D1484F8784219B594ED27F80">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420301</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">13</string>
										<Content name="NormalMap"><url>rbxassetid://12137265937</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137268819</url></Content>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX3EA624E755FB43C6B492270C5A8095BB">
									<Properties>
										<token name="AlphaMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://12137310288</url></Content>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<string name="Name">14</string>
										<Content name="NormalMap"><url>rbxassetid://12137311055</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TexturePack"><url>rbxassetid://12137314457</url></Content>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXD1D9F7BCF4A0434CB7E215EA2699BD65">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Effects</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX6B6CDF94B207419583E3F78FD32C7164">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Impact</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ParticleEmitter" referent="RBX4B995D9A6E7A4150B79483B3D3603F90">
										<Properties>
											<Vector3 name="Acceleration">
												<X>0</X>
												<Y>-5</Y>
												<Z>5</Z>
											</Vector3>
											<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
											<float name="Brightness">1</float>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
											<bool name="DefinesCapabilities">false</bool>
											<float name="Drag">25</float>
											<token name="EmissionDirection">1</token>
											<bool name="Enabled">true</bool>
											<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
											<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
											<token name="FlipbookLayout">0</token>
											<token name="FlipbookMode">0</token>
											<int name="FlipbookSizeX">1</int>
											<int name="FlipbookSizeY">1</int>
											<bool name="FlipbookStartRandom">false</bool>
											<NumberRange name="Lifetime">0.3 0.6 </NumberRange>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">0</float>
											<bool name="LockedToPart">false</bool>
											<string name="Name">Mist1</string>
											<token name="Orientation">1</token>
											<float name="Rate">0</float>
											<NumberRange name="RotSpeed">0 0 </NumberRange>
											<NumberRange name="Rotation">-90 90 </NumberRange>
											<token name="Shape">0</token>
											<token name="ShapeInOut">0</token>
											<float name="ShapePartial">1</float>
											<token name="ShapeStyle">0</token>
											<NumberSequence name="Size">0 0 0 0.0985037 0.276242 0 1 0.441989 0 </NumberSequence>
											<int64 name="SourceAssetId">-1</int64>
											<NumberRange name="Speed">5 30 </NumberRange>
											<Vector2 name="SpreadAngle">
												<X>15</X>
												<Y>15</Y>
											</Vector2>
											<NumberSequence name="Squash">0 0 0 1 0.6375 0 </NumberSequence>
											<BinaryString name="Tags"></BinaryString>
											<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
											<float name="TimeScale">1</float>
											<NumberSequence name="Transparency">0 1 0 0.071831 0.81875 0 1 1 0 </NumberSequence>
											<float name="VelocityInheritance">0</float>
											<bool name="WindAffectsDrag">false</bool>
											<float name="ZOffset">0</float>
										</Properties>
									</Item>
									<Item class="ParticleEmitter" referent="RBX958612F34AEF42D98EDCD6AAC846DD7A">
										<Properties>
											<Vector3 name="Acceleration">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
											</Vector3>
											<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
											<float name="Brightness">1</float>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
											<bool name="DefinesCapabilities">false</bool>
											<float name="Drag">0</float>
											<token name="EmissionDirection">1</token>
											<bool name="Enabled">true</bool>
											<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
											<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
											<token name="FlipbookLayout">0</token>
											<token name="FlipbookMode">0</token>
											<int name="FlipbookSizeX">1</int>
											<int name="FlipbookSizeY">1</int>
											<bool name="FlipbookStartRandom">false</bool>
											<NumberRange name="Lifetime">0.1 0.4 </NumberRange>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">1</float>
											<bool name="LockedToPart">false</bool>
											<string name="Name">Puddle</string>
											<token name="Orientation">3</token>
											<float name="Rate">0</float>
											<NumberRange name="RotSpeed">-40 40 </NumberRange>
											<NumberRange name="Rotation">-180 180 </NumberRange>
											<token name="Shape">0</token>
											<token name="ShapeInOut">0</token>
											<float name="ShapePartial">1</float>
											<token name="ShapeStyle">0</token>
											<NumberSequence name="Size">0 1.27072 0 1 2.0442 0 </NumberSequence>
											<int64 name="SourceAssetId">-1</int64>
											<NumberRange name="Speed">0.001 0.001 </NumberRange>
											<Vector2 name="SpreadAngle">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<NumberSequence name="Squash">0 0.1 0 1 0.1 0 </NumberSequence>
											<BinaryString name="Tags"></BinaryString>
											<Content name="Texture"><url>rbxassetid://3193359153</url></Content>
											<float name="TimeScale">1</float>
											<NumberSequence name="Transparency">0 0.96875 0 1 1 0 </NumberSequence>
											<float name="VelocityInheritance">0</float>
											<bool name="WindAffectsDrag">false</bool>
											<float name="ZOffset">0</float>
										</Properties>
									</Item>
									<Item class="ParticleEmitter" referent="RBXC50D3732A97A49939F3F4B2A5013D0DB">
										<Properties>
											<Vector3 name="Acceleration">
												<X>0</X>
												<Y>-20</Y>
												<Z>0</Z>
											</Vector3>
											<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAALkA=</BinaryString>
											<float name="Brightness">1</float>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
											<bool name="DefinesCapabilities">false</bool>
											<float name="Drag">0</float>
											<token name="EmissionDirection">1</token>
											<bool name="Enabled">true</bool>
											<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
											<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
											<token name="FlipbookLayout">0</token>
											<token name="FlipbookMode">0</token>
											<int name="FlipbookSizeX">1</int>
											<int name="FlipbookSizeY">1</int>
											<bool name="FlipbookStartRandom">false</bool>
											<NumberRange name="Lifetime">0.6 0.8 </NumberRange>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">1</float>
											<bool name="LockedToPart">false</bool>
											<string name="Name">Squirt</string>
											<token name="Orientation">2</token>
											<float name="Rate">0</float>
											<NumberRange name="RotSpeed">0 0 </NumberRange>
											<NumberRange name="Rotation">0 0 </NumberRange>
											<token name="Shape">0</token>
											<token name="ShapeInOut">0</token>
											<float name="ShapePartial">1</float>
											<token name="ShapeStyle">0</token>
											<NumberSequence name="Size">0 0.05 0 1 0.05 0 </NumberSequence>
											<int64 name="SourceAssetId">-1</int64>
											<NumberRange name="Speed">6 10 </NumberRange>
											<Vector2 name="SpreadAngle">
												<X>10</X>
												<Y>10</Y>
											</Vector2>
											<NumberSequence name="Squash">0 -1.3 0 1 -1.3 0 </NumberSequence>
											<BinaryString name="Tags"></BinaryString>
											<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
											<float name="TimeScale">1</float>
											<NumberSequence name="Transparency">0 0.35625 0 1 1 0 </NumberSequence>
											<float name="VelocityInheritance">0</float>
											<bool name="WindAffectsDrag">false</bool>
											<float name="ZOffset">0</float>
										</Properties>
									</Item>
								</Item>
								<Item class="Trail" referent="RBX2B9EB55C105D4C08BB13B599584D9D8B">
									<Properties>
										<Ref name="Attachment0">null</Ref>
										<Ref name="Attachment1">null</Ref>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<float name="Brightness">1</float>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<ColorSequence name="Color">0 0.309804 0 0 0 1 0.309804 0 0 0 </ColorSequence>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Enabled">false</bool>
										<bool name="FaceCamera">true</bool>
										<float name="Lifetime">0.0500000007</float>
										<float name="LightEmission">0</float>
										<float name="LightInfluence">0</float>
										<float name="MaxLength">0</float>
										<float name="MinLength">0.100000001</float>
										<string name="Name">Trail</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="Texture"><null></null></Content>
										<float name="TextureLength">1</float>
										<token name="TextureMode">0</token>
										<NumberSequence name="Transparency">0 0 0 0.502494 0.2625 0 1 1 0 </NumberSequence>
										<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX1E3497F718C44A128F5A2DB71799F8E5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Folder</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX0EE927AC52384E20986F2201D2292B9C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Meshes</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="MeshPart" referent="RBX96940F41E74D41F78AA831DCE6021745">
									<Properties>
										<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
										<bool name="Anchored">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AudioCanCollide">true</bool>
										<float name="BackParamA">-0.5</float>
										<float name="BackParamB">0.5</float>
										<token name="BackSurface">0</token>
										<token name="BackSurfaceInput">0</token>
										<float name="BottomParamA">-0.5</float>
										<float name="BottomParamB">0.5</float>
										<token name="BottomSurface">0</token>
										<token name="BottomSurfaceInput">0</token>
										<CoordinateFrame name="CFrame">
											<X>71.2647705</X>
											<Y>1.5951376</Y>
											<Z>-259.880127</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<bool name="CanCollide">false</bool>
										<bool name="CanQuery">false</bool>
										<bool name="CanTouch">false</bool>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="CastShadow">true</bool>
										<string name="CollisionGroup">Default</string>
										<int name="CollisionGroupId">0</int>
										<Color3uint8 name="Color3uint8">4284940288</Color3uint8>
										<PhysicalProperties name="CustomPhysicalProperties">
											<CustomPhysics>false</CustomPhysics>
										</PhysicalProperties>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="DoubleSided">false</bool>
										<bool name="EnableFluidForces">true</bool>
										<token name="FluidFidelityInternal">0</token>
										<float name="FrontParamA">-0.5</float>
										<float name="FrontParamB">0.5</float>
										<token name="FrontSurface">0</token>
										<token name="FrontSurfaceInput">0</token>
										<bool name="HasJointOffset">false</bool>
										<bool name="HasSkinnedMesh">false</bool>
										<bool name="InertiaMigrated">true</bool>
										<Vector3 name="InitialSize">
											<X>200</X>
											<Y>3.25841356e-05</Y>
											<Z>200</Z>
										</Vector3>
										<Vector3 name="JointOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="LeftParamA">-0.5</float>
										<float name="LeftParamB">0.5</float>
										<token name="LeftSurface">0</token>
										<token name="LeftSurfaceInput">0</token>
										<bool name="Locked">false</bool>
										<bool name="Massless">false</bool>
										<token name="Material">1568</token>
										<string name="MaterialVariantSerialized"></string>
										<Content name="MeshId"><url>rbxassetid://9648592256</url></Content>
										<string name="Name">Decal</string>
										<SharedString name="PhysicalConfigData">hFbDjtH6cycB1zhM9yA98w==</SharedString>
										<BinaryString name="PhysicsData"></BinaryString>
										<CoordinateFrame name="PivotOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<float name="Reflectance">0</float>
										<token name="RenderFidelity">1</token>
										<float name="RightParamA">-0.5</float>
										<float name="RightParamB">0.5</float>
										<token name="RightSurface">0</token>
										<token name="RightSurfaceInput">0</token>
										<int name="RootPriority">0</int>
										<Vector3 name="RotVelocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TextureID"><null></null></Content>
										<float name="TopParamA">-0.5</float>
										<float name="TopParamB">0.5</float>
										<token name="TopSurface">0</token>
										<token name="TopSurfaceInput">0</token>
										<float name="Transparency">0.0199999996</float>
										<Vector3 name="UnscaledCofm">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaDiags">
											<X>1</X>
											<Y>1</Y>
											<Z>1</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaOffDiags">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="UnscaledVolume">10</float>
										<Vector3 name="Velocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<int name="VertexCount">4</int>
										<Vector3 name="size">
											<X>0.100000001</X>
											<Y>0.100000001</Y>
											<Z>0.100000001</Z>
										</Vector3>
									</Properties>
									<Item class="Attachment" referent="RBX6940896810E6494CB765C805C92480AE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A0</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX316D9AF5FAC848A98436888075F08998">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame">
												<X>0.0369129181</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A1</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX5CBA21165328418FA3263534A148BE7E">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>2.38419062e-09</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Impact</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">false</bool>
										</Properties>
										<Item class="ParticleEmitter" referent="RBX85A6CAE2E55348D98D1C9767FE67A6C4">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-5</Y>
													<Z>5</Z>
												</Vector3>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<float name="Brightness">1</float>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<bool name="DefinesCapabilities">false</bool>
												<float name="Drag">25</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.3 0.6 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">0</float>
												<bool name="LockedToPart">false</bool>
												<string name="Name">Mist1</string>
												<token name="Orientation">1</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">-90 90 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0 0 0.0985037 0.276242 0 1 0.441989 0 </NumberSequence>
												<int64 name="SourceAssetId">-1</int64>
												<NumberRange name="Speed">5 30 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>15</X>
													<Y>15</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0 0 1 0.6375 0 </NumberSequence>
												<BinaryString name="Tags"></BinaryString>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 1 0 0.071831 0.81875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX4ACF518B06954227BC46D48E0014958E">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>0</Y>
													<Z>0</Z>
												</Vector3>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<float name="Brightness">1</float>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<bool name="DefinesCapabilities">false</bool>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.1 0.4 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<string name="Name">Puddle</string>
												<token name="Orientation">3</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">-40 40 </NumberRange>
												<NumberRange name="Rotation">-180 180 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 1.27072 0 1 2.0442 0 </NumberSequence>
												<int64 name="SourceAssetId">-1</int64>
												<NumberRange name="Speed">0.001 0.001 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0.1 0 1 0.1 0 </NumberSequence>
												<BinaryString name="Tags"></BinaryString>
												<Content name="Texture"><url>rbxassetid://3193359153</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.96875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX3342C88216D247B58243D13A398D266F">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-20</Y>
													<Z>0</Z>
												</Vector3>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAALkA=</BinaryString>
												<float name="Brightness">1</float>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<bool name="DefinesCapabilities">false</bool>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.6 0.8 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<string name="Name">Squirt</string>
												<token name="Orientation">2</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">0 0 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0.05 0 1 0.05 0 </NumberSequence>
												<int64 name="SourceAssetId">-1</int64>
												<NumberRange name="Speed">6 10 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>10</X>
													<Y>10</Y>
												</Vector2>
												<NumberSequence name="Squash">0 -1.3 0 1 -1.3 0 </NumberSequence>
												<BinaryString name="Tags"></BinaryString>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.35625 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
											</Properties>
										</Item>
									</Item>
									<Item class="Trail" referent="RBX46108CAAC58143CB9ACC7CCF69CB43AE">
										<Properties>
											<Ref name="Attachment0">RBX6940896810E6494CB765C805C92480AE</Ref>
											<Ref name="Attachment1">RBX316D9AF5FAC848A98436888075F08998</Ref>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<float name="Brightness">1</float>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<ColorSequence name="Color">0 0.517647 0 0 0 1 0.517647 0 0 0 </ColorSequence>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Enabled">false</bool>
											<bool name="FaceCamera">true</bool>
											<float name="Lifetime">0.0500000007</float>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">0</float>
											<float name="MaxLength">0</float>
											<float name="MinLength">0.100000001</float>
											<string name="Name">Trail</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<Content name="Texture"><null></null></Content>
											<float name="TextureLength">1</float>
											<token name="TextureMode">0</token>
											<NumberSequence name="Transparency">0 0 0 0.502494 0.2625 0 1 1 0 </NumberSequence>
											<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
										</Properties>
									</Item>
								</Item>
								<Item class="MeshPart" referent="RBX4F0DF77BFA45438F88AF305FD4A57C36">
									<Properties>
										<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
										<bool name="Anchored">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AudioCanCollide">true</bool>
										<float name="BackParamA">-0.5</float>
										<float name="BackParamB">0.5</float>
										<token name="BackSurface">0</token>
										<token name="BackSurfaceInput">0</token>
										<float name="BottomParamA">-0.5</float>
										<float name="BottomParamB">0.5</float>
										<token name="BottomSurface">0</token>
										<token name="BottomSurfaceInput">0</token>
										<CoordinateFrame name="CFrame">
											<X>90.4211121</X>
											<Y>2.14056873</Y>
											<Z>-235.98407</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<bool name="CanCollide">false</bool>
										<bool name="CanQuery">false</bool>
										<bool name="CanTouch">false</bool>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="CastShadow">true</bool>
										<string name="CollisionGroup">Default</string>
										<int name="CollisionGroupId">0</int>
										<Color3uint8 name="Color3uint8">4283236352</Color3uint8>
										<PhysicalProperties name="CustomPhysicalProperties">
											<CustomPhysics>false</CustomPhysics>
										</PhysicalProperties>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="DoubleSided">false</bool>
										<bool name="EnableFluidForces">true</bool>
										<token name="FluidFidelityInternal">0</token>
										<float name="FrontParamA">-0.5</float>
										<float name="FrontParamB">0.5</float>
										<token name="FrontSurface">0</token>
										<token name="FrontSurfaceInput">0</token>
										<bool name="HasJointOffset">false</bool>
										<bool name="HasSkinnedMesh">false</bool>
										<bool name="InertiaMigrated">true</bool>
										<Vector3 name="InitialSize">
											<X>1.99211502</X>
											<Y>2</Y>
											<Z>1.9960537</Z>
										</Vector3>
										<Vector3 name="JointOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="LeftParamA">-0.5</float>
										<float name="LeftParamB">0.5</float>
										<token name="LeftSurface">0</token>
										<token name="LeftSurfaceInput">0</token>
										<bool name="Locked">false</bool>
										<bool name="Massless">false</bool>
										<token name="Material">1568</token>
										<string name="MaterialVariantSerialized"></string>
										<Content name="MeshId"><url>rbxassetid://15372969595</url></Content>
										<string name="Name">Droplet</string>
										<SharedString name="PhysicalConfigData">aaQQwlzZOlor7w4mpBFaRg==</SharedString>
										<BinaryString name="PhysicsData"></BinaryString>
										<CoordinateFrame name="PivotOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<float name="Reflectance">0</float>
										<token name="RenderFidelity">0</token>
										<float name="RightParamA">-0.5</float>
										<float name="RightParamB">0.5</float>
										<token name="RightSurface">0</token>
										<token name="RightSurfaceInput">0</token>
										<int name="RootPriority">0</int>
										<Vector3 name="RotVelocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TextureID"><null></null></Content>
										<float name="TopParamA">-0.5</float>
										<float name="TopParamB">0.5</float>
										<token name="TopSurface">0</token>
										<token name="TopSurfaceInput">0</token>
										<float name="Transparency">0.25</float>
										<Vector3 name="UnscaledCofm">
											<X>-5.7645525e-07</X>
											<Y>1.97096427e-17</Y>
											<Z>-3.71146967e-07</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaDiags">
											<X>1.65671015</X>
											<Y>1.65450311</Y>
											<Z>1.6567167</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaOffDiags">
											<X>3.34739873e-18</X>
											<Y>2.4742576e-06</Y>
											<Z>-3.32570281e-17</Z>
										</Vector3>
										<float name="UnscaledVolume">4.1594038</float>
										<Vector3 name="Velocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<int name="VertexCount">1324</int>
										<Vector3 name="size">
											<X>0.100000001</X>
											<Y>0.100000001</Y>
											<Z>0.100000001</Z>
										</Vector3>
									</Properties>
									<Item class="Trail" referent="RBX76C5C3CB49EF4DF4906F314D4463F57A">
										<Properties>
											<Ref name="Attachment0">RBX6712B931168443F79BA098BAD72CC730</Ref>
											<Ref name="Attachment1">RBX57973AB7B7544BADB113D941F1D9670B</Ref>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<float name="Brightness">1</float>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<ColorSequence name="Color">0 0.309804 0 0 0 1 0.309804 0 0 0 </ColorSequence>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Enabled">false</bool>
											<bool name="FaceCamera">true</bool>
											<float name="Lifetime">0.0500000007</float>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">0</float>
											<float name="MaxLength">0</float>
											<float name="MinLength">0.100000001</float>
											<string name="Name">Trail</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<Content name="Texture"><null></null></Content>
											<float name="TextureLength">1</float>
											<token name="TextureMode">0</token>
											<NumberSequence name="Transparency">0 0 0 0.502494 0.2625 0 1 1 0 </NumberSequence>
											<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX6712B931168443F79BA098BAD72CC730">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A0</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX57973AB7B7544BADB113D941F1D9670B">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame">
												<X>0.0369129181</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A1</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX9F4CE6E0D1AD4D388E3F7258521384A4">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>2.38418579e-07</Y>
												<Z>0</Z>
												<R00>-1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>-1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Impact</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">false</bool>
										</Properties>
										<Item class="ParticleEmitter" referent="RBX137F9FE31AF942A58A8A3AA93FAB3A70">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-5</Y>
													<Z>5</Z>
												</Vector3>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<float name="Brightness">1</float>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<bool name="DefinesCapabilities">false</bool>
												<float name="Drag">25</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.3 0.6 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">0</float>
												<bool name="LockedToPart">false</bool>
												<string name="Name">Mist1</string>
												<token name="Orientation">1</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">-90 90 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0 0 0.0985037 0.276242 0 1 0.441989 0 </NumberSequence>
												<int64 name="SourceAssetId">-1</int64>
												<NumberRange name="Speed">5 30 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>15</X>
													<Y>15</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0 0 1 0.6375 0 </NumberSequence>
												<BinaryString name="Tags"></BinaryString>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 1 0 0.071831 0.81875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX795F11E8EFD64C01922829F5207685E7">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>0</Y>
													<Z>0</Z>
												</Vector3>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<float name="Brightness">1</float>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<bool name="DefinesCapabilities">false</bool>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.1 0.4 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<string name="Name">Puddle</string>
												<token name="Orientation">3</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">-40 40 </NumberRange>
												<NumberRange name="Rotation">-180 180 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 1.27072 0 1 2.0442 0 </NumberSequence>
												<int64 name="SourceAssetId">-1</int64>
												<NumberRange name="Speed">0.001 0.001 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0.1 0 1 0.1 0 </NumberSequence>
												<BinaryString name="Tags"></BinaryString>
												<Content name="Texture"><url>rbxassetid://3193359153</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.96875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX8269D0AC5CEE425F807F883E8E42B2DE">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-20</Y>
													<Z>0</Z>
												</Vector3>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAALkA=</BinaryString>
												<float name="Brightness">1</float>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<bool name="DefinesCapabilities">false</bool>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.6 0.8 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<string name="Name">Squirt</string>
												<token name="Orientation">2</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">0 0 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0.05 0 1 0.05 0 </NumberSequence>
												<int64 name="SourceAssetId">-1</int64>
												<NumberRange name="Speed">6 10 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>10</X>
													<Y>10</Y>
												</Vector2>
												<NumberSequence name="Squash">0 -1.3 0 1 -1.3 0 </NumberSequence>
												<BinaryString name="Tags"></BinaryString>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.35625 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="MeshPart" referent="RBX8831A37A9EAB4D319457DEFB8FF392A6">
									<Properties>
										<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
										<bool name="Anchored">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AudioCanCollide">true</bool>
										<float name="BackParamA">-0.5</float>
										<float name="BackParamB">0.5</float>
										<token name="BackSurface">0</token>
										<token name="BackSurfaceInput">0</token>
										<float name="BottomParamA">-0.5</float>
										<float name="BottomParamB">0.5</float>
										<token name="BottomSurface">0</token>
										<token name="BottomSurfaceInput">0</token>
										<CoordinateFrame name="CFrame">
											<X>71.2647705</X>
											<Y>1.5951376</Y>
											<Z>-259.880127</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<bool name="CanCollide">false</bool>
										<bool name="CanQuery">false</bool>
										<bool name="CanTouch">false</bool>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="CastShadow">true</bool>
										<string name="CollisionGroup">Default</string>
										<int name="CollisionGroupId">0</int>
										<Color3uint8 name="Color3uint8">4284940288</Color3uint8>
										<PhysicalProperties name="CustomPhysicalProperties">
											<CustomPhysics>false</CustomPhysics>
										</PhysicalProperties>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="DoubleSided">false</bool>
										<bool name="EnableFluidForces">true</bool>
										<token name="FluidFidelityInternal">0</token>
										<float name="FrontParamA">-0.5</float>
										<float name="FrontParamB">0.5</float>
										<token name="FrontSurface">3</token>
										<token name="FrontSurfaceInput">0</token>
										<bool name="HasJointOffset">false</bool>
										<bool name="HasSkinnedMesh">false</bool>
										<bool name="InertiaMigrated">true</bool>
										<Vector3 name="InitialSize">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="JointOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="LeftParamA">-0.5</float>
										<float name="LeftParamB">0.5</float>
										<token name="LeftSurface">0</token>
										<token name="LeftSurfaceInput">0</token>
										<bool name="Locked">false</bool>
										<bool name="Massless">false</bool>
										<token name="Material">1568</token>
										<string name="MaterialVariantSerialized"></string>
										<Content name="MeshId"><null></null></Content>
										<string name="Name">Brick</string>
										<SharedString name="PhysicalConfigData">hFbDjtH6cycB1zhM9yA98w==</SharedString>
										<BinaryString name="PhysicsData"></BinaryString>
										<CoordinateFrame name="PivotOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<float name="Reflectance">0</float>
										<token name="RenderFidelity">1</token>
										<float name="RightParamA">-0.5</float>
										<float name="RightParamB">0.5</float>
										<token name="RightSurface">0</token>
										<token name="RightSurfaceInput">0</token>
										<int name="RootPriority">0</int>
										<Vector3 name="RotVelocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TextureID"><null></null></Content>
										<float name="TopParamA">-0.5</float>
										<float name="TopParamB">0.5</float>
										<token name="TopSurface">0</token>
										<token name="TopSurfaceInput">0</token>
										<float name="Transparency">0.0199999996</float>
										<Vector3 name="UnscaledCofm">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaDiags">
											<X>1</X>
											<Y>1</Y>
											<Z>1</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaOffDiags">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="UnscaledVolume">10</float>
										<Vector3 name="Velocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<int name="VertexCount">0</int>
										<Vector3 name="size">
											<X>0.100000001</X>
											<Y>0.100000001</Y>
											<Z>0.100000001</Z>
										</Vector3>
									</Properties>
									<Item class="Attachment" referent="RBX7ED6DD4012DC4BDA9F0AD6C459A1BC22">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A0</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX7587EDABB6E34A189286B9DFDA40C5FE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame">
												<X>0.0369129181</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A1</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX26E90BCCF212455286159128AB7A807C">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>2.38419062e-09</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Impact</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">false</bool>
										</Properties>
										<Item class="ParticleEmitter" referent="RBXF3459FFAA8FB47A2974940E49A04C083">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-5</Y>
													<Z>5</Z>
												</Vector3>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<float name="Brightness">1</float>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<bool name="DefinesCapabilities">false</bool>
												<float name="Drag">25</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.3 0.6 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">0</float>
												<bool name="LockedToPart">false</bool>
												<string name="Name">Mist1</string>
												<token name="Orientation">1</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">-90 90 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0 0 0.0985037 0.276242 0 1 0.441989 0 </NumberSequence>
												<int64 name="SourceAssetId">-1</int64>
												<NumberRange name="Speed">5 30 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>15</X>
													<Y>15</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0 0 1 0.6375 0 </NumberSequence>
												<BinaryString name="Tags"></BinaryString>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 1 0 0.071831 0.81875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBXA475D730290F4DB4BD71D42F2C64FD2C">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>0</Y>
													<Z>0</Z>
												</Vector3>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<float name="Brightness">1</float>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<bool name="DefinesCapabilities">false</bool>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.1 0.4 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<string name="Name">Puddle</string>
												<token name="Orientation">3</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">-40 40 </NumberRange>
												<NumberRange name="Rotation">-180 180 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 1.27072 0 1 2.0442 0 </NumberSequence>
												<int64 name="SourceAssetId">-1</int64>
												<NumberRange name="Speed">0.001 0.001 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0.1 0 1 0.1 0 </NumberSequence>
												<BinaryString name="Tags"></BinaryString>
												<Content name="Texture"><url>rbxassetid://3193359153</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.96875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBXFE861D0B59C84F088BD0974D22B03F8A">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-20</Y>
													<Z>0</Z>
												</Vector3>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAALkA=</BinaryString>
												<float name="Brightness">1</float>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<bool name="DefinesCapabilities">false</bool>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.6 0.8 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<string name="Name">Squirt</string>
												<token name="Orientation">2</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">0 0 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0.05 0 1 0.05 0 </NumberSequence>
												<int64 name="SourceAssetId">-1</int64>
												<NumberRange name="Speed">6 10 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>10</X>
													<Y>10</Y>
												</Vector2>
												<NumberSequence name="Squash">0 -1.3 0 1 -1.3 0 </NumberSequence>
												<BinaryString name="Tags"></BinaryString>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.35625 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
											</Properties>
										</Item>
									</Item>
									<Item class="Trail" referent="RBXDC74052964FA473084143C295DB111DE">
										<Properties>
											<Ref name="Attachment0">RBX7ED6DD4012DC4BDA9F0AD6C459A1BC22</Ref>
											<Ref name="Attachment1">RBX7587EDABB6E34A189286B9DFDA40C5FE</Ref>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<float name="Brightness">1</float>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<ColorSequence name="Color">0 0.517647 0 0 0 1 0.517647 0 0 0 </ColorSequence>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Enabled">false</bool>
											<bool name="FaceCamera">true</bool>
											<float name="Lifetime">0.0500000007</float>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">0</float>
											<float name="MaxLength">0</float>
											<float name="MinLength">0.100000001</float>
											<string name="Name">Trail</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<Content name="Texture"><null></null></Content>
											<float name="TextureLength">1</float>
											<token name="TextureMode">0</token>
											<NumberSequence name="Transparency">0 0 0 0.502494 0.2625 0 1 1 0 </NumberSequence>
											<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXE8649AE88B804149867ACBE0B73A9FE2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{FE6D4C81-0370-41B2-9166-2DD2F27A4BF8}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "BloodEngine",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 82208816003099,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Smileeiles"},
		{Text = "Description: A droplet emitter system, used to emit droplets from a specified origin point. These droplets are then given a velocity, and upon landing on a surface, transform into pools. This process can be customized to suit various needs and genres."},
		{Text = "Version: 1.1.3"},

		{Separator = "Features"},
		{Text = " Customizable droplet physics"},
		{Text = " Pool transformation system"},
		{Text = " Optimized performance"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX9E99B6A3BCFB45CF923B4AF1AD38140C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TopbarPlus</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX01AF0E8225AA492B978AC8B26AA54D46">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{D3319C08-3BC4-4E52-9753-6D4B59207E21}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "TopbarPlus",
	Thumbnail = "rbxassetid://71152585441542",
	AssetId = 92368439343389,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: ForeverHD"},
		{Text = "Description: TopbarPlus v3 uses the Mozilla Public License v2.0. You can use this application free of charge; all you need to do is provide credit back to this resource (such as link to this post) and to open source any significant changes you make to the package."},
		{Text = "Version: 3.4.0 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX1E8C12AAE5854DE0878435A1EBE7F244">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">TopbarPlus</string>
							<int64 name="SourceAssetId">92368439343389</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Script" referent="RBX7972E93F8BED44F983128D06EF876816">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">READ_ME</string>
								<token name="RunContext">2</token>
								<string name="ScriptGuid">{811B6CFC-5E9A-4E31-8406-4B70CC777C48}</string>
								<ProtectedString name="Source"><![CDATA[--[[

> TopbarPlus was developed by ForeverHD and is actively maintained
thanks to HD Admin.

> You can get in touch with me on Discord via the social link here:
https://create.roblox.com/store/asset/92368439343389/TopbarPlus

> READ_ME is Script with RunContext set to 'Client' meaning you can
store it in ReplicatedStorage and Workspace and it will still run 
like a normal LocalScript. DO NOT PLACE place in StarterPlayerScripts
(because this is a Script with RunContext). You need to create a separate
LocalScript for anything under StarterPlayerScripts. 

> You're welcome to move `Icon` and require it yourself. You can
then delete this folder and READ_ME.

> Icon is a Package for when Roblox (hopefully soon) release
public packages. This for example will enable you to receive
automatic updates, and to compare code easily between changes

> Have feedback? Post it to devforum.roblox.com/t/topbarplus/1017485
which I actively monitor. Enjoy! ~ForeverHD June 2025

--]]



local container  = script.Parent
local Icon = require(container.Icon)

Icon.new()
	:setName("Example")
	:setLabel("Example")
	:setImage(16086868244, "Deselected")
	:setImage(16086868447, "Selected")]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDAF652F8C3F147C897A133F164DE8957">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Icon</string>
								<string name="ScriptGuid">{B5F7978F-0192-4D43-A713-3399FCA9E4D7}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	
	The majority of this code is an interface designed to make it easy for you to
	work with TopbarPlus (most methods for instance reference :modifyTheme()).
	The processing overhead mainly consists of applying themes and calculating 
	appearance (such as size and width of labels) which is handled in about
	200 lines of code here and the Widget UI module. This has been achieved
	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
	features like UIListLayouts.


	v3 provides inbuilt support for controllers (simply press DPadUp),
	touch devices (phones, tablets , etc), localization (automatic resizing
	of widgets, autolocalize for relevant labels), backwards compatability
	with the old topbar, and more.


	My primary goals for the v3 re-write have been to:
		
	1. Improve code readability and organisation (reduced lines of code within
	   Icon+IconController from 3200 to ~950, separated UI elements, etc)
		
	2. Improve ease-of-use (themes now actually make sense and can account
	   for any modifications you want, converted to a package for
	   quick installation and easy-comparisons of new updates, etc)
	
	3. Provide support for all key features of the new Roblox topbar
	   while improving performance of the module (deferring and collecting
	   changes then calling as a singular, utilizing inbuilt Roblox features
	   such as UILIstLayouts, etc)

--]]



-- SERVICES
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Types = require(script.Types)



-- TYPES
export type Icon = Types.Icon



-- REFERENCE HANDLER
-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
-- therefore this ensures that the first required package becomes the dominant and only functioning module
local iconModule = script
local Reference = require(iconModule.Reference)
local referenceObject = Reference.getObject()
local leadPackage = referenceObject and referenceObject.Value
if leadPackage and leadPackage ~= iconModule then
	return require(leadPackage) :: Types.StaticIcon
end
if not referenceObject then
	Reference.addToReplicatedStorage()
end



-- MODULES
local Signal = require(iconModule.Packages.GoodSignal)
local Janitor = require(iconModule.Packages.Janitor)
local Utility = require(iconModule.Utility)
local Themes = require(iconModule.Features.Themes)
local Gamepad = require(iconModule.Features.Gamepad)
local Overflow = require(iconModule.Features.Overflow)
local Icon = {}
Icon.__index = Icon



--- LOCAL
local localPlayer = Players.LocalPlayer
local themes = iconModule.Features.Themes
local iconsDict = {}
local anyIconSelected = Signal.new()
local elements = iconModule.Elements
local totalCreatedIcons = 0
local preferredInput = {
	mobile = Enum.PreferredInput.Touch,
	desktop = Enum.PreferredInput.KeyboardAndMouse,
	console = Enum.PreferredInput.Gamepad
}



-- PUBLIC VARIABLES
Icon.baseDisplayOrderChanged = Signal.new()
Icon.baseDisplayOrder = 10
Icon.baseTheme = require(themes.Default)
Icon.isOldTopbar = false -- Logic has been moved to Container
Icon.iconsDictionary = iconsDict
Icon.insetHeightChanged = Signal.new()
Icon.container = require(elements.Container)(Icon)
Icon.topbarEnabled = true
Icon.iconAdded = Signal.new()
Icon.iconRemoved = Signal.new()
Icon.iconChanged = Signal.new()



-- PUBLIC FUNCTIONS
function Icon.getIcons()
	return Icon.iconsDictionary
end

function Icon.getIconByUID(UID)
	local match = Icon.iconsDictionary[UID]
	if match then
		return match
	end
	return nil
end

function Icon.getIcon(nameOrUID)
	local match = Icon.getIconByUID(nameOrUID)
	if match then
		return match
	end
	for _, icon in pairs(iconsDict) do
		if icon.name == nameOrUID then
			return icon
		end
	end
	return nil
end

function Icon.setTopbarEnabled(bool, isInternal)
	if typeof(bool) ~= "boolean" then
		bool = Icon.topbarEnabled
	end
	if not isInternal then
		Icon.topbarEnabled = bool
	end
	for _, screenGui in pairs(Icon.container) do
		screenGui.Enabled = bool
	end
end

function Icon.modifyBaseTheme(modifications)
	modifications = Themes.getModifications(modifications)
	for _, modification in pairs(modifications) do
		for _, detail in pairs(Icon.baseTheme) do
			Themes.merge(detail, modification)
		end
	end
	for _, icon in pairs(iconsDict) do
		icon:setTheme(Icon.baseTheme)
	end
end

function Icon.setDisplayOrder(int)
	Icon.baseDisplayOrder = int
	Icon.baseDisplayOrderChanged:Fire(int)
end



-- SETUP
task.defer(Gamepad.start, Icon)
task.defer(Overflow.start, Icon)
task.defer(function()
	local playerGui = localPlayer:WaitForChild("PlayerGui")
	for _, screenGui in pairs(Icon.container) do
		screenGui.Parent = playerGui
	end
	require(iconModule.Attribute)
end)



-- CONSTRUCTOR
function Icon.new()
	local self = {}
	setmetatable(self, Icon)

	--- Janitors (for cleanup)
	local janitor = Janitor.new()
	self.janitor = janitor
	self.themesJanitor = janitor:add(Janitor.new())
	self.singleClickJanitor = janitor:add(Janitor.new())
	self.captionJanitor = janitor:add(Janitor.new())
	self.joinJanitor = janitor:add(Janitor.new())
	self.menuJanitor = janitor:add(Janitor.new())
	self.dropdownJanitor = janitor:add(Janitor.new())

	-- Register
	local iconUID = Utility.generateUID()
	iconsDict[iconUID] = self
	janitor:add(function()
		iconsDict[iconUID] = nil
	end)

	-- Signals (events)
	self.selected = janitor:add(Signal.new())
	self.deselected = janitor:add(Signal.new())
	self.toggled = janitor:add(Signal.new())
	self.viewingStarted = janitor:add(Signal.new())
	self.viewingEnded = janitor:add(Signal.new())
	self.stateChanged = janitor:add(Signal.new())
	self.notified = janitor:add(Signal.new())
	self.noticeStarted = janitor:add(Signal.new())
	self.noticeChanged = janitor:add(Signal.new())
	self.endNotices = janitor:add(Signal.new())
	self.toggleKeyAdded = janitor:add(Signal.new())
	self.fakeToggleKeyChanged = janitor:add(Signal.new())
	self.alignmentChanged = janitor:add(Signal.new())
	self.updateSize = janitor:add(Signal.new())
	self.resizingComplete = janitor:add(Signal.new())
	self.joinedParent = janitor:add(Signal.new())
	self.menuSet = janitor:add(Signal.new())
	self.dropdownSet = janitor:add(Signal.new())
	self.updateMenu = janitor:add(Signal.new())
	self.startMenuUpdate = janitor:add(Signal.new())
	self.childThemeModified = janitor:add(Signal.new())
	self.indicatorSet = janitor:add(Signal.new())
	self.dropdownChildAdded = janitor:add(Signal.new())
	self.menuChildAdded = janitor:add(Signal.new())

	-- Properties
	self.iconModule = iconModule
	self.UID = iconUID
	self.isEnabled = true
	self.enabled = self.isEnabled -- Backwards compatability
	self.isSelected = false
	self.isViewing = false
	self.joinedFrame = false
	self.parentIconUID = false
	self.deselectWhenOtherIconSelected = true
	self.totalNotices = 0
	self.activeState = "Deselected"
	self.alignment = ""
	self.originalAlignment = ""
	self.appliedTheme = {}
	self.appearance = {}
	self.cachedInstances = {}
	self.cachedNamesToInstances = {}
	self.cachedCollectives = {}
	self.bindedToggleKeys = {}
	self.customBehaviours = {}
	self.toggleItems = {}
	self.bindedEvents = {}
	self.notices = {}
	self.menuIcons = {}
	self.dropdownIcons = {}
	self.childIconsDict = {}
	self.creationTime = os.clock()

	-- Widget is the new name for an icon
	local widget = janitor:add(require(elements.Widget)(self, Icon))
	self.widget = widget
	self:setAlignment()
	
	-- It's important we set an order otherwise icons will not align
	-- correctly within menus
	totalCreatedIcons += 1
	local ourOrder = 1+(totalCreatedIcons*0.01)
	self:setOrder(ourOrder, "deselected")
	self:setOrder(ourOrder, "selected")

	-- This applies the default them
	self:setTheme(Icon.baseTheme)

	-- Button Clicked (for states "Selected" and "Deselected")
	local clickRegion = self:getInstance("ClickRegion")
	local hasUsedMouseButton1Click = false
	local lastToggleTime = 0
	local DEBOUNCE_TIME = 0.1 -- 100ms debounce to prevent rapid toggles

	local function handleToggle()
		if self.locked then
			return
		end

		-- Debounce logic to prevent rapid toggling
		local currentTime = tick()
		if currentTime - lastToggleTime < DEBOUNCE_TIME then
			return
		end
		lastToggleTime = currentTime

		if self.isSelected then
			self:deselect("User", self)
		else
			self:select("User", self)
		end
	end

	clickRegion.MouseButton1Click:Connect(function()
		hasUsedMouseButton1Click = true
		handleToggle()
	end)

	clickRegion.TouchTap:Connect(function()
		-- This resolves the bug report by @28Pixels:
		-- https://devforum.roblox.com/t/topbarplus/1017485/1104
		-- Only use TouchTap if MouseButton1Click has never fired
		-- This handles edge cases where ONLY TouchTap works
		-- Also prevents double-toggle bug with multi-touch on mobile
		-- Credit to @sayer80 for this fix
		if not hasUsedMouseButton1Click then
			handleToggle()
		end
	end)

	-- Keys can be bound to toggle between Selected and Deselected
	janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
		if self.locked then
			return
		end
		if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
			handleToggle()
		end
	end))

	-- Button Hovering (for state "Viewing")
	-- Hovering is a state only for devices with keyboards
	-- and controllers (not touchpads)
	local function viewingStarted(dontSetState)
		if self.locked then
			return
		end
		self.isViewing = true
		self.viewingStarted:Fire(true)
		if not dontSetState then
			self:setState("Viewing", "User", self)
		end
	end
	local function viewingEnded()
		if self.locked then
			return
		end
		self.isViewing = false
		self.viewingEnded:Fire(true)
		self:setState(nil, "User", self)
	end
	self.joinedParent:Connect(function()
		if self.isViewing then
			viewingEnded()
		end
	end)
	clickRegion.MouseEnter:Connect(function()
		local dontSetState = UserInputService.PreferredInput ~= preferredInput.desktop
		viewingStarted(dontSetState)
	end)
	local touchCount = 0
	janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
	clickRegion.MouseLeave:Connect(viewingEnded)
	clickRegion.SelectionGained:Connect(viewingStarted)
	clickRegion.SelectionLost:Connect(viewingEnded)
	clickRegion.MouseButton1Down:Connect(function()
		if not self.locked and UserInputService.PreferredInput == preferredInput.mobile then
			touchCount += 1
			local myTouchCount = touchCount
			task.delay(0.2, function()
				if myTouchCount == touchCount then
					viewingStarted()
				end
			end)
		end
	end)
	clickRegion.MouseButton1Up:Connect(function()
		touchCount += 1
	end)

	-- Handle overlay on viewing
	local iconOverlay = self:getInstance("IconOverlay")
	self.viewingStarted:Connect(function()
		iconOverlay.Visible = not self.overlayDisabled
	end)
	self.viewingEnded:Connect(function()
		iconOverlay.Visible = false
	end)

	-- Deselect when another icon is selected
	janitor:add(anyIconSelected:Connect(function(incomingIcon)
		if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
			self:deselect("AutoDeselect", incomingIcon)
		end
	end))

	-- This checks if the script calling this module is a descendant of a ScreenGui
	-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
	-- client respawns. This solves one of the most asked about questions on the post
	-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
	-- the LocalScript rests within
	local source =  debug.info(2, "s")
	local sourcePath = string.split(source, ".")
	local origin = game
	local originsScreenGui
	for i, sourceName in pairs(sourcePath) do
		origin = origin:FindFirstChild(sourceName)
		if not origin then
			break
		end
		if origin:IsA("ScreenGui") then
			originsScreenGui = origin
		end
	end
	if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
		self.originsScreenGui = originsScreenGui
		Utility.localPlayerRespawned(function()
			self:destroy()
		end)
	end

	-- Additional children behaviour when toggled (mostly notices)
	self.toggled:Connect(function(isSelected)
		self.noticeChanged:Fire(self.totalNotices)
		for childIconUID, _ in pairs(self.childIconsDict) do
			local childIcon = Icon.getIconByUID(childIconUID)
			childIcon.noticeChanged:Fire(childIcon.totalNotices)
			if not isSelected and childIcon.isSelected then
				-- If an icon within a menu or dropdown is also
				-- a dropdown or menu, then close it
				for _, _ in pairs(childIcon.childIconsDict) do
					childIcon:deselect("HideParentFeature", self)
				end
			end
		end
	end)
	
	-- This closes/reopens the chat or playerlist if the icon is a dropdown
	-- In the future I'd prefer to use the position+size of the chat
	-- to determine whether to close dropdown (instead of non-right-set)
	-- but for reasons mentioned here it's unreliable at the time of
	-- writing this: https://devforum.roblox.com/t/here/2794915
	-- I could also make this better by accounting for multiple
	-- dropdowns being open (not just this one) but this will work
	-- fine for almost every use case for now.
	self.selected:Connect(function()
		local isDropdown = #self.dropdownIcons > 0
		if isDropdown then
			if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
				self.chatWasPreviouslyActive = true
				StarterGui:SetCore("ChatActive", false)
			end
			if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
				self.playerlistWasPreviouslyActive = true
				StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
			end
		end
	end)
	self.deselected:Connect(function()
		if self.chatWasPreviouslyActive then
			self.chatWasPreviouslyActive = nil
			StarterGui:SetCore("ChatActive", true)
		end
		if self.playerlistWasPreviouslyActive then
			self.playerlistWasPreviouslyActive = nil
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
		end
	end)
	
	-- There's a rare occassion where the appearance is not
	-- fully set to deselected so this ensures the icons
	-- appearance is fully as it should be
	task.delay(0.1, function()
		if self.activeState == "Deselected" then
			self.stateChanged:Fire("Deselected")
			self:refresh()
		end
	end)
	
	-- Call icon added
	Icon.iconAdded:Fire(self)

	return self
end



-- METHODS
function Icon:setName(name)
	self.widget.Name = name
	self.name = name
	return self
end

function Icon:setState(incomingStateName, fromSource, sourceIcon)
	-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
	-- a users mouse enters the widget), then informing other systems of this state change to then act upon
	-- (such as the theme handler applying the theme which corresponds to that state).
	if not incomingStateName then
		incomingStateName = (self.isSelected and "Selected") or "Deselected"
	end
	local stateName = Utility.formatStateName(incomingStateName)
	local previousStateName = self.activeState
	if previousStateName == stateName then
		return
	end
	local currentIsSelected = self.isSelected
	self.activeState = stateName
	if stateName == "Deselected" then
		self.isSelected = false
		if currentIsSelected then
			self.toggled:Fire(false, fromSource, sourceIcon)
			self.deselected:Fire(fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(false, fromSource, sourceIcon)
	elseif stateName == "Selected" then
		self.isSelected = true
		if not currentIsSelected then
			self.toggled:Fire(true, fromSource, sourceIcon)
			self.selected:Fire(fromSource, sourceIcon)
			anyIconSelected:Fire(self, fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(true, fromSource, sourceIcon)
	end
	self.stateChanged:Fire(stateName, fromSource, sourceIcon)
end

function Icon:getInstance(name)
	-- This enables us to easily retrieve instances located within the icon simply by passing its name.
	-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
	-- We cache the result for more performant retrieval in the future.
	local instance = self.cachedNamesToInstances[name]
	if instance then
		return instance
	end
	local function cacheInstance(childName, child)
		local currentCache = self.cachedInstances[child]
		if not currentCache then
			local collectiveName = child:GetAttribute("Collective")
			local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
			if cachedCollective then
				table.insert(cachedCollective, child)
			end
			self.cachedNamesToInstances[childName] = child
			self.cachedInstances[child] = true
			child.Destroying:Once(function()
				self.cachedNamesToInstances[childName] = nil
				self.cachedInstances[child] = nil
			end)
		end
	end
	local widget = self.widget
	cacheInstance("Widget", widget)
	if name == "Widget" then
		return widget
	end

	local returnChild
	local function scanChildren(parentInstance)
		for _, child in pairs(parentInstance:GetChildren()) do
			local widgetUID = child:GetAttribute("WidgetUID")
			if widgetUID and widgetUID ~= self.UID then
				-- This prevents instances within other icons from being recorded
				-- (for instance when other icons are added to this icons menu)
				continue
			end
			-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
			-- then its important we scan the real original instance instead of this clone
			local realChild = Themes.getRealInstance(child)
			if realChild then
				child = realChild
			end
			-- Finally scan its children
			scanChildren(child)
			if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
				local childName = child.Name
				cacheInstance(childName, child)
				if childName == name then
					returnChild = child
				end
			end
		end
	end
	scanChildren(widget)
	return returnChild
end

function Icon:getCollective(name)
	-- A collective is an array of instances within the Widget that have been
	-- grouped together based on a given name. This just makes it easy
	-- to act on multiple instances at once which share similar behaviours.
	-- For instance, if we want to change the icons corner size, all corner instances
	-- with the attribute "Collective" and value "WidgetCorner" could be updated
	-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
	local collective = self.cachedCollectives[name]
	if collective then
		return collective
	end
	collective = {}
	for instance, _ in pairs(self.cachedInstances) do
		if instance:GetAttribute("Collective") == name then
			table.insert(collective, instance)
		end
	end
	self.cachedCollectives[name] = collective
	return collective
end

function Icon:getInstanceOrCollective(collectiveOrInstanceName)
	-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
	-- an array of instances instead of a single instance
	local instances = {}
	local instance = self:getInstance(collectiveOrInstanceName)
	if instance then
		table.insert(instances, instance)
	end
	if #instances == 0 then
		instances = self:getCollective(collectiveOrInstanceName)
	end
	return instances
end

function Icon:getStateGroup(iconState)
	local chosenState = iconState or self.activeState
	local stateGroup = self.appearance[chosenState]
	if not stateGroup then
		stateGroup = {}
		self.appearance[chosenState] = stateGroup
	end
	return stateGroup
end

function Icon:refreshAppearance(instance, specificProperty)
	Themes.refresh(self, instance, specificProperty)
	return self
end

function Icon:refresh()
	self:refreshAppearance(self.widget)
	self.updateSize:Fire()
	return self
end

function Icon:updateParent()
	local parentIcon = Icon.getIconByUID(self.parentIconUID)
	if parentIcon then
		parentIcon.updateSize:Fire()
	end
end

function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
	-- You can specify your own custom callback to handle custom logic just before
	-- an instances property is changed by using :setBehaviour()
	local key = collectiveOrInstanceName.."-"..property
	self.customBehaviours[key] = callback
	if refreshAppearance then
		local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
		for _, instance in pairs(instances) do
			self:refreshAppearance(instance, property)
		end
	end
end

function Icon:modifyTheme(modifications, customModificationUID)
	local modificationUID = Themes.modify(self, modifications, customModificationUID)
	return self, modificationUID
end

function Icon:modifyChildTheme(modifications, modificationUID)
	-- Same as modifyTheme except for its children (i.e. icons
	-- within its dropdown or menu)
	self.childModifications = modifications
	self.childModificationsUID = modificationUID
	for childIconUID, _ in pairs(self.childIconsDict) do
		local childIcon = Icon.getIconByUID(childIconUID)
		childIcon:modifyTheme(modifications, modificationUID)
	end
	self.childThemeModified:Fire()
	return self
end

function Icon:removeModification(modificationUID)
	Themes.remove(self, modificationUID)
	return self
end

function Icon:removeModificationWith(instanceName, property, state)
	Themes.removeWith(self, instanceName, property, state)
	return self
end

function Icon:setTheme(theme)
	Themes.set(self, theme)
	return self
end

function Icon:setEnabled(bool)
	self.isEnabled = bool
	self.enabled = self.isEnabled
	self.widget.Visible = bool
	self:updateParent()
	return self
end

function Icon:select(fromSource, sourceIcon)
	self:setState("Selected", fromSource, sourceIcon)
	return self
end

function Icon:deselect(fromSource, sourceIcon)
	self:setState("Deselected", fromSource, sourceIcon)
	return self
end

function Icon:notify(customClearSignal, noticeId)
	-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
	-- users of changes/updates within your UI such as a Catalog
	-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
	-- Roblox event (e.g. Instance.new("BindableEvent").Event)
	local notice = self.notice
	if not notice then
		notice = require(elements.Notice)(self, Icon)
		self.notice = notice
	end
	self.noticeStarted:Fire(customClearSignal, noticeId)
	return self
end

function Icon:clearNotices()
	self.endNotices:Fire()
	return self
end

function Icon:disableOverlay(bool)
	self.overlayDisabled = bool
	return self
end
Icon.disableStateOverlay = Icon.disableOverlay

function Icon:setImage(imageId, iconState)
	self:modifyTheme({"IconImage", "Image", imageId, iconState})
	
	-- This code ensures icon images are preloaded if they haven't been fetched yet
	task.spawn(function()
		local newIdContent = if tonumber(imageId) then `rbxassetid://{imageId}` else imageId
		local initialAssetFetchStatus = ContentProvider:GetAssetFetchStatus(newIdContent)
	
		if initialAssetFetchStatus ~= Enum.AssetFetchStatus.Success then
			pcall(ContentProvider.PreloadAsync, ContentProvider, { newIdContent })
		end
	end)
		
	return self
end

function Icon:setLabel(text, iconState)
	self:modifyTheme({"IconLabel", "Text", text, iconState})
	return self
end

function Icon:setOrder(int, iconState)
	-- We multiply by 100 to allow for custom increments inbetween
	-- (.01, .02, etc) as LayoutOrders only support integers
	local newInt = int*100
	self:modifyTheme({"IconSpot", "LayoutOrder", newInt, iconState})
	self:modifyTheme({"Widget", "LayoutOrder", newInt, iconState})
	return self
end

function Icon:setCornerRadius(udim, iconState)
	self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
	return self
end

function Icon:align(leftCenterOrRight, isFromParentIcon)
	-- Determines the side of the screen the icon will be ordered
	local direction = tostring(leftCenterOrRight):lower()
	if direction == "mid" or direction == "centre" then
		direction = "center"
	end
	if direction ~= "left" and direction ~= "center" and direction ~= "right" then
		direction = "left"
	end
	local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
	local holders = screenGui.Holders
	local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
	if not isFromParentIcon then
		self.originalAlignment = finalDirection
	end
	local joinedFrame = self.joinedFrame
	local alignmentHolder = holders[finalDirection]
	self.screenGui = screenGui
	self.alignmentHolder = alignmentHolder
	if not self.isDestroyed then
		self.widget.Parent = joinedFrame or alignmentHolder
	end
	self.alignment = finalDirection
	self.alignmentChanged:Fire(finalDirection)
	Icon.iconChanged:Fire(self)
	return self
end
Icon.setAlignment = Icon.align

function Icon:setLeft()
	self:setAlignment("Left")
	return self
end

function Icon:setMid()
	self:setAlignment("Center")
	return self
end

function Icon:setRight()
	self:setAlignment("Right")
	return self
end

function Icon:setWidth(offsetMinimum, iconState)
	-- This sets a minimum X offset size for the widget, useful
	-- for example if you're constantly changing the label
	-- but don't want the icon to resize every time
	self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
	return self
end

function Icon:setImageScale(number, iconState)
	self:modifyTheme({"IconImageScale", "Value", number, iconState})
	return self
end

function Icon:setImageRatio(number, iconState)
	self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
	return self
end

function Icon:setTextSize(number, iconState)
	self:modifyTheme({"IconLabel", "TextSize", number, iconState})
	return self
end

function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
	fontWeight = fontWeight or Enum.FontWeight.Regular
	fontStyle = fontStyle or Enum.FontStyle.Normal
	local fontFace
	local fontType = typeof(font)
	if fontType == "number" then
		fontFace = Font.fromId(font, fontWeight, fontStyle)
	elseif fontType == "EnumItem" then
		fontFace = Font.fromEnum(font)
	elseif fontType == "string" then
		if not font:match("rbxasset") then
			fontFace = Font.fromName(font, fontWeight, fontStyle)
		end
	end
	if not fontFace then
		fontFace = Font.new(font, fontWeight, fontStyle)
	end
	self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
	return self
end

function Icon:setTextColor(Color, iconState)
	if Color == nil or Color == "" or (type(Color) ~= "userdata" or typeof(Color) ~= "Color3") then
		if Color ~= nil and Color ~= "" then
			warn("setTextColor item must be a Color3 value! Changed the color to white.")
		end
		Color = Color3.fromRGB(255, 255, 255)
	end

	self:modifyTheme({"IconLabel", "TextColor3", Color, iconState})
	return self
end

function Icon:bindToggleItem(guiObjectOrLayerCollector)
	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
		error("Toggle item must be a GuiObject or LayerCollector!")
	end
	self.toggleItems[guiObjectOrLayerCollector] = true
	self:_updateSelectionInstances()
	return self
end

function Icon:unbindToggleItem(guiObjectOrLayerCollector)
	self.toggleItems[guiObjectOrLayerCollector] = nil
	self:_updateSelectionInstances()
	return self
end

function Icon:_updateSelectionInstances()
	-- This is to assist with controller navigation and selection
	-- It converts the value true to an array
	for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
		local buttonInstancesArray = {}
		for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
			if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
				table.insert(buttonInstancesArray, instance)
			end
		end
		self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
	end
end

function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
	for toggleItem, _ in pairs(self.toggleItems) do
		if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
			local property = "Visible"
			if toggleItem:IsA("LayerCollector") then
				property = "Enabled"
			end
			toggleItem[property] = bool
		end
	end
end

function Icon:bindEvent(iconEventName, eventFunction)
	local event = self[iconEventName]
	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
	self.bindedEvents[iconEventName] = event:Connect(function(...)
		eventFunction(self, ...)
	end)
	return self
end

function Icon:unbindEvent(iconEventName)
	local eventConnection = self.bindedEvents[iconEventName]
	if eventConnection then
		eventConnection:Disconnect()
		self.bindedEvents[iconEventName] = nil
	end
	return self
end

function Icon:bindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = true
	self.toggleKeyAdded:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:unbindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = nil
	return self
end

function Icon:call(callback, ...)
	local packedArgs = table.pack(...)
	task.spawn(function()
		callback(self, table.unpack(packedArgs))
	end)
	return self
end

function Icon:addToJanitor(callback, methodName, index)
	self.janitor:add(callback, methodName, index)
	return self
end

function Icon:lock()
	-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = false
	self.locked = true
	return self
end

function Icon:unlock()
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = true
	self.locked = false
	return self
end

function Icon:debounce(seconds)
	self:lock()
	task.wait(seconds)
	self:unlock()
	return self
end

function Icon:autoDeselect(bool)
	-- When set to true the icon will deselect itself automatically whenever
	-- another icon is selected
	if bool == nil then
		bool = true
	end
	self.deselectWhenOtherIconSelected = bool
	return self
end

function Icon:oneClick(bool)
	-- When set to true the icon will automatically deselect when selected, this creates
	-- the effect of a single click button
	local singleClickJanitor = self.singleClickJanitor
	singleClickJanitor:clean()
	if bool or bool == nil then
		singleClickJanitor:add(self.selected:Connect(function()
			self:deselect("OneClick", self)
		end))
	end
	self.oneClickEnabled = true
	return self
end

function Icon:setCaption(text)
	if text == "_hotkey_" and (self.captionText) then
		return self
	end
	local captionJanitor = self.captionJanitor
	self.captionJanitor:clean()
	if not text or text == "" then
		self.caption = nil
		self.captionText = nil
		return self
	end
	local caption = captionJanitor:add(require(elements.Caption)(self))
	caption:SetAttribute("CaptionText", text)
	self.caption = caption
	self.captionText = text
	return self
end

function Icon:setCaptionHint(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.fakeToggleKey = keyCodeEnum
	self.fakeToggleKeyChanged:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:leave()
	local joinJanitor = self.joinJanitor
	joinJanitor:clean()
	return self
end

function Icon:joinMenu(parentIcon)
	Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
	parentIcon.menuChildAdded:Fire(self)
	return self
end

function Icon:setMenu(arrayOfIcons)
	self.menuSet:Fire(arrayOfIcons)
	return self
end

function Icon:setFixedMenu(arrayOfIcons)
	self:freezeMenu(arrayOfIcons)
	self:setMenu(arrayOfIcons)
end
Icon.setFrozenMenu = Icon.setFixedMenu

function Icon:freezeMenu()
	-- A frozen menu is a menu which is permanently locked in the
	-- the selected state (with its toggle hidden)
	self:select("FrozenMenu", self)
	self:bindEvent("deselected", function(icon)
		icon:select("FrozenMenu", self)
	end)
	self:modifyTheme({"IconSpot", "Visible", false})
end

function Icon:joinDropdown(parentIcon)
	parentIcon:getDropdown()
	Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
	parentIcon.dropdownChildAdded:Fire(self)
	return self
end

function Icon:getDropdown()
	local dropdown = self.dropdown
	if not dropdown then
		dropdown = require(elements.Dropdown)(self)
		self.dropdown = dropdown
		self:clipOutside(dropdown)
	end
	return dropdown
end

function Icon:setDropdown(arrayOfIcons)
	self:getDropdown()
	self.dropdownSet:Fire(arrayOfIcons)
	return self
end

function Icon:clipOutside(instance)
	-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
	-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
	-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
	-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
	-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
	local instanceClone = Utility.clipOutside(self, instance)
	self:refreshAppearance(instance)
	return self, instanceClone
end

function Icon:setIndicator(keyCode)
	-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
	-- with controllers to show the user what button to press to highlight the topbar. You don't need
	-- to set an indicator for controllers as this is handled internally within the Gamepad module
	local indicator = self.indicator
	if not indicator then
		indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
		self.indicator = indicator
	end
	self.indicatorSet:Fire(keyCode)
end

function Icon:convertLabelToNumberSpinner(numberSpinner, callback)
	task.defer(function()
		
		local label = self:getInstance("IconLabel")
		label.Transparency = 1
		numberSpinner.Parent = label.Parent
		numberSpinner.Size = UDim2.fromScale(1, 1)
		numberSpinner.AnchorPoint = Vector2.new(0.5, 0.5)
		numberSpinner.Position = UDim2.new(0.5, 0, 0.5, 0)
		numberSpinner.TextXAlignment = Enum.TextXAlignment.Center
		numberSpinner.ClipsDescendants = false

		local propertiesToChangeLabel = {
			"FontFace",
			"BorderSizePixel",
			"BorderColor3",
			"Rotation",
			"TextStrokeTransparency",
			"TextStrokeColor3",
			"TextStrokeTransparency",
			"TextColor3",
		}
		for _, property in ipairs(propertiesToChangeLabel) do
			numberSpinner[property] = label[property]
			self:addToJanitor(label:GetPropertyChangedSignal(property):Connect(function()
				numberSpinner[property] = label[property]
			end))
		end

		local minDigits = 0
		local maxDigits = 8
		local function getSpinnerSizeAndDigitCount()
			local TotalSize = 0
			local numOfDigits = 0
			for i, child in numberSpinner.Frame:GetChildren() do
				local name = string.lower(child.Name)
				if name == "digit" then
					TotalSize += child.AbsoluteSize.X
					numOfDigits += 1
				elseif name == "prefix" or name == "suffix" or name == "comma" then
					if child.Text ~= "" then
						TotalSize += child.AbsoluteSize.X
						numOfDigits += 1
					end
				end
			end
			return TotalSize, numOfDigits
		end
		
		local function getLabelParentContainerXSize()
			local firstParent = label.Parent
			local nextParent = firstParent and firstParent.Parent
			if nextParent == nil then
				return 0
			end
			if nextParent.IconImage.Visible == true then
				return numberSpinner.Frame.AbsoluteSize.X + label.Parent.Parent.IconImage.AbsoluteSize.X
			else
				return nextParent.AbsoluteSize.X
			end
		end
		local function getNumberSpinnerXSize()
			return numberSpinner.Frame.AbsoluteSize.X
		end

		local function adjustSize()
			local totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			if numOfDigits < 18 then
				self:setLabel(numberSpinner.Value)
			end

			local NumberSpinnerXSize = getNumberSpinnerXSize()

			while totalDigitXSize < NumberSpinnerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits > minDigits and numOfDigits < maxDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize += 1
				end

				NumberSpinnerXSize = getNumberSpinnerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end

			local labelParentContainerXSize = getLabelParentContainerXSize()
			while totalDigitXSize > labelParentContainerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits < maxDigits and numOfDigits > minDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize -= 1
				end

				labelParentContainerXSize = getLabelParentContainerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end
		end

		self:addToJanitor(numberSpinner.Frame.ChildAdded:Connect(adjustSize))
		self:addToJanitor(numberSpinner.Frame.ChildRemoved:Connect(adjustSize))
		self:addToJanitor(self.iconAdded:Connect(function()
			task.wait(1)
			adjustSize()
		end))

		self:updateParent()

		-- This corrects text to the size of a normal label
		numberSpinner.Name = "LabelSpinner"
		numberSpinner.Prefix = "$"
		numberSpinner.Commas = true
		numberSpinner.Decimals = 0
		numberSpinner.Duration = 0.25
		numberSpinner.Value = 10
		task.wait(0.2)
		
		if typeof(callback) == "function" then
			callback()
		end
		
	end)
	return self
end



-- DESTROY/CLEANUP
function Icon:destroy()
	if self.isDestroyed then
		return
	end
	self:clearNotices()
	if self.parentIconUID then
		self:leave()
	end
	self.isDestroyed = true
	self.janitor:clean()
	Icon.iconRemoved:Fire(self)
end
Icon.Destroy = Icon.destroy

return Icon :: Types.StaticIcon]]></ProtectedString>
								<int64 name="SourceAssetId">16049574146</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXFBF1F8BFF00E494789C0F37C49D477EC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Types</string>
									<string name="ScriptGuid">{65C3D69B-10BF-4CC4-9F5C-D7F0A4E54270}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

-- GoodSignal Types (...but simpler!)

--- Connection

type Connection<Variant... = ...any> = {
	Disconnect: (self: Connection<Variant...>) -> (),
}

--- Signal

type Signal<Variant... = ...any> = {
	Connect: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
    Once: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
	Wait: (self: Signal<Variant...>) -> Variant...,
}

----------------------

export type IconState = "Deselected" | "Selected" | "Viewing"
export type Events = "selected" | "deselected" | "toggled" | "viewingStarted" | "viewingEnded" | "notified"
export type Alignment = "Left" | "Center" | "Right"
export type EventSource = "User" | "OneClick" | "AutoDeselect" | "HideParentFeature" | "Overflow"
export type Modification = { any }


type StaticFunctions = {
	getIcons: typeof(
		--[[
			Returns a dictionary of icons where the key is the icon's UID and value the icon.
		]]
		function(): { Icon }
			return (nil :: any) :: { Icon }
		end
	),
	getIcon: typeof(
		--[[
			Returns an icon of the given name or UID.
		]]
		function(nameOrUID: string): Icon?
			return nil :: any
		end
	),
	setTopbarEnabled: typeof(
		--[[
			When set to <code>false</code> all TopbarPlus ScreenGuis are hidden.
			This does not impact Roblox's Topbar.
		]]
		function(enabled: boolean)

		end
	),
	modifyBaseTheme: typeof(
		--[[
			Updates the appearance of all icons.
		]]
		function(modifications: { Modification })

		end
	),
	setDisplayOrder: typeof(
		--[[
			Sets the base DisplayOrder of all TopbarPlus ScreenGuis.
		]]
		function(order: number)

		end
	),
}

type Methods = {
	
	-- CLASS FUNCTIONS
	setName: typeof(
		--[[
			Sets the name of the Widget instance. This can be used in conjunction with <code>Icon.getIcon(name)</code>
		]]
		function(self: Icon, name: string): Icon
			return nil :: any
		end
	),
	getInstance: typeof(
		--[[
			Returns the first descendant found within the widget of name <code>instanceName</code>.
		]]
		function(self: Icon, instanceName: string): Instance?
			return (nil :: any) :: Instance?
		end
	),
	modifyTheme: typeof(
		--[[
			Updates the appearance of the icon.
		]]
		function(self: Icon, modifications: {Modification} | Modification): Icon
			return nil :: any
		end
	),
	modifyChildTheme: typeof(
		--[[
			Updates the appearance of all icons that are parented to this icon (for example when a menu or dropdown).
		]]
		function(self: Icon, modifications: { Modification }): Icon
			return nil :: any
		end
	),
	setEnabled: typeof(
		--[[
			When set to <code>false</code> the icon will be disabled and hidden.
		]]
		function(self: Icon, enabled: boolean): Icon
			return nil :: any
		end
	),
	select: typeof(
		--[[
			Selects the icon (as if it were clicked once).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	deselect: typeof(
		--[[
			Deselects the icon (as if it were clicked, then clicked again).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	notify: typeof(
		--[[
			Prompts a notice bubble which accumulates the further it is prompted.
			If the icon belongs to a dropdown or menu, then the notice will appear on the parent icon when the parent icon is deselected.
		]]
		function(self: Icon, clearNoticeEvent: Signal?): Icon
			return nil :: any
		end
	),
	clearNotices: typeof(
		--[[
			
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	disableOverlay: typeof(
		--[[
			When set to <code>true</code>, disables the shade effect which appears when the icon is pressed and released.
		]]
		function(self: Icon, disabled: boolean): Icon
			return nil :: any
		end
	),
	setImage: typeof(
		--[[
			Applies an image to the icon based on the given <code>imageId</code>. <code>imageId</code> can be an assetId or a complete asset string.
		]]
		function(self: Icon, imageId: string | number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setLabel: typeof(
		--[[
			
		]]
		function(self: Icon, text: string, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setOrder: typeof(
		--[[
			
		]]
		function(self: Icon, order: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setCornerRadius: typeof(
		--[[
			
		]]
		function(self: Icon, udim: UDim2, iconState: IconState?): Icon
			return nil :: any
		end
	),
	align: typeof(
		--[[
			This enables you to set the icon to the <code>"Left"</code> (default), <code>"Center"</code> or <code>"Right"</code> side of the screen.
		]]
		function(self: Icon, alignment: Alignment?): Icon
			return nil :: any
		end
	),
	setWidth: typeof(
		--[[
			This sets the minimum width the icon can be (it can be larger for instance when setting a long label). The default width is <code>44</code>.
		]]
		function(self: Icon, minimumSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageScale: typeof(
		--[[
			How large the image is relative to the icon. The default value is <code>0.5</code>.
		]]
		function(self: Icon, scale: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageRatio: typeof(
		--[[
			How stretched the image will appear. The default value is <code>1</code> (a perfect square).
		]]
		function(self: Icon, ratio: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextSize: typeof(
		--[[
			The size of the icon labels' text. The default value is <code>16</code>.
		]]
		function(self: Icon, textSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextColor: typeof(
		--[[
			The color of the icon labels' text
		]]
		function(self: Icon, color: Color3, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextFont: typeof(
		--[[
			Sets the labels FontFace.
			<code>font</code> can be a font family name (such as <code>"Creepster"</code>),
			a font enum (such as <code>Enum.Font.Bangers</code>),
			a font ID (such as <code>12187370928</code>),
			or font family link (such as <code>"rbxasset://fonts/families/Sarpanch.json"</code>).
		]]
		function(self: Icon, font: string | Enum.Font, fontWeight: Enum.FontWeight?, fontStyle: Enum.FontSize?, iconState: IconState?): Icon
			return nil :: any
		end
	),
	bindToggleItem: typeof(
		--[[
			Binds a GuiObject or LayerCollector to appear and disappeared when the icon is toggled.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	unbindToggleItem: typeof(
		--[[
			Unbinds the given GuiObject or LayerCollector from the toggle.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	bindEvent: typeof(
		--[[
			Connects to an icon event with <code>iconEventName</code>.
			It's important to remember all event names are in <code>camelCase</code>.
			<code>callback</code> is called with arguments <code>(self, ...)</code> when the event is triggered.
		]]
		function(self: Icon, event: Events, callback: (...any) -> ()): Icon
			return nil :: any
		end
	),
	unbindEvent: typeof(
		--[[
			Unbinds the connection of the associated <code>iconEventName</code>.
		]]
		function(self: Icon, event: Events): Icon
			return nil :: any
		end
	),
	bindToggleKey: typeof(
		--[[
			Binds a keycode which toggles the icon when pressed.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	unbindToggleKey: typeof(
		--[[
			Unbinds the given keycode.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	call: typeof(
		--[[
			Calls the function immediately via <code>task.spawn</code>.
			The first argument passed is the icon itself.
			This is useful when needing to extend the behaviour of an icon while remaining in the chain.
		]]
		function(self: Icon, func: (self: Icon) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	addToJanitor: typeof(
		--[[
			Passes the given userdata to the icons janitor to be destroyed/disconnected on the icons destruction.
			If a function is passed, it will be called when the icon is destroyed.
		]]
		function(self: Icon, userdata: unknown): Icon
			return nil :: any
		end
	),
	lock: typeof(
		--[[
			Prevents the icon being toggled by user-input (such as clicking), however, the icon can still be toggled via localscript using methods such as <code>icon:select()</code>.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	unlock: typeof(
		--[[
			Re-enables user-input to toggle the icon again.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	debounce: typeof(
		--[[
			Locks the icon, yields for the given time, then unlocks the icon, effectively shorthand for <code>icon:lock() task.wait(seconds) icon:unlock()</code>.
			This is useful for applying cooldowns (to prevent an icon from being pressed again) after an icon has been selected or deselected.
		]]
		function(self: Icon, seconds: number): Icon
			return nil :: any
		end
	),
	autoDeselect: typeof(
		--[[
			When set to <code>true</code> (the default) the icon is deselected when another icon (with autoDeselect enabled) is pressed.
			Set to <code>false</code> to prevent the icon being deselected when another icon is selected (a useful behaviour in dropdowns).
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	oneClick: typeof(
		--[[
			When set to true the icon will automatically deselect when selected.
			This creates the effect of a single click button.
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	setCaption: typeof(
		--[[
			Sets a caption. To remove, pass <code>nil</code> as <code>text</code>.
		]]
		function(self: Icon, text: string?): Icon
			return nil :: any
		end
	),
	setCaptionHint: typeof(
		--[[
			This customizes the appearance of the caption's hint without having to use <code>icon:bindToggleKey</code>.
		]]
		function(self: Icon, keyCode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	setDropdown: typeof(
		--[[
			Creates a vertical dropdown based upon the given table array of icons.
			Pass an empty table <code>{}</code> to remove the dropdown.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinDropdown: typeof(
		--[[
			Joins the dropdown of <code>parentIcon</code>.
			This is what <code>icon:setDropdown</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parent: Icon): Icon
			return nil :: any
		end
	),
	setMenu: typeof(
		--[[
			Creates a horizontal menu based upon the given array of icons.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	setFixedMenu: typeof(
		--[[
			Creates a menu that is always selected and has it's close button hidden.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinMenu: typeof(
		--[[
			Joins the menu of <code>parentIcon</code>.
			This is what <code>icon:setMenu</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parentIcon: Icon): Icon
			return nil :: any
		end
	),
	leave: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	convertLabelToNumberSpinner: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon, numberSpinner: any, func: (...any) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	destroy: typeof(
		--[[
			Clears all connections and destroys all instances associated with the icon.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
} & StaticFunctions

type Fields = {
	-- CLASS PROPERTIES
	name: string,
	isSelected: boolean,
	isEnabled: boolean,
	totalNotices: number,
	locked: boolean,

	-- CLASS EVENTS
	selected: Signal<EventSource>,
	deselected: Signal<EventSource>,
	toggled: Signal<boolean, EventSource>,
	viewingStarted: Signal,
	viewingEnded: Signal,
	notified: Signal,
}

export type Icon = Methods & StaticFunctions --typeof(setmetatable({} :: Fields, MT))

export type StaticIcon = {
	new: typeof(
		--[[
			Constructs an empty <code>32x32</code> icon on the topbar.
		]]
		function(): Icon
			return (nil :: any) :: Icon
		end
	),
} & StaticFunctions

return {}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX007CAFC7FA5B448C96BF7F31CC7F14F2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">VERSION</string>
									<string name="ScriptGuid">{2202B746-1816-40F9-9E6D-F772B2F1B72D}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- LOCAL
local VERSION = {}



-- SHARED
VERSION.appVersion = "v3.4.0"
VERSION.latestVersion = nil :: string?



-- FUNCTIONS
function VERSION.getLatestVersion(): string?
	local DEVELOPMENT_PLACE_ID = 117501901079852
	local latestVersion = VERSION.latestVersion
	if latestVersion then
		return latestVersion
	end
	local placeName = ""
	while true do
		local success, hdDevelopmentDetails = pcall(function()
			return game:GetService("MarketplaceService"):GetProductInfo(DEVELOPMENT_PLACE_ID)
		end)
		if success and hdDevelopmentDetails then
			placeName = hdDevelopmentDetails.Name
			break
		end
		task.wait(1)
	end
	latestVersion = string.match(placeName, "^TopbarPlus (.*)$")
	if latestVersion then
		latestVersion = latestVersion:gsub("%s+", "") -- Remove all whitespace (spaces, tabs, newlines)
	end
	VERSION.latestVersion = latestVersion
	return latestVersion
end

function VERSION.getAppVersion()
	return VERSION.appVersion
end

function VERSION.isUpToDate()
	local latestVersion = VERSION.getLatestVersion()
	local appVersion = VERSION.getAppVersion()
	return latestVersion ~= nil and latestVersion == appVersion
end



return VERSION]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX537F475F9183454E92BB67EAF12AAA3C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Reference</string>
									<string name="ScriptGuid">{63688DFD-9B95-4C6C-946B-F844BC4623DB}</string>
									<ProtectedString name="Source"><![CDATA[-- This module enables you to place Icon wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
-- cause icons to overlap with each other

local replicatedStorage = game:GetService("ReplicatedStorage")
local Reference = {}
Reference.objectName = "TopbarPlusReference"

function Reference.addToReplicatedStorage()
	local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
	objectValue.Name = Reference.objectName
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    return objectValue
end

function Reference.getObject()
	local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
    if objectValue then
        return objectValue
    end
    return false
end

return Reference]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3BE48578FC6F451B85C4A45BAD4917D4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Attribute</string>
									<string name="ScriptGuid">{DC2940F5-EB81-4FC2-B32F-C1279AE0A56A}</string>
									<ProtectedString name="Source"><![CDATA[--[[

	TopbarPlus was developed by ForeverHD and is possible thanks to HD Admin.

	By using TopbarPlus in your experience or application, you agree to either:
		1. Keep Attribute unchanged, or
		2. If an experience, to credit TopbarPlus in your description, or in a
		   devforum post linked from your experience's description.

	v3 has involved over 350 hours of work to develop, so please consider supporting
	its development by reporting any issues or feedback you have at its repository:
	https://github.com/1ForeverHD/TopbarPlus

	You can get in touch with me on Discord via the social link here:
	https://create.roblox.com/store/asset/92368439343389/TopbarPlus

	Many thanks! ~Ben, June 10th 2025
	
]]

task.defer(function()
	local RunService = game:GetService("RunService")
	local VERSION = require(script.Parent.VERSION)
	local appVersion = VERSION.getAppVersion()
	local latestVersion = VERSION.getLatestVersion()
	local isOutdated = not VERSION.isUpToDate()
	if not RunService:IsStudio() then
		print(` Running TopbarPlus {appVersion} by @ForeverHD & HD Admin`)
	end
	if isOutdated then
		warn(`A new version of TopbarPlus ({latestVersion}) is available: https://devforum.roblox.com/t/topbarplus/1017485`)
	end
end)

return {}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDC1389D65BDA49C0B49B6B90EE803A2F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Utility</string>
									<string name="ScriptGuid">{B21FFAEF-2697-490B-AAEE-E06E33E38AA5}</string>
									<ProtectedString name="Source"><![CDATA[-- Just generic utility functions which I use and repeat across all my projects



-- LOCAL
local Utility = {}
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer



-- FUNCTIONS
function Utility.createStagger(delayTime, callback, delayInitially)
	-- This creates and returns a function which when called
	-- acts identically to callback, however will only be called
	-- for a maximum of once per delayTime. If the returned function
	-- is called more than once during the delayTime, then it will
	-- wait until the expiryTime then perform another recall.
	-- This is useful for visual interfaces and effects which may be
	-- triggered multiple times within a frame or short period, but which
	-- we don't necessary need to (for performance reasons).
	local staggerActive = false
	local multipleCalls = false
	if not delayTime or delayTime == 0 then
		-- We make 0.01 instead of 0 because devices can now run at
		-- different frame rates
		delayTime = 0.01
	end
	local function staggeredCallback(...)
		if staggerActive then
			multipleCalls = true
			return
		end
		local packedArgs = table.pack(...)
		staggerActive = true
		multipleCalls = false
		task.spawn(function()
			if delayInitially then
				task.wait(delayTime)
			end
			callback(table.unpack(packedArgs))
		end)
		task.delay(delayTime, function()
			staggerActive = false
			if multipleCalls then
				-- This means it has been called at least once during
				-- the stagger period, so call again
				staggeredCallback(table.unpack(packedArgs))
			end
		end)
	end
	return staggeredCallback
end

function Utility.round(n)
	-- Credit to Darkmist101 for this
	return math.floor(n + 0.5)
end

function Utility.reverseTable(t)
	for i = 1, math.floor(#t/2) do
		local j = #t - i + 1
		t[i], t[j] = t[j], t[i]
	end
end

function Utility.copyTable(t)
	-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = Utility.copyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end

local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
function Utility.generateUID(length)
	length = length or 8
	local UID = ""
	local list = validCharacters
	local total = #list
	for i = 1, length do
		local randomCharacter = list[math.random(1, total)]
		UID = UID..randomCharacter
	end
	return UID
end

local instanceTrackers = {}
function Utility.setVisible(instance, bool, sourceUID)
	-- This effectively works like a buff object but
	-- incredibly simplified. It stacks false values
	-- so that if there is more than more than, the 
	-- instance remains hidden even if set visible true
	local tracker = instanceTrackers[instance]
	if not tracker then
		tracker = {}
		instanceTrackers[instance] = tracker
		instance.Destroying:Once(function()
			instanceTrackers[instance] = nil
		end)
	end
	if not bool then
		tracker[sourceUID] = true
	else
		tracker[sourceUID] = nil
	end
	local isVisible = bool
	if bool then
		for sourceUID, _ in pairs(tracker) do
			isVisible = false
			break
		end
	end
	instance.Visible = isVisible
end

function Utility.formatStateName(incomingStateName)
	return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
end

function Utility.localPlayerRespawned(callback)
	-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
	-- In these scenarios, traditional methods like CharacterAdded won't be called by the
	-- time the localscript has been destroyed, therefore we listen for removing instead
	-- If humanoid and health == 0, then reset/died normally, else was
	-- forcefully reset via a method such as LoadCharacter
	-- We wrap this behaviour in case any additional quirks need to be accounted for
	localPlayer.CharacterRemoving:Connect(callback)
end

function Utility.getClippedContainer(screenGui)
	-- We always want clipped items to display in front hence
	-- why we have this
	local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
	if not clippedContainer then
		clippedContainer = Instance.new("Folder")
		clippedContainer.Name = "ClippedContainer"
		clippedContainer.Parent = screenGui
	end
	return clippedContainer
end

local Janitor = require(script.Parent.Packages.Janitor)
local GuiService = game:GetService("GuiService")
function Utility.clipOutside(icon, instance)
	local cloneJanitor = icon.janitor:add(Janitor.new())
	instance.Destroying:Once(function()
		cloneJanitor:Destroy()
	end)
	icon.janitor:add(instance)

	local originalParent = instance.Parent
	local clone = cloneJanitor:add(Instance.new("Frame"))
	clone:SetAttribute("IsAClippedClone", true)
	clone.Name = instance.Name
	clone.AnchorPoint = instance.AnchorPoint
	clone.Size = instance.Size
	clone.Position = instance.Position
	clone.BackgroundTransparency = 1
	clone.LayoutOrder = instance.LayoutOrder
	clone.Parent = originalParent

	local valueInstance = Instance.new("ObjectValue")
	valueInstance.Name = "OriginalInstance"
	valueInstance.Value = instance
	valueInstance.Parent = clone

	local valueInstanceCopy = valueInstance:Clone()
	instance:SetAttribute("HasAClippedClone", true)
	valueInstanceCopy.Name = "ClippedClone"
	valueInstanceCopy.Value = clone
	valueInstanceCopy.Parent = instance

	local screenGui
	local Icon = require(icon.iconModule)
	local container = Icon.container
	local function updateScreenGui()
		local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
		screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else container[originalScreenGui.Name.."Clipped"]
		instance.AnchorPoint = Vector2.new(0, 0)
		instance.Parent = Utility.getClippedContainer(screenGui)
	end
	cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
	updateScreenGui()

	-- Lets copy over children that modify size
	for _, child in pairs(instance:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			child:Clone().Parent = clone
		end
	end

	-- If the icon is hidden, its important we are too (as
	-- setting a parent to visible = false no longer makes
	-- this hidden)
	local widget = icon.widget
	local isOutsideParent = false
	local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
	local function updateVisibility()
		if ignoreVisibilityUpdater then
			return
		end
		local isVisible = widget.Visible
		if isOutsideParent then
			isVisible = false
		end
		Utility.setVisible(instance, isVisible, "ClipHandler")
	end
	cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))

	local previousScroller
	local function checkIfOutsideParentXBounds()
		-- Defer so that roblox's properties reflect their true values
		task.defer(function()
			-- If the instance is within a parent item (such as a dropdown or menu)
			-- then we hide it if it exceeds the bounds of that parent
			local parentInstance
			local ourUID = icon.UID
			local nextIconUID = ourUID
			local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
			if shouldClipToParent then
				for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
					local nextIcon = Icon.getIconByUID(nextIconUID)
					if not nextIcon then
						break
					end
					local nextParentInstance = nextIcon.joinedFrame
					nextIconUID = nextIcon.parentIconUID
					if not nextParentInstance then
						break
					end
					parentInstance = nextParentInstance
					if parentInstance and parentInstance.Name == "DropdownScroller" then
						break
					end
				end
			end
			if not parentInstance then
				isOutsideParent = false
				updateVisibility()
				return
			end
			local pos = instance.AbsolutePosition
			local halfSize = instance.AbsoluteSize/2
			local parentPos = parentInstance.AbsolutePosition
			local parentSize = parentInstance.AbsoluteSize
			local posHalf = (pos + halfSize)
			local exceededLeft = posHalf.X < parentPos.X
			local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
			local exceededTop = posHalf.Y < parentPos.Y
			local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
			local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
			if hasExceeded ~= isOutsideParent then
				isOutsideParent = hasExceeded
				updateVisibility()
			end
			if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
				previousScroller = parentInstance
				local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
					checkIfOutsideParentXBounds()
				end)
				cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
			end
		end)
	end

	local camera = workspace.CurrentCamera
	local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
	local function trackProperty(property)
		local absoluteProperty = "Absolute"..property
		local function updateProperty()
			local cloneValue = clone[absoluteProperty]
			local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
			if property == "Position" then

				-- This binds the instances within the bounds of the screen
				local SIDE_PADDING = 4
				local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
				local inputX = absoluteValue.X.Offset
				if inputX < SIDE_PADDING then
					inputX = SIDE_PADDING
				elseif inputX > limitX then
					inputX = limitX
				end
				absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)

				-- AbsolutePosition does not perfectly match with TopbarInsets enabled
				-- This corrects this
				local topbarInset = GuiService.TopbarInset
				local viewportWidth = workspace.CurrentCamera.ViewportSize.X
				local guiWidth = screenGui.AbsoluteSize.X
				local guiOffset = screenGui.AbsolutePosition.X
				--local widthDifference = guiOffset - topbarInset.Min.X
				local oldTopbarCenterOffset = 0--widthDifference/30
				local offsetX = if Icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset
				
				-- Also add additionalOffset
				offsetX -= additionalOffsetX
				absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)

				-- Finally check if within its direct parents bounds
				checkIfOutsideParentXBounds()

			end
			instance[property] = absoluteValue
		end
		
		-- This defer is essential as the listener may be in a different screenGui to the actor
		local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))
		cloneJanitor:add(clone:GetAttributeChangedSignal("ForceUpdate"):Connect(function()
			updatePropertyStaggered()
		end))

		-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
		-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
		-- within this type of screenGui DO NOT accurately update to match their new
		-- real world position; instead they jump around almost randomly for a few frames.
		-- I have spent way too many hours trying to solve this bug, I think the only way
		-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
		-- have time to redesign the entire system around that at the moment.
		-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
		local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))
		
		-- When the screenGui is resized (such as when chat is hidden/shown), we need
		-- to update the position of the clone. Ths especially fixes the following:
		-- https://devforum.roblox.com/t/bug/1017485/1732
		if property == "Position" then
			cloneJanitor:add(screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updatePropertyStaggered()
			end))
		end

	end
	task.delay(0.1, checkIfOutsideParentXBounds)
	checkIfOutsideParentXBounds()
	updateVisibility()
	trackProperty("Position")
	
	-- Track visiblity changes
	cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
		--print("Visiblity changed:", instance, clone, instance.Visible)
		--clone.Visible = instance.Visible
	end))

	-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
	local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
	if shouldTrackCloneSize then
		trackProperty("Size")
	else
		cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			local absolute = instance.AbsoluteSize
			clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end))
	end

	return clone
end

function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)

	-- This is resonsible for moving the icon under a feature like a dropdown
	local joinJanitor = originalIcon.joinJanitor
	joinJanitor:clean()
	if not scrollingFrameOrFrame then
		originalIcon:leave()
		return
	end
	originalIcon.parentIconUID = parentIcon.UID
	originalIcon.joinedFrame = scrollingFrameOrFrame
	local function updateAlignent()
		local parentAlignment = parentIcon.alignment
		if parentAlignment == "Center" then
			parentAlignment = "Left"
		end
		originalIcon:setAlignment(parentAlignment, true)
	end
	joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
	updateAlignent()
	originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
	originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
	if parentIcon.childModifications then
		-- We defer so that the default values (such as dropdown
		-- minimum width can be applied before any custom
		-- child modifications from the user)
		task.defer(function()
			originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
		end)
	end
	--
	local clickRegion = originalIcon:getInstance("ClickRegion")
	local function makeSelectable()
		clickRegion.Selectable = parentIcon.isSelected
	end
	joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
	task.defer(makeSelectable)
	joinJanitor:add(function()
		clickRegion.Selectable = true
	end)
	--

	-- We track icons in arrays and dictionaries using their UID instead of the icon
	-- itself to prevent heavy cyclical tables when printing the icons
	local originalIconUID = originalIcon.UID
	table.insert(iconsArray, originalIconUID)
	parentIcon:autoDeselect(false)
	parentIcon.childIconsDict[originalIconUID] = true
	if not parentIcon.isEnabled then
		parentIcon:setEnabled(true)
	end
	originalIcon.joinedParent:Fire(parentIcon)

	-- This is responsible for removing it from that feature and updating
	-- their parent icon so its informed of the icon leaving it
	joinJanitor:add(function()
		local joinedFrame = originalIcon.joinedFrame
		if not joinedFrame then
			return
		end
		for i, iconUID in pairs(iconsArray) do
			if iconUID == originalIconUID then
				table.remove(iconsArray, i)
				break
			end
		end
		local Icon = require(originalIcon.iconModule)
		local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
		if not parentIcon then
			return
		end
		originalIcon:setAlignment(originalIcon.originalAlignment)
		originalIcon.parentIconUID = false
		originalIcon.joinedFrame = false
		--originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
		originalIcon:removeModification("JoinModification")
		
		local parentHasNoChildren = true
		local parentChildIcons = parentIcon.childIconsDict
		parentChildIcons[originalIconUID] = nil
		for childIconUID, _ in pairs(parentChildIcons) do
			parentHasNoChildren = false
			break
		end
		if parentHasNoChildren and not parentIcon.isAnOverflow then
			parentIcon:setEnabled(false)
		end
		updateAlignent()

	end)

end



return Utility]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="PackageLink" referent="RBX187B3A61A5B24A25A893A4BBE955E66C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoUpdate">false</bool>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<string name="DefaultName"></string>
									<bool name="DefinesCapabilities">false</bool>
									<int name="ModifiedState">-1</int>
									<string name="Name">PackageLink</string>
									<Content name="PackageIdSerialize"><url>rbxassetid://102254594775361</url></Content>
									<BinaryString name="SerializedDefaultAttributes"></BinaryString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<int64 name="VersionIdSerialize">15</int64>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBXE0675DB343F646FFA5FEE28EE4F5803F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Elements</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXE1448EB9C0B4422FB3F32EB76E44C40C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Caption</string>
										<string name="ScriptGuid">{3FB5366E-5008-4CF7-B6C1-5E9D5678A979}</string>
										<ProtectedString name="Source"><![CDATA[local CAPTION_COLOR = Color3.fromRGB(39, 41, 48)
local TEXT_SIZE = 15
return function(icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local clickRegion = icon:getInstance("ClickRegion")
	local caption = Instance.new("CanvasGroup")
	caption.Name = "Caption"
	caption.AnchorPoint = Vector2.new(0.5, 0)
	caption.BackgroundTransparency = 1
	caption.BorderSizePixel = 0
	caption.GroupTransparency = 1
	caption.Position = UDim2.fromOffset(0, 0)
	caption.Visible = true
	caption.ZIndex = 30
	caption.Parent = clickRegion

	local box = Instance.new("Frame")
	box.Name = "Box"
	box.AutomaticSize = Enum.AutomaticSize.XY
	box.BackgroundColor3 = CAPTION_COLOR
	box.Position = UDim2.fromOffset(4, 7)
	box.ZIndex = 12
	box.Parent = caption

	local header = Instance.new("TextLabel")
	header.Name = "Header"
	header.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	header.Text = "Caption"
	header.TextColor3 = Color3.fromRGB(255, 255, 255)
	header.TextSize = TEXT_SIZE
	header.TextTruncate = Enum.TextTruncate.None
	header.TextWrapped = false
	header.TextXAlignment = Enum.TextXAlignment.Left
	header.AutomaticSize = Enum.AutomaticSize.X
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Size = UDim2.fromOffset(0, 16)
	header.ZIndex = 18
	header.Parent = box

	local layout = Instance.new("UIListLayout")
	layout.Name = "Layout"
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = box

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "CaptionCorner"
	UICorner.Parent = box

	local padding = Instance.new("UIPadding")
	padding.Name = "Padding"
	padding.PaddingBottom = UDim.new(0, 12)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingTop = UDim.new(0, 12)
	padding.Parent = box

	local hotkeys = Instance.new("Frame")
	hotkeys.Name = "Hotkeys"
	hotkeys.AutomaticSize = Enum.AutomaticSize.Y
	hotkeys.BackgroundTransparency = 1
	hotkeys.LayoutOrder = 3
	hotkeys.Size = UDim2.fromScale(1, 0)
	hotkeys.Visible = false
	hotkeys.Parent = box

	local layout1 = Instance.new("UIListLayout")
	layout1.Name = "Layout1"
	layout1.Padding = UDim.new(0, 6)
	layout1.FillDirection = Enum.FillDirection.Vertical
	layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout1.HorizontalFlex = Enum.UIFlexAlignment.None
	layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
	layout1.VerticalFlex = Enum.UIFlexAlignment.None
	layout1.SortOrder = Enum.SortOrder.LayoutOrder
	layout1.Parent = hotkeys

	local keyTag1 = Instance.new("ImageLabel")
	keyTag1.Name = "Key1"
	keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
	keyTag1.ImageTransparency = 0.7
	keyTag1.ScaleType = Enum.ScaleType.Slice
	keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
	keyTag1.AutomaticSize = Enum.AutomaticSize.X
	keyTag1.BackgroundTransparency = 1
	keyTag1.LayoutOrder = 1
	keyTag1.Size = UDim2.fromOffset(0, 30)
	keyTag1.ZIndex = 15
	keyTag1.Parent = hotkeys

	local inset = Instance.new("UIPadding")
	inset.Name = "Inset"
	inset.PaddingLeft = UDim.new(0, 8)
	inset.PaddingRight = UDim.new(0, 8)
	inset.Parent = keyTag1

	local labelContent = Instance.new("TextLabel")
	labelContent.AutoLocalize = false
	labelContent.Name = "LabelContent"
	labelContent.FontFace = Font.new(
		"rbxasset://fonts/families/GothamSSm.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	labelContent.Text = ""
	labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
	labelContent.TextSize = TEXT_SIZE
	labelContent.AutomaticSize = Enum.AutomaticSize.X
	labelContent.BackgroundTransparency = 1
	labelContent.Position = UDim2.fromOffset(0, -1)
	labelContent.Size = UDim2.fromScale(1, 1)
	labelContent.ZIndex = 16
	labelContent.Parent = keyTag1
	
	local caret = Instance.new("ImageLabel")
	caret.Name = "Caret"
	caret.Image = "rbxassetid://101906294438076"
	caret.ImageColor3 = CAPTION_COLOR
	caret.AnchorPoint = Vector2.new(0, 0.5)
	caret.BackgroundTransparency = 1
	caret.Position = UDim2.new(0, 0, 0, 4)
	caret.Size = UDim2.fromOffset(16, 8)
	caret.ZIndex = 12
	caret.Parent = caption

	local dropShadow = Instance.new("ImageLabel")
	dropShadow.Visible = true
	dropShadow.Name = "DropShadow"
	dropShadow.Image = "rbxassetid://124920646932671"
	dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	dropShadow.ImageTransparency = 0.45
	dropShadow.ScaleType = Enum.ScaleType.Slice
	dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
	dropShadow.BackgroundTransparency = 1
	dropShadow.Position = UDim2.fromOffset(0, 5)
	dropShadow.Size = UDim2.new(1, 0, 0, 48)
	dropShadow.Parent = caption
	box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
	end)
	
	-- It's important we match the sizes as this is not
	-- handles within clipOutside (as it assumes the sizes
	-- are already the same)
	local captionJanitor = icon.captionJanitor
	local _, captionClone = icon:clipOutside(caption)
	captionClone.AutomaticSize = Enum.AutomaticSize.None
	local function matchSize()
		local absolute = caption.AbsoluteSize
		captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
	end
	captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
	matchSize()
	
	
	
	-- This handles the appearing/disappearing/positioning of the caption
	local isCompletelyEnabled = false
	local captionHeader = caption.Box.Header
	local UserInputService = game:GetService("UserInputService")
	local function updateHotkey(keyCodeEnum)
		local hasKeyboard = UserInputService.KeyboardEnabled
		local text = caption:GetAttribute("CaptionText") or ""
		local hideHeader = text == "_hotkey_"
		if not hasKeyboard and hideHeader then
			icon:setCaption()
			return
		end
		captionHeader.Text = text
		captionHeader.Visible = not hideHeader
		if keyCodeEnum then
			labelContent.Text = keyCodeEnum.Name
			hotkeys.Visible = true
		end
		if not hasKeyboard then
			hotkeys.Visible = false
		end
	end
	caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)

	local EASING_STYLE = Enum.EasingStyle.Quad
	local TWEEN_SPEED = 0.2
	local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
	local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local function getCaptionPosition(customEnabled)
		local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
		local yOut = 2
		local yIn = yOut + 8
		local yOffset = if enabled then yIn else yOut
		return UDim2.new(0.5, 0, 1, yOffset)
	end
	local function updatePosition(forcedEnabled)
		
		-- Ignore changes if not enabled to reduce redundant calls
		if not isCompletelyEnabled then
			return
		end
		
		-- Currently the one thing which isn't accounted for are the bounds of the screen
		-- This would be an issue if someone sets a long caption text for the left or
		-- right most icon
		local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
		local startPosition = getCaptionPosition(not enabled)
		local endPosition = getCaptionPosition(enabled)
		
		-- It's essential we reset the carets position to prevent the x sizing bounds
		-- of the caption from infinitely scaling up
		if enabled then
			local caretY = caret.Position.Y.Offset
			caret.Position = UDim2.fromOffset(0, caretY)
			caption.AutomaticSize = Enum.AutomaticSize.XY
			caption.Size = UDim2.fromOffset(32, 53)
		else
			local absolute = caption.AbsoluteSize
			caption.AutomaticSize = Enum.AutomaticSize.Y
			caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end
		
		-- We initially default to the opposite state
		local previousCaretX
		local function updateCaret()
			local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
			local caretY = caret.Position.Y.Offset
			local newCaretPosition = UDim2.fromOffset(caretX, caretY)
			if previousCaretX ~= caretX then
				-- Again, it's essential we reset the caret if
				-- a difference in X position is detected otherwise
				-- a slight quirk with AutomaticCanvas can cause
				-- the caption to infinitely scale
				previousCaretX = caretX
				caret.Position = UDim2.fromOffset(0, caretY)
				task.wait()
			end
			caret.Position = newCaretPosition
		end
		captionClone.Position = startPosition
		updateCaret()
		
		-- Now we tween into the new state
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
		local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
		tween:Play()
		tween.Completed:Once(function()
			updateCaretConnection:Disconnect()
		end)
		
	end
	captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updatePosition()
	end))
	updatePosition(false)
	
	captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
	for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
		updateHotkey(keyCodeEnum)
		break
	end
	captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
	local fakeToggleKey = icon.fakeToggleKey
	if fakeToggleKey then
		updateHotkey(fakeToggleKey)
	end

	local function setCaptionEnabled(enabled)
		if isCompletelyEnabled == enabled then
			return
		end
		local joinedFrame = icon.joinedFrame
		if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
			enabled = false
		end
		isCompletelyEnabled = enabled
		local newTransparency = (enabled and 0) or 1
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tweenTransparency = TweenService:Create(caption, tweenInfo, {
			GroupTransparency = newTransparency
		})
		tweenTransparency:Play()
		if enabled then
			captionClone:SetAttribute("ForceUpdate", true)
		end
		updatePosition()
		updateHotkey()
	end
	
	local WAIT_DURATION = 0.5
	local RECOVER_PERIOD = 0.3
	local Icon = require(icon.iconModule)
	captionJanitor:add(icon.stateChanged:Connect(function(stateName)
		if stateName == "Viewing" then
			local lastClock = Icon.captionLastClosedClock
			local clockDifference = (lastClock and os.clock() - lastClock) or 999
			local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
			task.delay(waitDuration, function()
				if icon.activeState == "Viewing" then
					setCaptionEnabled(true)
				end
			end)
		else
			Icon.captionLastClosedClock = os.clock()
			setCaptionEnabled(false)
		end
	end))
	
	return caption
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX525822840B4E42E3BCAE7AD5ADC9CCB7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Container</string>
										<string name="ScriptGuid">{30966F32-BE94-4366-8E93-0066D097CEAB}</string>
										<ProtectedString name="Source"><![CDATA[local hasBecomeOldTheme = false
local previousInsetHeight = 0
return function(Icon)
	
	-- Has to be included for the time being due to this bug mentioned here:
	-- https://devforum.roblox.com/t/bug/2973508/7
	local GuiService = game:GetService("GuiService")
	local Players =  game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local container = {}
	local Signal = require(script.Parent.Parent.Packages.GoodSignal)
	local insetChanged = Signal.new()
	local guiInset = GuiService:GetGuiInset()
	local startInset = 0
	local yDownOffset = 0
	local ySizeOffset = 0
	local checkCount = 0
	local isConsoleScreen = false
	local isUsingVR = false
	local function checkInset(status)
		local currentHeight = GuiService.TopbarInset.Height
		local isOldTopbar = currentHeight <= 36
		

		-- These additional checks are needed to ensure *it is actually* the old topbar
		-- and not a client which takes a really long time to load
		-- There's unfortunately no APIs to do this a prettier way
		isConsoleScreen = GuiService:IsTenFootInterface()
		isUsingVR = UserInputService.VREnabled
		Icon.isOldTopbar = isOldTopbar
		checkCount += 1
		if currentHeight == 0 and status == nil then
			task.defer(function()
				task.wait(8)
				checkInset("ForceConvertToOld")
			end)
		elseif checkCount == 1 then
			task.delay(5, function()
				local localPlayer = Players.LocalPlayer
				localPlayer:WaitForChild("PlayerGui")
				if checkCount == 1 then
					checkInset()
				end
			end)
		end

		-- Conver to old theme if verified
		if Icon.isOldTopbar and not isConsoleScreen and not isUsingVR and hasBecomeOldTheme == false and (currentHeight ~= 0 or status == "ForceConvertToOld") then
			hasBecomeOldTheme = true
			task.defer(function()
				-- If oldtopbar, apply the Classic theme
				local themes = script.Parent.Parent.Features.Themes
				local Classic = require(themes.Classic)
				Icon.modifyBaseTheme(Classic)

				-- Also configure the oldtopbar correctly
				local function decideToHideTopbar()
					if GuiService.MenuIsOpen then
						Icon.setTopbarEnabled(false, true)
					else
						Icon.setTopbarEnabled()
					end
				end
				GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
				decideToHideTopbar()
			end)
		end

		-- Modify the offsets slightly depending on device type
		guiInset = GuiService:GetGuiInset()
		startInset = if isOldTopbar then 12 else guiInset.Y - 50
		yDownOffset = if isOldTopbar then 2 else 0 --if isOldTopbar then 2 else 0 
		ySizeOffset = -2
		if isConsoleScreen then
			startInset = 10
			yDownOffset = 0 ---9
		end
		if GuiService.TopbarInset.Height == 0 and not hasBecomeOldTheme then
			yDownOffset += 13
			ySizeOffset = 50
		end

		-- Now inform other areas of the change
		insetChanged:Fire(guiInset)
		local insetHeight = guiInset.Y
		if insetHeight ~= previousInsetHeight then
			previousInsetHeight = insetHeight
			task.defer(function()
				Icon.insetHeightChanged:Fire(insetHeight)
			end)
		end
		
	end
	GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(checkInset)
	checkInset("FirstTime")

	local screenGui = Instance.new("ScreenGui")
	insetChanged:Connect(function()
		screenGui:SetAttribute("StartInset", startInset)
	end)
	screenGui.Name = "TopbarStandard"
	screenGui.Enabled = true
	screenGui.DisplayOrder = Icon.baseDisplayOrder
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true
	screenGui.ResetOnSpawn = false
	screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
	container[screenGui.Name] = screenGui
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGui.DisplayOrder = Icon.baseDisplayOrder
	end)

	local holders = Instance.new("Frame")
	holders.Name = "Holders"
	holders.BackgroundTransparency = 1
	insetChanged:Connect(function()
		local holderY = if isUsingVR then 36 else 56
		local holderSize = if isConsoleScreen then UDim2.new(1, 0, 0, holderY) else UDim2.new(1, 0, 1, ySizeOffset)
		holders.Position = UDim2.new(0, 0, 0, yDownOffset)
		holders.Size = holderSize
	end)
	holders.Visible = true
	holders.ZIndex = 1
	holders.Parent = screenGui
	
	local screenGuiCenter = screenGui:Clone()
	local holdersCenter = screenGuiCenter.Holders
	local function updateCenteredHoldersHeight()
		holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
	end
	screenGuiCenter.Name = "TopbarCentered"
	screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	end)
	container[screenGuiCenter.Name] = screenGuiCenter
	
	insetChanged:Connect(updateCenteredHoldersHeight)
	updateCenteredHoldersHeight()
	
	local screenGuiClipped = screenGui:Clone()
	screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
	screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	end)
	container[screenGuiClipped.Name] = screenGuiClipped
	
	local screenGuiCenterClipped = screenGuiCenter:Clone()
	screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
	screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	end)
	container[screenGuiCenterClipped.Name] = screenGuiCenterClipped
	
	local holderReduction = -24
	local left = Instance.new("ScrollingFrame")
	left:SetAttribute("IsAHolder", true)
	left.Name = "Left"
	insetChanged:Connect(function()
		left.Position = UDim2.fromOffset(startInset, 0)
	end)
	left.Size = UDim2.new(1, holderReduction, 1, 0)
	left.BackgroundTransparency = 1
	left.Visible = true
	left.ZIndex = 1
	left.Active = false
	left.ClipsDescendants = true
	left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
	left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	left.AutomaticCanvasSize = Enum.AutomaticSize.X
	left.ScrollingDirection = Enum.ScrollingDirection.X
	left.ScrollBarThickness = 0
	left.BorderSizePixel = 0
	left.Selectable = false
	left.ScrollingEnabled = false--true
	left.ElasticBehavior = Enum.ElasticBehavior.Never
	left.Parent = holders
	
	local UIListLayout = Instance.new("UIListLayout")
	insetChanged:Connect(function()
		UIListLayout.Padding = UDim.new(0, startInset)
	end)
	UIListLayout.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	UIListLayout.Parent = left
	
	local center = left:Clone()
	insetChanged:Connect(function()
		center.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	center.ScrollingEnabled = false
	center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	center.Name = "Center"
	center.Parent = holdersCenter
	
	local right = left:Clone()
	insetChanged:Connect(function()
		right.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	right.Name = "Right"
	right.AnchorPoint = Vector2.new(1, 0)
	right.Position = UDim2.new(1, -12, 0, 0)
	right.Parent = holders

	-- This is important so that all elements update instantly
	insetChanged:Fire(guiInset)

	return container
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX09F500B0B8554088BC3AFCAE81CFABF4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Indicator</string>
										<string name="ScriptGuid">{D116B6CA-9B39-4434-886B-054A43B84FEA}</string>
										<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local widget = icon.widget
	local contents = icon:getInstance("Contents")
	local indicator = Instance.new("Frame")
	indicator.Name = "Indicator"
	indicator.LayoutOrder = 9999999
	indicator.ZIndex = 6
	indicator.Size = UDim2.new(0, 42, 0, 42)
	indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicator.BackgroundTransparency = 1
	indicator.Position = UDim2.new(1, 0, 0.5, 0)
	indicator.BorderSizePixel = 0
	indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicator.Parent = contents

	local indicatorButton = Instance.new("Frame")
	indicatorButton.Name = "IndicatorButton"
	indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
	indicatorButton.BorderSizePixel = 0
	indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.Parent = indicator
	
	local GuiService = game:GetService("GuiService")
	local GamepadService = game:GetService("GamepadService")
	local ourClickRegion = icon:getInstance("ClickRegion")
	local function selectionChanged()
		local selectedClickRegion = GuiService.SelectedObject
		if selectedClickRegion == ourClickRegion then
			indicatorButton.BackgroundTransparency = 1
			indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
		else
			indicatorButton.BackgroundTransparency = 0.75
			indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1, 1)
		end
	end
	icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
	selectionChanged()

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.LayoutOrder = 2
	imageLabel.ZIndex = 15
	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.Image = "rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png"
	imageLabel.Parent = indicatorButton

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = indicatorButton

	local UserInputService = game:GetService("UserInputService")
	local function setIndicatorVisible(visibility)
		if visibility == nil then
			visibility = indicator.Visible
		end
		if GamepadService.GamepadCursorEnabled then
			visibility = false
		end
		if visibility then
			icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
		elseif indicator.Visible then
			icon:removeModification("IndicatorPadding")
		end
		icon:modifyTheme({"Indicator", "Visible", visibility})
		icon.updateSize:Fire()
	end
	icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
	icon.indicatorSet:Connect(function(keyCode)
		local visibility = false
		if keyCode then
			imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
			visibility = true
		end
		setIndicatorVisible(visibility)
	end)

	local function updateSize()
		local ySize = widget.AbsoluteSize.Y*0.96
		indicator.Size = UDim2.new(0, ySize, 0, ySize)
	end
	widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
	updateSize()

	return indicator
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXEDEAB64768C748C4B9E95EBC027F0940">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Menu</string>
										<string name="ScriptGuid">{1EF97056-C0AC-47DD-B128-9A1AD93B3D54}</string>
										<ProtectedString name="Source"><![CDATA[return function(icon)

	local menu = Instance.new("ScrollingFrame")
	menu.Name = "Menu"
	menu.BackgroundTransparency = 1
	menu.Visible = true
	menu.ZIndex = 1
	menu.Size = UDim2.fromScale(1, 1)
	menu.ClipsDescendants = true
	menu.TopImage = ""
	menu.BottomImage = ""
	menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
	menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	menu.ScrollingEnabled = true
	menu.ScrollingDirection = Enum.ScrollingDirection.X
	menu.ZIndex = 20
	menu.ScrollBarThickness = 3
	menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	menu.ScrollBarImageTransparency = 0.8
	menu.BorderSizePixel = 0
	menu.Selectable = false
	
	local Icon = require(icon.iconModule)
	local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
	menuUIListLayout.Name = "MenuUIListLayout"
	menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	menuUIListLayout.Parent = menu

	local menuGap = Instance.new("Frame")
	menuGap.Name = "MenuGap"
	menuGap.BackgroundTransparency = 1
	menuGap.Visible = false
	menuGap.AnchorPoint = Vector2.new(0, 0.5)
	menuGap.ZIndex = 5
	menuGap.Parent = menu
	
	local hasStartedMenu = false
	local Themes = require(script.Parent.Parent.Features.Themes)
	local function totalChildrenChanged()
		
		local menuJanitor = icon.menuJanitor
		local totalIcons = #icon.menuIcons
		if hasStartedMenu then
			if totalIcons <= 0 then
				menuJanitor:clean()
				hasStartedMenu = false
			end
			return
		end
		hasStartedMenu = true
		
		-- Listen for changes
		menuJanitor:add(icon.toggled:Connect(function()
			if #icon.menuIcons > 0 then
				icon.updateSize:Fire()
			end
		end))
		
		-- Modify appearance of menu icon when joined
		local _, modificationUID = icon:modifyTheme({
			{"Menu", "Active", true},
		})
		task.defer(function()
			menuJanitor:add(function()
				icon:removeModification(modificationUID)
			end)
		end)
		
		-- For right-aligned icons, this ensures their menus
		-- close button appear instantly when selected (instead
		-- of partially hidden from view)
		local previousCanvasX = menu.AbsoluteCanvasSize.X
		local function rightAlignCanvas()
			if icon.alignment == "Right" then
				local newCanvasX = menu.AbsoluteCanvasSize.X
				local difference = previousCanvasX - newCanvasX
				previousCanvasX = newCanvasX
				menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
			end
		end
		menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
		menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))
		
		-- Apply a close selected image if the user hasn't applied thier own
		local stateGroup = icon:getStateGroup()
		local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
		local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
		if imageDeselected == imageSelected then
			local fontLink = "rbxasset://fonts/families/FredokaOne.json"
			local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
			icon:removeModificationWith("IconLabel", "Text", "Viewing")
			icon:removeModificationWith("IconLabel", "Image", "Viewing")
			icon:modifyTheme({
				{"IconLabel", "FontFace", fontFace, "Selected"},
				{"IconLabel", "Text", "X", "Selected"},
				{"IconLabel", "TextSize", 20, "Selected"},
				{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
				{"IconImage", "Image", "", "Selected"},
			})
		end

		-- Change order of spot when alignment changes
		local menuGap = icon:getInstance("MenuGap")
		local function updateAlignent()
			local alignment = icon.alignment
			local spotIndex = -99999
			local gapIndex = -99998
			if alignment == "Right" then
				spotIndex = 99999
				gapIndex = 99998
			end
			icon:modifyTheme({"IconSpot", "LayoutOrder", spotIndex})
			menuGap.LayoutOrder = gapIndex
		end
		menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
		updateAlignent()
		
		-- This updates the scrolling frame to only display a scroll
		-- length equal to the distance produced by its MaxIcons
		menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
			local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
			local canvasY = menu.CanvasSize.Y
			menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
		end)
		menuJanitor:add(icon.updateMenu:Connect(function()
			local maxIcons = menu:GetAttribute("MaxIcons")
			if not maxIcons then
				return
			end
			local orderedInstances = {}
			for _, child in pairs(menu:GetChildren()) do
				local widgetUID = child:GetAttribute("WidgetUID")
				if widgetUID and child.Visible then
					table.insert(orderedInstances, {child, child.AbsolutePosition.X})
				end
			end
			table.sort(orderedInstances, function(groupA, groupB)
				return groupA[2] < groupB[2]
			end)
			local totalWidth = 0
			for i = 1, maxIcons do
				local group = orderedInstances[i]
				if not group then
					break
				end
				local child = group[1]
				local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
				totalWidth += width
			end
			menu:SetAttribute("MenuWidth", totalWidth)
		end))
		local function startMenuUpdate()
			task.delay(0.1, function()
				icon.startMenuUpdate:Fire()
			end)
		end
		menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
		menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
		startMenuUpdate()
	end
	
	icon.menuChildAdded:Connect(totalChildrenChanged)
	icon.menuSet:Connect(function(arrayOfIcons)
		-- Reset any previous icons
		for i, otherIconUID in pairs(icon.menuIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Apply new icons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinMenu(icon)
			end
		end
	end)
	
	return menu
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXAC13DA15206D4730A95E9BB6494BA5F8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Notice</string>
										<string name="ScriptGuid">{A148C372-4966-4C73-9532-458CD8E8661F}</string>
										<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local notice = Instance.new("Frame")
	notice.Name = "Notice"
	notice.ZIndex = 25
	notice.AutomaticSize = Enum.AutomaticSize.X
	notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
	notice.BorderSizePixel = 0
	notice.BackgroundTransparency = 0.1
	notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	notice.Visible = false
	notice.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = notice

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Parent = notice

	local noticeLabel = Instance.new("TextLabel")
	noticeLabel.Name = "NoticeLabel"
	noticeLabel.ZIndex = 26
	noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	noticeLabel.AutomaticSize = Enum.AutomaticSize.X
	noticeLabel.Size = UDim2.new(1, 0, 1, 0)
	noticeLabel.BackgroundTransparency = 1
	noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
	noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.FontSize = Enum.FontSize.Size14
	noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.Text = "1"
	noticeLabel.TextWrapped = true
	noticeLabel.TextWrap = true
	noticeLabel.Font = Enum.Font.Arial
	noticeLabel.Parent = notice
	
	local iconModule = script.Parent.Parent
	local packages = iconModule.Packages
	local Janitor = require(packages.Janitor)
	local Signal = require(packages.GoodSignal)
	local Utility = require(iconModule.Utility)
	icon.noticeChanged:Connect(function(totalNotices)

		-- Notice amount
		if not totalNotices then
			return
		end
		local exceeded99 = totalNotices > 99
		local noticeDisplay = (exceeded99 and "99+") or totalNotices
		noticeLabel.Text = noticeDisplay
		if exceeded99 then
			noticeLabel.TextSize = 11
		end

		-- Should enable
		local enabled = true
		if totalNotices < 1 then
			enabled = false
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
		if icon.isSelected and dropdownOrMenuActive then
			enabled = false
		elseif parentIcon and not parentIcon.isSelected then
			enabled = false
		end
		Utility.setVisible(notice, enabled, "NoticeHandler")

	end)
	icon.noticeStarted:Connect(function(customClearSignal, noticeId)
	
		if not customClearSignal then
			customClearSignal = icon.deselected
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		if parentIcon then
			parentIcon:notify(customClearSignal)
		end
		
		local noticeJanitor = icon.janitor:add(Janitor.new())
		local noticeComplete = noticeJanitor:add(Signal.new())
		noticeJanitor:add(icon.endNotices:Connect(function()
			noticeComplete:Fire()
		end))
		noticeJanitor:add(customClearSignal:Connect(function()
			noticeComplete:Fire()
		end))
		noticeId = noticeId or Utility.generateUID()
		icon.notices[noticeId] = {
			completeSignal = noticeComplete,
			clearNoticeEvent = customClearSignal,
		}
		local function updateNotice()
			icon.noticeChanged:Fire(icon.totalNotices)
		end
		icon.notified:Fire(noticeId)
		icon.totalNotices += 1
		updateNotice()
		noticeComplete:Once(function()
			noticeJanitor:destroy()
			icon.totalNotices -= 1
			icon.notices[noticeId] = nil
			updateNotice()
		end)
	end)
	
	-- Establish the notice
	notice:SetAttribute("ClipToJoinedParent", true)
	icon:clipOutside(notice)
	
	return notice
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX177491BBC45A4C63836B9FB4E2D3D738">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Selection</string>
										<string name="ScriptGuid">{472FEA02-747F-4C47-8A57-8386B217F885}</string>
										<ProtectedString name="Source"><![CDATA[return function(Icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local selectionContainer = Instance.new("Frame")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Visible = false
	
	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	selection.BackgroundTransparency = 1
	selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
	selection.BorderSizePixel = 0
	selection.Parent = selectionContainer

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Name = "UIStroke"
	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	UIStroke.Color = Color3.fromRGB(255, 255, 255)
	UIStroke.Thickness = 3
	UIStroke.Parent = selection

	local selectionGradient = Instance.new("UIGradient")
	selectionGradient.Name = "SelectionGradient"
	selectionGradient.Parent = UIStroke

	local UICorner = Instance.new("UICorner")
	UICorner:SetAttribute("Collective", "IconCorners")
	UICorner.Name = "UICorner"
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = selection
	
	local RunService = game:GetService("RunService")
	local GuiService = game:GetService("GuiService")
	local rotationSpeed = 1
	selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
		rotationSpeed = selection:GetAttribute("RotationSpeed")
	end)
	RunService.Heartbeat:Connect(function()
		if not GuiService.SelectedObject then
			return
		end
		selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
	end)

	return selectionContainer
	
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXFF1BD3CB016C4F6DB148F921ECEDD7B7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Widget</string>
										<string name="ScriptGuid">{07860B1F-E48F-4EE4-91A9-254E50E329DB}</string>
										<ProtectedString name="Source"><![CDATA[-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
-- the icon (aka Widget) instance.
-- This contains the core components of the icon such as the button, image, label and notice. It's
-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)

return function(icon, Icon)

	local widget = Instance.new("Frame")
	widget:SetAttribute("WidgetUID", icon.UID)
	widget.Name = "Widget"
	widget.BackgroundTransparency = 1
	widget.Visible = true
	widget.ZIndex = 20
	widget.Active = false
	widget.ClipsDescendants = true

	local button = Instance.new("Frame")
	button.Name = "IconButton"
	button.Visible = true
	button.ZIndex = 2
	button.BorderSizePixel = 0
	button.Parent = widget
	button.ClipsDescendants = true
	button.Active = false -- This is essential for mobile scrollers to work when dragging
	icon.deselected:Connect(function()
		button.ClipsDescendants = true
		task.delay(0.2, function()
			if icon.isSelected then
				button.ClipsDescendants = false
			end
		end)
	end)

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("IconButton", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(button, "BackgroundTransparency")
	end))

	local iconCorner = Instance.new("UICorner")
	iconCorner:SetAttribute("Collective", "IconCorners")
	iconCorner.Name = "UICorner"
	iconCorner.Parent = button

	local menu = require(script.Parent.Menu)(icon)
	local menuUIListLayout = menu.MenuUIListLayout
	local menuGap = menu.MenuGap
	menu.Parent = button

	local iconSpot = Instance.new("Frame")
	iconSpot.Name = "IconSpot"
	iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
	iconSpot.BackgroundTransparency = 0.9
	iconSpot.Visible = true
	iconSpot.AnchorPoint = Vector2.new(0, 0.5)
	iconSpot.ZIndex = 5
	iconSpot.Parent = menu

	local iconSpotCorner = iconCorner:Clone()
	iconSpotCorner.Parent = iconSpot

	local overlay = iconSpot:Clone()
	overlay.UICorner.Name = "OverlayUICorner"
	overlay.Name = "IconOverlay"
	overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	overlay.ZIndex = iconSpot.ZIndex + 1
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.AnchorPoint = Vector2.new(0, 0)
	overlay.Visible = false
	overlay.Parent = iconSpot

	local clickRegion = Instance.new("TextButton")
	clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
	clickRegion.Name = "ClickRegion"
	clickRegion.BackgroundTransparency = 1
	clickRegion.Visible = true
	clickRegion.Text = ""
	clickRegion.ZIndex = 20
	clickRegion.Selectable = true
	clickRegion.SelectionGroup = true
	clickRegion.Parent = iconSpot
	
	local Gamepad = require(script.Parent.Parent.Features.Gamepad)
	Gamepad.registerButton(clickRegion)

	local clickRegionCorner = iconCorner:Clone()
	clickRegionCorner.Parent = clickRegion

	local contents = Instance.new("Frame")
	contents.Name = "Contents"
	contents.BackgroundTransparency = 1
	contents.Size = UDim2.fromScale(1, 1)
	contents.Parent = iconSpot

	local contentsList = Instance.new("UIListLayout")
	contentsList.Name = "ContentsList"
	contentsList.FillDirection = Enum.FillDirection.Horizontal
	contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
	contentsList.SortOrder = Enum.SortOrder.LayoutOrder
	contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
	contentsList.Padding = UDim.new(0, 3)
	contentsList.Parent = contents

	local paddingLeft = Instance.new("Frame")
	paddingLeft.Name = "PaddingLeft"
	paddingLeft.LayoutOrder = 1
	paddingLeft.ZIndex = 5
	paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingLeft.BackgroundTransparency = 1
	paddingLeft.BorderSizePixel = 0
	paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingLeft.Parent = contents

	local paddingCenter = Instance.new("Frame")
	paddingCenter.Name = "PaddingCenter"
	paddingCenter.LayoutOrder = 3
	paddingCenter.ZIndex = 5
	paddingCenter.Size = UDim2.new(0, 0, 1, 0)
	paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingCenter.BackgroundTransparency = 1
	paddingCenter.BorderSizePixel = 0
	paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingCenter.Parent = contents

	local paddingRight = Instance.new("Frame")
	paddingRight.Name = "PaddingRight"
	paddingRight.LayoutOrder = 5
	paddingRight.ZIndex = 5
	paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingRight.BackgroundTransparency = 1
	paddingRight.BorderSizePixel = 0
	paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingRight.Parent = contents

	local iconLabelContainer = Instance.new("Frame")
	iconLabelContainer.Name = "IconLabelContainer"
	iconLabelContainer.LayoutOrder = 4
	iconLabelContainer.ZIndex = 3
	iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
	iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
	iconLabelContainer.BackgroundTransparency = 1
	iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	iconLabelContainer.Parent = contents

	local iconLabel = Instance.new("TextLabel")
	local viewportX = workspace.CurrentCamera.ViewportSize.X+200
	iconLabel.Name = "IconLabel"
	iconLabel.LayoutOrder = 4
	iconLabel.ZIndex = 15
	iconLabel.AnchorPoint = Vector2.new(0, 0)
	iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
	iconLabel.ClipsDescendants = false
	iconLabel.BackgroundTransparency = 1
	iconLabel.Position = UDim2.fromScale(0, 0)
	iconLabel.RichText = true
	iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
	iconLabel.Text = ""
	iconLabel.TextWrapped = true
	iconLabel.TextWrap = true
	iconLabel.TextScaled = false
	iconLabel.Active = false
	iconLabel.AutoLocalize = true
	iconLabel.Parent = iconLabelContainer

	local iconImage = Instance.new("ImageLabel")
	iconImage.Name = "IconImage"
	iconImage.LayoutOrder = 2
	iconImage.ZIndex = 15
	iconImage.AnchorPoint = Vector2.new(0, 0.5)
	iconImage.Size = UDim2.new(0, 0, 0.5, 0)
	iconImage.BackgroundTransparency = 1
	iconImage.Position = UDim2.new(0, 11, 0.5, 0)
	iconImage.ScaleType = Enum.ScaleType.Stretch
	iconImage.Active = false
	iconImage.Parent = contents

	local iconImageCorner = iconCorner:Clone()
	iconImageCorner:SetAttribute("Collective", nil)
	iconImageCorner.CornerRadius = UDim.new(0, 0)
	iconImageCorner.Name = "IconImageCorner"
	iconImageCorner.Parent = iconImage

	local TweenService = game:GetService("TweenService")
	local resizingCount = 0
	local function handleLabelAndImageChangesUnstaggered(forceUpdateString)

		-- We defer changes by a frame to eliminate all but 1 requests which
		-- could otherwise stack up to 20+ requests in a single frame
		-- We then repeat again once to account for any final changes
		-- Deferring is also essential because properties are set immediately
		-- afterwards (therefore calculations will use the correct values)
		task.defer(function()
			local indicator = icon.indicator
			local usingIndicator = indicator and indicator.Visible
			local usingText = usingIndicator or iconLabel.Text ~= ""
			local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
			local _alignment = Enum.HorizontalAlignment.Center
			local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
			local buttonSize = NORMAL_BUTTON_SIZE
			if usingImage and not usingText then
				iconLabelContainer.Visible = false
				iconImage.Visible = true
				paddingLeft.Visible = false
				paddingCenter.Visible = false
				paddingRight.Visible = false
			elseif not usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = false
				paddingLeft.Visible = true
				paddingCenter.Visible = false
				paddingRight.Visible = true
			elseif usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = true
				paddingLeft.Visible = true
				paddingCenter.Visible = not usingIndicator
				paddingRight.Visible = not usingIndicator
				_alignment = Enum.HorizontalAlignment.Left
			end
			button.Size = buttonSize

			local function getItemWidth(item)
				local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
				return targetWidth
			end
			local contentsPadding = contentsList.Padding.Offset
			local initialWidgetWidth = contentsPadding --0
			local textWidth = iconLabel.TextBounds.X
			iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
			for _, child in pairs(contents:GetChildren()) do
				if child:IsA("GuiObject") and child.Visible == true then
					local itemWidth = getItemWidth(child)
					initialWidgetWidth += itemWidth + contentsPadding
				end
			end
			local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
			local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
			local widgetBorderSize = widget:GetAttribute("BorderSize")
			local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
			local menuIcons = icon.menuIcons
			local additionalWidth = 0
			local hasMenu = #menuIcons > 0
			local showMenu = hasMenu and icon.isSelected
			if showMenu then
				for _, frame in pairs(menu:GetChildren()) do
					if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
						additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
					end
				end
				if not iconSpot.Visible then
					widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
				end
				additionalWidth -= (widgetBorderSize*0.5)
				widgetWidth += additionalWidth - (widgetBorderSize*0.75)
			end
			menuGap.Visible = showMenu and iconSpot.Visible
			local desiredWidth = widget:GetAttribute("DesiredWidth")
			if desiredWidth and widgetWidth < desiredWidth then
				widgetWidth = desiredWidth
			end

			icon.updateMenu:Fire()
			local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
			local spotWidth = preWidth-(widgetBorderSize*2)
			local menuWidth = menu:GetAttribute("MenuWidth")
			local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
			if totalMenuWidth then
				local maxWidth = menu:GetAttribute("MaxWidth")
				if maxWidth then
					totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
				end
				menu:SetAttribute("MenuCanvasWidth", widgetWidth)
				if totalMenuWidth < widgetWidth then
					widgetWidth = totalMenuWidth
				end
			end

			local style = Enum.EasingStyle.Quint
			local direction = Enum.EasingDirection.Out
			local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
			local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
			local SPEED = 750
			local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
			local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
			TweenService:Create(iconSpot, spotTweenInfo, {
				Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
				Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
			}):Play()
			TweenService:Create(clickRegion, spotTweenInfo, {
				Size = UDim2.new(0, spotWidth, 1, 0),
			}):Play()
			local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
			local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
			if updateInstantly then
				widget.Size = newWidgetSize
			end
			widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
			local movingTween = TweenService:Create(widget, widgetTweenInfo, {
				Size = newWidgetSize,
			})
			movingTween:Play()
			resizingCount += 1
			for i = 1, widgetTweenInfo.Time * 100 do
				task.delay(i/100, function()
					Icon.iconChanged:Fire(icon)
				end)
			end
			task.delay(widgetTweenInfo.Time-0.2, function()
				resizingCount -= 1
				task.defer(function()
					if resizingCount == 0 then
						icon.resizingComplete:Fire()
					end
				end)
			end)
			icon:updateParent()
		end)
	end
	local Utility = require(script.Parent.Parent.Utility)
	local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
	local firstTimeSettingFontFace = true
	icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
	icon:setBehaviour("IconLabel", "FontFace", function(value)
		local previousFontFace = iconLabel.FontFace
		if previousFontFace == value then
			return
		end
		task.spawn(function()
			--[[
			local fontLink = value.Family
			if string.match(fontLink, "rbxassetid://") then
				local ContentProvider = game:GetService("ContentProvider")
				local assets = {fontLink}
				ContentProvider:PreloadAsync(assets)
			end--]]

			-- Afaik there's no way to determine when a Font Family has
			-- loaded (even with ContentProvider), so we just have to try
			-- a few times and hope it loads within the refresh period
			handleLabelAndImageChanges()
			if firstTimeSettingFontFace then
				firstTimeSettingFontFace = false
				for i = 1, 10 do
					task.wait(1)
					handleLabelAndImageChanges()
				end
			end
		end)
	end)
	local function updateBorderSize()
		task.defer(function()
			local borderOffset = widget:GetAttribute("BorderSize")
			local alignment = icon.alignment
			local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
			menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
			menuGap.Size = UDim2.fromOffset(borderOffset, 0)
			menuUIListLayout.Padding = UDim.new(0, 0)
			handleLabelAndImageChanges()
		end)
	end
	icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
	icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
	icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
	icon.updateSize:Connect(handleLabelAndImageChanges)
	icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
	icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
	icon:setBehaviour("IconImage", "Image", function(value)
		local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
		if iconImage.Image ~= textureId then
			handleLabelAndImageChanges()
		end
		return textureId
	end)
	icon.alignmentChanged:Connect(function(newAlignment)
		if newAlignment == "Center" then
			newAlignment = "Left"
		end
		menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
		updateBorderSize()
	end)

	-- Localization support (refresh icon size whenever player changes language changes in-game)
	local Players = game:GetService("Players")
	local localPlayer = Players.LocalPlayer
	local lastLocaleId = localPlayer.LocaleId
	icon.janitor:add(localPlayer:GetPropertyChangedSignal("LocaleId"):Connect(function()
		task.delay(0.2, function()
			local newLocaleId = localPlayer.LocaleId
			if newLocaleId ~= lastLocaleId then
				lastLocaleId = newLocaleId
				icon:refresh()
				task.wait(0.5)
				icon:refresh()
			end
		end)
	end))
	
	local iconImageScale = Instance.new("NumberValue")
	iconImageScale.Name = "IconImageScale"
	iconImageScale.Parent = iconImage
	iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
		iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
	end)

	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
	UIAspectRatioConstraint.Name = "IconImageRatio"
	UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
	UIAspectRatioConstraint.Parent = iconImage

	local iconGradient = Instance.new("UIGradient")
	iconGradient.Name = "IconGradient"
	iconGradient.Enabled = true
	iconGradient.Parent = button

	local iconSpotGradient = Instance.new("UIGradient")
	iconSpotGradient.Name = "IconSpotGradient"
	iconSpotGradient.Enabled = true
	iconSpotGradient.Parent = iconSpot

	return widget
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXA5705E205A7441DF82D407ABA2DE6319">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Dropdown</string>
										<string name="ScriptGuid">{4A646599-B1C3-42F1-BEED-5FC90567620B}</string>
										<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Themes = require(script.Parent.Parent.Features.Themes)
local PADDING = 0 -- used to be 8
return function(icon)
	
	local dropdown = Instance.new("Frame") -- Instance.new("CanvasGroup")
	dropdown.Name = "Dropdown"
	dropdown.AutomaticSize = Enum.AutomaticSize.X
	dropdown.BackgroundTransparency = 1
	dropdown.BorderSizePixel = 0
	dropdown.AnchorPoint = Vector2.new(0.5, 0)
	dropdown.Position = UDim2.new(0.5, 0, 1, 10)
	dropdown.ZIndex = -2
	dropdown.ClipsDescendants = true
	dropdown.Parent = icon.widget

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("Dropdown", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(dropdown, "BackgroundTransparency")
	end))

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "DropdownCorner"
	UICorner.CornerRadius = UDim.new(0, 10)
	UICorner.Parent = dropdown

	local dropdownScroller = Instance.new("ScrollingFrame")
	dropdownScroller.Name = "DropdownScroller"
	dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
	dropdownScroller.BackgroundTransparency = 1
	dropdownScroller.BorderSizePixel = 0
	dropdownScroller.AnchorPoint = Vector2.new(0, 0)
	dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
	dropdownScroller.ZIndex = -1
	dropdownScroller.ClipsDescendants = true
	dropdownScroller.Visible = true
	dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.None --ScrollBar
	dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
	dropdownScroller.Active = false
	dropdownScroller.ScrollingEnabled = true
	dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
	dropdownScroller.ScrollBarThickness = 5
	dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	dropdownScroller.ScrollBarImageTransparency = 0.8
	dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	dropdownScroller.Selectable = false
	dropdownScroller.Active = true
	dropdownScroller.Parent = dropdown

	local TweenDuration = Instance.new("NumberValue") -- this helps to change the speed to open / close in modifyTheme()
	TweenDuration.Name = "DropdownSpeed"
	TweenDuration.Value = 0.07
	TweenDuration.Parent = dropdown

	local dropdownPadding = Instance.new("UIPadding")
	dropdownPadding.Name = "DropdownPadding"
	dropdownPadding.PaddingTop = UDim.new(0, PADDING)
	dropdownPadding.PaddingBottom = UDim.new(0, PADDING)
	dropdownPadding.Parent = dropdownScroller

	local dropdownList = Instance.new("UIListLayout")
	dropdownList.Name = "DropdownList"
	dropdownList.FillDirection = Enum.FillDirection.Vertical
	dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
	dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
	dropdownList.Parent = dropdownScroller

	local dropdownJanitor = icon.dropdownJanitor
	local Icon = require(icon.iconModule)
	icon.dropdownChildAdded:Connect(function(childIcon)
		local _, modificationUID = childIcon:modifyTheme({
			{"Widget", "BorderSize", 0},
			{"IconCorners", "CornerRadius", UDim.new(0, 10)},
			{"Widget", "MinimumWidth", 190},
			{"Widget", "MinimumHeight", 58},
			{"IconLabel", "TextSize", 20},
			{"IconOverlay", "Size", UDim2.new(1, 0, 1, 0)},
			{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
			{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
			{"Selection", "Size", UDim2.new(1, -PADDING, 1, -PADDING)},
			{"Selection", "Position", UDim2.new(0, PADDING/2, 0, PADDING/2)},
		})
		task.defer(function()
			childIcon.joinJanitor:add(function()
				childIcon:removeModification(modificationUID)
			end)
		end)
	end)
	icon.dropdownSet:Connect(function(arrayOfIcons)
		for i, otherIconUID in pairs(icon.dropdownIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinDropdown(icon)
			end
		end
	end)

	local function updateMaxIcons()
		--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return 0 end
		local children = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(children, child)
			end
		end

		table.sort(children, function(a, b) return a.AbsolutePosition.Y < b.AbsolutePosition.Y end)
		local totalHeight = 0
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local child = children[i]
			if not child then break end
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height *= (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset
		return totalHeight
	end
	
	local openTween = nil
	local closeTween = nil
	local currentSpeedMultiplier = nil
	local currentTweenInfo = nil
	local function getTweenInfo()
		local speedMultiplier = Themes.getInstanceValue(dropdown, "MaxIcons") or 1
		if currentSpeedMultiplier and currentSpeedMultiplier == speedMultiplier and currentTweenInfo then
			return currentTweenInfo
		end
		local newTweenInfo = TweenInfo.new(
			TweenDuration.Value * speedMultiplier,
			Enum.EasingStyle.Exponential,
			Enum.EasingDirection.Out
		)
		currentTweenInfo = newTweenInfo
		currentSpeedMultiplier = speedMultiplier
		return newTweenInfo
	end
	local function updateVisibility()
		-- Update visibiliy of dropdown using tween transition
		local tweenInfo = getTweenInfo()
		
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end

		if icon.isSelected then
			local height = updateMaxIcons()
			dropdown.Visible = true
			dropdown.BackgroundTransparency = 0 -- no transparency so it looks solid
			dropdown.Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0) -- reset height to 0 before tween

			openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
			openTween:Play()
			openTween.Completed:Connect(function()
				openTween = nil
			end)
		else
			local closeTweenInfo = TweenInfo.new(0)
			closeTween = TweenService:Create(dropdown, closeTweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0)})
			closeTween:Play()
			closeTween.Completed:Connect(function()
				closeTween = nil
			end)
		end
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
	updateVisibility()
	--task.delay(0.2, updateVisibility)

	local function updateChildSize()
		local tweenInfo = getTweenInfo()
		if not icon.isSelected then return end
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end
		
		RunService.Heartbeat:Wait()
		
		local height = updateMaxIcons()

		openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
		openTween:Play()
		openTween.Completed:Connect(function()	
			openTween = nil
		end)
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))

	-- Ensures canvas and size stay synced (original updateMaxIcons logic)
	local updateCount = 0
	local isUpdating = false

	-- This updates the scrolling frame to only display a scroll
	-- length equal to the distance produced by its MaxIcons
	local function updateMaxIconsListener()
		updateCount += 1
		if isUpdating then return end
		local myUpdateCount = updateCount
		isUpdating = true
		task.defer(function()
			isUpdating = false
			if updateCount ~= myUpdateCount then
				updateMaxIconsListener()
			end
		end)
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return end

		local orderedInstances = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
			end
		end
		table.sort(orderedInstances, function(a, b) return a[2] < b[2] end)

		local totalHeight = 0
		local hasSetNextSelection = false
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local group = orderedInstances[i]
			if not group then break end
			local child = group[1]
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height = height * (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
			if isReduced then
				continue
			end
			local iconUID = child:GetAttribute("WidgetUID")
			local childIcon = iconUID and Icon.getIconByUID(iconUID)
			if childIcon then
				local nextSelection = nil
				if not hasSetNextSelection then
					hasSetNextSelection = true
					nextSelection = icon:getInstance("ClickRegion")
				end
				childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
			end
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset

		dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)

	end

	dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateChildSize)) -- rezise the dropdown when icon delects or adds
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateChildSize))
	dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIconsListener))
	updateMaxIconsListener()

	-- Ensures each child listens to visibility changes
	local function connectVisibilityListeners(child)
		if child:IsA("GuiObject") then
			child:GetPropertyChangedSignal("Visible"):Connect(updateChildSize)
			child:GetPropertyChangedSignal("Size"):Connect(updateChildSize) -- -- update max icons when child size changes
		end
	end
	
	-- For existing children
	for _, child in pairs(dropdownScroller:GetChildren()) do
		connectVisibilityListeners(child)
	end
	-- For new children
	dropdownScroller.ChildAdded:Connect(function(child)
		RunService.Heartbeat:Wait()
		connectVisibilityListeners(child)
		updateChildSize()
	end)

	-- On start, hide dropdown (prevent it showing as opened)
	dropdown.Visible = false

	return dropdown
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXD605504119584118835250867C1C3FB3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Features</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXA3C8A055AB754BA5BAE8E58282BE2108">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Gamepad</string>
										<string name="ScriptGuid">{0CD02B9F-75AB-4FA0-A36A-813B6DE3A35C}</string>
										<ProtectedString name="Source"><![CDATA[-- As the name suggests, this handles everything related to gamepads
-- (i.e. Xbox or Playstation controllers) and their navigation
-- I created a separate module for gamepads (and not touchpads or
-- keyboards) because gamepads are greatly more unqiue and require
-- additional tailored programming



-- SERVICES
local GamepadService = game:GetService("GamepadService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")



-- LOCAL
local DEFAULT_HIGHLIGHT_KEY = Enum.KeyCode.DPadUp -- The default key to highlight the topbar icon
local GAMEPAD_INPUT = Enum.PreferredInput.Gamepad
local Gamepad = {}
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Gamepad.start(incomingIcon)
	
	-- Public variables
	Icon = incomingIcon
	Icon.highlightKey = if Icon.highlightKey ~= nil then Icon.highlightKey else DEFAULT_HIGHLIGHT_KEY -- What controller key to highlight the topbar (or set to false to disable)
	Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most
	
	-- We defer so the developer can make changes before the
	-- gamepad controls are initialized
	task.delay(1, function()
		-- Some local utility
		local iconsDict = Icon.iconsDictionary
		local function getIconFromSelectedObject()
			local clickRegion = GuiService.SelectedObject
			local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
			local icon = iconUID and iconsDict[iconUID]
			return icon
		end
		
		-- This enables users to instantly open up their last selected icon
		local previousHighlightedIcon
		local usedIndicatorOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local usedBOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local Selection = require(script.Parent.Parent.Elements.Selection)
		local function updateSelectedObject()
			local icon = getIconFromSelectedObject()
			local isUsingGamepad = UserInputService.PreferredInput == GAMEPAD_INPUT
			if icon then
				if isUsingGamepad then
					local clickRegion = icon:getInstance("ClickRegion")
					local selection = icon.selection
					if not selection then
						selection = icon.janitor:add(Selection(Icon))
						selection:SetAttribute("IgnoreVisibilityUpdater", true)
						selection.Parent = icon.widget
						icon.selection = selection
						icon:refreshAppearance(selection) --icon:clipOutside(selection)
					end
					clickRegion.SelectionImageObject = selection.Selection
				end
				if previousHighlightedIcon and previousHighlightedIcon ~= icon then
					previousHighlightedIcon:setIndicator()
				end
				local newIndicator = if isUsingGamepad and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
				previousHighlightedIcon = icon
				Icon.lastHighlightedIcon = icon
				icon:setIndicator(newIndicator)
			else
				local newIndicator = if isUsingGamepad and not usedIndicatorOnce then Icon.highlightKey else nil
				if not previousHighlightedIcon then
					previousHighlightedIcon = Gamepad.getIconToHighlight()
				end
				if newIndicator == Icon.highlightKey then
					-- We only display the highlightKey once to show
					-- the user how to highlight the topbar icon
					usedIndicatorOnce = true
				else
					--usedBOnce = true
				end
				if previousHighlightedIcon then
					previousHighlightedIcon:setIndicator(newIndicator)
				end
			end
		end
		GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)

		-- This listens for a gamepad being present/added/removed
		local function preferredInputChanged()
			local preferredInput = UserInputService.PreferredInput
			local isUsingGamepad = preferredInput == GAMEPAD_INPUT

			if not isUsingGamepad then
				usedIndicatorOnce = false
				usedBOnce = false
			end
			updateSelectedObject()
		end
		UserInputService:GetPropertyChangedSignal("PreferredInput"):Connect(preferredInputChanged)
		preferredInputChanged()

		-- This allows for easy highlighting of the topbar when the
		-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
		-- If you'd like to disable, do ``Icon.highlightKey = false``
		UserInputService.InputBegan:Connect(function(input, touchingAnObject)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				-- Sometimes the Roblox gamepad glitches when combined with a cursor
				-- This fixes that by unhighlighting if the cursor is pressed down
				-- (i.e. a mouse click)
				local icon = getIconFromSelectedObject()
				if icon then
					GuiService.SelectedObject = nil
				end
				return
			end
			if input.KeyCode ~= Icon.highlightKey then
				return
			end
			local iconToHighlight = Gamepad.getIconToHighlight()
			if iconToHighlight then
				if GamepadService.GamepadCursorEnabled then
					task.wait(0.2)
					GamepadService:DisableGamepadCursor()
				end
				local clickRegion = iconToHighlight:getInstance("ClickRegion")
				GuiService.SelectedObject = clickRegion
			end
		end)
	end)
end

function Gamepad.getIconToHighlight()
	-- If an icon has already been selected, returns the last selected icon
	-- Else if more than 0 icons, it selects the left-most icon
	local iconsDict = Icon.iconsDictionary
	local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
	if not iconToHighlight then
		local currentX
		for _, icon in pairs(iconsDict) do
			if icon.parentIconUID then
				continue
			end
			local thisX = icon.widget.AbsolutePosition.X
			if not currentX or thisX < currentX then
				iconToHighlight = icon
				currentX = iconToHighlight.widget.AbsolutePosition.X
			end
		end
	end
	return iconToHighlight
end

-- This called when the icon's ClickRegion is created
function Gamepad.registerButton(buttonInstance)
	-- This provides a basic level of support for controllers by making
	-- the icons easy to highlight via the virtual cursor, then
	-- when selected, focuses in on the selected icon and hops
	-- between other nearby icons simply by toggling the joystick
	local inputBegan = false
	buttonInstance.InputBegan:Connect(function(input)
		-- Two wait frames required to ensure inputBegan is detected within
		-- UserInputService.InputBegan. We do this because object.InputBegan
		-- does not return the correct input objects (unlike the service)
		inputBegan = true
		task.wait()
		task.wait()
		inputBegan = false
	end)
	local connection = UserInputService.InputBegan:Connect(function(input)
		task.wait()
		if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
			-- We focus on an icon when selected via the virtual cursor
			task.wait(0.2)
			GamepadService:DisableGamepadCursor()
			GuiService.SelectedObject = buttonInstance
			return
		end
		local isSelected = GuiService.SelectedObject == buttonInstance
		local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
		local keyName = input.KeyCode.Name
		if table.find(unselectKeyCodes, keyName) and isSelected then
			-- We unfocus when back button is pressed, but ignore
			-- if the virtual cursor is disabled otherwise it will be
			-- impossible to select the topbar
			if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
				GuiService.SelectedObject = nil
			end
		end
	end)
	buttonInstance.Destroying:Once(function()
		connection:Disconnect()
	end)
end



return Gamepad]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9C46EC7D97434BF89637D9D2C3C46C7F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Overflow</string>
										<string name="ScriptGuid">{0261DE4B-D2DF-43AE-AEF9-7743BC89E418}</string>
										<ProtectedString name="Source"><![CDATA[-- When designing your game for many devices and screen sizes, icons may occasionally
-- particularly for smaller devices like phones, overlap with other icons or the bounds
-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring



-- LOCAL
local Overflow = {}
local holders = {}
local orderedAvailableIcons = {}
local iconsDict
local currentCamera = workspace.CurrentCamera
local overflowIcons = {}
local overflowIconUIDs = {}
local Utility = require(script.Parent.Parent.Utility)
local beginCheckingCenterIcons = false
local beganSecondaryCenterCheck = false
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Overflow.start(incomingIcon)
	Icon = incomingIcon
	iconsDict = Icon.iconsDictionary
	local primaryScreenGui
	for _, screenGui in pairs(Icon.container) do
		if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
			primaryScreenGui = screenGui
		end
		for _, holder in pairs(screenGui.Holders:GetChildren()) do
			if holder:GetAttribute("IsAHolder") then
				holders[holder.Name] = holder
			end
		end
	end

	-- We listen for changes in icons (such as them being added, removed,
	-- the setting of a different alignment, the widget size changing, etc)
	local beginOverflow = false
	local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
		if not beginOverflow then
			return
		end
		if not ignoreAvailable then
			Overflow.updateAvailableIcons("Center")
		end
		Overflow.updateBoundary("Left")
		Overflow.updateBoundary("Right")
	end)
	task.delay(0.5, function()
		beginOverflow = true
		updateBoundaries()
	end)
	task.delay(2, function()
		-- This is essential to prevent central icons begin added
		-- left or right due to incomplete UIListLayout calculations
		-- within the first few frames
		beginCheckingCenterIcons = true
		updateBoundaries()
	end)
	Icon.iconAdded:Connect(updateBoundaries)
	Icon.iconRemoved:Connect(updateBoundaries)
	Icon.iconChanged:Connect(updateBoundaries)
	currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
		updateBoundaries(true)
	end)
	primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updateBoundaries(true)
	end)
end

function Overflow.getWidth(icon, getMaxWidth)
	local widget = icon.widget
	return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
end

function Overflow.getAvailableIcons(alignment)
	local ourOrderedIcons = orderedAvailableIcons[alignment]
	if not ourOrderedIcons then
		ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	end
	return ourOrderedIcons
end

function Overflow.updateAvailableIcons(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon)
	local ourTotal = 0
	local ourOrderedIcons = {}
	for _, icon in pairs(iconsDict) do
		local parentUID = icon.parentIconUID
		local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
		local isOverflow = overflowIconUIDs[icon.UID]
		if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow and icon.isEnabled then
			table.insert(ourOrderedIcons, icon)
			ourTotal += 1
		end
	end

	-- Ignore if no icons are available
	if ourTotal <= 0 then
		return {}
	end

	-- This sorts these icons by smallest order, or if equal, left-most position
	-- (even for the right alignment because all icons are sorted left-to-right)
	table.sort(ourOrderedIcons, function(iconA, iconB)
		local orderA = iconA.widget.LayoutOrder
		local orderB = iconB.widget.LayoutOrder
		local hasParentA = iconA.parentIconUID
		local hasParentB = iconB.parentIconUID
		if hasParentA == hasParentB then
			if orderA < orderB then
				return true
			end
			if orderA > orderB then
				return false
			end
			return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
		elseif hasParentB then
			return false
		elseif hasParentA then
			return true
		end
		return nil
	end)

	-- Finish up
	orderedAvailableIcons[alignment] = ourOrderedIcons
	return ourOrderedIcons

end

function Overflow.getRealXPositions(alignment, orderedIcons)
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local isLeft = alignment == "Left"
	local holder = holders[alignment]
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local holderUIList = holder.UIListLayout
	local topbarInset = holderUIList.Padding.Offset
	local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
	local realXPositions = {}
	if isLeft then
		Utility.reverseTable(orderedIcons)
	end
	for i = #orderedIcons, 1, -1 do
		local icon = orderedIcons[i]
		local sizeX = Overflow.getWidth(icon)
		if not isLeft then
			absoluteX -= sizeX
		end
		realXPositions[icon.UID] = absoluteX
		if isLeft then
			absoluteX += sizeX
		end
		absoluteX += (isLeft and topbarInset) or -topbarInset
	end
	return realXPositions
end

function Overflow.updateBoundary(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local topbarInset = holderUIList.Padding.Offset
	local topbarPadding = holderUIList.Padding.Offset
	local BOUNDARY_GAP = topbarInset
	local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	local boundWidth = 0
	local ourTotal = 0
	for _, icon in pairs(ourOrderedIcons) do
		boundWidth += Overflow.getWidth(icon) + topbarPadding
		ourTotal += 1
	end
	if ourTotal <= 0 then
		return
	end
	
	-- These are the icons with menus which icons will be moved into
	-- when overflowing
	local isCentral = alignment == "Center"
	local isLeft = alignment == "Left"
	local isRight = not isLeft
	local overflowIcon = overflowIcons[alignment]
	if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
		local order = (isLeft and -9999999) or 9999999
		overflowIcon = Icon.new()--:setLabel(`{alignment}`)
		overflowIcon:setImage(6069276526, "Deselected")
		overflowIcon:setName("Overflow"..alignment)
		overflowIcon:setOrder(order)
		overflowIcon:setAlignment(alignment)
		overflowIcon:autoDeselect(false)
		overflowIcon.isAnOverflow = true
		--overflowIcon:freezeMenu()
		overflowIcon:select("OverflowStart", overflowIcon)
		overflowIcon:setEnabled(false)
		overflowIcons[alignment] = overflowIcon
		overflowIconUIDs[overflowIcon.UID] = true
		if not Icon.closeableOverflowMenus then
			local iconSpot = overflowIcon:getInstance("IconSpot")
			iconSpot.Visible = false
		end
	end

	-- The default boundary is the point where both the left-most-right-icon
	-- and left-most-right-icon meet OR the opposite side of the screen
	local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
	local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
	local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
	local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
	local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
	if nearestOppositeIcon then
		local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
		local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
		local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
		boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
	end
	
	-- We get the left-most icon (if left alignment) or right-most-icon (if
	-- right alignment) of the central icons group to see if we need to change
	-- the boundary (if the central icon boundary is smaller than the alignment
	-- boundary then we use the central)
	local totalChecks = 0
	local usingNearestCenter = false
	local function checkToShiftCentralIcon()
		local centerOrderedIcons = Overflow.getAvailableIcons("Center")
		local centerPos = (isLeft and 1) or #centerOrderedIcons
		local nearestCenterIcon = centerOrderedIcons[centerPos]
		local function secondaryCheck()
			if not beganSecondaryCenterCheck then
				beganSecondaryCenterCheck = true
				task.delay(3, Overflow.updateBoundary, alignment)
			end
		end
		if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
			local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
			local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
			local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
			local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
			local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
			local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
			local hasShifted = false
			if isLeft then
				if centerBoundary < removeBoundary then
					if not beginCheckingCenterIcons then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Left")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			elseif isRight then
				if centerBoundary > removeBoundary then
					if not beginCheckingCenterIcons or removeBoundary < 0 then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Right")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			end
			if hasShifted then
				totalChecks += 1
				if totalChecks <= 4 then
					Overflow.updateAvailableIcons("Center")
					checkToShiftCentralIcon()
				end
			end
		end
	end
	checkToShiftCentralIcon()
	
	--[[
	This updates the maximum size of the overflow menus
	The menu determines its bounds from the smallest of either:
	 	1. The closest center-aligned icon (i.e. the boundary)
	 	2. The edge of the opposite overflow menu UNLESS...
	 	3. ... the edge exceeds more than half the screenGui
	--]]
	if overflowIcon then
		local menuBoundary = boundary
		local menu = overflowIcon:getInstance("Menu")
		local holderXEndPos = holderXPos + holderXSize
		local menuWidth = holderXSize
		if menu and oppositeOverflowIcon then
			local oppositeWidget = oppositeOverflowIcon.widget
			local oppositeXPos = oppositeWidget.AbsolutePosition.X
			local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
			local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
			local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
			local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
			if not usingNearestCenter then
				local halfwayXPos = holderXPos + holderXSize/2
				local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
				menuBoundary = halfwayBoundary
				if isDominant then
					menuBoundary = oppositeBoundary
				end
			end
			menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
		end
		local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
		menuWidth = Utility.round(menuWidth)
		if menu and currentMaxWidth ~= menuWidth then
			menu:SetAttribute("MaxWidth", menuWidth)
		end
	end

	-- Parent ALL icons of that alignment into the overflow if at least on
	-- sibling exceeds the bounds.
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local widgetX = Overflow.getWidth(icon)
		local xPos = realXPositions[icon.UID]
		if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
			joinOverflow = true
		end
	end
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local isOverflow = overflowIconUIDs[icon.UID]
		if not isOverflow then
			if joinOverflow and not icon.parentIconUID then
				icon:joinMenu(overflowIcon)
			elseif not joinOverflow and icon.parentIconUID then
				icon:leave()
			end
		end
	end
	
	-- Hide the overflows when not in use
	if overflowIcon.isEnabled ~= joinOverflow then
		overflowIcon:setEnabled(joinOverflow)
	end
	
	-- Have the menus auto selected
	if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
		overflowIcon.overflowAlreadyOpened = true
		overflowIcon:select()
	end

end



return Overflow]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXB980FBC12A2B4E5FA9E13502EE66AC68">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Themes</string>
										<string name="ScriptGuid">{EA30EFAC-65FC-4A54-AC42-394E1E4EA328}</string>
										<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
	return nil
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXF2BACDC77CEE45F1B435E4409A56ABE6">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Classic</string>
											<string name="ScriptGuid">{DFC504B1-E561-43AD-A4E8-AD505741D3D8}</string>
											<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX94DBFEE7F8374B1CA8AF32AC68D8F6E6">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Default</string>
											<string name="ScriptGuid">{1438AA05-1B91-4927-B26A-50674211ADE6}</string>
											<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "DesiredWidth", 44, "Deselected"},
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
  	{"IconButton", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.08, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconImageRatio", "AspectRatio", 1, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.85, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
  	{"Dropdown", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.08, "Deselected"},
	{"Dropdown", "MaxIcons", 4.5, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX1091758F46B947449CE91FC4C5FD3188">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Packages</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX932D43760B4F4F79B7D24A0B0C5AEAEE">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">GoodSignal</string>
										<string name="ScriptGuid">{DD537714-2F9A-4983-98B9-04666D830912}</string>
										<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end
Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end
Signal.Destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXF5CD9A0A6C9C4B658D7C8533CC111642">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Janitor</string>
										<string name="ScriptGuid">{9EE33865-24BF-47B1-8D36-A490775E63D2}</string>
										<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------
This package was modified by ForeverHD.

PACKAGE MODIFICATIONS:
	1. Added pascalCase aliases for all methods
	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
	3. Slight change to how promises are tracked
	4. Added isAnInstanceBeingDestroyed check to line 228
	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
	6. Likely some additional changes which weren't record here
	7. Removed comments as these were detected by Moonwave
-------------------------------------
--]]



-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local function getPromiseReference()
	return false
end

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	IGNORE_MEMORY_DEBUG = true,
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	["Promise"] = "cancel";
	RBXScriptConnection = "Disconnect";
}

function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

function Janitor.__index:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local objectType = typeof(Object)
	if objectType == "table" and string.match(tostring(Object), "Promise") then
		objectType = "Promise"
		--local status = Object:getStatus()
		--print("status =", status, status == "Rejected")
	end
	MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
	end

	local OriginalTraceback = debug.traceback("")
	self[Object] = {MethodName, OriginalTraceback}
	return Object
end
Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

function Janitor.__index:AddPromise(PromiseObject)
	local Promise = getPromiseReference()
	if Promise then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
						PromiseObject:cancel()
					end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	local Promise = getPromiseReference()
	if Promise and Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]
	if This then
		local Object = This[Index]

		if Object then
			local ObjectDetail = self[Object]
			local MethodName = ObjectDetail and ObjectDetail[1]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
	return nil
end

function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, ObjectDetail in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			local MethodName = ObjectDetail[1]
			local OriginalTraceback = ObjectDetail[2]
			local function warnUser(warning)
				local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
				local addedLine = OriginalTraceback
				warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
			end
			if MethodName == true then
				local success, warning = pcall(Object)
				if not success then
					warnUser(warning)
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					local success, warning = pcall(ObjectMethod, Object)
					local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
					if not success and not isAnInstanceBeingDestroyed then
						warnUser(warning)
					end
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXEA2B899ABF794096A4059603F3183EB0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">SmoothShiftLock</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX7F6BD0422D1B43D2953D4A4AD975B004">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{2F99FBAD-AF40-4EB3-80D5-76B60A2F94BF}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "SmoothShiftLock",
	Thumbnail = "rbxassetid://18622284295",
	AssetId = 18598633874,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Nekothyl"},
		{Text = "Description: THE shift lock library, a easy alternative to the default roblox shiftlock."},
		{Text = "Version: 1.3.0 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Model" referent="RBX585D16FC799946B5824627E0BCE054DB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<token name="LevelOfDetail">0</token>
							<CoordinateFrame name="ModelMeshCFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<Vector3 name="ModelMeshSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="ModelStreamingMode">0</token>
							<string name="Name">SmoothShiftLock</string>
							<bool name="NeedsPivotMigration">false</bool>
							<Ref name="PrimaryPart">null</Ref>
							<float name="ScaleFactor">1</float>
							<SharedString name="SlimHash">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<int64 name="SourceAssetId">18598633874</int64>
							<BinaryString name="Tags"></BinaryString>
							<OptionalCoordinateFrame name="WorldPivotData">
								<CFrame>
									<X>86.6030807</X>
									<Y>0</Y>
									<Z>-123.296478</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CFrame>
							</OptionalCoordinateFrame>
						</Properties>
						<Item class="ModuleScript" referent="RBX724278A0BD2140678494BF240527F344">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SETUP GUIDE</string>
								<string name="ScriptGuid">{41CA6B03-9347-4F71-8B0C-C82DB7DE60D4}</string>
								<ProtectedString name="Source"><![CDATA[--[[

	-<< SmoothShiftLock Setup Guide >>-
	
	1. Put "DisableDefaultShiftLock" script into ServerScriptService.
		(Alternatively click on StarterPlayer and in properties under Controls find EnableMouseLockOption and uncheck the box)
	2. Put "CustomShiftLock" script into StarterPlayer>StarterPlayerScripts.

	Congratulations, you've successfully set up SmoothShiftLock!
	The settings of SmoothShiftLock are located at CustomShiftLock>SmoothShiftLock (Line 31)
	
	
	
	
	-<< For Advanced Scripters >>-
	
	To access the module's methods, simply require the SmoothShiftLock module script.
	Example:
	
	```
	local SmoothShiftLock = require(CustomShiftLock.SmoothShiftLock);
	print(SmoothShiftLock:IsEnabled());
	```
	
	@ Variables:
		.Enabled - ShiftLock's enabled state.
		
	@ Methods:
		:Enable() - Enables the whole module.
		:Disable() - Disables the whole module.
		:IsEnabled(): boolean - Returns ShiftLock's enabled state.
		:ToggleShiftLock(Enable: boolean?) - Toggles the ShiftLock, if Enable parameter is provided then ShiftLock will be toggled to it.
		
		
--]]]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX965EDC86183B4EBE9484BF3F156C5356">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">DisableDefaultShiftLock</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{AD810EDD-C1F5-40E2-A9A6-7F877C018B60}</string>
								<ProtectedString name="Source"><![CDATA[--[[

	Put this into ServerScriptService

--]]

local StarterPlayer = game:GetService("StarterPlayer");
StarterPlayer.EnableMouseLockOption = false;]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="LocalScript" referent="RBX1AA550A6588A458585BD3F0331FCD42B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CustomShiftLock</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{87BE3DBE-FC0C-4AE5-9C67-AC7BDEDF2C11}</string>
								<ProtectedString name="Source"><![CDATA[--[[

	Put this into StarterPlayer>StarterPlayerScripts

--]]

require(script:WaitForChild("SmoothShiftLock"));]]></ProtectedString>
								<int64 name="SourceAssetId">13628590040</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX7CE3DD6705484BB39488619F534B77C8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SmoothShiftLock</string>
									<string name="ScriptGuid">{F5ECD0F6-D05C-4ED8-B78D-DD863C8DF4A4}</string>
									<ProtectedString name="Source"><![CDATA[--[[

	@ Name: SmoothShiftLock
	@ Author: x33
	@ Version: 1.3.0
	
	@ Variables:
		.Enabled - ShiftLock's enabled state.
		
	@ Methods:
		:Enable() - Enables the whole module.
		:Disable() - Disables the whole module.
		:IsEnabled(): boolean - Returns ShiftLock's enabled state.
		:ToggleShiftLock(Enable: boolean?) - Toggles the ShiftLock, if Enable parameter is provided then ShiftLock will be toggled to it.

--]]

local SmoothShiftLock = {};
SmoothShiftLock.__index = SmoothShiftLock;

--// [ Locals: ]

--// Services
local Workspace = game:GetService("Workspace");
local Players = game:GetService("Players");
local RunService = game:GetService("RunService");
local ContextActionService = game:GetService("ContextActionService");
local UserInputService = game:GetService("UserInputService");

--// Utilities
local Maid = require(script:WaitForChild("Maid"));
local Spring = require(script:WaitForChild("Spring"));

--// Instances
local LocalPlayer = Players.LocalPlayer;
local PlayerMouse = LocalPlayer:GetMouse();
local Camera = Workspace.CurrentCamera;

--// Configuration
local Config = {
	MOBILE_SUPPORT              = false,                      --// Adds a button to toggle the shift lock for touchscreen devices
	SMOOTH_CHARACTER_ROTATION   = true,                       --// If your character should rotate smoothly or not
	CHARACTER_ROTATION_SPEED    = 3,                          --// How quickly character rotates smoothly
	TRANSITION_SPRING_DAMPER    = 0.7,                        --// Camera transition spring damper, test it out to see what works for you
	CAMERA_TRANSITION_IN_SPEED  = 10,                         --// How quickly locked camera moves to offset position
	CAMERA_TRANSITION_OUT_SPEED = 14,                         --// How quickly locked camera moves back from offset position
	LOCKED_CAMERA_OFFSET        = Vector3.new(1.75, 0.25, 0), --// Locked camera offset
	LOCKED_MOUSE_ICON           =                             --// Locked mouse icon
		"rbxasset://textures/MouseLockedCursor.png",
	SHIFT_LOCK_KEYBINDS         =                             --// Shift lock keybinds
		{Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift}
};

--// [ Constructor: ]
function SmoothShiftLock.new()
	local self = setmetatable({}, SmoothShiftLock);
	
	--// Utilities
	self._runtimeMaid = Maid.new();
	self._shiftlockMaid = Maid.new();
	self._cameraOffsetSpring = Spring.new(Vector3.new(0, 0, 0));
	self._cameraOffsetSpring.Damper = Config.TRANSITION_SPRING_DAMPER;

	--// Variables
	self.Enabled = false;
	
	--// Setup
	self:Enable();
	
	return self;
end;

--// [ Module Functions: ]
function SmoothShiftLock:Enable()
	self:_refreshCharacterVariables();
	self._runtimeMaid:GiveTask(LocalPlayer.CharacterAdded:Connect(function()
		self:_refreshCharacterVariables();
	end));
	
	--// Bind Keybinds
	ContextActionService:BindActionAtPriority("ShiftLockSwitchAction", function(Name, State, Input)
		return self:_doShiftLockSwitch(Name, State, Input);
	end, Config.MOBILE_SUPPORT, Enum.ContextActionPriority.Medium.Value, unpack(Config.SHIFT_LOCK_KEYBINDS));

	--// Camera Offset
	self._runtimeMaid:GiveTask(RunService.RenderStepped:Connect(function()
		if self.Head.LocalTransparencyModifier > 0.6 then return; end;

		local CameraCFrame = Camera.CoordinateFrame;
		local Distance = (self.Head.Position - CameraCFrame.p).magnitude;

		--// Camera offset
		if Distance > 1 then	
			Camera.CFrame = (Camera.CFrame * CFrame.new(self._cameraOffsetSpring.Position)); 
			if self.Enabled and UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
				self:_updateMouseState();
			end;
		end;
	end));
end;

function SmoothShiftLock:Disable()
	self._runtimeMaid:DoCleaning();
	self._shiftlockMaid:DoCleaning();
	
	--// Unbind Keybinds
	ContextActionService:UnbindAction("ShiftLockSwitchAction");
end;

--// [ Internal Functions: ]
function SmoothShiftLock:_refreshCharacterVariables()
	self.Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait();
	self.RootPart = self.Character:WaitForChild("HumanoidRootPart");
	self.Humanoid = self.Character:WaitForChild("Humanoid");
	self.Head = self.Character:WaitForChild("Head");
end;

--// Internal function for ContextActionService
function SmoothShiftLock:_doShiftLockSwitch(_, State: Enum.UserInputState)
	if State == Enum.UserInputState.Begin then
		self:ToggleShiftLock();
		return Enum.ContextActionResult.Sink;
	end;

	return Enum.ContextActionResult.Pass;
end;

--// Update the mouse behaviour
function SmoothShiftLock:_updateMouseState()
	UserInputService.MouseBehavior = (self.Enabled and Enum.MouseBehavior.LockCenter) or Enum.MouseBehavior.Default;
end;

--// Update the mouse icon
function SmoothShiftLock:_updateMouseIcon()
	PlayerMouse.Icon = (self.Enabled and Config.LOCKED_MOUSE_ICON :: string) or "";
end;

--// Transition the camera to lock offset
function SmoothShiftLock:_transitionLockOffset()
	if self.Enabled then
		self._cameraOffsetSpring.Speed = Config.CAMERA_TRANSITION_IN_SPEED;
		self._cameraOffsetSpring.Target = Config.LOCKED_CAMERA_OFFSET;
	else
		self._cameraOffsetSpring.Speed = Config.CAMERA_TRANSITION_OUT_SPEED;
		self._cameraOffsetSpring.Target = Vector3.new(0, 0, 0);
	end;
end;

--// [ External Functions: ]
function SmoothShiftLock:IsEnabled(): boolean
	return self.Enabled;
end;

--// ShiftLock toggle function
function SmoothShiftLock:ToggleShiftLock(Enable: boolean?)
	if Enable ~= nil then
		self.Enabled = Enable;
	else
		self.Enabled = not self.Enabled;
	end;

	self:_updateMouseState();
	self:_updateMouseIcon();
	self:_transitionLockOffset();
	if self.Enabled then
		self._shiftlockMaid:GiveTask(RunService.RenderStepped:Connect(function(Delta: number)
			if (self.Humanoid and self.RootPart) then 
				self.Humanoid.AutoRotate = not self.Enabled;
			end;
			
			--// Rotate the character
			if self.Humanoid.Sit then return; end;
			if Config.SMOOTH_CHARACTER_ROTATION then
				local x, y, z = Camera.CFrame:ToOrientation();
				self.RootPart.CFrame = self.RootPart.CFrame:Lerp(CFrame.new(self.RootPart.Position) * CFrame.Angles(0, y, 0), Delta * 5 * Config.CHARACTER_ROTATION_SPEED);
			else
				local x, y, z = Camera.CFrame:ToOrientation();
				self.RootPart.CFrame = CFrame.new(self.RootPart.Position) * CFrame.Angles(0, y, 0);
			end;
		end));
	else
		self.Humanoid.AutoRotate = true;
		self._shiftlockMaid:DoCleaning();
	end;
end;

return SmoothShiftLock.new();]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXAA8EA5A929394A76AD4E9EAF67CABFD8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Maid</string>
										<string name="ScriptGuid">{ED2C0EB8-E344-4BB3-8E1E-C23362F81956}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	Manages the cleaning of events and other things. Useful for
	encapsulating state and make deconstructors easy.

	See the [Five Powerful Code Patterns talk](https://developer.roblox.com/en-us/videos/5-powerful-code-patterns-behind-top-roblox-games)
	for a more in-depth look at Maids in top games.

	```lua
	local maid = Maid.new()

	maid:GiveTask(function()
		print("Cleaning up")
	end)

	maid:GiveTask(workspace.ChildAdded:Connect(print))

	-- Disconnects all events, and executes all functions
	maid:DoCleaning()
	```

	@class Maid
]=]
-- luacheck: pop

local Maid = {}
Maid.ClassName = "Maid"

--[=[
	Constructs a new Maid object

	```lua
	local maid = Maid.new()
	```

	@return Maid
]=]
function Maid.new()
	return setmetatable({
		_tasks = {}
	}, Maid)
end

--[=[
	Returns true if the class is a maid, and false otherwise.

	```lua
	print(Maid.isMaid(Maid.new())) --> true
	print(Maid.isMaid(nil)) --> false
	```

	@param value any
	@return boolean
]=]
function Maid.isMaid(value)
	return type(value) == "table" and value.ClassName == "Maid"
end

--[=[
	Returns Maid[key] if not part of Maid metatable

	```lua
	local maid = Maid.new()
	maid._current = Instance.new("Part")
	print(maid._current) --> Part

	maid._current = nil
	print(maid._current) --> nil
	```

	@param index any
	@return MaidTask
]=]
function Maid:__index(index)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--[=[
	Add a task to clean up. Tasks given to a maid will be cleaned when
	maid[index] is set to a different value.

	Task cleanup is such that if the task is an event, it is disconnected.
	If it is an object, it is destroyed.

	```
	Maid[key] = (function)         Adds a task to perform
	Maid[key] = (event connection) Manages an event connection
	Maid[key] = (thread)           Manages a thread
	Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
	Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
	Maid[key] = nil                Removes a named task.
	```

	@param index any
	@param newTask MaidTask
]=]
function Maid:__newindex(index, newTask)
	if Maid[index] ~= nil then
		error(("Cannot use '%s' as a Maid key"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]

	if oldTask == newTask then
		return
	end

	tasks[index] = newTask

	if oldTask then
		if type(oldTask) == "function" then
			oldTask()
		elseif type(oldTask) == "thread" then
			task.cancel(oldTask)
		elseif typeof(oldTask) == "RBXScriptConnection" then
			oldTask:Disconnect()
		elseif oldTask.Destroy then
			oldTask:Destroy()
		end
	end
end

--[=[
	Gives a task to the maid for cleanup, but uses an incremented number as a key.

	@param task MaidTask -- An item to clean
	@return number -- taskId
]=]
function Maid:GiveTask(task)
	if not task then
		error("Task cannot be false or nil", 2)
	end

	local taskId = #self._tasks+1
	self[taskId] = task

	if type(task) == "table" and (not task.Destroy) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

--[=[
	Gives a promise to the maid for clean.

	@param promise Promise<T>
	@return Promise<T>
]=]
function Maid:GivePromise(promise)
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--[=[
	Cleans up all tasks and removes them as entries from the Maid.

	:::note
	Signals that are already connected are always disconnected first. After that
	any signals added during a cleaning phase will be disconnected at random times.
	:::

	:::tip
	DoCleaning() may be recursively invoked. This allows the you to ensure that
	tasks or other tasks. Each task will be executed once.

	However, adding tasks while cleaning is not generally a good idea, as if you add a
	function that adds itself, this will loop indefinitely.
	:::
]=]
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, job in pairs(tasks) do
		if typeof(job) == "RBXScriptConnection" then
			tasks[index] = nil
			job:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, job = next(tasks)
	while job ~= nil do
		tasks[index] = nil
		if type(job) == "function" then
			job()
		elseif type(job) == "thread" then
			task.cancel(job)
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		elseif job.Destroy then
			job:Destroy()
		end
		index, job = next(tasks)
	end
end

--[=[
	Alias for [Maid.DoCleaning()](/api/Maid#DoCleaning)

	@function Destroy
	@within Maid
]=]
Maid.Destroy = Maid.DoCleaning

return Maid
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1FFEB77D0F7A4F22BAE61E120498633D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Spring</string>
										<string name="ScriptGuid">{B61AB3D7-2065-41EB-A78D-337744CB2237}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	A physical model of a spring, useful in many applications.
	A spring is an object that will compute based upon Hooke's law. Properties only evaluate
	upon index making this model good for lazy applications.
	```lua
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local spring = Spring.new(Vector3.new(0, 0, 0))
	RunService.RenderStepped:Connect(function()
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then
			spring.Target = Vector3.new(0, 0, 1)
		else
			spring.Target = Vector3.new(0, 0, 0)
		end
		print(spring.Position) -- A smoothed out version of the input keycode W
	end)
	```
	A good visualization can be found here, provided by Defaultio:
	https://www.desmos.com/calculator/hn2i9shxbz
	@class Spring
]=]
local Spring = {}

--[=[
	Constructs a new Spring at the position and target specified, of type T.
	```lua
	-- Linear spring
	local linearSpring = Spring.new(0)
	-- Vector2 spring
	local vector2Spring = Spring.new(Vector2.new(0, 0))
	-- Vector3 spring
	local vector3Spring = Spring.new(Vector3.new(0, 0, 0))
	```
	@param initial T -- The initial parameter is a number or Vector3 (anything with * number and addition/subtraction).
	@param clock? () -> number -- The clock function is optional, and is used to update the spring
	@return Spring<T>
]=]
function Spring.new(initial, clock)
	local target = initial or 0
	clock = clock or os.clock
	return setmetatable({
		_clock = clock;
		_time0 = clock();
		_position0 = target;
		_velocity0 = 0*target;
		_target = target;
		_damper = 1;
		_speed = 1;
	}, Spring)
end

--[=[
	Impulses the spring, increasing velocity by the amount given. This is useful to make something shake,
	like a Mac password box failing.
	@param velocity T -- The velocity to impulse with
	@return ()
]=]
function Spring:Impulse(velocity)
	self.Velocity = self.Velocity + velocity
end

--[=[
	Instantly skips the spring forwards by that amount time
	@param delta number -- Time to skip forwards
	@return ()
]=]
function Spring:TimeSkip(delta)
	local now = self._clock()
	local position, velocity = self:_positionVelocity(now+delta)
	self._position0 = position
	self._velocity0 = velocity
	self._time0 = now
end

--[=[
	The current position at the given clock time. Assigning the position will change the spring to have that position.
	```lua
	local spring = Spring.new(0)
	print(spring.Position) --> 0
	```
	@prop Position T
	@within Spring
]=]
--[=[
	Alias for [Spring.Position](/api/Spring#Position)
	@prop p T
	@within Spring
]=]
--[=[
	The current velocity. Assigning the velocity will change the spring to have that velocity.
	```lua
	local spring = Spring.new(0)
	print(spring.Velocity) --> 0
	```
	@prop Velocity T
	@within Spring
]=]
--[=[
	Alias for [Spring.Velocity](/api/Spring#Velocity)
	@prop v T
	@within Spring
]=]
--[=[
	The current target. Assigning the target will change the spring to have that target.
	```lua
	local spring = Spring.new(0)
	print(spring.Target) --> 0
	```
	@prop Target T
	@within Spring
]=]
--[=[
	Alias for [Spring.Target](/api/Spring#Target)
	@prop t T
	@within Spring
]=]
--[=[
	The current damper, defaults to 1. At 1 the spring is critically damped. At less than 1, it
	will be underdamped, and thus, bounce, and at over 1, it will be critically damped.
	@prop Damper number
	@within Spring
]=]
--[=[
	Alias for [Spring.Damper](/api/Spring#Damper)
	@prop d number
	@within Spring
]=]
--[=[
	The speed, defaults to 1, but should be between [0, infinity)
	@prop Speed number
	@within Spring
]=]
--[=[
	Alias for [Spring.Speed](/api/Spring#Speed)
	@prop s number
	@within Spring
]=]
--[=[
	The current clock object to syncronize the spring against.
	@prop Clock () -> number
	@within Spring
]=]
function Spring:__index(index)
	if Spring[index] then
		return Spring[index]
	elseif index == "Value" or index == "Position" or index == "p" then
		local position, _ = self:_positionVelocity(self._clock())
		return position
	elseif index == "Velocity" or index == "v" then
		local _, velocity = self:_positionVelocity(self._clock())
		return velocity
	elseif index == "Target" or index == "t" then
		return self._target
	elseif index == "Damper" or index == "d" then
		return self._damper
	elseif index == "Speed" or index == "s" then
		return self._speed
	elseif index == "Clock" then
		return self._clock
	else
		error(("%q is not a valid member of Spring"):format(tostring(index)), 2)
	end
end

function Spring:__newindex(index, value)
	local now = self._clock()

	if index == "Value" or index == "Position" or index == "p" then
		local _, velocity = self:_positionVelocity(now)
		self._position0 = value
		self._velocity0 = velocity
		self._time0 = now
	elseif index == "Velocity" or index == "v" then
		local position, _ = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = value
		self._time0 = now
	elseif index == "Target" or index == "t" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._target = value
		self._time0 = now
	elseif index == "Damper" or index == "d" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._damper = value
		self._time0 = now
	elseif index == "Speed" or index == "s" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._speed = value < 0 and 0 or value
		self._time0 = now
	elseif index == "Clock" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._clock = value
		self._time0 = value()
	else
		error(("%q is not a valid member of Spring"):format(tostring(index)), 2)
	end
end

function Spring:_positionVelocity(now)
	local p0 = self._position0
	local v0 = self._velocity0
	local p1 = self._target
	local d = self._damper
	local s = self._speed

	local t = s*(now - self._time0)
	local d2 = d*d

	local h, si, co
	if d2 < 1 then
		h = math.sqrt(1 - d2)
		local ep = math.exp(-d*t)/h
		co, si = ep*math.cos(h*t), ep*math.sin(h*t)
	elseif d2 == 1 then
		h = 1
		local ep = math.exp(-d*t)/h
		co, si = ep, ep*t
	else
		h = math.sqrt(d2 - 1)
		local u = math.exp((-d + h)*t)/(2*h)
		local v = math.exp((-d - h)*t)/(2*h)
		co, si = u + v, u - v
	end

	local a0 = h*co + d*si
	local a1 = 1 - (h*co + d*si)
	local a2 = si/s

	local b0 = -s*si
	local b1 = s*si
	local b2 = h*co - d*si

	return
		a0*p0 + a1*p1 + a2*v0,
		b0*p0 + b1*p1 + b2*v0
end

return Spring]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX9AAD4A9823B741D0BB4F1928532A79AC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">SimplePath</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA95A7AA8542B4BA48145917EAE8362E8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SimplePath</string>
							<string name="ScriptGuid">{86307859-57C7-4880-969F-40F5A46F8E58}</string>
							<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------------------------------------

Created by: @V3N0M_Z
Reference: https://v3n0m-z.github.io/RBLX-SimplePath/
License: MIT

---------------------------------------------------------------------
]]

local DEFAULT_SETTINGS = {

	TIME_VARIANCE = 0.07;

	COMPARISON_CHECKS = 1;

	JUMP_WHEN_STUCK = true;
}

---------------------------------------------------------------------

local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local function output(func, msg)
	func(((func == error and "SimplePath Error: ") or "SimplePath: ")..msg)
end
local Path = {
	StatusType = {
		Idle = "Idle";
		Active = "Active";
	};
	ErrorType = {
		LimitReached = "LimitReached";
		TargetUnreachable = "TargetUnreachable";
		ComputationError = "ComputationError";
		AgentStuck = "AgentStuck";
	};
}
Path.__index = function(table, index)
	if index == "Stopped" and not table._humanoid then
		output(error, "Attempt to use Path.Stopped on a non-humanoid.")
	end
	return (table._events[index] and table._events[index].Event)
		or (index == "LastError" and table._lastError)
		or (index == "Status" and table._status)
		or Path[index]
end

--Used to visualize waypoints
local visualWaypoint = Instance.new("Part")
visualWaypoint.Size = Vector3.new(0.3, 0.3, 0.3)
visualWaypoint.Anchored = true
visualWaypoint.CanCollide = false
visualWaypoint.Material = Enum.Material.Neon
visualWaypoint.Shape = Enum.PartType.Ball

--[[ PRIVATE FUNCTIONS ]]--
local function declareError(self, errorType)
	self._lastError = errorType
	self._events.Error:Fire(errorType)
end

--Create visual waypoints
local function createVisualWaypoints(waypoints)
	local visualWaypoints = {}
	for _, waypoint in ipairs(waypoints) do
		local visualWaypointClone = visualWaypoint:Clone()
		visualWaypointClone.Position = waypoint.Position
		visualWaypointClone.Parent = workspace
		visualWaypointClone.Color =
			(waypoint == waypoints[#waypoints] and Color3.fromRGB(0, 255, 0))
			or (waypoint.Action == Enum.PathWaypointAction.Jump and Color3.fromRGB(255, 0, 0))
			or Color3.fromRGB(255, 139, 0)
		table.insert(visualWaypoints, visualWaypointClone)
	end
	return visualWaypoints
end

--Destroy visual waypoints
local function destroyVisualWaypoints(waypoints)
	if waypoints then
		for _, waypoint in ipairs(waypoints) do
			waypoint:Destroy()
		end
	end
	return
end

--Get initial waypoint for non-humanoid
local function getNonHumanoidWaypoint(self)
	--Account for multiple waypoints that are sometimes in the same place
	for i = 2, #self._waypoints do
		if (self._waypoints[i].Position - self._waypoints[i - 1].Position).Magnitude > 0.1 then
			return i
		end
	end
	return 2
end

--Make NPC jump
local function setJumpState(self)
	pcall(function()
		if self._humanoid:GetState() ~= Enum.HumanoidStateType.Jumping and self._humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
			self._humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end)
end

--Primary move function
local function move(self)
	if self._waypoints[self._currentWaypoint].Action == Enum.PathWaypointAction.Jump then
		setJumpState(self)
	end
	self._humanoid:MoveTo(self._waypoints[self._currentWaypoint].Position)
end

--Disconnect MoveToFinished connection when pathfinding ends
local function disconnectMoveConnection(self)
	self._moveConnection:Disconnect()
	self._moveConnection = nil
end

--Fire the WaypointReached event
local function invokeWaypointReached(self)
	local lastWaypoint = self._waypoints[self._currentWaypoint - 1]
	local nextWaypoint = self._waypoints[self._currentWaypoint]
	self._events.WaypointReached:Fire(self._agent, lastWaypoint, nextWaypoint)
end

local function moveToFinished(self, reached)
	
	--Stop execution if Path is destroyed
	if not getmetatable(self) then return end

	--Handle case for non-humanoids
	if not self._humanoid then
		if reached and self._currentWaypoint + 1 <= #self._waypoints then
			invokeWaypointReached(self)
			self._currentWaypoint += 1
		elseif reached then
			self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
			self._target = nil
			self._events.Reached:Fire(self._agent, self._waypoints[self._currentWaypoint])
		else
			self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
			self._target = nil
			declareError(self, self.ErrorType.TargetUnreachable)
		end
		return
	end

	if reached and self._currentWaypoint + 1 <= #self._waypoints  then --Waypoint reached
		if self._currentWaypoint + 1 < #self._waypoints then
			invokeWaypointReached(self)
		end
		self._currentWaypoint += 1
		move(self)
	elseif reached then --Target reached, pathfinding ends
		disconnectMoveConnection(self)
		self._status = Path.StatusType.Idle
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		self._events.Reached:Fire(self._agent, self._waypoints[self._currentWaypoint])
	else --Target unreachable
		disconnectMoveConnection(self)
		self._status = Path.StatusType.Idle
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		declareError(self, self.ErrorType.TargetUnreachable)
	end
end

--Refer to Settings.COMPARISON_CHECKS
local function comparePosition(self)
	if self._currentWaypoint == #self._waypoints then return end
	self._position._count = ((self._agent.PrimaryPart.Position - self._position._last).Magnitude <= 0.07 and (self._position._count + 1)) or 0
	self._position._last = self._agent.PrimaryPart.Position
	if self._position._count >= self._settings.COMPARISON_CHECKS then
		if self._settings.JUMP_WHEN_STUCK then
			setJumpState(self)
		end
		declareError(self, self.ErrorType.AgentStuck)
	end
end

--[[ STATIC METHODS ]]--
function Path.GetNearestCharacter(fromPosition)
	local character, dist = nil, math.huge
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character and (player.Character.PrimaryPart.Position - fromPosition).Magnitude < dist then
			character, dist = player.Character, (player.Character.PrimaryPart.Position - fromPosition).Magnitude
		end
	end
	return character
end

--[[ CONSTRUCTOR ]]--
function Path.new(agent, agentParameters, override)
	if not (agent and agent:IsA("Model") and agent.PrimaryPart) then
		output(error, "Pathfinding agent must be a valid Model Instance with a set PrimaryPart.")
	end

	local self = setmetatable({
		_settings = override or DEFAULT_SETTINGS;
		_events = {
			Reached = Instance.new("BindableEvent");
			WaypointReached = Instance.new("BindableEvent");
			Blocked = Instance.new("BindableEvent");
			Error = Instance.new("BindableEvent");
			Stopped = Instance.new("BindableEvent");
		};
		_agent = agent;
		_humanoid = agent:FindFirstChildOfClass("Humanoid");
		_path = PathfindingService:CreatePath(agentParameters);
		_status = "Idle";
		_t = 0;
		_position = {
			_last = Vector3.new();
			_count = 0;
		};
	}, Path)

	--Configure settings
	for setting, value in pairs(DEFAULT_SETTINGS) do
		self._settings[setting] = self._settings[setting] == nil and value or self._settings[setting]
	end

	--Path blocked connection
	self._path.Blocked:Connect(function(...)
		if (self._currentWaypoint <= ... and self._currentWaypoint + 1 >= ...) and self._humanoid then
			setJumpState(self)
			self._events.Blocked:Fire(self._agent, self._waypoints[...])
		end
	end)

	return self
end


--[[ NON-STATIC METHODS ]]--
function Path:Destroy()
	for _, event in ipairs(self._events) do
		event:Destroy()
	end
	self._events = nil
	if rawget(self, "_visualWaypoints") then
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
	end
	self._path:Destroy()
	setmetatable(self, nil)
	for k, _ in pairs(self) do
		self[k] = nil
	end
end

function Path:Stop()
	if not self._humanoid then
		output(error, "Attempt to call Path:Stop() on a non-humanoid.")
		return
	end
	if self._status == Path.StatusType.Idle then
		output(function(m)
			warn(debug.traceback(m))
		end, "Attempt to run Path:Stop() in idle state")
		return
	end
	disconnectMoveConnection(self)
	self._status = Path.StatusType.Idle
	self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
	self._events.Stopped:Fire(self._model)
end

function Path:Run(target)

	--Non-humanoid handle case
	if not target and not self._humanoid and self._target then
		moveToFinished(self, true)
		return
	end

	--Parameter check
	if not (target and (typeof(target) == "Vector3" or target:IsA("BasePart"))) then
		output(error, "Pathfinding target must be a valid Vector3 or BasePart.")
	end

	--Refer to Settings.TIME_VARIANCE
	if os.clock() - self._t <= self._settings.TIME_VARIANCE and self._humanoid then
		task.wait(os.clock() - self._t)
		declareError(self, self.ErrorType.LimitReached)
		return false
	elseif self._humanoid then
		self._t = os.clock()
	end

	--Compute path
	local pathComputed, _ = pcall(function()
		self._path:ComputeAsync(self._agent.PrimaryPart.Position, (typeof(target) == "Vector3" and target) or target.Position)
	end)

	--Make sure path computation is successful
	if not pathComputed
		or self._path.Status == Enum.PathStatus.NoPath
		or #self._path:GetWaypoints() < 2
		or (self._humanoid and self._humanoid:GetState() == Enum.HumanoidStateType.Freefall) then
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		task.wait()
		declareError(self, self.ErrorType.ComputationError)
		return false
	end

	--Set status to active; pathfinding starts
	self._status = (self._humanoid and Path.StatusType.Active) or Path.StatusType.Idle
	self._target = target

	--Set network owner to server to prevent "hops"
	pcall(function()
		self._agent.PrimaryPart:SetNetworkOwner(nil)
	end)

	--Initialize waypoints
	self._waypoints = self._path:GetWaypoints()
	self._currentWaypoint = 2

	--Refer to Settings.COMPARISON_CHECKS
	if self._humanoid then
		comparePosition(self)
	end

	--Visualize waypoints
	destroyVisualWaypoints(self._visualWaypoints)
	self._visualWaypoints = (self.Visualize and createVisualWaypoints(self._waypoints))

	--Create a new move connection if it doesn't exist already
	self._moveConnection = self._humanoid and (self._moveConnection or self._humanoid.MoveToFinished:Connect(function(...)
		moveToFinished(self, ...)
	end))

	--Begin pathfinding
	if self._humanoid then
		self._humanoid:MoveTo(self._waypoints[self._currentWaypoint].Position)
	elseif #self._waypoints == 2 then
		self._target = nil
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		self._events.Reached:Fire(self._agent, self._waypoints[2])
	else
		self._currentWaypoint = getNonHumanoidWaypoint(self)
		moveToFinished(self, true)
	end
	return true
end

return Path]]></ProtectedString>
							<int64 name="SourceAssetId">6744337775</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX07A6BF0CEE194D30BEDF9D2C365CBA93">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{89336CEE-15B0-41C3-A895-402E1DB2DBD5}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "SimplePath",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 6744337775,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @V3N0M_Z"},
		{Text = "Description: A simple pathfinding library, easy to use and Powerful."},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXB6C049128F4744B18186C37402227508">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Ragdoll</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX51768E03097B4EC6920B4430CCFB503A">
						<Properties>
							<BinaryString name="AttributesSerialize"><![CDATA[AwAAAA4AAABEZWJ1Z1ByaW50TW9kZQMAFwAAAFNldE5QQ093bmVyc2hpcFRvU2VydmVyAwEH
AAAAVmVyc2lvbgIDAAAAMS4x]]></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Ragdoll</string>
							<string name="ScriptGuid">{8E304F84-1BAE-452E-9943-A840FA7A797B}</string>
							<ProtectedString name="Source"><![CDATA[

local RunService = game:GetService("RunService")


local debugPrintMode = script:GetAttribute("DebugPrintMode")

local ragdollModule = {}

local ragdollData = {}

local RagdollModes = script.RagdollModes

local function getConstraintType(motor, modeModule)
	if modeModule.Motors[motor.Name] then
		return modeModule.Motors[motor.Name]
	end
	for constraintType, constraintValue in modeModule.Motors do
		if string.find(motor.Name, constraintType) then
			return constraintValue
		end
	end
	return modeModule.DefaultConstraintType or "Default"
end

local function getLimbAttachments(motor, r6)
	if r6 then
		local name = "RagdollMotorAttachment"
		local at0 = Instance.new("Attachment")
		local at1 = Instance.new("Attachment")
		at0.CFrame = motor.C0
		at1.CFrame = motor.C1
		at0.Name = name
		at1.Name = name
		at0.Parent = motor.Part0
		at1.Parent = motor.Part1
		return at0, at1
	end
	
	local joint_name = motor.Name
	local part0 = motor.Part0
	local at0 = motor.Parent:FindFirstChild(joint_name.."Attachment") or motor.Parent:FindFirstChild(joint_name.."RigAttachment")
	local at1 = part0:FindFirstChild(joint_name.."Attachment") or part0:FindFirstChild(joint_name.."RigAttachment")
	
	while motor and not at0 do
		motor.Parent.ChildAdded:Wait()
		at0 = motor.Parent:FindFirstChild(joint_name.."Attachment") or motor.Parent:FindFirstChild(joint_name.."RigAttachment")
	end
	while motor and not at1 do
		part0.ChildAdded:Wait()
		at1 = part0:FindFirstChild(joint_name.."Attachment") or part0:FindFirstChild(joint_name.."RigAttachment")
	end
	if not motor then
		return
	end
	return at0, at1
end

local function applyImpact(character: Model, impactData: table)
	--[[impactData
			Part: Can be [Part in character] or [name of part in character]. If nil then this will default to HumanoidRootPart if available
			Hit: [Vector3] Position on impactData.Part to apply impact. If nil then defaults to impactData.Part's position
			Direction: [Vector3] Direction of impact
			Speed: [number] Speed of impact (default = 350)
			Lifetime: [number] Amount of time that the impact will last (default = 0.3)
			UseLinearVelocity: [bool] If true, use a LinearVelocity Instance instead of VectorForce Instance
	]]
	local part = typeof(impactData.Part) == "Instance" and impactData.Part or (not impactData.Part and character:FindFirstChild("HumanoidRootPart")) or character:FindFirstChild(impactData.Part)
	if part then
		if part:IsA("Accessory") then
			part = part:FindFirstChildOfClass("BasePart")
		end
		if part and part:IsDescendantOf(character) and impactData.Direction then
			local speed = impactData.Speed or 350
			local unit = impactData.Direction.Unit
			if not (unit.Magnitude > 0) then
				return
			end
			
			local impactPoint = Instance.new("Attachment")
			impactPoint.Name = "ImpactPoint"
			impactPoint.Parent = part
			impactPoint.Position = impactData.Hit or part.Position
			
			local force
			if impactData.UseLinearVelocity then
				force = Instance.new("LinearVelocity")
				force.ForceLimitsEnabled = false
				force.VectorVelocity = unit * speed
			else
				force = Instance.new("VectorForce")
				force.Force = unit * speed
			end
			force.Attachment0 = impactPoint
			force.Name = "ImpactVelocity"
			force.Parent = part
			
			
			force.RelativeTo = Enum.ActuatorRelativeTo.World
			
			task.delay(impactData.Lifetime or 0.3, function()
				if force then
					force:Destroy()
				end
				if impactPoint then
					impactPoint:Destroy()
				end
			end)
		end
	end
end

local function rigMotor(character, motor, modeModule, r6)
	if not motor:IsA("Motor6D") then
		return
	end
	
	local constraints = getConstraintType(motor, modeModule)
	if constraints == "None" then
		if debugPrintMode then
			print("[" .. script.Name ..  "] ConstraintType: [None] applied to Motor: [" .. motor.Name .. "]")
		end
		return
	end
	if typeof(constraints) == "string" then
		constraints = {constraints}
	end
	
	local attach0, attach1 = getLimbAttachments(motor, r6)
	if r6 then
		local data = ragdollData[character]
		table.insert(data.R6Attachments, attach0)
		table.insert(data.R6Attachments, attach1)
	end

	local newConstraintAdded = false
	
	for _, constraintValue in constraints do
		local isConstraintInstance = typeof(constraintValue) == "Instance"
		local constraintName = isConstraintInstance and constraintValue.Name or constraintValue
		if debugPrintMode then
			print("[" .. script.Name ..  "] ConstraintType: [" .. constraintName .. "] applied to Motor: [" .. motor.Name .. "]")
		end
		
		if not isConstraintInstance and not modeModule.ConstraintTypes[constraintValue] then
			if debugPrintMode then
				warn("[" .. script.Name ..  "] Missing ConstraintType: [" .. constraintName .. "]")
			end
			continue
		end
		local newConstraint
		if not isConstraintInstance then
			newConstraint = modeModule.ConstraintTypes[constraintValue](character, motor, r6, attach0, attach1)
		else
			newConstraint = constraintValue:Clone()
		end
		
		if newConstraint then
			newConstraintAdded = true
			newConstraint.Name = "Ragdoll" .. newConstraint.ClassName
			
			local usePart0 = pcall(function()
				newConstraint.Part0 = newConstraint.Part0
			end)
			if usePart0 then
				newConstraint.Part0 = motor.Part0
				newConstraint.Part1 = motor.Part1
			else
				if not attach0 then
					newConstraint:Destroy()
					continue
				end
				newConstraint.Attachment0 = attach0
				newConstraint.Attachment1 = attach1
			end
			newConstraint.Enabled = false
			newConstraint.Parent = motor.Parent

			table.insert(ragdollData[character].Constraints, newConstraint)
		end
	end
	if newConstraintAdded then
		table.insert(ragdollData[character].Motors, motor)
	elseif debugPrintMode then
		warn("[" .. script.Name .. "] No return value among ConstraintTypes: [", constraints, "] (Motor: [" .. motor.Name .. "])")
	end
end

local function addToMotorsTable(motors: table, newEntry: Instance, nameOverride: string)
	local name = nameOverride or newEntry.Name
	
	if name == "Default" then
		table.insert(motors, newEntry)
		return
	end
	
	if not motors[name] then
		motors[name] = {}
	end
	table.insert(motors[name], newEntry)
end

local function loadRagdollMode(instance: Instance)
	if instance:IsA("ModuleScript") then
		return require(instance)
	elseif instance:IsA("Folder") then
		local modeData = {}
		
		local constraintsFolder = instance:FindFirstChild("Constraints")
		local settingsFolder = instance:FindFirstChild("Settings")
		local functionsModule = instance:FindFirstChild("RagdollStateFunctions")
		functionsModule = functionsModule and require(functionsModule)
		modeData.Motors = {}
		modeData.ConstraintTypes = "LoadedFromInstance"
		modeData.DefaultConstraintType = {}
		
		if constraintsFolder then
			for _, constraintType in constraintsFolder:GetChildren() do
				local selectedMotorsTable
				if constraintType.Name == "Default" then	
					selectedMotorsTable = modeData.DefaultConstraintType
				else
					selectedMotorsTable = modeData.Motors
				end
				if constraintType:IsA("Folder") then
					for _, subConstraintType in constraintType:GetChildren() do
						if subConstraintType:IsA("StringValue") and subConstraintType.Value == "None" then
							if debugPrintMode then
								warn("[" .. script.Name .. "]" .. [[ Do not use keyword "None" inside a Folder]])
							end
							continue
						end
						addToMotorsTable(selectedMotorsTable, subConstraintType, constraintType.Name)
					end
				else
					if constraintType:IsA("StringValue") and constraintType.Value == "None"  then
						modeData.Motors[constraintType.Name] = "None"
						continue
					end
					addToMotorsTable(selectedMotorsTable, constraintType)
				end
			end
		end
		
		if #modeData.DefaultConstraintType == 0 then
			modeData.DefaultConstraintType = "None"
		end
		
		if settingsFolder then
			for _, setting in settingsFolder:GetChildren() do
				modeData[setting.Name] = setting.Value
			end
		end
		
		if functionsModule then
			for name, func in functionsModule do
				modeData[name] = func
			end
		end
		
		return modeData
	end
	if debugPrintMode then
		warn("[" .. script.Name .. "] Unsupported Ragdoll Mode type [" .. instance.ClassName .. "] (Must be a Folder or ModuleScript)")
	end
end

local function onPlayerAdded(player: Player, ragdollMode: string)
	if player.Character then
		task.spawn(function()
			ragdollModule.RigCharacter(player.Character, ragdollMode)
		end)
	end
	player.CharacterAdded:Connect(function(character)
		ragdollModule.RigCharacter(character, ragdollMode)
	end)
end

function ragdollModule.RigPlayers(ragdollMode: string)
	if ragdollModule.PlayersRigged then
		return
	end
	ragdollModule.PlayersRigged = true
	for _, player in game.Players:GetPlayers() do
		task.spawn(onPlayerAdded, player, ragdollMode)
	end
	game.Players.PlayerAdded:Connect(function(player)
		onPlayerAdded(player, ragdollMode)
	end)
end

function ragdollModule.RigCharacter(character:Model, ragdollMode: string)
	local humanoid = character:WaitForChild("Humanoid")
	local r6 = humanoid.RigType.Value == 0
	
	local defaultMode = RagdollModes:GetAttribute("DefaultMode")
	
	local modeModuleObject = ragdollMode and RagdollModes:FindFirstChild(ragdollMode) or 
		(defaultMode and defaultMode ~= "" and RagdollModes:FindFirstChild(defaultMode) or RagdollModes:FindFirstChild("Default"))
	local modeModule = loadRagdollMode(modeModuleObject)
	
	local r6ModeModule = modeModule.R6RagdollMode
	if r6ModeModule and r6 then
		if typeof(r6ModeModule) == "table" then
			modeModule = r6ModeModule
		elseif typeof(r6ModeModule) == "string" then
			modeModule = loadRagdollMode(RagdollModes:FindFirstChild(r6ModeModule))
		elseif typeof(r6ModeModule) == "Instance" and (r6ModeModule:IsA("ModuleScript") or r6ModeModule:IsA("Folder")) then
			modeModule = loadRagdollMode(r6ModeModule)
		elseif debugPrintMode then
			warn("[" .. script.Name .. "] Unsupported R6RagdollMode type. Must be a string(that matches a module in RagdollModes folder), ModuleScript (return table or object)")
		end
	end
	
	if ragdollData[character] then
		ragdollModule.UnrigCharacter(character)
	end
	ragdollData[character] = {Motors = {}, Constraints = {}, Connections = {}, R6Attachments = {}, RagdollMode = modeModule}
	local data = ragdollData[character]
	
	
	humanoid.BreakJointsOnDeath = modeModule.BreakJointsOnDeath
	
	local player = game.Players:GetPlayerFromCharacter(character)
	local stateManager = player and character:FindFirstChild("PlayerRagdollManager") or character:FindFirstChild("NPCRagdollManager")
	
	if not stateManager then
		stateManager = player and script.PlayerRagdollManager:Clone() or script.NPCRagdollManager:Clone()
		stateManager.Parent = character
		stateManager.Enabled = true
	end

	for _, instance in pairs(character:GetDescendants()) do
		task.spawn(rigMotor, character, instance, modeModule, r6)
	end
	data.Connections.DescendantAdded = character.DescendantAdded:Connect(function(instance)
		rigMotor(character, instance, modeModule, r6)
	end)
	data.Connections.Destroyed = character:GetPropertyChangedSignal("Parent"):Connect(function()
		if not character.Parent then
			ragdollModule.UnrigCharacter(character)
		end
	end)

	data.Functions = {}
	data.Functions.PreRagdollEnabledFunction = modeModule.PreRagdollEnabledFunction
	data.Functions.AfterRagdollEnabledFunction = modeModule.AfterRagdollEnabledFunction
	data.Functions.PreRagdollDisabledFunction = modeModule.PreRagdollDisabledFunction
	data.Functions.AfterRagdollDisabledFunction = modeModule.AfterRagdollDisabledFunction
	
	data.Functions.RagdollRiggedFunction = modeModule.RagdollRiggedFunction
	data.Functions.RagdollUnriggedFunction = modeModule.RagdollUnriggedFunction
	
	if data.Functions.RagdollRiggedFunction then
		data.Functions.RagdollRiggedFunction(character, data)
	end
	character:SetAttribute("RagdollMode", modeModuleObject.Name)
	character:SetAttribute("RagdollLoaded", true)
end

function ragdollModule.UnrigCharacter(character:Model)
	local data = ragdollData[character]
	if not data then
		return
	end
	if character.Parent then
		ragdollModule.DisableRagdoll(character)
		character:SetAttribute("RagdollLoaded", false)
		character:SetAttribute("RagdollMode", nil)
		if character:FindFirstChild("Humanoid") then
			character.Humanoid.BreakJointsOnDeath = true
		end
	end
	
	for _, connection in data.Connections do
		connection:Disconnect()
	end
	for i, constraint in data.Constraints do
		constraint:Destroy()
	end
	for _, attachment in data.R6Attachments do
		attachment:Destroy()
	end
	if data.Functions.RagdollUnriggedFunction then
		data.Functions.RagdollUnriggedFunction(character, data)
	end
	ragdollData[character] = nil
end

function ragdollModule.EnableRagdoll(character: Model, impactData: table)
	--Check if character is fully loaded and not already in ragdoll state
	if not character then
		return
	end
	if not character:GetAttribute("RagdollLoaded") then
		if debugPrintMode then
			warn("[" .. script.Name ..  "] (Enable) Ragdoll module not initialized for character: " .. character:GetFullName())
		end
		return
	end
	if character:GetAttribute("Ragdolled") then
		return
	end
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoidRootPart or not humanoid then
		return
	end
	
	local data = ragdollData[character]
	
	if data.Functions.PreRagdollEnabledFunction then
		local returnValue = data.Functions.PreRagdollEnabledFunction(character, data, impactData)
		if returnValue == "Sink" then
			return
		elseif typeof(returnValue) == "table" then
			impactData = returnValue
		end
	end
	
	if script:GetAttribute("SetNPCOwnershipToServer") and not game.Players:GetPlayerFromCharacter(character) then
		if humanoidRootPart:CanSetNetworkOwnership() then
			humanoidRootPart:SetNetworkOwner(nil)
		end
	end
	

	--Update ragdoll state
	character:SetAttribute("Ragdolled", true)

	--Set humanoid states and root part properties
	
	--humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
	--humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
	humanoid.AutoRotate = false

	humanoidRootPart.CanCollide = false
	
	

	--Enable constraints, disable motors
	for _, constraint in data.Constraints do
		constraint.Enabled = true
	end
	for _, motor in data.Motors do
		motor.Enabled = false
	end
	
	--Apply impact velocity if available
	if impactData then
		--RunService.Heartbeat:Wait()
		applyImpact(character, impactData)
	end
	
	if data.Functions.AfterRagdollEnabledFunction then
		data.Functions.AfterRagdollEnabledFunction(character, data, impactData)
	end
end

function ragdollModule.DisableRagdoll(character: Model)
	--Check if character is fully loaded and not already in ragdoll state
	if not character then
		return
	end
	if not character:GetAttribute("RagdollLoaded") then
		if debugPrintMode then
			warn("[" .. script.Name ..  "] (Disable) Ragdoll module not initialized for character: " .. character:GetFullName())
		end
		return
	end
	if not character:GetAttribute("Ragdolled") then
		return
	end
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoidRootPart or not humanoid then
		return
	end
	
	local data = ragdollData[character]
	
	if data.Functions.PreRagdollDisabledFunction then
		local returnValue = data.Functions.PreRagdollDisabledFunction(character, data)
		if returnValue == "Sink" then
			return
		end
	end
	
	
	humanoidRootPart.CanCollide = true
	humanoid.AutoRotate = true

	for _, constraint in data.Constraints do
		constraint.Enabled = false
	end
	for _, motor in data.Motors do
		motor.Enabled = true
	end

	character:SetAttribute("Ragdolled", false)
	
	if data.Functions.AfterRagdollDisabledFunction then
		data.Functions.AfterRagdollDisabledFunction(character, data)
	end
	
	if script:GetAttribute("SetNPCOwnershipToServer") and not game.Players:GetPlayerFromCharacter(character) then
		if humanoidRootPart:CanSetNetworkOwnership() then
			humanoidRootPart:SetNetworkOwnershipAuto()
		end
	end
end

return ragdollModule
]]></ProtectedString>
							<int64 name="SourceAssetId">87270072599288</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="LocalScript" referent="RBXCB6E34BAC7C144A6BDBF6C9888EAE1EC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PlayerRagdollManager</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{EFD9B0BF-F10B-4980-876C-70179BB2FAD4}</string>
								<ProtectedString name="Source"><![CDATA[local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid: Humanoid = character:WaitForChild("Humanoid")
character:GetAttributeChangedSignal("Ragdolled"):Connect(function()
	local newState = character:GetAttribute("Ragdolled")
	if newState then
		humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
	else
		humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
		
	end
end)]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX5654BBC5FA8F42C6B65B1C3180F3F359">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">NPCRagdollManager</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{A7423B39-4798-4387-99C8-D47F9250D4F4}</string>
								<ProtectedString name="Source"><![CDATA[local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")

character:GetAttributeChangedSignal("Ragdolled"):Connect(function()
	local newState = character:GetAttribute("Ragdolled")
	if newState then
		humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
	else
		humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)

	end
end)
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5FFCD9EDA2144FE1B926A2AA44A27494">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LoadConstraintTypes</string>
								<string name="ScriptGuid">{C2785C36-4B55-48B5-9413-90FC41493514}</string>
								<ProtectedString name="Source"><![CDATA[local Ragdoll = script.Parent
local ConstraintTypes = Ragdoll.ConstraintTypes

return function(...)
	local constraintTypeModules = {...}
	
	local sendingTable = {}
	
	for _, constraintTypeModule in constraintTypeModules do
		local module = constraintTypeModule
		if typeof(module) == "string" then
			module = ConstraintTypes:FindFirstChild(module)
		end
		
		if module then
			
			if typeof(module) ~= "table" then
				module = require(module)
			end
			for i, v in module do
				sendingTable[i] = v
			end
			
		elseif Ragdoll:GetAttribute("DebugPrintMode") then
			if constraintTypeModule then
				warn("Module: [" .. constraintTypeModule .. "] does not exist in ConstraintTypes folder(" .. ConstraintTypes:GetFullName() .. ")")
			else
				warn("ConstraintType module does not exist")
			end
		end
	end
	
	return sendingTable
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Script" referent="RBXBF456047421246B8BC897062374A673C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">(READ ME) Instructions</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{4242C3B8-5CB8-41EC-8235-95A70A9326D6}</string>
								<ProtectedString name="Source"><![CDATA[--[[
Made by Ike
Devforum Post: https://devforum.roblox.com/t/customizable-ragdoll-module-create-your-own-custom-ragdolls/3545305

FEATURES
	
	R15 and R6 compatibility
	Player and NPC support
	Premade scripts (Button to Ragdoll, Ragdoll Death)
	Customizable: You can create your own ragdoll settings
	Multiple RagdollModes: You can rig each character with different ragdoll settings

QUICKSTART
	
	You can place the Ragdoll Module where you'd like, but I recommend placing it in ServerScriptService
	This module comes with a default RagdollMode that should work just fine for most users, and is optimized for both R15 and R6.
	I have made two scripts (Button to Ragdoll, Ragdoll Death) that you can use to easily add this module into your experience
	These are located in the PremadeScripts Folder in the module. See the README in this folder for installation instructions.
	See section "PREMADE SCRIPTS SETTINGS" for settings
	
BASIC USAGE

	1.
	Load the module
	local Ragdoll = require(ServerScriptService.Ragdoll)
	2. Rig characters, you can do this by rigging each character individually
		Ragdoll.RigCharacter(character, ragdollMode)
		--if ragdollMode is nil, then it will apply a default value (either the RagdollModes Folder's DefaultMode attribute or "Default")
		--If the character is already rigged, this function will automatically unrig the character before rigging it again with the new ragdollMode
		--It's a good idea to run this as soon as possible instead of rigging, then immediately ragdolling. But if you can't avoid it, it should still work fine
	OR you can rig every player and players that join after by using
		Ragdoll.RigPlayers(ragdollMode)
	3. Ragdoll/unragdoll the character
		Ragdoll.EnableRagdoll(character, impactData) --(impactData is explained in the Module Functions section)
		Ragdoll.DisableRagdoll(character)


MODULE SETTINGS
	DebugPrintMode: Gives information that may be helpful when debugging, especially for catching typos
	(RagdollModes Folder) DefaultMode: Set this to the name of a module in this folder that you want to be the default mode. If this is blank, "Default" will be used instead


PREMADESCRIPTS SETTINGS
	
	Each script has settings that you can change. These will either be an attribute ( in the Property window) or as a module named "Configuration"
	The following section will explain what each setting does

	PressButtonToRagdoll
		(ButtonRagdollServer)
			RagdollMode: Set this to the name of the RagdollMode you want to use (in RagdollModes folder), will use the default RagdollMode if empty
			AutoRigPlayers: If enabled, automatically rigs every player and players who join later. If using multiple scripts that have this setting,
				make sure to only have it enabled on one script
			ApplyMoveDirectionVelocity: If enabled, adds Humanoid's MoveDirection to ragdoll's velocity
		
		(ButtonRagdollClient Configuration Module)
			Cooldown: How many seconds until player can ragdoll again
			CreateMobileButton: If true, will make a mobile button
			KeyCode: Keyboard button to activate
			ControllerCode: Controller button to activate
			RemoteEvent: RemoteEvent to fire to toggle ragdoll state
	
	RagdollDeath
		RagdollMode: Set this to the name of the RagdollMode you want to use (in RagdollModes folder), will use the default RagdollMode if empty
		AutoRigPlayers: If enabled, automatically rigs every player and players who join later. If using multiple scripts that have this setting,
				make sure to only have it enabled on one script
		ApplyMoveDirectionVelocity: If enabled, adds Humanoid's MoveDirection to ragdoll's velocity
		FixDoubleDeathSound: Fixes double death sound by removing the player's HumanoidStateManager on death
		CreateDummy: If enabled creates a separate character on death. this prevents it from being destroyed when the character respawns
			Note: If you enable this, make sure to place the DummyCamera localscript in StarterPlayerScripts (this script is located in the RagdollDeath script)
		DummyLifetime: If CreateDummy is enabled, after this amount of seconds, the dummy will be removed
			
		


CREATING A NEW RAGDOLLMODE

	(Check out the ExampleTemplate Module in RagdollModes Folder for detailed explanations on what everything does.)
	
	Create a new RagdollMode ModuleScript
		Open the RagdollModes folder. Every RagdollMode needs to be placed here to work. You can copy and paste the Default or ExampleTemplate ModuleScript
		to use as a base if you would like
		and modify those if you would like. ExampleTemplate lists and explains every setting/function in detail.
		
	Create a ConstraintTypes (table or ModuleScript in ConstraintTypes Folder)
	If you use a ModuleScript, I have created a module to load multiple ConstraintTypes modules, 
	you can use this module by doing 
		local LoadConstraintTypes = require(Ragdoll.LoadConstraintTypes)
		local ConstraintTypes = LoadConstraintTypes("Example", "Example2")
	You can load as many as you want, just note that each module will overwrite each module to the left of it (this only applies to matching entries)
	(example: "ConstraintType1" in "Example2" will overwrite "ConstraintType1" in "Example")
	This is the format for each ConstraintType in the ConstraintTypes table
		ConstraintTypes.ConstraintName = function(character, motor, r6, attach0, attach1) --You can omit the parameters if you aren't using them
			local newConstraint = Instance.new([ClassName]) --This instance needs an Enabled property and either a Attachment0/1 or Part0/1 property to work
			--modify newConstraint
			return newConstraint
		end
	(IMPORTANT) Make sure to set the RagdollMode.ConstraintTypes to the ConstraintTypes table
	Once you are done creating your ConstraintTypes table, now you can pick which ConstraintType is applied to each motor in the RagdollMode.Motors table
	Motors table format:
		MotorName = "ConstraintType"
	MotorName is the characters motor that "ConstraintType" will be applied to
	The MotorName can either be the exact Motor6D name or a part of it. For example MotorName "RightShoulder" will only apply to the "RightShoulder" Motor6D,
	while MotorName "Shoulder" will apply to both Motor6Ds "LeftShoulder" and "RightShoulder"
	"ConstraintType" can also be set to a table to apply multiple ConstraintTypes to one Motor6D (MotorName = {"ConstraintType1", "ConstraintType2"})
	This can be useful if you want to add trails to your ragdoll
	If a MotorName is set to nil it will use the RagdollMode.DefaultConstraintType value (below the Motors table). If set to "None" that motor will be
	skipped and will not be disabled when the character ragdolls
	If RagdollMode.DefaultConstraintType is not set, it will default to "Default"
	There are two more settings: R6RagdollMode and BreakJointsOnDeath, both these settings can be deleted if you aren't using them
		R6Ragdollmode: if the characters rig is R6, this RagdollMode will be loaded instead. If this is set to nil, then the current RagdollMode will be used for both
			R6 and R15
			This value can be a ModuleScript object, a loaded ModuleScript, or a string (must match a ModuleScript in RagdollModes Folder)
		BreakJointsOnDeath: disables the character falling apart on death (defaults to false)
	There are also four functions that fire when the character is ragdolled/unragdolled. See the ExampleTemplate for instructions on how to use these.
	If you don't need them, they can be deleted
	Your RagdollMode should now be ready to use! Don't forget to test it and if you are using my PremadeScripts, then change the RagdollMode setting to your new
	RagdollMode
	
	


MODULE FUNCTIONS
	
	Ragdoll.RigCharacter(character, ragdollMode)
		Rigs character by setting up attachments and constraints using ragdollMode
		Before rigging, this function will automatically unrig the character if it is already rigged
		if ragdollMode is nil, it will default to the default RagdollMode folder setting or "Default"
	
	Ragdoll.UnrigCharacter(character)
		Removes constraints and new attachments created, and unragdolls the character
		
	Ragdoll.EnableRagdoll(character, impactData)
		Will ragdoll the character if it is rigged, and not already in a ragdolled state,
		impactData affects the velocity applied to the character (this can be nil for no added velocity)
		
		impactData usage:
			impactData = {
				Part = Can be [Part in character] or [name of part in character]. If nil then this will default to HumanoidRootPart if available
				Hit = [Vector3] Position on impactData.Part to apply impact. If nil then defaults to impactData.Part's position
				Direction = [Vector3] Direction of impact
				Speed = [number] Speed of impact (default = 350)
				Lifetime = [number] Amount of time that the impact will last (default = 0.3)
				UseLinearVelocity = [bool] If true, use a LinearVelocity Instance instead of VectorForce Instance
			}
			
	Ragdoll.DisableRagdoll(character)
		Will unragdoll the character if it is rigged, and in a ragdolled state
		This function will be called automatically when UnrigCharacter() is called

	Ragdoll.RigPlayers(ragdollMode)
		Automatically rigs every player with the provided ragdollMode
		If this function was already run, it will not run again
	

CHARACTER ATTRIBUTES

	These are the attributes applied to each character model rigged by this module:
		Ragdolled = boolean : This is enabled when the character is in a ragdolled state
		RagdollLoaded = boolean : This is enabled after character is done being rigged and is ready to be ragdolled
		RagdollMode = string : This is the currently selected RagdollMode for the character (Note that this will not change if R6RagdollMode setting gets applied)

]]
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX815236F28B144999A0B519E4856EE024">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABEZWZhdWx0TW9kZQIHAAAARGVmYXVsdA==</BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">RagdollModes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXB882D1A8560E457C91EEC39F5AD83793">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Elastic</string>
									<string name="ScriptGuid">{54703410-B92A-4D7E-ACB3-8A5D25554277}</string>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}
local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes)

local ConstraintTypes = LoadConstraintTypes("Default")

ConstraintTypes.Default = function()
	local constraint = Instance.new("BallSocketConstraint")
	return constraint
end

ragdollMode.Motors = {
	Root = "Weld",
	Neck = "NeckHinge",
	Wrist = "WristAnkleSocket",
	Ankle = "WristAnkleSocket",
}
ragdollMode.DefaultConstraintType = "Default"
ragdollMode.ConstraintTypes = ConstraintTypes

return ragdollMode
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX68D6D4B5AAF0434AB177EF0695CBD746">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rope</string>
									<string name="ScriptGuid">{675C62F8-B551-4264-95A9-6FDD6B1B9115}</string>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}
local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes)

local ConstraintTypes = LoadConstraintTypes("Default")

ConstraintTypes.Default = function(character, motor)
	local constraint = Instance.new("RopeConstraint")
	constraint.Visible = true
	constraint.Color = motor.Parent.BrickColor
	constraint.Length = 2
	return constraint
end
ConstraintTypes.Trail = function()
	local trail = Instance.new("Trail")
	trail.Lifetime = 0.1
	trail.Transparency = NumberSequence.new(0.5, 1)
	trail.WidthScale = NumberSequence.new(0.8, 0)
	return trail
end

ragdollMode.Motors = {
	Neck = "NeckHinge",
	Root = "Weld",
	Wrist = "WristAnkleSocket",
	Ankle = "WristAnkleSocket",
	Waist = "Weld",
}
ragdollMode.DefaultConstraintType = {"Default", "Trail"}
ragdollMode.ConstraintTypes = ConstraintTypes

return ragdollMode
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX865DAE86E2DE42AC8BE3FB5B0F3773E3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ExampleTemplate</string>
									<string name="ScriptGuid">{A128E68D-9D38-428F-BA7A-3C793A694AF0}</string>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}

local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes) --Loads ConstraintTypes from ConstraintType Folder

local ConstraintTypes = LoadConstraintTypes("Default") -- List all the Constraint Types you want to load (continued on next line)
--(continued) Matching ConstraintTypes will be overwritten by the next argument (example LoadConstraintTypes("a", "b") "b" will overwrite "a")
--(continued) Values with Different names will not be overwritten (example "Weld" will only overwrite which has the name "Weld")
--(continued) Accepted argument types: String ("" [Must be in Ragdoll.ConstraintTypes]), ModuleScript (Instance), or a table (can be a loaded ModuleScript)

ConstraintTypes.Example = function(character, motor, r6, attach0, attach1) -- This is an example ConstraintTypes entry that I will use to explain its function
	--Notice that this entry is local to this script only and will not write to the "Default" ModuleScript it is loaded from. This is a feature of the
	--LoadConstraintTypes ModuleScript
	--If you use a loaded ModuleScript as your ConstraintTypes table (example: require(ConstraintTypes.Default)) any entry you make will write to that Module,
	--and also overwrite that entry if there is a matching one
	--[[Parameters: 
		character: The characterModel being rigged
		motor: The motor that this ConstraintType is being applied to
		r6: This is true if the character is an R6 rig
		attach0, attach1: These are the attachments used by the ConstraintType. if the character's rig is R6, new attachments will be made when rigging the character,
		but if the rig is R15, it will use the attachments already created by Roblox's CoreScripts, so be careful when modifying these
		]]
	
	local newConstraint = Instance.new("BallSocketConstraint") --The constraint instance to be used. Make sure to return this and only one constraint per ConstraintType
	--The requirements for a constraint is that it needs an Enabled property and either a Part0/Part1 or Attachment0/Attachment1 property
	
	newConstraint.LimitsEnabled = true
	--Modify the constraint before returning if you wish
	
	return newConstraint --Return the newly created constraint
end


ragdollMode.Motors = { --Applied motors. The only keyword is "None", this keyword will skip that motor, meaning it won't be disabled when ragdolling
	--You can apply multiple ConstraintTypes to each motor by using a table (example: Waist = {"Weld", "Example", "Trail"})
	Root = "Weld", --"Root" is the motor in the character model, "Weld" is the ConstraintType

	Neck = "NeckHinge", 
	Waist = "Weld",

	Shoulder = "Default",
	Elbow = "ElbowSocket",
	Wrist = "WristAnkleSocket",

	Hip = "Default",
	Knee = "KneeSocket",
	Ankle = "WristAnkleSocket",
}
--Motors: 

ragdollMode.R6RagdollMode = nil --Will load this module instead if character rig is R6
ragdollMode.DefaultConstraintType = "None" --Default ConstraintType, this value will be used when a Motor is set to nil
ragdollMode.ConstraintTypes = ConstraintTypes --This is the table of ConstraintTypes that this module will be using during gameplay
ragdollMode.BreakJointsOnDeath = false --Defaults to true


-- Below are the functions that will fire when the character's ragdoll enables or disables, rigs/ unrigs
-- You can delete these if you don't want to use them
-- The Pre function fires before changes are made to the character, and After is once all changes are made
-- The Rigged function fires right after the rigData table is created, Unrigged fires right before the rigData table is deleted
-- Returning "Sink" for the Pre functions will cancel the ragdoll enable/disable
-- You can change data in impactData and it will affect the characters velocity, just make sure to check if impactData exists before trying to make changes
--(example) if impactData then impactData.Speed *= 2 end
-- If you set impactData to a new table (example impactData = {}) in the PreRagdollEnableFunction, the main module will not use that new table
-- To get around this, you can return the new table. So any table set as the return value will be used as impactData in the main module
-- Changing impactData in the AfterRagdollEnabledFunction doesn't do anything. It is there mainly for if you want to see if impactData is being updated properly

--rigData is a table that is created when a character is rigged. It is structured like so:
--Constraints: Constraints created by the current RagdollMode
--Motors: Character's Motor6Ds that are in use by the current RagdollMode
--R6Attachments: A table of attachments that is created when rigging if the character's rig is R6
--Connections: A table of connections made when rigging the character (mainly used for cleanup, and to rig motors)
--RagdollMode: The loaded RagdollMode Module
--Functions: A table of the below functions ([Pre/After]Ragdoll[Enabled/Disabled]Function)

--You will probably only need the Constraints table and maybe the Motors or R6Attachments table, the rest you can ignore

ragdollMode.PreRagdollEnabledFunction = function(character, rigData, impactData)

end
ragdollMode.AfterRagdollEnabledFunction = function(character, rigData, impactData)

end
ragdollMode.PreRagdollDisabledFunction = function(character, rigData, beingUnrigged)

end
ragdollMode.AfterRagdollDisabledFunction = function(character, rigData, beingUnrigged)

end

ragdollMode.RagdollRiggedFunction = function(character, rigData)
	
end
ragdollMode.RagdollUnriggedFunction = function(character, rigData)
	
end

return ragdollMode
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2C76B34A850D4855AC7DD7E7A0ED3A63">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">DefaultR6</string>
									<string name="ScriptGuid">{B0778628-2758-49CE-A5D7-D6E345B3BB08}</string>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}
local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes)

local ConstraintTypes = LoadConstraintTypes("Default", "R6AttachmentFix")


ragdollMode.Motors = {
	Root = "Weld",

	Neck = "NeckHinge",
	Shoulder = {"Default", "R6ShoulderFix"},
	Hip = {"Default", "R6HipFix"},
}

ragdollMode.DefaultConstraintType = "Default"
ragdollMode.ConstraintTypes = ConstraintTypes

ragdollMode.PreRagdollEnabledFunction = function(character, rigData, impactData)
	
	if not impactData or (impactData.Direction and impactData.Direction.Magnitude == 0) then
		local root = character:FindFirstChild("HumanoidRootPart")
		local humanoid = character:FindFirstChild("Humanoid")
		if root and humanoid and humanoid.MoveDirection.Magnitude == 0 then
			local params = RaycastParams.new()
			params.FilterType = Enum.RaycastFilterType.Exclude
			params.FilterDescendantsInstances = {character}
			local result = workspace:Raycast(root.Position, root.CFrame.UpVector * -3.5, params)
			if result then
				impactData = {
					Part = root,
					Speed = 13,
					Direction = root.CFrame.LookVector * -1,
					Lifetime = 0.13,
					UseLinearVelocity = true,
				}
				return impactData
			end
		end
	else
		impactData.Speed /= 1.917
	end
end

return ragdollMode
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9674C0A199454E76A01302C5DBA46E36">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Default</string>
									<string name="ScriptGuid">{C8C0CE77-8AC9-42C4-9ACD-918FF5A5E693}</string>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}
local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes)

local ConstraintTypes = LoadConstraintTypes("Default")

ragdollMode.Motors = {
	Root = "Weld",

	Neck = "NeckHinge",
	Waist = "Weld",

	Shoulder = nil,
	Elbow = "ElbowSocket",
	Wrist = "WristAnkleSocket",

	Hip = nil,
	Knee = "KneeSocket",
	Ankle = "WristAnkleSocket",
}

ragdollMode.R6RagdollMode = "DefaultR6"
ragdollMode.DefaultConstraintType = "Default"
ragdollMode.ConstraintTypes = ConstraintTypes

return ragdollMode
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX3CD024FD5C9A45D0B416E11C4321850E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">FolderExampleTemplate</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX7DBD3EFDF9FF469A9D907DE836D014DA">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">RagdollStateFunctions</string>
										<string name="ScriptGuid">{2501208D-EAAE-4F4F-B7E9-E0CDFF74D5D6}</string>
										<ProtectedString name="Source"><![CDATA[local ragdollStateFunctions = {}

-- Below are the functions that will fire when the character's ragdoll enables or disables, rigs/ unrigs
-- You can delete these if you don't want to use them
-- The Pre function fires before changes are made to the character, and After is once all changes are made
-- The Rigged function fires right after the rigData table is created, Unrigged fires right before the rigData table is deleted
-- Returning "Sink" for the Pre functions will cancel the ragdoll enable/disable
-- You can change data in impactData and it will affect the characters velocity, just make sure to check if impactData exists before trying to make changes
--(example) if impactData then impactData.Speed *= 2 end
-- If you set impactData to a new table (example impactData = {}) in the PreRagdollEnableFunction, the main module will not use that new table
-- To get around this, you can return the new table. So any table set as the return value will be used as impactData in the main module
-- Changing impactData in the AfterRagdollEnabledFunction doesn't do anything. It is there mainly for if you want to see if impactData is being updated properly

--rigData is a table that is created when a character is rigged. It is structured like so:
--Constraints: Constraints created by the current RagdollMode
--Motors: Character's Motor6Ds that are in use by the current RagdollMode
--R6Attachments: A table of attachments that is created when rigging if the character's rig is R6
--Connections: A table of connections made when rigging the character (mainly used for cleanup, and to rig motors)
--RagdollMode: The loaded RagdollMode Module
--Functions: A table of the below functions ([Pre/After]Ragdoll[Enabled/Disabled]Function)

--You will probably only need the Constraints table and maybe the Motors or R6Attachments table, the rest you can ignore

ragdollStateFunctions.PreRagdollEnabledFunction = function(character, rigData, impactData)
	
end
ragdollStateFunctions.AfterRagdollEnabledFunction = function(character, rigData, impactData)
	
end
ragdollStateFunctions.PreRagdollDisabledFunction = function(character, rigData, beingUnrigged)

end
ragdollStateFunctions.AfterRagdollDisabledFunction = function(character, rigData, beingUnrigged)

end

ragdollStateFunctions.RagdollRiggedFunction = function(character, rigData)

end
ragdollStateFunctions.RagdollUnriggedFunction = function(character, rigData)
	
end

return ragdollStateFunctions
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBXE184D517029D4D10980E0A47825B8471">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Constraints</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="WeldConstraint" referent="RBX74119B785F2644F8996E352A374712AF">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame0">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Root</string>
											<Ref name="Part0Internal">null</Ref>
											<Ref name="Part1Internal">null</Ref>
											<int64 name="SourceAssetId">-1</int64>
											<int name="State">3</int>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Folder" referent="RBX6743C388DCCA4D2D84F8F742537F31F7">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Default</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="BallSocketConstraint" referent="RBXF1D617CE3FD64CA1B8F06E793D40D5D1">
											<Properties>
												<Ref name="Attachment0">null</Ref>
												<Ref name="Attachment1">null</Ref>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<int name="Color">1009</int>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Enabled">true</bool>
												<bool name="LimitsEnabled">true</bool>
												<float name="MaxFrictionTorqueXml">0</float>
												<string name="Name">BallSocketConstraint</string>
												<float name="Radius">0.150000006</float>
												<float name="Restitution">0</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<bool name="TwistLimitsEnabled">false</bool>
												<float name="TwistLowerAngle">-45</float>
												<float name="TwistUpperAngle">45</float>
												<float name="UpperAngle">45</float>
												<bool name="Visible">false</bool>
											</Properties>
										</Item>
									</Item>
									<Item class="WeldConstraint" referent="RBX6C516C35B869499E89C327AEA71FD608">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<CoordinateFrame name="CFrame0">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Waist</string>
											<Ref name="Part0Internal">null</Ref>
											<Ref name="Part1Internal">null</Ref>
											<int64 name="SourceAssetId">-1</int64>
											<int name="State">3</int>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="HingeConstraint" referent="RBXD61E4068F6E64A6AB4DFD9EE80B8D940">
										<Properties>
											<token name="ActuatorType">0</token>
											<float name="AngularResponsiveness">45</float>
											<float name="AngularSpeed">0</float>
											<float name="AngularVelocity">0</float>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<int name="Color">1009</int>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Enabled">true</bool>
											<bool name="LimitsEnabled">true</bool>
											<float name="LowerAngle">-10</float>
											<float name="MotorMaxAcceleration">500000</float>
											<float name="MotorMaxTorque">0</float>
											<string name="Name">Neck</string>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<float name="ServoMaxTorque">0</float>
											<bool name="SoftlockServoUponReachingTarget">false</bool>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<float name="TargetAngle">0</float>
											<float name="UpperAngle">10</float>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="BallSocketConstraint" referent="RBX670D9C0CD69743E0A8593F6BA621AB68">
										<Properties>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<int name="Color">1009</int>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Enabled">true</bool>
											<bool name="LimitsEnabled">true</bool>
											<float name="MaxFrictionTorqueXml">0</float>
											<string name="Name">Knee</string>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="TwistLimitsEnabled">true</bool>
											<float name="TwistLowerAngle">-10</float>
											<float name="TwistUpperAngle">90</float>
											<float name="UpperAngle">45</float>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="BallSocketConstraint" referent="RBX4046B36474AE4A05BED40F4C1818E239">
										<Properties>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<int name="Color">1009</int>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Enabled">true</bool>
											<bool name="LimitsEnabled">true</bool>
											<float name="MaxFrictionTorqueXml">0</float>
											<string name="Name">Elbow</string>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="TwistLimitsEnabled">true</bool>
											<float name="TwistLowerAngle">-120</float>
											<float name="TwistUpperAngle">10</float>
											<float name="UpperAngle">45</float>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="BallSocketConstraint" referent="RBXBB2FBC1AE73643DEB0A9B0F467768619">
										<Properties>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<int name="Color">1009</int>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Enabled">true</bool>
											<bool name="LimitsEnabled">true</bool>
											<float name="MaxFrictionTorqueXml">0</float>
											<string name="Name">Wrist</string>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="TwistLimitsEnabled">true</bool>
											<float name="TwistLowerAngle">-15</float>
											<float name="TwistUpperAngle">15</float>
											<float name="UpperAngle">10</float>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
									<Item class="BallSocketConstraint" referent="RBXC967C421F46641B3A2B1A520123967EC">
										<Properties>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<int name="Color">1009</int>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Enabled">true</bool>
											<bool name="LimitsEnabled">true</bool>
											<float name="MaxFrictionTorqueXml">0</float>
											<string name="Name">Ankle</string>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="TwistLimitsEnabled">true</bool>
											<float name="TwistLowerAngle">-15</float>
											<float name="TwistUpperAngle">15</float>
											<float name="UpperAngle">10</float>
											<bool name="Visible">false</bool>
										</Properties>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXD5BE25DA1CAB47029AC6382C1C8D54CA">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Settings</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ObjectValue" referent="RBXFF8390A07F2848EDAFB5BA86FE0074A3">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">R6RagdollMode</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<Ref name="Value">null</Ref>
										</Properties>
									</Item>
									<Item class="BoolValue" referent="RBXE9D42D9556514A76A6C1A27DA108E9BE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">BreakJointsOnDeath</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Value">false</bool>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXF3BD49D34EC54243BDDEC497F9137824">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">ConstraintTypes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXAF89626B5AB34006855F02009B5FC4BD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">R6AttachmentFix</string>
									<string name="ScriptGuid">{BF69CA83-7088-4623-80C9-BFB2629FB728}</string>
									<ProtectedString name="Source"><![CDATA[local constraintType = {}

constraintType.R6ShoulderFix = function(character, motor, r6, attach0, attach1)
	if r6 then
		attach0.CFrame = attach0.CFrame + attach1.CFrame.LookVector * -0.3
		attach1.CFrame = attach1.CFrame + attach1.CFrame.LookVector * -0.3
	end
end

constraintType.R6HipFix = function(character, motor, r6, attach0, attach1)
	if r6 then
		attach0.CFrame = attach0.CFrame + attach1.CFrame.LookVector * 0.3
		attach1.CFrame = attach1.CFrame + attach1.CFrame.LookVector * 0.3
	end
end

return constraintType
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB770D9D6C3B94ABC87D6516C3C9DA73F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Default</string>
									<string name="ScriptGuid">{619ABB37-54F1-430C-83E5-9C4814D6147D}</string>
									<ProtectedString name="Source"><![CDATA[local constraintTypes = {}

constraintTypes.Default = function(character)
	local constraint = Instance.new("BallSocketConstraint")
	constraint.LimitsEnabled = true
	constraint.TwistLimitsEnabled = true
	return constraint
end
constraintTypes.Weld = function()
	local weld = Instance.new("WeldConstraint")
	return weld
end
constraintTypes.NeckHinge = function()
	local hinge = Instance.new("HingeConstraint")
	hinge.LimitsEnabled = true
	hinge.UpperAngle = 10
	hinge.LowerAngle = -10
	return hinge
end
constraintTypes.KneeSocket = function()
	local constraint = Instance.new("BallSocketConstraint")
	constraint.LimitsEnabled = true
	constraint.TwistLimitsEnabled = true
	constraint.TwistUpperAngle = 90
	constraint.TwistLowerAngle = -10
	return constraint
end
constraintTypes.ElbowSocket = function()
	local constraint = Instance.new("BallSocketConstraint")
	constraint.LimitsEnabled = true
	constraint.TwistLimitsEnabled = true
	constraint.TwistUpperAngle = 10
	constraint.TwistLowerAngle = -120
	return constraint
end
constraintTypes.WristAnkleSocket = function()
	local constraint = Instance.new("BallSocketConstraint")
	constraint.LimitsEnabled = true
	constraint.TwistLimitsEnabled = true
	constraint.UpperAngle = 10
	constraint.TwistUpperAngle = 15
	constraint.TwistLowerAngle = -15
	return constraint
end

return constraintTypes
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX3580E7719CD042EFBEDA1CF61FC15B9B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PremadeScripts</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Script" referent="RBXE09A67BA1A0047768D7F4E752099F693">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Disabled">true</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">(READ ME) How to install</string>
									<token name="RunContext">0</token>
									<string name="ScriptGuid">{F3781C75-2348-4B5E-A2BA-2DB9A365FE08}</string>
									<ProtectedString name="Source"><![CDATA[--[[
To install a premade script, open the folder, check each folder for scripts and enable them.
Each script may or may not have its own settings as either Attributes (in the Property window) or a module inside the script named "Configuration",
feel free to change these settings as you wish (you can look up what each setting does in the Instructions folder located in the main Ragdoll module or Devforum post)
Then place each folder into the matching service in the Explorer and press Control + U with the folder selected to ungroup it.

Note for RagdollDeath script: place the script "DummyCamera" into StarterPlayerScripts if you have CreateDummy enabled (disabled by default)
]]
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX0CA0C6A55526454C9CC2D540CBEC0357">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">PressButtonToRagdoll</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX61BE779F585E477B8A15F2AD2D86E646">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ServerScriptService</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Script" referent="RBXA13618C0BCEE40A9911FD600C2853DEC">
										<Properties>
											<BinaryString name="AttributesSerialize"><![CDATA[AwAAABoAAABBcHBseU1vdmVEaXJlY3Rpb25WZWxvY2l0eQMBDgAAAEF1dG9SaWdQbGF5ZXJz
AwELAAAAUmFnZG9sbE1vZGUCAAAAAA==]]></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Disabled">true</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">ButtonRagdollServer</string>
											<token name="RunContext">0</token>
											<string name="ScriptGuid">{76BC3F22-45CA-4028-B947-6357B9FA0264}</string>
											<ProtectedString name="Source"><![CDATA[local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")


local Ragdoll = require(script.Module.Value or ServerScriptService.Ragdoll)
local remote = ReplicatedStorage.ChangeRagdollState

local mode = script:GetAttribute("RagdollMode")

if script:GetAttribute("AutoRigPlayers") then
	Ragdoll.RigPlayers(mode ~= "" and mode)
end

remote.OnServerEvent:Connect(function(player, state)
	if player.Character then
		local newState = state or player.Character:GetAttribute("Ragdolled") and "Unragdoll" or "Ragdoll"
		if newState == "Ragdoll" then
			local humanoid = player.Character:FindFirstChild("Humanoid")
			local root:Part = player.Character:FindFirstChild("HumanoidRootPart")
			if not humanoid or not root then
				return
			end
			local impact
			if script:GetAttribute("ApplyMoveDirectionVelocity") then
				impact = {}
				impact.Part = "Head"
				impact.Direction = humanoid.MoveDirection
				impact.Speed = 23 + root.AssemblyLinearVelocity.Magnitude
				impact.Lifetime = 0.13
				impact.UseLinearVelocity = true
			end
			Ragdoll.EnableRagdoll(player.Character, humanoid.FloorMaterial ~= Enum.Material.Air and impact)
		elseif newState == "Unragdoll" then
			Ragdoll.DisableRagdoll(player.Character)
		end
	end
end)]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ObjectValue" referent="RBX69D42E95AF16416EAC68FFB80FFAB903">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Module</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<Ref name="Value">RBX51768E03097B4EC6920B4430CCFB503A</Ref>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXACC0D589716E4187AE482CD21EEA3C79">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">StarterCharacterScripts</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="LocalScript" referent="RBX541874F081604E20BD17546E95CF7965">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Disabled">true</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">ButtonRagdollClient</string>
											<token name="RunContext">0</token>
											<string name="ScriptGuid">{FA508208-6740-444A-B1F3-46358E760DD0}</string>
											<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local configuration = require(script:WaitForChild("Configuration"))



local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local db = false

local function changeRagdollState(actionName, inputState, inputObject)
	if inputState ~= Enum.UserInputState.Begin then
		return
	end
	if db then
		return
	end
	if humanoid and humanoid.Health <= 0 then
		return
	end
	db = true
	configuration.RemoteEvent:FireServer()
	task.wait(configuration.Cooldown)
	db = false
	return Enum.ContextActionResult.Sink
end

ContextActionService:BindAction("Ragdoll", changeRagdollState, configuration.CreateMobileButton, configuration.KeyCode, configuration.ControllerCode)
ContextActionService:SetTitle("Ragdoll", configuration.KeyCode.Name)
local button = ContextActionService:GetButton("Ragdoll")
if button then
	ContextActionService:SetPosition("Ragdoll", UDim2.new(0.9, -button.Size.X.Offset, 0.4, -button.Size.Y.Offset))
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX95DADF2CA5DF471CB4733BE131440F0A">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Configuration</string>
												<string name="ScriptGuid">{44DB7BA3-E233-44B2-B7F7-267FE3DE7FF5}</string>
												<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local configuration = {}

configuration.Cooldown = 0.25
configuration.CreateMobileButton = true

configuration.KeyCode = Enum.KeyCode.F
configuration.ControllerCode = Enum.KeyCode.ButtonX

configuration.RemoteEvent = ReplicatedStorage.ChangeRagdollState

return configuration
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXBCF819EEE6A84A59AE83462AC5147188">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ReplicatedStorage</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="RemoteEvent" referent="RBXBC54B6EA33654C938BEE48B2DF931B04">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ChangeRagdollState</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXD8CF0F32924644FF8D1CAD0D808D6E69">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">RagdollDeath</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBXAFDB84D89E4F4354BDE104A8BB14131C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ServerScriptService</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Script" referent="RBXDCA973A6D4344F728533CA95316E9BF7">
										<Properties>
											<BinaryString name="AttributesSerialize"><![CDATA[BgAAABoAAABBcHBseU1vdmVEaXJlY3Rpb25WZWxvY2l0eQMBDgAAAEF1dG9SaWdQbGF5ZXJz
AwELAAAAQ3JlYXRlRHVtbXkDAA0AAABEdW1teUxpZmV0aW1lBgAAAAAAACRAEwAAAEZpeERv
dWJsZURlYXRoU291bmQDAQsAAABSYWdkb2xsTW9kZQIAAAAA]]></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Disabled">true</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">RagdollDeath</string>
											<token name="RunContext">0</token>
											<string name="ScriptGuid">{C8EA7462-48C1-4EA3-BCD2-A9D50ED5EC8B}</string>
											<ProtectedString name="Source"><![CDATA[local ServerScriptService = game:GetService("ServerScriptService")

local Ragdoll = require(script.Module.Value or ServerScriptService.Ragdoll)

local mode = script:GetAttribute("RagdollMode")

if script:GetAttribute("AutoRigPlayers") then
	Ragdoll.RigPlayers(mode ~= "" and mode)
end

local deadFolder = script:GetAttribute("CreateDummy") and Instance.new("Folder")
local deadStorage
if deadFolder then
	deadFolder.Name = "DeadCharacters"
	deadFolder.Parent = workspace
	
	deadStorage = Instance.new("Folder")
	deadStorage.Name = "DeadCharacterStorage"
	deadStorage.Parent = game.ReplicatedStorage
	
	local folder = script:FindFirstChildOfClass("Folder")
	if folder and folder:FindFirstChild("DummyCamera") then
		warn("[" .. script.Name ..  "] Since you are using CreateDummy, please move the DummyCamera script into StarterPlayerScripts to fix the camera. It is located in a folder in this script")
	end
end

local function onCharacterAdded(character)
	local player = game.Players:GetPlayerFromCharacter(character)
	local humanoid = character:WaitForChild("Humanoid")
	local root = character:WaitForChild("HumanoidRootPart")
	
	humanoid.Died:Connect(function()
		if player and script:GetAttribute("FixDoubleDeathSound") then
			local clientManager = character:FindFirstChild("PlayerRagdollManager")
			if clientManager then
				clientManager:Destroy()
			end
		end
		if deadFolder and player then
			character.Archivable = true
			local dummy = character:Clone()
			dummy.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
			for _, characterScript in dummy:GetChildren() do
				if characterScript:IsA("LocalScript") or characterScript:IsA("Script") then
					characterScript:Destroy()
				end
			end
			character.Parent = deadStorage
			dummy.Parent = deadFolder
			Ragdoll.RigCharacter(dummy, character:GetAttribute("RagdollMode"))
			
			dummy.Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
			dummy.Humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
			dummy.Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
			local oldCharacter = character
			character = dummy
			
			task.delay(2, function()
				if oldCharacter then
					oldCharacter:Destroy()
				end
			end)
			task.delay(script:GetAttribute("DummyLifetime"), function()
				if character then
					character:Destroy()
				end
			end)
		end
		local impact
		if script:GetAttribute("ApplyMoveDirectionVelocity") then
			impact = {}
			impact.Part = "Head"
			impact.Direction = humanoid.MoveDirection
			impact.Speed = 23 + root.AssemblyLinearVelocity.Magnitude
			impact.Lifetime = 0.13
			impact.UseLinearVelocity = true
		end
		
		Ragdoll.EnableRagdoll(character, humanoid.FloorMaterial ~= Enum.Material.Air and impact)
	end)
end

local function onPlayerAdded(player)
	
	if player.Character then
		task.spawn(onCharacterAdded, player.Character)
	end
	player.CharacterAdded:Connect(onCharacterAdded)
end

for _, player in game.Players:GetPlayers() do
	task.spawn(onPlayerAdded, player)
end
game.Players.PlayerAdded:Connect(onPlayerAdded)
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ObjectValue" referent="RBX69F068A03F864B77AFA99AF77C6552C5">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Module</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<Ref name="Value">RBX51768E03097B4EC6920B4430CCFB503A</Ref>
											</Properties>
										</Item>
										<Item class="Folder" referent="RBX4E6684F983534DEA9A538C58230512A6">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Place into StarterPlayerScripts if CreateDummy is enabled</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="LocalScript" referent="RBX3C135B464F3B4747BE21EECE87695FBD">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Disabled">true</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">DummyCamera</string>
													<token name="RunContext">0</token>
													<string name="ScriptGuid">{23A39563-FA65-4BE1-ACF5-5D2F0DC39039}</string>
													<ProtectedString name="Source"><![CDATA[local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera

local folder = workspace:WaitForChild("DeadCharacters")
folder.ChildAdded:Connect(function(dummy)
	if dummy.Name == player.Name then
		local humanoid = dummy:WaitForChild("Humanoid")
		camera.CameraSubject = humanoid
	end
end)]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX64B5D848D56B45BE8A1995904DC56D78">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{842413D8-E6A0-4AB4-AA66-DCF55334F3B4}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "Ragdoll",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Ike"},
		{Text = "Description: A Powerful and easy ragdoll library for r15 and r6 rigs, with npc support and a lot more!"},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX9B13F06949854293A207036D73527A62">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">QuestPP</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX1C82E6DA7CE94E9CBD31645C6742A2FA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">QuestPP</string>
							<string name="ScriptGuid">{8B0EEAEF-F27C-4F02-B21D-50327D3F0D33}</string>
							<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native

--[[
      ___   __ __    ___  _____ ______     __        __
     /   \ |  |  |  /  _]/ ___/|      |   |  |      |  |
    |     ||  |  | /  [_(   \_ |      | __|  |__  __|  |__
    |  Q  ||  |  ||    _]\__  ||_|  |_||        ||        |
    |     ||  :  ||   [_ /  \ |  |  |  |__    __||__    __|
    |     ||     ||     |\    |  |  |     |  |      |  |
     \__,_| \__,_||_____| \___|  |__|     |__|      |__|
    Created by ArtSeb
    v1.0.1
    
    The ultimate quest module for Roblox!
    Handles everything from leveling systems to item collection and achievements.

    Features:
    - Simple quest creation and management
    - Progress tracking with events
    - Temporary and completion-based quests
    - Easy quest retrieval system
    - Quest locking mechanism

    Documentation:
    local QuestPP = require(PathToQuest++)
    
    -- Create a new quest
    local quest = QuestPP.new({
        Name = "Quest Name",
        Objective = "Quest Objective",
        Type = "Temporary" | "Completion",	-- Defaults to "Completion"
        TimeLimit = 1000,					-- Optional (for Temporary quests only)
        Key = "UniqueQuestKey123",			-- Used to retrieve quest later
        RewardCallback = function(quest)	-- Optional
            -- Reward player here
        end,
        CompletionCondition = function(quest) -- Optional
            -- Return true if quest should complete immediately
        end,
    })
    
    -- Quest API --
    quest:addProgress(0.5)			-- Add progress (0-1 scale)
    quest:complete()				-- Complete quest immediately
    quest:lock()					-- Lock quest to make it read-only
    quest:destroy()					-- Clean up quest
    
    -- Module API --
    QuestPP:getQuestFromKey(key)	-- Retrieve quest by key
    QuestPP:GetNormal()				-- Get module instance
    
    -- Events --
    quest.Changed					-- Fires when progress changes
    quest.Completed					-- Fires when quest completes
    quest.Destroying				-- Fires before quest destruction
    
    Socials:
    - Discord: ArtSeb
    - Twitter: @art_seb117
]]

local Quest = {}
Quest.__index = Quest
local Quests = {}
local Types = require(script.Types)

export type Quest = Types.Quest

-- Public Functions --
function Quest:getQuestFromKey(key: any)
	local match = Quests[key]
	if match then
		return match
	end
	return nil
end

function Quest:getNormal()
	return script
end

function Quest:getQuests()
	return Quests
end

-- Constructor --
function Quest.new(customization: QuestCustomization)
	local self = {}
	setmetatable(self, Quest)

	-- Initialize quest properties
	self.name = customization.Name
	self.objective = customization.Objective
	self.type = customization.Type or "Completion"
	self.timeLimit = customization.TimeLimit
	self.key = customization.Key

	Quests[self.key] = self

	self._rewardCallback = customization.RewardCallback
	self._completionCondition = customization.CompletionCondition

	self.currentProgress = 0
	self.isCompleted = false
	self._destroyed = false
	self.isLocked = false
	self._completionCheckRunning = false
	
	-- Create events
	self.Changed = Instance.new("BindableEvent")
	self.Changed.Name = "Changed"

	self.Completed = Instance.new("BindableEvent")
	self.Completed.Name = "Completed"

	self.Destroying = Instance.new("BindableEvent")
	self.Destroying.Name = "Destroying"

	-- Create instance representation
	self._instance = self:_createInstance()

	-- Set up time limit if applicable
	if self.type == "Temporary" then
		assert(self.timeLimit, "A Quest with the Temporary type must have a TimeLimit")
		task.delay(self.timeLimit, function()
			if not self.isCompleted then
				--print(self.isCompleted)
				self:destroy()
			end
		end)
	end

	-- Start completion condition checker if it exists
	if self._completionCondition then
		self:_startCompletionChecker()
	end

	return self
end

-- Internal method to create the instance representation
function Quest:_createInstance()
	local instance = Instance.new("Configuration")
	instance.Name = tostring(self.key)

	-- Create child values
	local function createValue(className, name, value)
		local val = Instance.new(className)
		val.Name = name
		val.Value = value
		val.Parent = instance
		return val
	end

	createValue("StringValue", "Q_Name", self.name)
	createValue("StringValue", "Q_Objective", self.objective)
	createValue("NumberValue", "Q_Progress", self.currentProgress)
	createValue("BoolValue", "Q_Completed", self.isCompleted)
	createValue("BoolValue", "Q_Locked", self.isLocked)
	
	self.Completed.Parent = instance
	self.Changed.Parent = instance
	self.Destroying.Parent = instance

	instance.Parent = script
	return instance
end

-- Internal method to start the completion condition checker
function Quest:_startCompletionChecker()
	if self._completionCheckRunning or self._destroyed then return end

	self._completionCheckRunning = true

	task.spawn(function()
		while not self._destroyed and not self.isCompleted and not self.isLocked do
			-- Check if progress is complete
			if self.currentProgress >= 1 then
				self:complete()
				break
			end

			-- Check custom completion condition
			if self._completionCondition then
				local success, result = pcall(self._completionCondition, self)
				if success and result then
					self:complete()
					break
				end
			end

			-- Wait a bit before checking again
			task.wait(0.1)
		end

		self._completionCheckRunning = false
	end)
end

function Quest:lock()
	if self._destroyed then return end

	self.isLocked = true
	if self._instance and self._instance:FindFirstChild("Q_Locked") then
		self._instance.Q_Locked.Value = true
	end
end

function Quest:destroy()
	if self._destroyed then return end

	self._destroyed = true
	self.Destroying:Fire()

	Quests[self.key] = nil

	self._instance:Destroy()
	self.Changed:Destroy()
	self.Completed:Destroy()
	self.Destroying:Destroy()

	-- Clear table
	table.clear(self)
	setmetatable(self, nil)
end

function Quest:addProgress(amount: number)
	if self._destroyed or self.isCompleted or self.isLocked then return end

	self.currentProgress = math.clamp(self.currentProgress + amount, 0, 1)
	self._instance.Q_Progress.Value = self.currentProgress
	self.Changed:Fire(self.currentProgress)

	-- Check for automatic completion if progress reaches 1
	if self.currentProgress >= 1 then
		self:complete()
	end

	-- Restart completion checker if it's not running
	if self._completionCondition and not self._completionCheckRunning and not self.isCompleted then
		self:_startCompletionChecker()
	end
end

function Quest:complete()
	if self._destroyed or self.isCompleted or self.isLocked then return end

	self.isCompleted = true
	self._instance.Q_Completed.Value = true
	self.Completed:Fire()

	if self._rewardCallback then
		self._rewardCallback(self)
	end
end

return Quest :: Types.StaticQuest]]></ProtectedString>
							<int64 name="SourceAssetId">83392252086224</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX2F294C1888D44AE59A75348B504AEEE0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{E8846BB2-110C-4B88-842C-F3303DBC2D10}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

type StaticMethods = {
	getQuestFromKey: typeof(
		--[[
		Returns a SAME SIDE Quest from a given key

		A quest made on the server can be only accessed on the server and vice versa
		]]
		function(key: string): Quest?
			return nil :: any
		end
	),
	getNormal: typeof(
		--[[
		Returns the module script instance
		]]
		function(): ModuleScript
			return nil :: any
		end
	),
	getQuests: typeof(
		--[[
		Returns all of the quests
		]]
		function(): { Quest }
			return nil :: any
		end
	),
}

export type QuestCustomization = {
	Name: string,
	Objective: string,
	Type: "Temporary" | "Completion"?,
	TimeLimit: number?,
	Key: any,
	RewardCallback: ((quest: Quest) -> ())?,
	CompletionCondition: ((quest: Quest) -> (boolean | nil))?,
}

local MT = {} :: Methods
type Methods = {
	__index: typeof(MT),
	
	-- QUEST FUNCTIONS --
	destroy: typeof(
		--[=[
    	Cleans up the quest and all its resources
		]=]
		function(self: Quest): ()
			return nil :: any
		end
	),
	addProgress: typeof(
		--[=[
    	Adds progress to the quest
   		Amount = progress to add (0-1 scale)
		]=]
		function(self: Quest, amount: number): ()
			return nil :: any
		end
	),
	complete: typeof(
		--[=[
    	Completes the quest immediately
		]=]
		function(self: Quest): ()
			return nil :: any
		end
	),
	lock: typeof(
		--[=[
		Locks the quest so it's read only
		]=]
		function(self: Quest): ()
			return nil :: any
		end
	)
}

export type Fields = {
	-- Properties
	name: string,
	objective: string,
	type: "Temporary" | "Completion"?,
	timeLimit: number?,
	key: any,
	currentProgress: number,
	isCompleted: boolean,
	isLocked: boolean,
	
	-- Events
	changed: BindableEvent,
	completed: BindableEvent,
	destroying: BindableEvent,
}

export type Quest = typeof(setmetatable({}::Fields, MT))

export type StaticQuest = {
	new: typeof(
		--[=[
		Creates a new quest.
		]=]
		function(customization: QuestCustomization): Quest
			return nil :: any
		end
	)
} & StaticMethods

return {}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFD3043E5440246DC8321BE83DF8DEC99">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Config</string>
								<string name="ScriptGuid">{A81B0404-EEC2-4E96-9826-D187A8093E6E}</string>
								<ProtectedString name="Source"><![CDATA[return {
	Name = "QuestPP",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: ArtSeb"},
		{Text = "Description: The ultimate quest module for Roblox! Handles everything from leveling systems to item collection and achievements."},
		{Text = "Version: 1.0.1 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Advanced scripting knowledge"}
	}
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX916EEF6114D44758AD84BF078A032D72">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{781CA3BC-710F-4F9A-BD17-C10449025163}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "QuestPP",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 83392252086224,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: ArtSeb"},
		{Text = "Description: The ultimate quest module for Roblox! Handles everything from leveling systems to item collection and achievements."},
		{Text = "Version: 1.0.1 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Advanced scripting knowledge"}
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXC0EBE553B32E473B9F401F02EEA9E7B3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ProfileStore</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX51C82664045E45F88C763CA8AA870EDF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ProfileStore</string>
							<string name="ScriptGuid">{7B667C90-B5AE-4041-A76C-C35011A3E431}</string>
							<ProtectedString name="Source"><![CDATA[--[[
MAD STUDIO (by loleris)

-[ProfileStore]---------------------------------------

	Periodic DataStore saving solution with session locking
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to store such tables will result in an error.
		! Do not create mixed tables (some values indexed by number and others by a string key)
			- only numerically indexed  data will be stored.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	Members:
	
		ProfileStore.IsClosing          [bool]
			-- Set to true after a game:BindToClose() trigger
			
		ProfileStore.IsCriticalState    [bool]
			-- Set to true when ProfileStore experiences too many consecutive errors
		
		ProfileStore.OnError            [Signal] (message, store_name, profile_key)
			-- Most ProfileStore errors will be caught and passed to this signal
			
		ProfileStore.OnOverwrite        [Signal] (store_name, profile_key)
			-- Triggered when a DataStore key was likely used to store data that wasn't
			a ProfileStore profile or the ProfileStore structure was invalidly manually
			altered for that DataStore key
			
		ProfileStore.OnCriticalToggle   [Signal] (is_critical)
			-- Triggered when ProfileStore experiences too many consecutive errors
		
		ProfileStore.DataStoreState     [string] ("NotReady", "NoInternet", "NoAccess", "Access")
			-- This value resembles ProfileStore's access to the DataStore; The value starts
			as "NotReady" and will eventually change to one of the other 3 possible values.
	
	Functions:
	
		ProfileStore.New(store_name, template?) --> [ProfileStore]
			store_name   [string] -- DataStore name
			template     [table] or nil -- Profiles will default to given table (hard-copy) when no data was saved previously
			
		ProfileStore.SetConstant(name, value)
			name    [string]
			value   [number]
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore]
			-- Reflection of ProfileStore methods, but the methods will now query a mock
			DataStore with no relation to the real DataStore
			
		ProfileStore.Name   [string]
		
	Methods [ProfileStore]:
	
		ProfileStore:StartSessionAsync(profile_key, params?) --> [Profile] or nil
			profile_key [string] -- DataStore key
			params      nil or [table]: -- Custom params; E.g. {Steal = true}
				{
					Steal = true, -- Pass this to disregard an existing session lock
					Cancel = fn() -> (boolean), -- Pass this to create a request cancel condition.
						-- If the cancel function returns true, ProfileStore will stop trying to
						-- start the session and return nil
				}
			
		ProfileStore:MessageAsync(profile_key, message) --> is_success [bool]
			profile_key [string] -- DataStore key
			message     [table] -- Data to be messaged to the profile
			
		ProfileStore:GetAsync(profile_key, version?) --> [Profile] or nil
			-- Reads a profile without starting a session - will not autosave
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:VersionQuery(profile_key, sort_direction?, min_date?, max_date?) --> [VersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:RemoveAsync(profile_key) --> is_success [bool]
			-- Completely removes profile data from the DataStore / mock DataStore with no way to recover it.

	Methods [VersionQuery]:

		VersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile is similar to profiles returned by ProfileStore:GetAsync()
		
	Members [Profile]:
	
		Profile.Data               [table]
			-- When the profile is active changes to this table are guaranteed to be saved
		Profile.LastSavedData      [table] (Read-only)
			-- Last snapshot of "Profile.Data" that has been successfully saved to the DataStore;
			Useful for proper developer product purchase receipt handling
		
		Profile.FirstSessionTime   [number] (Read-only)
			-- os.time() timestamp of the first profile session
			
		Profile.SessionLoadCount   [number] (Read-only) -- Amount of times a session was started for this profile
			
		Profile.Session            [table] (Read-only) {PlaceId = number, JobId = string} / nil
			-- Set to a table if this profile is in use by a server; nil if released

		Profile.RobloxMetaData     [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds            [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo            [DataStoreKeyInfo] -- Changes before OnAfterSave signal
		
		Profile.OnSave             [Signal] ()
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			
		Profile.OnLastSave         [Signal] (reason [string]: "Manual", "External", "Shutdown")
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			for the last time; A reason is provided for the last save:
				- "Manual"   - Profile:EndSession() was called
				- "Shutdown" - The server that has ownership of this profile is shutting down
				- "External" - Another server has started a session for this profile
			Note that this event will not trigger for when a profile session is ended by
			another server trying to take ownership of the session - this is impossible to
			do without compromising on ProfileStore's speed.
			
		Profile.OnSessionEnd       [Signal] ()
			-- Triggered when the profile session is terminated on this server
		
		Profile.OnAfterSave        [Signal] (last_saved_data)
			-- Triggered after a successful save
			last_saved_data [table] -- Profile.LastSavedData
			
		Profile.ProfileStore       [ProfileStore] -- ProfileStore object this profile belongs to
		Profile.Key                [string] -- DataStore key
		
	Methods [Profile]:
	
		Profile:IsActive() --> [bool] -- If "true" is returned, changes to Profile.Data are guaranteed to save;
			This guarantee is only valid until code yields (e.g. task.wait() is used).
			
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
			from the "template" argument that was passed to "ProfileStore.New()"
			
		Profile:EndSession() -- Call after the server has finished working with this profile
			e.g., after the player leaves (Profile object will become inactive)

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)
			user_id   [number]
			
		Profile:MessageHandler(fn) -- Sets a message handler for this profile
			fn [function] (message [table], processed [function]())
			-- The handler function receives a message table and a callback function;
			The callback function is to be called when a message has been processed
			- this will discard the message from the profile message cache; If the
			callback function is not called, other message handlers will also be triggered
			with unprocessed message data.
			
		Profile:Save() -- If the profile session is still active makes an UpdateAsync call
			to the DataStore to immediately save profile data

		Profile:SetAsync() -- Forcefully saves changes to the profile; Only for profiles
			loaded with ProfileStore:GetAsync() or ProfileStore:VersionQuery()
		
--]]

local AUTO_SAVE_PERIOD = 300 -- (Seconds) Time between when changes to a profile are saved to the DataStore
local LOAD_REPEAT_PERIOD = 10 -- (Seconds) Time between successive profile reads when handling a session conflict
local FIRST_LOAD_REPEAT = 5 -- (Seconds) Time between first and second profile read when handling a session conflict
local SESSION_STEAL = 40 -- (Seconds) Time until a session conflict is resolved with the waiting server stealing the session
local ASSUME_DEAD = 630 -- (Seconds) If a profile hasn't had updates for this long, quickly assume an active session belongs to a crashed server
local START_SESSION_TIMEOUT = 120 -- (Seconds) If a session can't be started for a profile for this long, stop repeating calls to the DataStore

local CRITICAL_STATE_ERROR_COUNT = 5 -- Assume critical state if this many issues happen in a short amount of time
local CRITICAL_STATE_ERROR_EXPIRE = 120 -- (Seconds) Individual issue expiration
local CRITICAL_STATE_EXPIRE = 120 -- (Seconds) Critical state expiration

local MAX_MESSAGE_QUEUE = 1000 -- Max messages saved in a profile that were sent using "ProfileStore:MessageAsync()"

----- Dependencies -----

-- local Util = require(game.ReplicatedStorage.Shared.Util)
-- local Signal = Util.Signal

local Signal do

	local FreeRunnerThread

	--[[
		Yield-safe coroutine reusing by stravant;
		Sources:
		https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063
		https://gist.github.com/stravant/b75a322e0919d60dde8a0316d1f09d2f
	--]]

	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		-- The handler finished running, this runner thread is free again.
		FreeRunnerThread = acquired_runner_thread
	end

	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end

	local Connection = {}
	Connection.__index = Connection

	local SignalClass = {}
	SignalClass.__index = SignalClass

	function Connection:Disconnect()

		if self.is_connected == false then
			return
		end

		local signal = self.signal
		self.is_connected = false
		signal.listener_count -= 1

		if signal.head == self then
			signal.head = self.next
		else
			local prev = signal.head
			while prev ~= nil and prev.next ~= self do
				prev = prev.next
			end
			if prev ~= nil then
				prev.next = self.next
			end
		end

	end

	function SignalClass.New()

		local self = {
			head = nil,
			listener_count = 0,
		}
		setmetatable(self, SignalClass)

		return self

	end

	function SignalClass:Connect(listener: (...any) -> ())

		if type(listener) ~= "function" then
			error(`[{script.Name}]: \"listener\" must be a function; Received {typeof(listener)}`)
		end

		local connection = {
			listener = listener,
			signal = self,
			next = self.head,
			is_connected = true,
		}
		setmetatable(connection, Connection)

		self.head = connection
		self.listener_count += 1

		return connection

	end

	function SignalClass:GetListenerCount(): number
		return self.listener_count
	end

	function SignalClass:Fire(...)
		local item = self.head
		while item ~= nil do
			if item.is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item.listener, ...)
			end
			item = item.next
		end
	end

	function SignalClass:Wait()
		local co = coroutine.running()
		local connection
		connection = self:Connect(function(...)
			connection:Disconnect()
			task.spawn(co, ...)
		end)
		return coroutine.yield()
	end

	Signal = table.freeze({
		New = SignalClass.New,
	})

end

----- Private -----

local ActiveSessionCheck = {} -- {[session_token] = profile, ...}
local AutoSaveList = {} -- {profile, ...} -- Loaded profile table which will be circularly auto-saved
local IssueQueue = {} -- {issue_time, ...}

local DataStoreService = game:GetService("DataStoreService")
local MessagingService = game:GetService("MessagingService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access" = "NotReady"

local MockStore = {}
local UserMockStore = {}
local MockFlag = false

local OnError = Signal.New() -- (message, store_name, profile_key)
local OnOverwrite = Signal.New() -- (store_name, profile_key)

local UpdateQueue = { -- For stability sake, we won't do UpdateAsync calls for the same key until all previous calls finish
	--[[
		[session_token] = {
			coroutine, ...
		},
		...
	--]]
}

local function WaitInUpdateQueue(session_token) --> next_in_queue()

	local is_first = false

	if UpdateQueue[session_token] == nil then
		is_first = true
		UpdateQueue[session_token] = {}
	end

	local queue = UpdateQueue[session_token]

	if is_first == false then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	return function()
		local next_co = table.remove(queue, 1)
		if next_co ~= nil then
			coroutine.resume(next_co)
		else
			UpdateQueue[session_token] = nil
		end
	end

end

local function SessionToken(store_name, profile_key, is_mock)

	local session_token = "L_" -- Live

	if is_mock == true then
		session_token = "U_" -- User mock
	elseif DataStoreState ~= "Access" then
		session_token = "M_" -- Mock, cause no DataStore access
	end

	session_token ..= store_name .. "\0" .. profile_key

	return session_token

end

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

local function RegisterError(error_message, store_name, profile_key) -- Called when a DataStore API call errors
	warn(`[{script.Name}]: DataStore API error (STORE:{store_name}; KEY:{profile_key}) - {tostring(error_message)}`)
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	OnError:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterOverwrite(store_name, profile_key) -- Called when a corrupted profile is loaded
	warn(`[{script.Name}]: Invalid profile was overwritten (STORE:{store_name}; KEY:{profile_key})`)
	OnOverwrite:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = DeepCopyTable(transform)
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function UpdateAsync(profile_store, profile_key, transform_params, is_user_mock, is_get_call, version) --> loaded_data, key_info
	--transform_params = {
	--	ExistingProfileHandle = function(latest_data),
	--	MissingProfileHandle = function(latest_data),
	--	EditProfile = function(latest_data),
	--}

	local loaded_data, key_info

	local next_in_queue = WaitInUpdateQueue(SessionToken(profile_store.Name, profile_key, is_user_mock))

	local success = true

	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local overwritten = false
			local global_updates = {0, {}}

			if latest_data == nil then

				missing_profile = true

			elseif type(latest_data) ~= "table" then

				missing_profile = true
				overwritten = true

			else

				if type(latest_data.Data) == "table" and type(latest_data.MetaData) == "table" and type(latest_data.GlobalUpdates) == "table" then

					-- Regular profile structure detected:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates

					if transform_params.ExistingProfileHandle ~= nil then
						transform_params.ExistingProfileHandle(latest_data)
					end

				elseif latest_data.Data == nil and latest_data.MetaData == nil and type(latest_data.GlobalUpdates) == "table" then

					-- Regular structure not detected, but GlobalUpdate data exists:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates or global_updates
					missing_profile = true

				else

					missing_profile = true
					overwritten = true

				end

			end

			-- Profile was not created or corrupted and no GlobalUpdate data exists:
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates,
				}
				if transform_params.MissingProfileHandle ~= nil then
					transform_params.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if transform_params.EditProfile ~= nil then
				transform_params.EditProfile(latest_data)
			end

			-- Invalid data handling (Silently override with empty profile)
			if overwritten == true then
				latest_data.WasOverwritten = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end

		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

			loaded_data, key_info = MockUpdateAsync(UserMockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		elseif DataStoreState ~= "Access" then -- Used when API access is disabled

			loaded_data, key_info = MockUpdateAsync(MockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		else

			if is_get_call == true then

				if version ~= nil then

					local success, error_message = pcall(function()
						loaded_data, key_info = profile_store.data_store:GetVersionAsync(profile_key, version)
					end)

					if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
						warn(`[{script.Name}]: Passed version argument is not valid; Traceback:\n` .. debug.traceback())
					end

				else

					loaded_data, key_info = profile_store.data_store:GetAsync(profile_key)

				end

				loaded_data = transform_function(loaded_data)

			else

				loaded_data, key_info = profile_store.data_store:UpdateAsync(profile_key, transform_function)

			end

		end

	end)

	next_in_queue()

	if success == true and type(loaded_data) == "table" then
		-- Invalid data handling:
		if loaded_data.WasOverwritten == true and is_get_call ~= true then
			RegisterOverwrite(
				profile_store.Name,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		-- Error handling:
		RegisterError(
			error_message or "Undefined error",
			profile_store.Name,
			profile_key
		)
		-- Return nothing:
		return nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

local function ReadMockFlag(): boolean
	local is_mock = MockFlag
	MockFlag = false
	return is_mock
end

local function WaitForStoreReady(profile_store)
	while profile_store.is_ready == false do
		task.wait()
	end
end

local function AddProfileToAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = profile

	-- Add at AutoSaveIndex and move AutoSaveIndex right:

	table.insert(AutoSaveList, AutoSaveIndex, profile)

	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end

end

local function RemoveProfileFromAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = nil

	local auto_save_index = table.find(AutoSaveList, profile)

	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end

end

local function SaveProfileAsync(profile, is_ending_session, is_overwriting, last_save_reason)

	if type(profile.Data) ~= "table" then
		error(`[{script.Name}]: Developer code likely set "Profile.Data" to a non-table value! (STORE:{profile.ProfileStore.Name}; KEY:{profile.Key})`)
	end

	profile.OnSave:Fire()
	if is_ending_session == true then
		profile.OnLastSave:Fire(last_save_reason or "Manual")
	end

	if is_ending_session == true and is_overwriting ~= true then
		if profile.roblox_message_subscription ~= nil then
			profile.roblox_message_subscription:Disconnect()
		end
		RemoveProfileFromAutoSave(profile)
		profile.OnSessionEnd:Fire()
	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1

	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again

	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	local exp_backoff = 1

	while repeat_save_flag == true do

		if is_ending_session ~= true then
			repeat_save_flag = false
		end

		local loaded_data, key_info = UpdateAsync(
			profile.ProfileStore,
			profile.Key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					-- Check if this session still owns the profile:

					local session_owns_profile = false

					if is_overwriting ~= true then

						local active_session = latest_data.MetaData.ActiveSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
						end

					else
						session_owns_profile = true
					end

					-- We may only edit the profile if this server has ownership of the profile:

					if session_owns_profile == true then

						-- Clear processed updates (messages):

						local locked_updates = profile.locked_global_updates -- [index] = true, ...
						local active_updates = latest_data.GlobalUpdates[2]
						-- ProfileService module format: {{update_id, version_id, update_locked, update_data}, ...}
						-- ProfileStore module format: {{update_id, update_data}, ...}

						if next(locked_updates) ~= nil then
							local i = 1
							while i <= #active_updates do
								local update = active_updates[i]
								if locked_updates[update[1]] == true then
									table.remove(active_updates, i)
								else
									i += 1
								end
							end
						end

						-- Save profile data:

						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then

							latest_data.MetaData.LastUpdate = os.time()

							if is_ending_session == true then
								latest_data.MetaData.ActiveSession = nil
							end

						else

							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil

						end

					end

				end,
			},
			profile.is_mock
		)

		if loaded_data ~= nil and key_info ~= nil then

			if is_overwriting == true then
				break
			end

			repeat_save_flag = false

			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false

			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
			end

			local force_load_session = loaded_data.MetaData.ForceLoadSession
			local force_load_pending = false
			if type(force_load_session) == "table" then
				force_load_pending = not IsThisSession(force_load_session)
			end

			local is_active = profile:IsActive()

			-- If another server is trying to start a session for this profile - end the session:

			if force_load_pending == true and session_owns_profile == true then
				if is_active == true then
					SaveProfileAsync(profile, true, false, "External")
				end
				break
			end

			-- Clearing processed update list / Detecting new updates:

			local locked_updates = profile.locked_global_updates -- [index] = true, ...
			local received_updates = profile.received_global_updates -- [index] = true, ...
			local active_updates = loaded_data.GlobalUpdates[2]

			local new_updates = {} -- {}, ...
			local still_pending = {} -- [index] = true, ...

			for _, update in ipairs(active_updates) do
				if locked_updates[update[1]] == true then
					still_pending[update[1]] = true
				elseif received_updates[update[1]] ~= true then
					received_updates[update[1]] = true
					table.insert(new_updates, update)
				end
			end

			for index in pairs(locked_updates) do
				if still_pending[index] ~= true then
					locked_updates[index] = nil
				end
			end

			-- Updating profile values:

			profile.KeyInfo = key_info
			profile.LastSavedData = loaded_data.Data
			profile.global_updates = loaded_data.GlobalUpdates and loaded_data.GlobalUpdates[2] or {}

			if session_owns_profile == true then
				if is_active == true and is_ending_session ~= true then

					-- Processing new global updates (messages):

					for _, update in ipairs(new_updates) do

						local index = update[1]
						local update_data = update[#update] -- Backwards compatibility with ProfileService

						for _, handler in ipairs(profile.message_handlers) do

							local is_processed = false
							local processed_callback = function()
								is_processed = true
								locked_updates[index] = true
							end

							local send_update_data = DeepCopyTable(update_data)

							task.spawn(handler, send_update_data, processed_callback)

							if is_processed == true then
								break
							end

						end

					end

				end
			else

				if profile.roblox_message_subscription ~= nil then
					profile.roblox_message_subscription:Disconnect()
				end

				if is_active == true then
					RemoveProfileFromAutoSave(profile)
					profile.OnSessionEnd:Fire()
				end

			end

			profile.OnAfterSave:Fire(profile.LastSavedData)

		elseif repeat_save_flag == true then

			-- DataStore call likely resulted in an error; Repeat the DataStore call shortly
			task.wait(exp_backoff)
			exp_backoff = math.min(if last_save_reason == "Shutdown" then 8 else 20, exp_backoff * 2)

		end

	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1

end

----- Public -----

--[[
	Saved profile structure:
	
	{
		Data = {},
		
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id, unique_session_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			LastUpdate = 0, -- os.time()
			MetaTags = {}, -- Backwards compatibility with ProfileService
		},
		
		RobloxMetaData = {},
		UserIds = {},
		
		GlobalUpdates = {
			update_index,
			{
				{update_index, data}, ...
			},
		},
	}

--]]

export type JSONAcceptable = { JSONAcceptable } | { [string]: JSONAcceptable } | number | string | boolean | buffer

export type Profile<T> = {
	Data: T & JSONAcceptable,
	LastSavedData: T & JSONAcceptable,
	FirstSessionTime: number,
	SessionLoadCount: number,
	Session: {PlaceId: number, JobId: string}?,
	RobloxMetaData: JSONAcceptable,
	UserIds: {number},
	KeyInfo: DataStoreKeyInfo,
	OnSave: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnLastSave: {Connect: (self: any, listener: (reason: "Manual" | "External" | "Shutdown") -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnSessionEnd: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnAfterSave: {Connect: (self: any, listener: (last_saved_data: T & JSONAcceptable) -> ()) -> ({Disconnect: (self: any) -> ()})},
	ProfileStore: JSONAcceptable,
	Key: string,

	IsActive: (self: any) -> (boolean),
	Reconcile: (self: any) -> (),
	EndSession: (self: any) -> (),
	AddUserId: (self: any, user_id: number) -> (),
	RemoveUserId: (self: any, user_id: number) -> (),
	MessageHandler: (self: any, fn: (message: JSONAcceptable, processed: () -> ()) -> ()) -> (),
	Save: (self: any) -> (),
	SetAsync: (self: any) -> (),
}

export type VersionQuery<T> = {
	NextAsync: (self: any) -> (Profile<T>?),
}

type ProfileStoreStandard<T> = {
	Name: string,
	StartSessionAsync: (self: any, profile_key: string, params: {Steal: boolean?}) -> (Profile<T>?),
	MessageAsync: (self: any, profile_key: string, message: JSONAcceptable) -> (boolean),
	GetAsync: (self: any, profile_key: string, version: string?) -> (Profile<T>?),
	VersionQuery: (self: any, profile_key: string, sort_direction: Enum.SortDirection?, min_date: DateTime | number | nil, max_date: DateTime | number | nil) -> (VersionQuery<T>),
	RemoveAsync: (self: any, profile_key: string) -> (boolean),
}

export type ProfileStore<T> = {
	Mock: ProfileStoreStandard<T>,
} & ProfileStoreStandard<T>

type ConstantName = "AUTO_SAVE_PERIOD" | "LOAD_REPEAT_PERIOD" | "FIRST_LOAD_REPEAT" | "SESSION_STEAL"
| "ASSUME_DEAD" | "START_SESSION_TIMEOUT" | "CRITICAL_STATE_ERROR_COUNT" | "CRITICAL_STATE_ERROR_EXPIRE"
| "CRITICAL_STATE_EXPIRE" | "MAX_MESSAGE_QUEUE"

export type ProfileStoreModule = {
	IsClosing: boolean,
	IsCriticalState: boolean,
	OnError: {Connect: (self: any, listener: (message: string, store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnOverwrite: {Connect: (self: any, listener: (store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnCriticalToggle: {Connect: (self: any, listener: (is_critical: boolean) -> ()) -> ({Disconnect: (self: any) -> ()})},
	DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access",
	New: <T>(store_name: string, template: (T & JSONAcceptable)?) -> (ProfileStore<T>),
	SetConstant: (name: ConstantName, value: number) -> ()
}

local Profile = {}
Profile.__index = Profile

function Profile.New(raw_data, key_info, profile_store, key, is_mock, session_token)

	local data = raw_data.Data or {}
	local session = raw_data.MetaData and raw_data.MetaData.ActiveSession or nil

	local global_updates = raw_data.GlobalUpdates and raw_data.GlobalUpdates[2] or {}
	local received_global_updates = {}

	for _, update in ipairs(global_updates) do
		received_global_updates[update[1]] = true
	end

	local self = {

		Data = data,
		LastSavedData = DeepCopyTable(data),

		FirstSessionTime = raw_data.MetaData and raw_data.MetaData.ProfileCreateTime or 0,
		SessionLoadCount = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		Session = session and {PlaceId = session[1], JobId = session[2]},

		RobloxMetaData = raw_data.RobloxMetaData or {},
		UserIds = raw_data.UserIds or {},
		KeyInfo = key_info,

		OnAfterSave = Signal.New(),
		OnSave = Signal.New(),
		OnLastSave = Signal.New(),
		OnSessionEnd = Signal.New(),

		ProfileStore = profile_store,
		Key = key,

		load_timestamp = os.clock(),
		is_mock = is_mock,
		session_token = session_token or "",
		load_index = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		locked_global_updates = {},
		received_global_updates = received_global_updates,
		message_handlers = {},
		global_updates = global_updates,

	}
	setmetatable(self, Profile)

	return self

end

function Profile:IsActive()
	return ActiveSessionCheck[self.session_token] == self
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self.ProfileStore.template)
end

function Profile:EndSession()
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true, nil, "Manual") -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :AddUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	if user_id < 0 and self.is_mock ~= true and DataStoreState == "Access" then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end

end

function Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :RemoveUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:SetAsync() -- Saves the profile to the DataStore and removes the session lock

	if self.view_mode ~= true then
		error(`[{script.Name}]: :SetAsync() can only be used in view mode`)
	end

	SaveProfileAsync(self, nil, true)

end

function Profile:MessageHandler(fn)

	if type(fn) ~= "function" then
		error(`[{script.Name}]: fn argument is not a function`)
	end

	if self.view_mode ~= true and self:IsActive() ~= true then
		return -- Don't process messages if the profile session was ended
	end

	local locked_updates = self.locked_global_updates
	table.insert(self.message_handlers, fn)

	for _, update in ipairs(self.global_updates) do

		local index = update[1]
		local update_data = update[#update] -- Backwards compatibility with ProfileService

		if locked_updates[index] ~= true then

			local processed_callback = function()
				locked_updates[index] = true
			end

			local send_update_data = DeepCopyTable(update_data)

			task.spawn(fn, send_update_data, processed_callback)

		end

	end

end

function Profile:Save()

	if self.view_mode == true then
		error(`[{script.Name}]: Can't save profile in view mode; Should you be calling :SetAsync() instead?`)
	end

	if self:IsActive() == false then
		warn(`[{script.Name}]: Attempted saving an inactive profile (STORE:{self.ProfileStore.Name}; KEY:{self.Key});`
			.. ` Traceback:\n` .. debug.traceback())
		return
	end

	-- Move the profile right behind the auto save index to delay the next auto save for it:
	RemoveProfileFromAutoSave(self)
	AddProfileToAutoSave(self)

	-- Perform save in new thread:
	task.spawn(SaveProfileAsync, self)

end

local ProfileStore: ProfileStoreModule = {

	IsClosing = false,
	IsCriticalState = false,
	OnError = OnError, -- (message, store_name, profile_key)
	OnOverwrite = OnOverwrite, -- (store_name, profile_key)
	OnCriticalToggle = Signal.New(), -- (is_critical)
	DataStoreState = "NotReady", -- ("NotReady", "NoInternet", "NoAccess", "Access")

}
ProfileStore.__index = ProfileStore

function ProfileStore.SetConstant(name, value)

	if type(value) ~= "number" then
		error(`[{script.Name}]: Invalid value type`)
	end

	if name == "AUTO_SAVE_PERIOD" then
		AUTO_SAVE_PERIOD = value
	elseif name == "LOAD_REPEAT_PERIOD" then
		LOAD_REPEAT_PERIOD = value
	elseif name == "FIRST_LOAD_REPEAT" then
		FIRST_LOAD_REPEAT = value
	elseif name == "SESSION_STEAL" then
		SESSION_STEAL = value
	elseif name == "ASSUME_DEAD" then
		ASSUME_DEAD = value
	elseif name == "START_SESSION_TIMEOUT" then
		START_SESSION_TIMEOUT = value
	elseif name == "CRITICAL_STATE_ERROR_COUNT" then
		CRITICAL_STATE_ERROR_COUNT = value
	elseif name == "CRITICAL_STATE_ERROR_EXPIRE" then
		CRITICAL_STATE_ERROR_EXPIRE = value
	elseif name == "CRITICAL_STATE_EXPIRE" then
		CRITICAL_STATE_EXPIRE = value
	elseif name == "MAX_MESSAGE_QUEUE" then
		MAX_MESSAGE_QUEUE = value
	else
		error(`[{script.Name}]: Invalid constant name was provided`)
	end

end

function ProfileStore.Test()
	return {
		ActiveSessionCheck = ActiveSessionCheck,
		AutoSaveList = AutoSaveList,
		ActiveProfileLoadJobs = ActiveProfileLoadJobs,
		ActiveProfileSaveJobs = ActiveProfileSaveJobs,
		MockStore = MockStore,
		UserMockStore = UserMockStore,
		UpdateQueue = UpdateQueue,
	}
end

function ProfileStore.New(store_name, template)

	template = template or {}

	if type(store_name) ~= "string" then
		error(`[{script.Name}]: Invalid or missing "store_name"`)
	elseif string.len(store_name) == 0 then
		error(`[{script.Name}]: store_name cannot be an empty string`)
	elseif string.len(store_name) > 50 then
		error(`[{script.Name}]: store_name is too long`)
	end

	if type(template) ~= "table" then
		error(`[{script.Name}]: Invalid template argument`)
	end

	local self
	self = {

		Mock = {

			Name = store_name,

			StartSessionAsync = function(_, profile_key)
				MockFlag = true
				return self:StartSessionAsync(profile_key)
			end,
			MessageAsync = function(_, profile_key, message)
				MockFlag = true
				return self:MessageAsync(profile_key, message)
			end,
			GetAsync = function(_, profile_key, version)
				MockFlag = true
				return self:GetAsync(profile_key, version)
			end,
			VersionQuery = function(_, profile_key, sort_direction, min_date, max_date)
				MockFlag = true
				return self:VersionQuery(profile_key, sort_direction, min_date, max_date)
			end,
			RemoveAsync = function(_, profile_key)
				MockFlag = true
				return self:RemoveAsync(profile_key)
			end
		},

		Name = store_name,

		template = template,
		data_store = nil,
		load_jobs = {},
		mock_load_jobs = {},
		is_ready = true,

	}
	setmetatable(self, ProfileStore)

	local options = Instance.new("DataStoreOptions")
	options:SetExperimentalFeatures({v2 = true})

	if DataStoreState == "NotReady" then

		-- The module is not sure whether DataStores are accessible yet:

		self.is_ready = false

		task.spawn(function()

			repeat task.wait() until DataStoreState ~= "NotReady"

			if DataStoreState == "Access" then
				self.data_store = DataStoreService:GetDataStore(store_name, nil, options)
			end

			self.is_ready = true

		end)

	elseif DataStoreState == "Access" then

		self.data_store = DataStoreService:GetDataStore(store_name, nil, options)

	end

	return self

end

local function RobloxMessageSubscription(profile, unique_session_id)

	local last_roblox_message = 0

	local roblox_message_subscription = MessagingService:SubscribeAsync("PS_" .. unique_session_id, function(message)
		if type(message.Data) == "table" and message.Data.LoadCount == profile.SessionLoadCount then
			-- High reaction rate, based on numPlayers  10 DataStore budget as of writing
			if os.clock() - last_roblox_message > 6 then 
				last_roblox_message = os.clock()
				if profile:IsActive() == true then
					if message.Data.EndSession == true then
						SaveProfileAsync(profile, true, false, "External")
					else
						profile:Save()
					end
				end
			end
		end
	end)

	if profile:IsActive() == true then
		profile.roblox_message_subscription = roblox_message_subscription
	else
		roblox_message_subscription:Disconnect()
	end

end

function ProfileStore:StartSessionAsync(profile_key, params)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if params ~= nil and type(params) ~= "table" then
		error(`[{script.Name}]: Invalid params`)
	end

	params = params or {}

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	local session_token = SessionToken(self.Name, profile_key, is_mock)

	if ActiveSessionCheck[session_token] ~= nil then
		error(`[{script.Name}]: Profile (STORE:{self.Name}; KEY:{profile_key}) is already loaded in this session`)
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1

	local is_user_cancel = false

	local function cancel_condition()
		if is_user_cancel == false then
			if params.Cancel ~= nil then
				is_user_cancel = params.Cancel() == true
			end
			return is_user_cancel
		end
		return true
	end

	local user_steal = params.Steal == true

	local force_load_steps = 0 -- Session conflict handling values
	local request_force_load = true
	local steal_session = false

	local start = os.clock()
	local exp_backoff = 1

	while ProfileStore.IsClosing == false and cancel_condition() == false do

		-- Load profile:

		-- SPECIAL CASE - If StartSessionAsync is called for the same key again before another StartSessionAsync finishes,
		-- grab the DataStore return for the new call. The early call will return nil. This is supposed to retain
		-- expected and efficient behavior in cases where a player would quickly rejoin the same server.

		LoadIndex += 1
		local load_id = LoadIndex
		local profile_load_jobs = is_mock == true and self.mock_load_jobs or self.load_jobs
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}

		local loaded_data, key_info
		local unique_session_id = HttpService:GenerateGUID(false)

		if profile_load_job ~= nil then

			profile_load_job[1] = load_id -- Steal load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

		else

			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job

			profile_load_job[2] = table.pack(UpdateAsync(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession

						if active_session == nil then
							latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
							latest_data.MetaData.ForceLoadSession = nil
						elseif type(active_session) == "table" then
							if IsThisSession(active_session) == false then
								local last_update = latest_data.MetaData.LastUpdate
								if last_update ~= nil then
									if os.time() - last_update > ASSUME_DEAD then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
										return
									end
								end
								if steal_session == true or user_steal == true then
									local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true
									if force_load_interrupted == false or user_steal == true then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
									end
								elseif request_force_load == true then
									latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
								end
							else
								latest_data.MetaData.ForceLoadSession = nil
							end
						end

					end,
					MissingProfileHandle = function(latest_data)

						local is_cancel = ProfileStore.IsClosing == true or cancel_condition() == true

						latest_data.Data = DeepCopyTable(self.template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = if is_cancel == false then {PlaceId, JobId, unique_session_id} else nil,
							ForceLoadSession = nil,
							MetaTags = {}, -- Backwards compatibility with ProfileService
						}

					end,
					EditProfile = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						if active_session ~= nil and IsThisSession(active_session) == true then
							latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
							latest_data.MetaData.LastUpdate = os.time()
						end

					end,
				},
				is_mock
				))
			if profile_load_job[1] == load_id then -- Load job hasn't been stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job stolen
			end
		end

		-- Handle load_data:

		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then

				if IsThisSession(active_session) == true then

					-- Profile is now taken by this session:

					local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock, session_token)
					AddProfileToAutoSave(profile)

					if is_mock ~= true and DataStoreState == "Access" then

						-- Use MessagingService to quickly detect session conflicts and resolve them quickly:
						task.spawn(RobloxMessageSubscription, profile, unique_session_id) -- Blocking prevention

					end

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						-- The server has initiated a shutdown by the time this profile was loaded
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- Don't return the profile object
					end

					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile

				else

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					-- Profile is taken by some other session:

					local force_load_session = loaded_data.MetaData.ForceLoadSession
					local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true

					if force_load_interrupted == false then

						if request_force_load == false then
							force_load_steps = force_load_steps + 1
							if force_load_steps >= math.ceil(SESSION_STEAL / LOAD_REPEAT_PERIOD) then
								steal_session = true
							end
						end

						-- Request the remote server to end its session:
						if type(active_session[3]) == "string" then
							local session_load_count = loaded_data.MetaData.SessionLoadCount or 0
							task.spawn(MessagingService.PublishAsync, MessagingService, "PS_" .. active_session[3], {LoadCount = session_load_count, EndSession = true})
						end

						-- Attempt to load the profile again after a delay
						local wait_until = os.clock() + if request_force_load == true then FIRST_LOAD_REPEAT else LOAD_REPEAT_PERIOD
						repeat task.wait() until os.clock() >= wait_until or ProfileStore.IsClosing == true

					else
						-- Another session tried to load this profile:
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					request_force_load = false -- Only request a force load once

				end

			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely that this server started shutting down
			end
		else

			-- A DataStore call has likely ended in an error:

			local default_timeout = false

			if params.Cancel == nil then
				default_timeout = os.clock() - start >= START_SESSION_TIMEOUT
			end

			if default_timeout == true or ProfileStore.IsClosing == true or cancel_condition() == true then
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

			task.wait(exp_backoff)  -- Repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- Game started shutting down or the request was cancelled - don't return the profile

end

function ProfileStore:MessageAsync(profile_key, message)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if type(message) ~= "table" then
		error(`[{script.Name}]: message must be a table`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Updating profile:

		local loaded_data = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local global_updates = latest_data.GlobalUpdates
					local update_list = global_updates[2]
					--{
					--	update_index,
					--	{
					--		{update_index, data}, ...
					--	},
					--},

					global_updates[1] += 1
					table.insert(update_list, {global_updates[1], message})

					-- Clearing queue if above limit:

					while #update_list > MAX_MESSAGE_QUEUE do
						table.remove(update_list, 1)
					end

				end,
			},
			is_mock
		)

		if loaded_data ~= nil then

			local session_token = SessionToken(self.Name, profile_key, is_mock)

			local profile = ActiveSessionCheck[session_token]

			if profile ~= nil then

				-- The message was sent to a profile that is active in this server:
				profile:Save()

			else

				local meta_data = loaded_data.MetaData or {}
				local active_session = meta_data.ActiveSession
				local session_load_count = meta_data.SessionLoadCount or 0

				if type(active_session) == "table" and type(active_session[3]) == "string" then
					-- Request the remote server to auto-save sooner and receive the message:
					task.spawn(MessagingService.PublishAsync, MessagingService, "PS_" .. active_session[3], {LoadCount = session_load_count})
				end

			end

			return true

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return false

end

function ProfileStore:GetAsync(profile_key, version)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	if version ~= nil and (is_mock or DataStoreState ~= "Access") then
		return nil -- No version support in mock mode
	end

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Load profile:

		local loaded_data, key_info = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)

					latest_data.Data = DeepCopyTable(self.template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {}, -- Backwards compatibility with ProfileService
					}

				end,
				EditProfile = nil,
			},
			is_mock,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)

		-- Handle load_data:

		if loaded_data ~= nil then

			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end

			local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock)
			profile.view_mode = true

			return profile

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return nil -- Game started shutting down - don't return the profile

end

function ProfileStore:RemoveAsync(profile_key)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local wipe_status = false

	local next_in_queue = WaitInUpdateQueue(SessionToken(self.Name, profile_key, is_mock))

	if is_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

		local mock_data_store = UserMockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				UserMockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	elseif DataStoreState ~= "Access" then -- Used when API access is disabled

		local mock_data_store = MockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				MockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	else -- Live DataStore

		wipe_status = pcall(function()
			self.data_store:RemoveAsync(profile_key)
		end)

	end

	next_in_queue()

	return wipe_status

end

local ProfileVersionQuery = {}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery.New(profile_store, profile_key, sort_direction, min_date, max_date, is_mock)

	local self = {
		profile_store = profile_store,
		profile_key = profile_key,
		sort_direction = sort_direction,
		min_date = min_date,
		max_date = max_date,

		query_pages = nil,
		query_index = 0,
		query_failure = false,

		is_query_yielded = false,
		query_queue = {},

		is_mock = is_mock,
	}
	setmetatable(self, ProfileVersionQuery)

	return self

end

function MoveVersionQueryQueue(self) -- Hidden ProfileVersionQuery method
	while #self.query_queue > 0 do

		local queue_entry = table.remove(self.query_queue, 1)

		task.spawn(queue_entry)

		if self.is_query_yielded == true then
			break
		end

	end
end

local VersionQueryNextAsyncStackingFlag = false
local WarnAboutVersionQueryOnce = false

function ProfileVersionQuery:NextAsync()

	local is_stacking = VersionQueryNextAsyncStackingFlag == true
	VersionQueryNextAsyncStackingFlag = false

	WaitForStoreReady(self.profile_store)

	if ProfileStore.IsClosing == true then
		return nil -- Silently fail :NextAsync() requests
	end

	if self.is_mock == true or DataStoreState ~= "Access" then
		if IsStudio == true and WarnAboutVersionQueryOnce == false then
			WarnAboutVersionQueryOnce = true
			warn(`[{script.Name}]: :VersionQuery() is not supported in mock mode!`)
		end
		return nil -- Silently fail :NextAsync() requests
	end

	local profile
	local is_finished = false

	local function query_job()

		if self.query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self.query_pages == nil then

			self.is_query_yielded = true

			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local list_success, error_message = pcall(function()
				self.query_pages = self.profile_store.data_store:ListVersionsAsync(
					self.profile_key,
					self.sort_direction,
					self.min_date,
					self.max_date
				)
				self.query_index = 0
			end)

			if list_success == false or self.query_pages == nil then
				warn(`[{script.Name}]: Version query fail - {tostring(error_message)}`)
				self.query_failure = true
			end

			self.is_query_yielded = false

			MoveVersionQueryQueue(self)

			return

		end

		local current_page = self.query_pages:GetCurrentPage()
		local next_item = current_page[self.query_index + 1]

		-- No more entries:

		if self.query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self.is_query_yielded = true
			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local success, error_message = pcall(function()
				self.query_pages:AdvanceToNextPageAsync()
				self.query_index = 0
			end)

			if success == false or #self.query_pages:GetCurrentPage() == 0 then
				self.query_failure = true
			end

			self.is_query_yielded = false
			MoveVersionQueryQueue(self)

			return

		end

		-- Next page item:

		self.query_index += 1
		profile = self.profile_store:GetAsync(self.profile_key, next_item.Version)
		is_finished = true

	end

	if self.is_query_yielded == false then
		query_job()
	else
		if is_stacking == true then
			table.insert(self.query_queue, 1, query_job)
		else
			table.insert(self.query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

function ProfileStore:VersionQuery(profile_key, sort_direction, min_date, max_date)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	-- Type check:

	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error(`[{script.Name}]: Invalid sort_direction ({tostring(sort_direction)})`)
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error(`[{script.Name}]: Invalid min_date ({tostring(min_date)})`)
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error(`[{script.Name}]: Invalid max_date ({tostring(max_date)})`)
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	return ProfileVersionQuery.New(self, profile_key, sort_direction, min_date, max_date, is_mock)

end

-- DataStore API access check:

if IsStudio == true then

	task.spawn(function()

		local new_state = "NoAccess"

		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)

		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil

		if no_internet_access == true then
			warn(`[{script.Name}]: No internet access - check your network connection`)
		end

		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			new_state = if no_internet_access == true then "NoInternet" else "NoAccess"
			print(`[{script.Name}]: Roblox API services unavailable - data will not be saved`)
		else
			new_state = "Access"
			print(`[{script.Name}]: Roblox API services available - data will be saved`)
		end

		DataStoreState = new_state
		ProfileStore.DataStoreState = new_state

	end)

else

	DataStoreState = "Access"
	ProfileStore.DataStoreState = "Access"

end

-- Update loop:

RunService.Heartbeat:Connect(function()

	-- Auto saving:

	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = AUTO_SAVE_PERIOD / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile.load_timestamp < AUTO_SAVE_PERIOD / 2 then
				-- This profile is freshly loaded - auto saving immediately is not necessary:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile.load_timestamp >= AUTO_SAVE_PERIOD / 2 then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end

	-- Critical state handling:

	if ProfileStore.IsCriticalState == false then
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			ProfileStore.IsCriticalState = true
			ProfileStore.OnCriticalToggle:Fire(true)
			CriticalStateStart = os.clock()
			warn(`[{script.Name}]: Entered critical state`)
		end
	else
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > CRITICAL_STATE_EXPIRE then
			ProfileStore.IsCriticalState = false
			ProfileStore.OnCriticalToggle:Fire(false)
			warn(`[{script.Name}]: Critical state ended`)
		end
	end

	-- Issue queue:

	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > CRITICAL_STATE_ERROR_EXPIRE then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end

end)

-- Release all loaded profiles when the server is shutting down:

task.spawn(function()

	while DataStoreState == "NotReady" do
		task.wait()
	end

	if DataStoreState ~= "Access" then

		game:BindToClose(function()
			ProfileStore.IsClosing = true
			task.wait() -- Mock shutdown delay
		end)

		return -- Don't wait for profiles to properly save in mock mode so studio could end the simulation faster

	end

	game:BindToClose(function()

		ProfileStore.IsClosing = true

		-- Release all active profiles:
		-- (Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released)

		local on_close_save_job_count = 0
		local active_profiles = {}
		for index, profile in ipairs(AutoSaveList) do
			active_profiles[index] = profile
		end

		-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
		for _, profile in ipairs(active_profiles) do
			if profile:IsActive() == true then
				on_close_save_job_count = on_close_save_job_count + 1
				task.spawn(function() -- Save profile on new thread
					SaveProfileAsync(profile, true, nil, "Shutdown")
					on_close_save_job_count = on_close_save_job_count - 1
				end)
			end
		end

		-- Yield until all active profile jobs are finished:
		while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
			task.wait()
		end

		return -- We're done!

	end)

end)

return ProfileStore]]></ProtectedString>
							<int64 name="SourceAssetId">109379033046155</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD01628D5ABDB4CE0B52BDED0BF9F14FB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{9B780DAC-B21A-42D1-B0D1-32E425FC5B2C}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "ProfileStore",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 109379033046155,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Loleris"},
		{Text = "Description: Periodic DataStore saving solution with session locking"},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Advanced scripting knowledge"}
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX1027499733DA41EAB7A442A0AF6540E6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">NeoHotbarLoader</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="LocalScript" referent="RBX8470EBD997B249EB95E3BC33E221A019">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">NeoHotbarLoader</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{EADDE651-7774-4545-8F79-7733EFF325E2}</string>
							<ProtectedString name="Source"><![CDATA[local NeoHotbar = require(script.NeoHotbar)

NeoHotbar:Start()]]></ProtectedString>
							<int64 name="SourceAssetId">15617827028</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX7378BDD3042C456DAAA692AD7B2400AD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">NeoHotbar</string>
								<string name="ScriptGuid">{CCFE89E9-8F36-41CA-82B2-57D97A5B67EF}</string>
								<ProtectedString name="Source">return require(script.Packages[&quot;NeoHotbar&quot;])</ProtectedString>
								<int64 name="SourceAssetId">15617827028</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXFEFB266B1F344286B42DEAFA4F41491D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Packages</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX24714C6062EC46AD91CF41E40D089F0B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Fusion</string>
										<string name="ScriptGuid">{02811EA8-EE71-4850-8916-9C1064ACE26C}</string>
										<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["elttob_fusion@0.2.0"]["fusion"])
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX623921D0E10F46F0AFE39BD25F4D9531">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">FusionUtils</string>
										<string name="ScriptGuid">{A6C57CDE-99F4-4299-A968-CC1213998F30}</string>
										<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["hexcede_fusion-utils@0.1.2"]["fusion-utils"])
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX825506DFDE854292970174A239F6059C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">NeoHotbar</string>
										<string name="ScriptGuid">{22610283-5435-4FC0-9192-5080B5153EF8}</string>
										<ProtectedString name="Source"><![CDATA[local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

local States = require(script.States)
local HotbarGui = require(script.Components.Hotbar)

local GAMEPAD_SELECTOR_INDEXERS = { Left = -1, Right = 1 }

if not RunService:IsStudio() then
	print("NeoHotbar by Avafe ")
end

--[=[
	@class NeoHotbar
]=]
local NeoHotbar = {
	Started = false,
	States = States,
}

--[=[
	Initializes NeoHotbar and deploys its UI with default settings.
]=]
function NeoHotbar:Start()
	if self.Started then
		warn("NeoHotbar has already been started. It cannot be started again.")
		return
	end

	self.Started = true

	States:Start()

	self:_CreateGui()
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)

	UserInputService.InputEnded:Connect(function(Input)
		if not States.Enabled:get() then return end
		if UserInputService:GetFocusedTextBox() then return end

		local ToolSlots = States.ToolSlots:get()

		if Input.UserInputType == Enum.UserInputType.Keyboard then
			local InputNumber = tonumber(UserInputService:GetStringForKeyCode(Input.KeyCode))
			if InputNumber then
				local ToolSlot = ToolSlots[InputNumber]
				if ToolSlot then
					States:ToggleToolEquipped(ToolSlot.Tool:get())
				end
				States.ManagementMode.Active:set(false)
			elseif Input.KeyCode == Enum.KeyCode.Backquote then
				if States.ManagementMode.Enabled:get() then
					States.ManagementMode.Active:set(not States.ManagementMode.Active:get())
				end
			end
		elseif Input.UserInputType == Enum.UserInputType.Gamepad1 then
			local EquippedToolSlot, EquippedToolSlotIndex = States:GetEquippedToolSlot()
			local SelectorDirection

			if Input.KeyCode == Enum.KeyCode.ButtonL1 then
				SelectorDirection = "Left"
			elseif Input.KeyCode == Enum.KeyCode.ButtonR1 then
				SelectorDirection = "Right"
			else
				return
			end

			local ToolSlot
			if EquippedToolSlot then
				local ToolSlotIndex = EquippedToolSlotIndex + GAMEPAD_SELECTOR_INDEXERS[SelectorDirection]
				ToolSlot = ToolSlots[ToolSlotIndex]
				ToolSlot = ToolSlot or EquippedToolSlot -- Set equipped tool to be unequipped if reached end
			else
				if not ToolSlot then -- For default / wrapover selection based on direction
					if SelectorDirection == "Left" then
						ToolSlot = ToolSlots[#ToolSlots]
					elseif SelectorDirection == "Right" then
						ToolSlot = ToolSlots[1]
					end
				end
			end

			States:ToggleToolEquipped(ToolSlot.Tool:get())
			States.ManagementMode.Active:set(false)
		elseif (Input.UserInputType == Enum.UserInputType.MouseButton1) or (Input.UserInputType == Enum.UserInputType.Touch) then
			local InteractedGuiObjects = Players.LocalPlayer.PlayerGui:GetGuiObjectsAtPosition(Input.Position.X, Input.Position.Y)
			
			local GuiWithinToolSlots
			for _, GuiObject in ipairs(InteractedGuiObjects) do
				local NeoHotbarAncestor = GuiObject:FindFirstAncestor("NeoHotbar")
				if NeoHotbarAncestor == self._HotbarGui then
					GuiWithinToolSlots = true
					break
				end
			end

			if not GuiWithinToolSlots then
				States.ManagementMode.Active:set(false)
				States.ContextMenu.Active:set(false)
			end
		end
	end)
end

--[=[
	Sets whether NeoHotbar or not is enabled. Disabling hides the hotbar and turns off keybinds.

	@param Enabled -- Whether or not to enable NeoHotbar.
]=]
function NeoHotbar:SetEnabled(Enabled: boolean)
	if typeof(Enabled) ~= "boolean" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can change if it's enabled or not.")
		return
	end

	States.Enabled:set(Enabled)

	States.ManagementMode.Active:set(false)
	States.ContextMenu.Active:set(false)
end

--[=[
	Sets whether or not ToolTips are enabled.

	@param Enabled -- Whether or not to enable.
]=]
function NeoHotbar:SetToolTipsEnabled(Enabled: boolean)
	if typeof(Enabled) ~= "boolean" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can change if ToolTips are enabled or not.")
		return
	end

	States.ToolTip.Enabled:set(Enabled)
end

--[=[
	Sets whether or not players can rearrange the tools in their hotbar.

	@param Enabled -- Whether or not to enable.
]=]
function NeoHotbar:SetManagementEnabled(Enabled: boolean)
	if typeof(Enabled) ~= "boolean" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can change if hotbar management is enabled.")
		return
	end

	States.ManagementMode.Enabled:set(Enabled)
end

--[=[
	Sets whether or not players can open the context menu. *(the one that appears when you right click on a tool)*

	@param Enabled -- Whether or not to enable.
]=]
function NeoHotbar:SetContextMenuEnabled(Enabled: boolean)
	if typeof(Enabled) ~= "boolean" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can change if the context menu is enabled or not.")
		return
	end

	States.ContextMenu.Enabled:set(Enabled)
end

--[=[
	Overrides NeoHotbar's UI with a new set of Gui objects.

	@param CustomGuiSet -- The parent folder containing your custom Gui objects.
	@param DefaultEffectsEnabled -- Whether or not to enable NeoHotbar's built-in UI effects. Not compatible with ultra-customized themes.
]=]
function NeoHotbar:OverrideGui(CustomGuiSet: Folder, DefaultEffectsEnabled: boolean?)
	if typeof(CustomGuiSet) ~= "Instance" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can override its GUI.")
		return
	end
	
	if DefaultEffectsEnabled == nil then
		DefaultEffectsEnabled = false
	end

	States.InstanceSet:set(CustomGuiSet)
	States.DefaultEffectsEnabled:set(DefaultEffectsEnabled)
	self._HotbarGui:Destroy()
	self:_CreateGui()
end

--[=[
	Reset NeoHotbar's UI back to the default.
]=]
function NeoHotbar:ResetGui()
	if not self.Started then
		warn("NeoHotbar needs to be started before you can reset its GUI.")
		return
	end

	States.InstanceSet:set(script.DefaultInstances)
	States.DefaultEffectsEnabled:set(true)
	self._HotbarGui:Destroy()
	self:_CreateGui()
end

--[=[
	Adds a custom button to the hotbar, prepended to the left-most side.

	@param ButtonName -- The name/identifier of the button to be added.
	@param IconImage -- The image URI to be used on the button icon. E.g. "rbxassetid://".
	@param Callback -- The function called upon button activation (click/touch/etc).
	@param GamepadKeybind -- A gamepad keycode to trigger your custom button.
]=]
function NeoHotbar:AddCustomButton(ButtonName: string, IconImage: string, Callback: any, GamepadKeybind: EnumItem?)
	if typeof(ButtonName) ~= "string" then return end
	if typeof(IconImage) ~= "string" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can add or remove custom buttons.")
		return
	end

	local CustomButtons = States.CustomButtons:get()
	table.insert(CustomButtons, {
		Name = ButtonName,
		Icon = IconImage,
		Callback = Callback,
		GamepadKeybind = GamepadKeybind,
	})
	States.CustomButtons:set(CustomButtons)

	if GamepadKeybind then
		ContextActionService:BindAction(`NeoHotbar_{ButtonName}`, function(_, InputState: EnumItem)
			if InputState == Enum.UserInputState.End then
				Callback()
			end
		end, false, GamepadKeybind)
	end
end

--[=[
	Removes the specified custom button from the hotbar.

	@param ButtonName -- The name of the button to be removed.
]=]
function NeoHotbar:RemoveCustomButton(ButtonName: string)
	if typeof(ButtonName) ~= "string" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can add or remove custom buttons.")
		return
	end

	local CustomButton = States:FindCustomButton(ButtonName)
	assert(CustomButton, 'Custom button "' .. ButtonName .. '" could not be found.')

	local CustomButtons = States.CustomButtons:get()
	table.remove(CustomButtons, table.find(CustomButtons, CustomButton))
	States.CustomButtons:set(CustomButtons)

	if CustomButton.GamepadKeybind then
		ContextActionService:UnbindAction(`NeoHotbar_{ButtonName}`)
	end
end

--[=[
	Returns the specified custom button if found.

	@param ButtonName -- The name of the button to be searched for.
]=]
function NeoHotbar:FindCustomButton(ButtonName: string)
	if typeof(ButtonName) ~= "string" then return end

	return States:FindCustomButton(ButtonName)
end

--[=[
	@private

	Builds NeoHotbar's UI. Only intended for internal use.
]=]
function NeoHotbar:_CreateGui()
	self._HotbarGui = HotbarGui({
		Parent = Players.LocalPlayer.PlayerGui,
	})
end

return NeoHotbar]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXC3E73DA9EAFF469C8A5A67647DFD926D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">States</string>
											<string name="ScriptGuid">{27D503DF-AA01-4528-BE1D-CE3FE8E79F0F}</string>
											<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local NeoHotbar = script.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)

local Value = Fusion.Value
local Observer = Fusion.Observer

local States = {
	Enabled = Value(true),
	InstanceSet = Value(NeoHotbar.DefaultInstances),
	DefaultEffectsEnabled = Value(true),
	ManagementMode = {
		Enabled = Value(true),
		Active = Value(false),
		Swapping = {
			PrimarySlot = Value(),
			SecondarySlot = Value(),
		},
	},
	ToolTip = {
		Enabled = Value(true),
		Visible = Value(false),
		Text = Value(""),
	},
	ContextMenu = {
		Enabled = Value(true),
		Active = Value(false),
		GuiObject = Value(),
		Actions = Value(),
	},
	ToolSlots = Value({}),
	CustomButtons = Value({}),
	GamepadInUse = Value(false),
}

function States:DropTool(Tool: Tool)
	States.Humanoid:EquipTool(Tool)
	Tool.Parent = workspace
end

function States:ToggleToolEquipped(Tool: Tool)
	if Tool.Parent == States.Backpack then
		States.Humanoid:EquipTool(Tool)
	else
		States.Humanoid:UnequipTools()
	end
end

function States:SwapToolSlots(SlotIndex1: number, SlotIndex2: number)
	local ToolSlots = States.ToolSlots:get()
	local ToolSlot1, ToolSlot2 = ToolSlots[SlotIndex1], ToolSlots[SlotIndex2]
	if ToolSlot1 and ToolSlot2 then
		ToolSlots[SlotIndex1] = ToolSlot2
		ToolSlots[SlotIndex2] = ToolSlot1
	end
	States.ToolSlots:set(ToolSlots)
end

function States:ToggleContextMenuToSlot(ToolButton: Instance, Tool: Tool)
	if States.ContextMenu.GuiObject:get() ~= ToolButton then
		States:SetContextMenuToSlot(ToolButton, Tool)
	else
		States.ContextMenu.Active:set(false)
		States.ContextMenu.GuiObject:set(nil)
		States.ContextMenu.Actions:set({})
	end
end

function States:SetContextMenuToSlot(ToolButton: GuiObject, Tool: Tool)
	if typeof(ToolButton) ~= "Instance" then
		return
	end
	if typeof(Tool) ~= "Instance" then
		return
	end
	if not Tool:IsA("Tool") then
		return
	end

	local Actions = {}
	if Tool.CanBeDropped then
		table.insert(Actions, {
			Name = "Drop",
			Function = function()
				States:DropTool(Tool)
			end,
		})
	end
	self.ContextMenu.Actions:set(Actions)

	if #Actions >= 1 then
		if self.ContextMenu.Enabled:get() then
			self.ContextMenu.GuiObject:set(ToolButton)
			self.ContextMenu.Active:set(true)
		end
	else
		self.ContextMenu.GuiObject:set(nil)
		self.ContextMenu.Active:set(false)
	end

	self.ToolTip.Visible:set(false)
end

function States:GetEquippedToolSlot()
	local ToolSlots = self.ToolSlots:get()
	for _, ToolSlot in ipairs(ToolSlots) do
		if ToolSlot.Equipped:get() then
			local Index = table.find(ToolSlots, ToolSlot)
			return ToolSlot, Index
		end
	end
end

function States:FindCustomButton(ButtonName: string)
	local CustomButtons = self.CustomButtons:get()
	for _, CustomButton in ipairs(CustomButtons) do
		if CustomButton.Name == ButtonName then
			return CustomButton
		end
	end
end

function States:_FindToolSlot(Tool: Tool)
	local ToolSlots = self.ToolSlots:get()
	for ToolNum, ToolSlot in ipairs(ToolSlots) do
		if ToolSlot.Tool:get() == Tool then
			return ToolNum
		end
	end
end

function States:_UpdateToolTip(ToolTip: string | nil)
	if ToolTip == nil then
		self.ToolTip.Visible:set(false)
	else
		if utf8.len(ToolTip) >= 1 then
			self.ToolTip.Text:set(ToolTip)
			self.ToolTip.Visible:set(States.ToolTip.Enabled:get() and true)
			if self.ToolTipProcess then
				task.cancel(self.ToolTipProcess)
			end
			self.ToolTipProcess = task.delay(2, function()
				self.ToolTip.Visible:set(false)
			end)
		else
			self.ToolTip.Visible:set(false)
		end
	end
end

function States:_UpdateToolTipListener(Tool: Tool | nil)
	if self.ToolTipChangedSignal then
		self.ToolTipChangedSignal:Disconnect()
	end

	if Tool then
		self.ToolTipChangedSignal = Tool:GetPropertyChangedSignal("ToolTip"):Connect(function()
			self:_UpdateToolTip(Tool.ToolTip)
		end)
	end
end

function States:_ToolAdded(Tool: Tool)
	if Tool:IsA("Tool") then
		local NewToolSlots = self.ToolSlots:get()
		local ToolSlot = NewToolSlots[self:_FindToolSlot(Tool)]
		if not ToolSlot then
			table.insert(NewToolSlots, {
				Tool = Value(Tool),
				Equipped = Value(Tool.Parent == self.Character),
			})
			ToolSlot = NewToolSlots[self:_FindToolSlot(Tool)]
		else
			ToolSlot.Equipped:set(Tool.Parent == self.Character)
		end
		self.ToolSlots:set(NewToolSlots)

		if ToolSlot.Equipped:get() then
			if self.ManagementMode.Active:get() then
				task.defer(function()
					if Tool.Parent == self.Character then
						self.ManagementMode.Active:set(false)
						self.ContextMenu.Active:set(false)

						if CollectionService:HasTag(GuiService.SelectedObject, "NeoHotbarToolButton") then
							GuiService.SelectedObject = nil
						end
					end
				end)
			else
				self:_UpdateToolTip(Tool.ToolTip)
				self:_UpdateToolTipListener(Tool)
			end
		end
	end
end

function States:_ToolRemoved(Tool: Tool)
	local NewToolSlots = self.ToolSlots:get()
	local ToolNum = self:_FindToolSlot(Tool)
	local ToolSlot = NewToolSlots[ToolNum]
	if ToolSlot then
		if Tool.Parent ~= self.Backpack and Tool.Parent ~= self.Character then
			table.remove(NewToolSlots, ToolNum)
			self:_UpdateToolTip()
		else
			ToolSlot.Equipped:set(Tool.Parent == self.Character)
		end
		self.ToolSlots:set(NewToolSlots)

		self:_UpdateToolTipListener()
	end
end

function States:_ScanToolDir(ToolDir: Instance)
	for _, Child in ipairs(ToolDir:GetChildren()) do
		self:_ToolAdded(Child)
	end
end

function States:_CharacterAdded(NewChar: Model)
	self.ToolSlots:set({})

	self.Character = NewChar
	self.Humanoid = self.Character:WaitForChild("Humanoid")

	self.Character.ChildAdded:Connect(function(Tool)
		self:_ToolAdded(Tool)
	end)
	self.Character.ChildRemoved:Connect(function(Tool)
		self:_ToolRemoved(Tool)
	end)
	self:_ScanToolDir(self.Character)

	self.Backpack = Players.LocalPlayer:WaitForChild("Backpack")
	self.Backpack.ChildAdded:Connect(function(Tool)
		self:_ToolAdded(Tool)
	end)
	self.Backpack.ChildRemoved:Connect(function(Tool)
		self:_ToolRemoved(Tool)
	end)
	self:_ScanToolDir(self.Backpack)
end

function States:_UpdateGamepadInUse(Input: InputObject)
	local Gamepads = {
		Enum.UserInputType.Gamepad1,
		Enum.UserInputType.Gamepad2,
		Enum.UserInputType.Gamepad3,
		Enum.UserInputType.Gamepad4,
		Enum.UserInputType.Gamepad5,
		Enum.UserInputType.Gamepad6,
		Enum.UserInputType.Gamepad7,
		Enum.UserInputType.Gamepad8,
	}
	States.GamepadInUse:set(table.find(Gamepads, Input.UserInputType) ~= nil)
end

function States:Start()
	self.Backpack = Players.LocalPlayer:WaitForChild("Backpack")

	Players.LocalPlayer.CharacterAdded:Connect(function(Char)
		self:_CharacterAdded(Char)
	end)
	local ExistingCharacter = Players.LocalPlayer.Character
	if ExistingCharacter then
		self:_CharacterAdded(ExistingCharacter)
	end

	Observer(self.ManagementMode.Active):onChange(function()
		if self.ManagementMode.Active:get() then
			if self.Humanoid then
				self.Humanoid:UnequipTools()
			end
		else
			States.ManagementMode.Swapping.PrimarySlot:set(nil)
			States.ManagementMode.Swapping.SecondarySlot:set(nil)
		end
	end)

	UserInputService.InputChanged:Connect(function(Input: InputObject)
		self:_UpdateGamepadInUse(Input)
	end)
	UserInputService.InputEnded:Connect(function(Input: InputObject)
		self:_UpdateGamepadInUse(Input)
	end)
end

return States
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXF38DB897925D469384C931BAFF1C5597">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Hotbar.story</string>
											<string name="ScriptGuid">{46ECD976-F80B-4718-8372-604333EB6CF5}</string>
											<ProtectedString name="Source"><![CDATA[local GuiModules = {script.Parent.Components.Hotbar}

return function(Target)
    local Guis = {}

    for _, GuiModule in ipairs(GuiModules) do
        local GuiNameSplit = string.split(GuiModule.Name, ".")
        local StorySuffix = GuiNameSplit[2]
        
        if not StorySuffix and GuiModule:IsA("ModuleScript") then
            local Gui = require(GuiModule)
            table.insert(Guis, Gui {
                Parent = Target
            })
        end
    end

    return function()
        for _, Gui in ipairs(Guis) do
            Gui:Destroy()
        end
    end
end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Folder" referent="RBX4E5A0F9FE4744C0CA3B19A7F17311796">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Components</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX1BBD9DC85B0E448F8D51FE9267AC1AA0">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">ButtonImage</string>
												<string name="ScriptGuid">{DBF21866-94A4-439A-9520-35450DB98940}</string>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child

return function(Props: table)
	Props.Image = EnsureProp(Props.Image, "string", "")

	return Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		[Child "Image"] = {
			Image = Props.Image
		}
	}
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX61088C2254E34CF68B6D1AB0475F4795">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">ButtonText</string>
												<string name="ScriptGuid">{BD60E87A-F75D-435E-B486-DE5ECD95BA6F}</string>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Hydrate = Fusion.Hydrate

return function(Props: table)
	Props.Text = EnsureProp(Props.Text, "string", "Text")

	local ButtonText = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		Text = Props.Text,
	}

	if States.DefaultEffectsEnabled:get() then
		Hydrate(ButtonText)({
			FontFace = Font.fromName("GothamSsm")
		})
	end

	return ButtonText
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXB5DCF39477F74CA195A0F7F0BE83B0FB">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">ContextMenu</string>
												<string name="ScriptGuid">{483D31E2-0928-4706-A0D7-EEEDDE1CB5C0}</string>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)

local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child
local Children = Fusion.Children
local ForValues = Fusion.ForValues

local Components = NeoHotbar.Components
local ContextActionButton = require(Components.ContextActionButton)

return function()
	return Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		Visible = States.ContextMenu.Active,

		[Child "Actions"] = {
			[Children] = {
				ForValues(States.ContextMenu.Actions, function(Action)
					return ContextActionButton({
						Action = Action,
					})
				end, Fusion.cleanup),
			},
		},
	}
end
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX8AEF6044379445B4A5E4516387E59869">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">CustomButton</string>
												<string name="ScriptGuid">{026505FC-C4D8-4F3A-9B2D-8D40E43F3D98}</string>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Children = Fusion.Children
local OnEvent = Fusion.OnEvent
local Hydrate = Fusion.Hydrate

local Components = NeoHotbar.Components

local ButtonImage = require(Components.ButtonImage)
local ButtonHint = require(Components.ButtonHint)

return function(Props: table)
	Props.LayoutOrder = EnsureProp(Props.LayoutOrder, "number", 0)
	Props.Callback = EnsureProp(Props.Callback, "function", function()end)
	Props.Icon = EnsureProp(Props.Icon, "string", "")
	Props.GamepadKeybind = EnsureProp(Props.GamepadKeybind, "EnumItem", nil)
	
	return Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		LayoutOrder = Props.LayoutOrder,

		[OnEvent "Activated"] = function()
			if Props.Callback:get() then
				Props.Callback:get()()
			end
		end,

		[Children] = {
			ButtonImage {
				Image = Props.Icon
			},
			ButtonHint {
				Keycode = Props.GamepadKeybind
			}
		}
	}
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXA09FC5E865794271A9738F39476597CF">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Hotbar</string>
												<string name="ScriptGuid">{EB00646B-393C-4BF9-A961-53FEC8FA2FF7}</string>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Computed = Fusion.Computed
local Children = Fusion.Children
local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child
local ForPairs = Fusion.ForPairs

local Components = NeoHotbar.Components

local ToolButton = require(Components.ToolButton)
local CustomButton = require(Components.CustomButton)
local ToolTip = require(Components.ToolTip)

return function(Props: table)
	Props.Parent = EnsureProp(Props.Parent, "Instance", nil)

	local Hotbar = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		Name = "NeoHotbar",
		Parent = Props.Parent,
		Enabled = States.Enabled,

		[Child "Hotbar"] = {
			[Child "Buttons"] = {
				[Child "CustomButtons"] = {
					Visible = Computed(function()
						return not States.ManagementMode.Active:get()
					end),

					[Children] = ForPairs(States.CustomButtons, function(ButtonNum, ButtonEntry)
						return ButtonNum,
							CustomButton {
								Icon = ButtonEntry.Icon,
								Callback = ButtonEntry.Callback,
								LayoutOrder = ButtonEntry.LayoutOrder,
								GamepadKeybind = ButtonEntry.GamepadKeybind,
							}
					end, Fusion.cleanup),
				},
				[Child "ToolSlots"] = {
					[Children] = ForPairs(States.ToolSlots, function(ToolNum, ToolSlot)
						return ToolNum,
							ToolButton {
								Tool = ToolSlot.Tool,
								Equipped = ToolSlot.Equipped,
								ToolNumber = ToolNum,
								LayoutOrder = ToolNum,
							}
					end, Fusion.cleanup),
				},
			},

			[Children] = {
				ToolTip {},
			},
		},
	}

	if States.DefaultEffectsEnabled:get() then
		local Padding = Computed(function()
			local ManagementModeEnabled = States.ManagementMode.Active:get()
			return UDim.new(0, (ManagementModeEnabled and 4) or 0)
		end)

		Hydrate(Hotbar) {
			[Child "Hotbar"] = {
				[Child "Buttons"] = {
					[Child "ToolSlots"] = {
						BackgroundTransparency = Computed(function()
							return (States.ManagementMode.Active:get() and 0.8) or 1
						end),

						[Child "UIPadding"] = {
							PaddingTop = Padding,
							PaddingBottom = Padding,
							PaddingRight = Padding,
							PaddingLeft = Padding,
						},
						[Child "UIStroke"] = {
							Enabled = States.ManagementMode.Active,
						},
					},
					[Child "UIListLayout"] = {
						Padding = Computed(function()
							local ToolSlots = States.ToolSlots:get()
							local CustomButtons = States.CustomButtons:get()
							local OffsetPadding = ((#ToolSlots >= 1 and #CustomButtons >= 1) and 10) or 0
							return UDim.new(0, OffsetPadding)
						end),
					},
				},
			},
		}
	end

	return Hotbar
end
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX544C92B627944094990E01D889394BE2">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">ToolButton</string>
												<string name="ScriptGuid">{AB657BFF-1ED8-4D34-BBB2-4DF595CC95E1}</string>
												<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Children = Fusion.Children
local Computed = Fusion.Computed
local OnEvent = Fusion.OnEvent
local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child
local Value = Fusion.Value
local New = Fusion.New
local Observer = Fusion.Observer
local Cleanup = Fusion.Cleanup

local Components = NeoHotbar.Components

local ButtonText = require(Components.ButtonText)
local ButtonImage = require(Components.ButtonImage)
local ContextMenu = require(Components.ContextMenu)

local Mouse = Players.LocalPlayer:GetMouse()
local PlayerGui = Players.LocalPlayer:FindFirstChild("PlayerGui")

local HoveredToolSlot = Value()

local MouseMoveConnection: RBXScriptConnection
local TouchMoveConnection: RBXScriptConnection

UserInputService.InputEnded:Connect(function(Input: InputObject)
	if (Input.UserInputType == Enum.UserInputType.MouseButton1) or Input.UserInputType == Enum.UserInputType.Touch then
		if MouseMoveConnection then
			MouseMoveConnection:Disconnect()
		end
		if TouchMoveConnection then
			TouchMoveConnection:Disconnect()
		end

		if States.ManagementMode.Swapping.PrimarySlot:get() and States.ManagementMode.Swapping.SecondarySlot:get() then
			States:SwapToolSlots(
				States.ManagementMode.Swapping.PrimarySlot:get():GetAttribute("SlotNumber"),
				States.ManagementMode.Swapping.SecondarySlot:get():GetAttribute("SlotNumber")
			)
		end
		States.ManagementMode.Swapping.PrimarySlot:set(nil)
		States.ManagementMode.Swapping.SecondarySlot:set(nil)
	end
end)

local function SelectionMove(X: number, Y: number)
	if PlayerGui then
		local Objects = PlayerGui:GetGuiObjectsAtPosition(X, Y)
		for _, Object in ipairs(Objects) do
			if CollectionService:HasTag(Object, "NeoHotbarToolButton") then
				if Object ~= HoveredToolSlot:get() then
					HoveredToolSlot:set(Object)
					States.ManagementMode.Swapping.SecondarySlot:set(Object)
				end
			end
		end
	end
end

return function(Props: table)
	Props.LayoutOrder = EnsureProp(Props.LayoutOrder, "number", 1)
	Props.Equipped = EnsureProp(Props.Equipped, "boolean", false)
	Props.Tool = EnsureProp(Props.Tool, "Tool", Instance.new("Tool"))
	Props.ToolNumber = EnsureProp(Props.ToolNumber, "number", 1)

	local Holding = Value(false)
	local ObserverDisconnects = {}

	local ToolButton
	ToolButton = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		LayoutOrder = Props.LayoutOrder,

		[OnEvent "Activated"] = function()
			if States.ManagementMode.Active:get() then
				local SwappedTool = false
				if GuiService.SelectedObject == ToolButton then
					if States.ManagementMode.Swapping.PrimarySlot:get() then
						States.ManagementMode.Swapping.SecondarySlot:set(ToolButton)
						States:SwapToolSlots(
							States.ManagementMode.Swapping.PrimarySlot:get():GetAttribute("SlotNumber"),
							States.ManagementMode.Swapping.SecondarySlot:get():GetAttribute("SlotNumber")
						)

						States.ManagementMode.Swapping.PrimarySlot:set()
						States.ManagementMode.Swapping.SecondarySlot:set()
						SwappedTool = true
					else
						States.ManagementMode.Swapping.PrimarySlot:set(ToolButton)
					end
				end

				if SwappedTool then
					States.ContextMenu.Active:set(false)
				else
					States:ToggleContextMenuToSlot(ToolButton, Props.Tool:get())
				end
			else
				States:ToggleToolEquipped(Props.Tool:get())
			end
		end,
		[OnEvent "MouseButton2Click"] = function()
			States:ToggleContextMenuToSlot(ToolButton, Props.Tool:get())
		end,
		[OnEvent "MouseButton1Down"] = function()
			Holding:set(true)

			if States.ManagementMode.Enabled:get() then
				if not States.ManagementMode.Active:get() or GuiService.SelectedObject == ToolButton then
					if States.HotbarHoldProcess then
						task.cancel(States.HotbarHoldProcess)
					end
					States.HotbarHoldProcess = task.delay(0.25, function()
						if Holding:get() == true then
							Holding:set(false)

							States.ManagementMode.Active:set(not States.ManagementMode.Active:get())
							States.ToolTip.Visible:set(false)
							States.ContextMenu.Active:set(false)

							if
								(not States.ManagementMode.Active:get()) and (GuiService.SelectedObject == ToolButton)
							then
								GuiService.SelectedObject = nil
							end
						end
					end)
				end
			end

			if States.ManagementMode.Active:get() and GuiService.SelectedObject ~= ToolButton then
				States.ManagementMode.Swapping.PrimarySlot:set(ToolButton)

				MouseMoveConnection = Mouse.Move:Connect(function()
					SelectionMove(Mouse.X, Mouse.Y)
				end)
				TouchMoveConnection = UserInputService.TouchMoved:Connect(function(Input: InputObject)
					SelectionMove(Input.Position.X, Input.Position.Y)
				end)
			end
		end,
		[OnEvent "MouseButton1Up"] = function()
			Holding:set(false)

			if States.ManagementMode.Swapping.PrimarySlot:get() == ToolButton then
				States.ManagementMode.Swapping.PrimarySlot:set(nil)
			end

			if MouseMoveConnection then
				MouseMoveConnection:Disconnect()
			end
			if TouchMoveConnection then
				TouchMoveConnection:Disconnect()
			end
		end,
		[OnEvent "MouseLeave"] = function()
			Holding:set(false)
		end,

		[Cleanup] = function()
			if MouseMoveConnection then
				MouseMoveConnection:Disconnect()
			end
			for _, Disconnect in ipairs(ObserverDisconnects) do
				Disconnect()
			end
		end,

		[Child "ToolNumber"] = {
			Text = Props.ToolNumber,
			Font = (States.DefaultEffectsEnabled:get() and Enum.Font.Gotham) or nil,
		},

		[Children] = {
			Computed(function()
				if Props.Tool:get().TextureId ~= "" then
					return ButtonImage {
						Image = Computed(function()
							local Image
							if Props.Tool:get() then
								Image = Props.Tool:get().TextureId
							end
							return Image or ""
						end),
					}
				else
					return ButtonText {
						Text = Computed(function()
							local Name
							if Props.Tool:get() then
								Name = Props.Tool:get().Name
							end
							return Name or "Tool"
						end),
					}
				end
			end, Fusion.cleanup),

			Computed(function()
				if States.ContextMenu.Active:get() and States.ContextMenu.GuiObject:get() == ToolButton then
					return ContextMenu {}
				else
					return {}
				end
			end, Fusion.cleanup),
		},
	}

	if States.DefaultEffectsEnabled:get() then
		Hydrate(ToolButton)({
			BackgroundColor3 = Fusion.Computed(function()
				local PrimarySlot = States.ManagementMode.Swapping.PrimarySlot:get()
				local SecondarySlot = States.ManagementMode.Swapping.SecondarySlot:get()

				local IsPrimarySwapSlot = PrimarySlot and (PrimarySlot == ToolButton)
				local IsSecondarySwapSlot = SecondarySlot and (SecondarySlot == ToolButton)

				if Holding:get() or (IsPrimarySwapSlot or IsSecondarySwapSlot) then
					return Color3.fromRGB(20, 20, 20)
				else
					return Color3.fromRGB(0, 0, 0)
				end
			end),

			[Child "UIStroke"] = {
				Enabled = Props.Equipped,
			},
		})
	end

	table.insert(
		ObserverDisconnects,
		Observer(Holding):onChange(function()
			ToolButton:SetAttribute("Holding", Holding:get())
		end)
	)
	ToolButton:SetAttribute("Holding", Holding:get())
	ToolButton:SetAttribute("Equipped", Props.Equipped:get())
	ToolButton:SetAttribute("SlotNumber", Props.ToolNumber:get())
	New "ObjectValue" {
		Name = "Tool",
		Value = Props.Tool:get(),
		Parent = ToolButton,
	}

	CollectionService:AddTag(ToolButton, "NeoHotbarToolButton")

	return ToolButton
end
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXB058D45F92CC4E6C9C09F29BEF87C383">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">ToolTip</string>
												<string name="ScriptGuid">{EAE29228-729C-4BB0-BD33-7DC988999D24}</string>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)

local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child
local Computed = Fusion.Computed
local Spring = Fusion.Spring

return function()
	local ToolTip = Hydrate(States.InstanceSet:get().ToolTip:Clone())({
		[Child "Text"] = {
			Text = States.ToolTip.Text,
		},
	})

	if States.DefaultEffectsEnabled:get() then
		Hydrate(ToolTip)({
			GroupTransparency = Spring(Computed(function()
				local Visible = States.ToolTip.Enabled:get() and States.ToolTip.Visible:get()
				return (Visible and 0) or 1
			end), 25, 1),

			[Child "Text"] = {
				Font = Enum.Font.Gotham,
			},
		})
	end

	return ToolTip
end
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX1A41D1DDFA3F4A2195D66049A18FA86C">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">ContextActionButton</string>
												<string name="ScriptGuid">{03C2B86C-B7AC-4258-BC60-8186143A0265}</string>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Hydrate = Fusion.Hydrate
local OnEvent = Fusion.OnEvent
local Value = Fusion.Value
local Computed = Fusion.Computed
local Child = FusionUtils.Child
local Observer = Fusion.Observer
local Cleanup = Fusion.Cleanup

return function(Props: table)
	Props.Action = EnsureProp(Props.Action, "table", {})

	local Hovering = Value(false)
	local ObserverDisconnects = {}

	local ContextActionButton = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		[OnEvent "Activated"] = function()
			States.ContextMenu.Active:set(false)

			if Props.Action:get() and Props.Action:get().Function then
				Props.Action:get():Function()
			end
		end,
		[OnEvent "MouseEnter"] = function()
			Hovering:set(true)
		end,
		[OnEvent "MouseLeave"] = function()
			Hovering:set(false)
		end,

		[Child "Text"] = {
			Text = Computed(function()
				local Name
				if Props.Action:get() then
					Name = Props.Action:get().Name
				end
				return Name or "Action"
			end),
		},

		[Cleanup] = function()
			for _, Disconnect in ipairs(ObserverDisconnects) do
				Disconnect()
			end
		end
	}

	if States.DefaultEffectsEnabled:get() then
		Hydrate(ContextActionButton) {
			BackgroundTransparency = Computed(function()
				return (Hovering:get() and 0.925) or 1
			end),

			[Child "Text"] = {
				FontFace = Font.fromName("GothamSsm")
			}
		}
	end

	table.insert(ObserverDisconnects, Observer(Hovering):onChange(function()
		ContextActionButton:SetAttribute("Hovering", Hovering:get())
	end))
	ContextActionButton:SetAttribute("Hovering", Hovering:get())

	return ContextActionButton
end
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX16F6F5E589DF44658C02D0284C3A61C5">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">ButtonHint</string>
												<string name="ScriptGuid">{E2BE9925-C95E-4472-A5BC-5BE5207781A0}</string>
												<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Hydrate = Fusion.Hydrate
local Computed = Fusion.Computed
local Child = FusionUtils.Child
local Spring = Fusion.Spring
local Observer = Fusion.Observer
local Cleanup = Fusion.Cleanup

return function(Props: table)
	Props.Keycode = EnsureProp(Props.Keycode, "EnumItem", nil)
  
  local KeycodeImage = Computed(function()
    if typeof(Props.Keycode:get()) == "EnumItem" then
      return UserInputService:GetImageForKeyCode(Props.Keycode:get())
    else
      return ""
    end
  end)
  local Shown = Computed(function()
    return States.GamepadInUse:get() and (string.len(KeycodeImage:get()) >= 1)
  end)
  local ObserverDisconnects = {}

	local ButtonHint = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
    [Child "Image"] = {
      Image = KeycodeImage,
    },
    
    [Cleanup] = function()
      for _, Disconnect in ipairs(ObserverDisconnects) do
        Disconnect()
      end
    end
	}

  if States.DefaultEffectsEnabled:get() then
    Hydrate(ButtonHint) {
      GroupTransparency = Spring(Computed(function()
        return (Shown:get() and 0) or 1
      end), 40, 1),
    }
  end

  table.insert(ObserverDisconnects, Observer(Shown):onChange(function()
    ButtonHint:SetAttribute("Shown", Shown:get())
  end))
  ButtonHint:SetAttribute("Shown", Shown:get())

  return ButtonHint
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX4641D7FB82F44BDFB2B498399A993AD3">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ExtPackages</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX8BD1D34D07A54274A6D6356A44742241">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">EnsureProp</string>
												<string name="ScriptGuid">{4C462869-8B1D-4FC4-B438-753AB0D3BFBA}</string>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)

local Value = Fusion.Value

return function(Prop: any, Type: string, Default: any)
  if Prop == nil then
    return Value(Default)
  elseif typeof(Prop) == Type then
    return Value(Prop)
  else
    return Prop
  end
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX710B24DB065343E29BFED670BAA2277A">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">DefaultInstances</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="TextButton" referent="RBXFBE7811826604424AF0BAF97FBA03358">
											<Properties>
												<bool name="Active">true</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoButtonColor">false</bool>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="BackgroundTransparency">0.300000012</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">false</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<Font name="FontFace">
													<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
													<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
												</Font>
												<Ref name="HoverHapticEffect">null</Ref>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">1</int>
												<float name="LineHeight">1</float>
												<string name="LocalizationMatchIdentifier"></string>
												<string name="LocalizationMatchedSourceText"></string>
												<int name="MaxVisibleGraphemes">-1</int>
												<bool name="Modal">false</bool>
												<string name="Name">CustomButton</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<string name="OpenTypeFeatures"></string>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<Ref name="PressHapticEffect">null</Ref>
												<bool name="RichText">false</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">true</bool>
												<bool name="Selected">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>60</XO>
													<YS>0</YS>
													<YO>60</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<token name="Style">0</token>
												<BinaryString name="Tags"></BinaryString>
												<string name="Text"></string>
												<Color3 name="TextColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="TextDirection">0</token>
												<bool name="TextScaled">false</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">false</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
											<Item class="UICorner" referent="RBXE5D0E195624A4CB0BE11ED53E3CD81BE">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<UDim name="CornerRadius">
														<S>0</S>
														<O>7</O>
													</UDim>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UICorner</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="UIStroke" referent="RBXED5863DD883D464AB03AD4042ABDFEAF">
												<Properties>
													<token name="ApplyStrokeMode">1</token>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<UDim name="BorderOffset">
														<S>0</S>
														<O>0</O>
													</UDim>
													<token name="BorderStrokePosition">0</token>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<Color3 name="Color">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Enabled">true</bool>
													<token name="LineJoinMode">0</token>
													<string name="Name">UIStroke</string>
													<int64 name="SourceAssetId">-1</int64>
													<token name="StrokeSizingMode">0</token>
													<BinaryString name="Tags"></BinaryString>
													<float name="Thickness">2</float>
													<float name="Transparency">0.300000012</float>
													<int name="ZIndex">1</int>
												</Properties>
											</Item>
										</Item>
										<Item class="TextButton" referent="RBXC830EBDE1B564D9B89C1B3A25F1D2F9D">
											<Properties>
												<bool name="Active">true</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoButtonColor">false</bool>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="BackgroundTransparency">0.300000012</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">false</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<Font name="FontFace">
													<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
													<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
												</Font>
												<Ref name="HoverHapticEffect">null</Ref>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">2</int>
												<float name="LineHeight">1</float>
												<string name="LocalizationMatchIdentifier"></string>
												<string name="LocalizationMatchedSourceText"></string>
												<int name="MaxVisibleGraphemes">-1</int>
												<bool name="Modal">false</bool>
												<string name="Name">ToolButton</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<string name="OpenTypeFeatures"></string>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<Ref name="PressHapticEffect">null</Ref>
												<bool name="RichText">false</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">true</bool>
												<bool name="Selected">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>60</XO>
													<YS>0</YS>
													<YO>60</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<token name="Style">0</token>
												<BinaryString name="Tags"></BinaryString>
												<string name="Text"></string>
												<Color3 name="TextColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="TextDirection">0</token>
												<bool name="TextScaled">false</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">false</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
											<Item class="UICorner" referent="RBX05F2FB47002D4D04B75ADCD8A1DD48C8">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<UDim name="CornerRadius">
														<S>0</S>
														<O>7</O>
													</UDim>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UICorner</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="UIStroke" referent="RBX49BA234F4936467A99C4B58F7A4D243B">
												<Properties>
													<token name="ApplyStrokeMode">1</token>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<UDim name="BorderOffset">
														<S>0</S>
														<O>0</O>
													</UDim>
													<token name="BorderStrokePosition">0</token>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<Color3 name="Color">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Enabled">false</bool>
													<token name="LineJoinMode">0</token>
													<string name="Name">UIStroke</string>
													<int64 name="SourceAssetId">-1</int64>
													<token name="StrokeSizingMode">0</token>
													<BinaryString name="Tags"></BinaryString>
													<float name="Thickness">2</float>
													<float name="Transparency">0.300000012</float>
													<int name="ZIndex">1</int>
												</Properties>
											</Item>
											<Item class="TextLabel" referent="RBX6E0C6FBA8AC449019AB46504F7F5B282">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Font name="FontFace">
														<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
														<Weight>400</Weight>
														<Style>Normal</Style>
														<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
													</Font>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<float name="LineHeight">1</float>
													<string name="LocalizationMatchIdentifier"></string>
													<string name="LocalizationMatchedSourceText"></string>
													<int name="MaxVisibleGraphemes">-1</int>
													<string name="Name">ToolNumber</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<string name="OpenTypeFeatures"></string>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>5</XO>
														<YS>0</YS>
														<YO>3</YO>
													</UDim2>
													<bool name="RichText">false</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
													<string name="Text">10</string>
													<Color3 name="TextColor3">
														<R>0.666666687</R>
														<G>0.666666687</G>
														<B>0.666666687</B>
													</Color3>
													<token name="TextDirection">0</token>
													<bool name="TextScaled">false</bool>
													<float name="TextSize">13</float>
													<Color3 name="TextStrokeColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="TextStrokeTransparency">1</float>
													<float name="TextTransparency">0</float>
													<token name="TextTruncate">0</token>
													<bool name="TextWrapped">false</bool>
													<token name="TextXAlignment">0</token>
													<token name="TextYAlignment">1</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
											</Item>
										</Item>
										<Item class="TextLabel" referent="RBXC52E096318D7485B9E997D85F4F588FD">
											<Properties>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">false</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<Font name="FontFace">
													<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
													<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
												</Font>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<float name="LineHeight">1</float>
												<string name="LocalizationMatchIdentifier"></string>
												<string name="LocalizationMatchedSourceText"></string>
												<int name="MaxVisibleGraphemes">-1</int>
												<string name="Name">ButtonText</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<string name="OpenTypeFeatures"></string>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<bool name="RichText">false</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>1</XS>
													<XO>0</XO>
													<YS>1</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<string name="Text">StarterTool</string>
												<Color3 name="TextColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<token name="TextDirection">0</token>
												<bool name="TextScaled">false</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">true</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
										</Item>
										<Item class="Frame" referent="RBXE0D47DE8859B441C9429857ED08DCFA6">
											<Properties>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">false</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<string name="Name">ButtonImage</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>1</XS>
													<XO>0</XO>
													<YS>1</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<token name="Style">0</token>
												<BinaryString name="Tags"></BinaryString>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
											<Item class="UIPadding" referent="RBXF5264163DD51484486F9DDCF29159ED1">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIPadding</string>
													<UDim name="PaddingBottom">
														<S>0.140000001</S>
														<O>0</O>
													</UDim>
													<UDim name="PaddingLeft">
														<S>0.140000001</S>
														<O>0</O>
													</UDim>
													<UDim name="PaddingRight">
														<S>0.140000001</S>
														<O>0</O>
													</UDim>
													<UDim name="PaddingTop">
														<S>0.140000001</S>
														<O>0</O>
													</UDim>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ImageLabel" referent="RBX598E4F3ECB2B428E81E47941A1FE790A">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Content name="Image"><url>rbxassetid://8539764711</url></Content>
													<Color3 name="ImageColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<Vector2 name="ImageRectOffset">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<Vector2 name="ImageRectSize">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<float name="ImageTransparency">0</float>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<string name="Name">Image</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="ResampleMode">0</token>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<token name="ScaleType">0</token>
													<bool name="Selectable">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<Rect2D name="SliceCenter">
														<min>
															<X>0</X>
															<Y>0</Y>
														</min>
														<max>
															<X>0</X>
															<Y>0</Y>
														</max>
													</Rect2D>
													<float name="SliceScale">1</float>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
													<UDim2 name="TileSize">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
											</Item>
										</Item>
										<Item class="ScreenGui" referent="RBX2C36F2818DAE4558AB447816ACE47822">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipToDeviceSafeArea">true</bool>
												<bool name="DefinesCapabilities">false</bool>
												<int name="DisplayOrder">1000</int>
												<bool name="Enabled">true</bool>
												<string name="Name">Hotbar</string>
												<bool name="ResetOnSpawn">false</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SafeAreaCompatibility">1</token>
												<token name="ScreenInsets">2</token>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<token name="ZIndexBehavior">1</token>
											</Properties>
											<Item class="Frame" referent="RBX55F05A7B1AFE44428D630DF2F9610060">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0.5</X>
														<Y>1</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<string name="Name">Hotbar</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0.5</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>-8</YO>
													</UDim2>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<int64 name="SourceAssetId">-1</int64>
													<token name="Style">0</token>
													<BinaryString name="Tags"></BinaryString>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
												<Item class="UIListLayout" referent="RBXEDAC9616CCBE451CAD6A035C6E949A44">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<token name="FillDirection">1</token>
														<token name="HorizontalAlignment">0</token>
														<token name="HorizontalFlex">0</token>
														<token name="ItemLineAlignment">0</token>
														<string name="Name">UIListLayout</string>
														<UDim name="Padding">
															<S>0</S>
															<O>8</O>
														</UDim>
														<token name="SortOrder">2</token>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
														<token name="VerticalAlignment">2</token>
														<token name="VerticalFlex">0</token>
														<bool name="Wraps">false</bool>
													</Properties>
												</Item>
												<Item class="Frame" referent="RBXFC5C32B867244E1E91DF7DD58D23566C">
													<Properties>
														<bool name="Active">false</bool>
														<Vector2 name="AnchorPoint">
															<X>0</X>
															<Y>0</Y>
														</Vector2>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<bool name="AutoLocalize">true</bool>
														<token name="AutomaticSize">3</token>
														<Color3 name="BackgroundColor3">
															<R>1</R>
															<G>1</G>
															<B>1</B>
														</Color3>
														<float name="BackgroundTransparency">1</float>
														<Color3 name="BorderColor3">
															<R>0.105882362</R>
															<G>0.164705887</G>
															<B>0.207843155</B>
														</Color3>
														<token name="BorderMode">0</token>
														<int name="BorderSizePixel">1</int>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="ClipsDescendants">false</bool>
														<bool name="DefinesCapabilities">false</bool>
														<bool name="Draggable">false</bool>
														<bool name="Interactable">true</bool>
														<int name="LayoutOrder">2</int>
														<string name="Name">Buttons</string>
														<Ref name="NextSelectionDown">null</Ref>
														<Ref name="NextSelectionLeft">null</Ref>
														<Ref name="NextSelectionRight">null</Ref>
														<Ref name="NextSelectionUp">null</Ref>
														<UDim2 name="Position">
															<XS>0</XS>
															<XO>0</XO>
															<YS>0</YS>
															<YO>0</YO>
														</UDim2>
														<Ref name="RootLocalizationTable">null</Ref>
														<float name="Rotation">0</float>
														<bool name="Selectable">false</bool>
														<token name="SelectionBehaviorDown">0</token>
														<token name="SelectionBehaviorLeft">0</token>
														<token name="SelectionBehaviorRight">0</token>
														<token name="SelectionBehaviorUp">0</token>
														<bool name="SelectionGroup">false</bool>
														<Ref name="SelectionImageObject">null</Ref>
														<int name="SelectionOrder">0</int>
														<UDim2 name="Size">
															<XS>0</XS>
															<XO>0</XO>
															<YS>0</YS>
															<YO>0</YO>
														</UDim2>
														<token name="SizeConstraint">0</token>
														<int64 name="SourceAssetId">-1</int64>
														<token name="Style">0</token>
														<BinaryString name="Tags"></BinaryString>
														<bool name="Visible">true</bool>
														<int name="ZIndex">1</int>
													</Properties>
													<Item class="Frame" referent="RBXE972070291394024B930B4294D316AF5">
														<Properties>
															<bool name="Active">false</bool>
															<Vector2 name="AnchorPoint">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<bool name="AutoLocalize">true</bool>
															<token name="AutomaticSize">3</token>
															<Color3 name="BackgroundColor3">
																<R>0</R>
																<G>0</G>
																<B>0</B>
															</Color3>
															<float name="BackgroundTransparency">1</float>
															<Color3 name="BorderColor3">
																<R>0.105882362</R>
																<G>0.164705887</G>
																<B>0.207843155</B>
															</Color3>
															<token name="BorderMode">0</token>
															<int name="BorderSizePixel">1</int>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="ClipsDescendants">false</bool>
															<bool name="DefinesCapabilities">false</bool>
															<bool name="Draggable">false</bool>
															<bool name="Interactable">true</bool>
															<int name="LayoutOrder">3</int>
															<string name="Name">ToolSlots</string>
															<Ref name="NextSelectionDown">null</Ref>
															<Ref name="NextSelectionLeft">null</Ref>
															<Ref name="NextSelectionRight">null</Ref>
															<Ref name="NextSelectionUp">null</Ref>
															<UDim2 name="Position">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<Ref name="RootLocalizationTable">null</Ref>
															<float name="Rotation">0</float>
															<bool name="Selectable">false</bool>
															<token name="SelectionBehaviorDown">0</token>
															<token name="SelectionBehaviorLeft">0</token>
															<token name="SelectionBehaviorRight">0</token>
															<token name="SelectionBehaviorUp">0</token>
															<bool name="SelectionGroup">false</bool>
															<Ref name="SelectionImageObject">null</Ref>
															<int name="SelectionOrder">0</int>
															<UDim2 name="Size">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<token name="SizeConstraint">0</token>
															<int64 name="SourceAssetId">-1</int64>
															<token name="Style">0</token>
															<BinaryString name="Tags"></BinaryString>
															<bool name="Visible">true</bool>
															<int name="ZIndex">1</int>
														</Properties>
														<Item class="UIListLayout" referent="RBX07E454FD811D44C7A081AAC74521066E">
															<Properties>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<token name="FillDirection">0</token>
																<token name="HorizontalAlignment">1</token>
																<token name="HorizontalFlex">0</token>
																<token name="ItemLineAlignment">0</token>
																<string name="Name">UIListLayout</string>
																<UDim name="Padding">
																	<S>0</S>
																	<O>7</O>
																</UDim>
																<token name="SortOrder">2</token>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
																<token name="VerticalAlignment">2</token>
																<token name="VerticalFlex">0</token>
																<bool name="Wraps">false</bool>
															</Properties>
														</Item>
														<Item class="UIPadding" referent="RBXBC0888B01E234E8BBFC969B680349481">
															<Properties>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">UIPadding</string>
																<UDim name="PaddingBottom">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<UDim name="PaddingLeft">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<UDim name="PaddingRight">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<UDim name="PaddingTop">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
														<Item class="UIStroke" referent="RBX027882AD5E1F46A9AD91017390C3EEBD">
															<Properties>
																<token name="ApplyStrokeMode">0</token>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<UDim name="BorderOffset">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<token name="BorderStrokePosition">0</token>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<Color3 name="Color">
																	<R>0</R>
																	<G>0</G>
																	<B>0</B>
																</Color3>
																<bool name="DefinesCapabilities">false</bool>
																<bool name="Enabled">false</bool>
																<token name="LineJoinMode">0</token>
																<string name="Name">UIStroke</string>
																<int64 name="SourceAssetId">-1</int64>
																<token name="StrokeSizingMode">0</token>
																<BinaryString name="Tags"></BinaryString>
																<float name="Thickness">3</float>
																<float name="Transparency">0.200000003</float>
																<int name="ZIndex">1</int>
															</Properties>
														</Item>
														<Item class="UICorner" referent="RBX134BEFC9870E4D148FD51666B1D43614">
															<Properties>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<UDim name="CornerRadius">
																	<S>0</S>
																	<O>7</O>
																</UDim>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">UICorner</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
													</Item>
													<Item class="Frame" referent="RBXBE59C1EE15FA45D5B4041009F846E547">
														<Properties>
															<bool name="Active">false</bool>
															<Vector2 name="AnchorPoint">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<bool name="AutoLocalize">true</bool>
															<token name="AutomaticSize">3</token>
															<Color3 name="BackgroundColor3">
																<R>1</R>
																<G>1</G>
																<B>1</B>
															</Color3>
															<float name="BackgroundTransparency">1</float>
															<Color3 name="BorderColor3">
																<R>0.105882362</R>
																<G>0.164705887</G>
																<B>0.207843155</B>
															</Color3>
															<token name="BorderMode">0</token>
															<int name="BorderSizePixel">1</int>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="ClipsDescendants">false</bool>
															<bool name="DefinesCapabilities">false</bool>
															<bool name="Draggable">false</bool>
															<bool name="Interactable">true</bool>
															<int name="LayoutOrder">1</int>
															<string name="Name">CustomButtons</string>
															<Ref name="NextSelectionDown">null</Ref>
															<Ref name="NextSelectionLeft">null</Ref>
															<Ref name="NextSelectionRight">null</Ref>
															<Ref name="NextSelectionUp">null</Ref>
															<UDim2 name="Position">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<Ref name="RootLocalizationTable">null</Ref>
															<float name="Rotation">0</float>
															<bool name="Selectable">false</bool>
															<token name="SelectionBehaviorDown">0</token>
															<token name="SelectionBehaviorLeft">0</token>
															<token name="SelectionBehaviorRight">0</token>
															<token name="SelectionBehaviorUp">0</token>
															<bool name="SelectionGroup">false</bool>
															<Ref name="SelectionImageObject">null</Ref>
															<int name="SelectionOrder">0</int>
															<UDim2 name="Size">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<token name="SizeConstraint">0</token>
															<int64 name="SourceAssetId">-1</int64>
															<token name="Style">0</token>
															<BinaryString name="Tags"></BinaryString>
															<bool name="Visible">true</bool>
															<int name="ZIndex">1</int>
														</Properties>
														<Item class="UIListLayout" referent="RBXDEB7A7A71C134218A388A49EC93FE392">
															<Properties>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<token name="FillDirection">0</token>
																<token name="HorizontalAlignment">1</token>
																<token name="HorizontalFlex">0</token>
																<token name="ItemLineAlignment">0</token>
																<string name="Name">UIListLayout</string>
																<UDim name="Padding">
																	<S>0</S>
																	<O>7</O>
																</UDim>
																<token name="SortOrder">2</token>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
																<token name="VerticalAlignment">2</token>
																<token name="VerticalFlex">0</token>
																<bool name="Wraps">false</bool>
															</Properties>
														</Item>
													</Item>
													<Item class="UIListLayout" referent="RBX366623B9D1FB48FA98A98A1663F5E92A">
														<Properties>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="DefinesCapabilities">false</bool>
															<token name="FillDirection">0</token>
															<token name="HorizontalAlignment">0</token>
															<token name="HorizontalFlex">0</token>
															<token name="ItemLineAlignment">0</token>
															<string name="Name">UIListLayout</string>
															<UDim name="Padding">
																<S>0</S>
																<O>10</O>
															</UDim>
															<token name="SortOrder">2</token>
															<int64 name="SourceAssetId">-1</int64>
															<BinaryString name="Tags"></BinaryString>
															<token name="VerticalAlignment">0</token>
															<token name="VerticalFlex">0</token>
															<bool name="Wraps">false</bool>
														</Properties>
													</Item>
												</Item>
											</Item>
										</Item>
										<Item class="CanvasGroup" referent="RBXE504189A629B411F9877F9577CDC5B74">
											<Properties>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0.5</X>
													<Y>1</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">3</token>
												<Color3 name="BackgroundColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="BackgroundTransparency">0.400000006</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">true</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<Color3 name="GroupColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="GroupTransparency">0</float>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">1</int>
												<string name="Name">ToolTip</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0.5</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>-7</YO>
												</UDim2>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
											<Item class="UICorner" referent="RBX5AF46DEFF32C4CDAA85A26CFD6A9C8AF">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<UDim name="CornerRadius">
														<S>0</S>
														<O>7</O>
													</UDim>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UICorner</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="TextLabel" referent="RBX13D1DD8617364F1F8A5C2B9B8B7642D3">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Font name="FontFace">
														<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
														<Weight>400</Weight>
														<Style>Normal</Style>
														<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
													</Font>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<float name="LineHeight">1</float>
													<string name="LocalizationMatchIdentifier"></string>
													<string name="LocalizationMatchedSourceText"></string>
													<int name="MaxVisibleGraphemes">-1</int>
													<string name="Name">Text</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<string name="OpenTypeFeatures"></string>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="RichText">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
													<string name="Text">Tooltip placeholder</string>
													<Color3 name="TextColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<token name="TextDirection">0</token>
													<bool name="TextScaled">false</bool>
													<float name="TextSize">14</float>
													<Color3 name="TextStrokeColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="TextStrokeTransparency">1</float>
													<float name="TextTransparency">0</float>
													<token name="TextTruncate">0</token>
													<bool name="TextWrapped">false</bool>
													<token name="TextXAlignment">0</token>
													<token name="TextYAlignment">1</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
											</Item>
											<Item class="UIPadding" referent="RBXF2E839A72AFA44B2BCB6445F7E36E742">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIPadding</string>
													<UDim name="PaddingBottom">
														<S>0</S>
														<O>6</O>
													</UDim>
													<UDim name="PaddingLeft">
														<S>0</S>
														<O>11</O>
													</UDim>
													<UDim name="PaddingRight">
														<S>0</S>
														<O>11</O>
													</UDim>
													<UDim name="PaddingTop">
														<S>0</S>
														<O>6</O>
													</UDim>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
										<Item class="Frame" referent="RBX12BCC0B26DEE440B8F5606DC80C33D0C">
											<Properties>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0.5</X>
													<Y>1</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">3</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0.105882362</R>
													<G>0.164705887</G>
													<B>0.207843155</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">1</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">true</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<string name="Name">ContextMenu</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0.5</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>-4</YO>
												</UDim2>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<token name="Style">0</token>
												<BinaryString name="Tags"></BinaryString>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
											<Item class="UIListLayout" referent="RBXCAEB01CAA05E425F9283F3437B69C9B3">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<token name="FillDirection">1</token>
													<token name="HorizontalAlignment">0</token>
													<token name="HorizontalFlex">0</token>
													<token name="ItemLineAlignment">0</token>
													<string name="Name">UIListLayout</string>
													<UDim name="Padding">
														<S>0</S>
														<O>0</O>
													</UDim>
													<token name="SortOrder">2</token>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
													<token name="VerticalAlignment">2</token>
													<token name="VerticalFlex">0</token>
													<bool name="Wraps">false</bool>
												</Properties>
											</Item>
											<Item class="Frame" referent="RBX7E061F68DB07462E8CD48424DA61B3BB">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0.105882362</R>
														<G>0.164705887</G>
														<B>0.207843155</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">1</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">2</int>
													<string name="Name">ArrowIcon</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<int64 name="SourceAssetId">-1</int64>
													<token name="Style">0</token>
													<BinaryString name="Tags"></BinaryString>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
												<Item class="ImageLabel" referent="RBX3F49975F54E744CD868F90C86EDF9CFC">
													<Properties>
														<bool name="Active">false</bool>
														<Vector2 name="AnchorPoint">
															<X>0</X>
															<Y>0</Y>
														</Vector2>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<bool name="AutoLocalize">true</bool>
														<token name="AutomaticSize">0</token>
														<Color3 name="BackgroundColor3">
															<R>1</R>
															<G>1</G>
															<B>1</B>
														</Color3>
														<float name="BackgroundTransparency">1</float>
														<Color3 name="BorderColor3">
															<R>0.105882362</R>
															<G>0.164705887</G>
															<B>0.207843155</B>
														</Color3>
														<token name="BorderMode">0</token>
														<int name="BorderSizePixel">1</int>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="ClipsDescendants">false</bool>
														<bool name="DefinesCapabilities">false</bool>
														<bool name="Draggable">false</bool>
														<Content name="Image"><url>rbxassetid://788089696</url></Content>
														<Color3 name="ImageColor3">
															<R>0</R>
															<G>0</G>
															<B>0</B>
														</Color3>
														<Vector2 name="ImageRectOffset">
															<X>0</X>
															<Y>0</Y>
														</Vector2>
														<Vector2 name="ImageRectSize">
															<X>0</X>
															<Y>0</Y>
														</Vector2>
														<float name="ImageTransparency">0.25</float>
														<bool name="Interactable">true</bool>
														<int name="LayoutOrder">0</int>
														<string name="Name">ArrowIcon</string>
														<Ref name="NextSelectionDown">null</Ref>
														<Ref name="NextSelectionLeft">null</Ref>
														<Ref name="NextSelectionRight">null</Ref>
														<Ref name="NextSelectionUp">null</Ref>
														<UDim2 name="Position">
															<XS>0</XS>
															<XO>0</XO>
															<YS>0</YS>
															<YO>0</YO>
														</UDim2>
														<token name="ResampleMode">0</token>
														<Ref name="RootLocalizationTable">null</Ref>
														<float name="Rotation">180</float>
														<token name="ScaleType">0</token>
														<bool name="Selectable">false</bool>
														<token name="SelectionBehaviorDown">0</token>
														<token name="SelectionBehaviorLeft">0</token>
														<token name="SelectionBehaviorRight">0</token>
														<token name="SelectionBehaviorUp">0</token>
														<bool name="SelectionGroup">false</bool>
														<Ref name="SelectionImageObject">null</Ref>
														<int name="SelectionOrder">0</int>
														<UDim2 name="Size">
															<XS>0</XS>
															<XO>11</XO>
															<YS>0</YS>
															<YO>6</YO>
														</UDim2>
														<token name="SizeConstraint">0</token>
														<Rect2D name="SliceCenter">
															<min>
																<X>0</X>
																<Y>0</Y>
															</min>
															<max>
																<X>0</X>
																<Y>0</Y>
															</max>
														</Rect2D>
														<float name="SliceScale">1</float>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
														<UDim2 name="TileSize">
															<XS>1</XS>
															<XO>0</XO>
															<YS>1</YS>
															<YO>0</YO>
														</UDim2>
														<bool name="Visible">true</bool>
														<int name="ZIndex">1</int>
													</Properties>
												</Item>
											</Item>
											<Item class="CanvasGroup" referent="RBX453D61F51F664D4A91E77C580BF4061F">
												<Properties>
													<bool name="Active">true</bool>
													<Vector2 name="AnchorPoint">
														<X>0.5</X>
														<Y>1</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="BackgroundTransparency">0.25</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">true</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Color3 name="GroupColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="GroupTransparency">0</float>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">1</int>
													<string name="Name">Actions</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0.5</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>-7</YO>
													</UDim2>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<bool name="Selectable">true</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
												<Item class="UICorner" referent="RBX1A1D0208C7384B3CBBF3ECD982EB8E22">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<UDim name="CornerRadius">
															<S>0</S>
															<O>7</O>
														</UDim>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UICorner</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="UIListLayout" referent="RBXD9E78A32612B4839AF921633E43AFD71">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<token name="FillDirection">1</token>
														<token name="HorizontalAlignment">0</token>
														<token name="HorizontalFlex">0</token>
														<token name="ItemLineAlignment">0</token>
														<string name="Name">UIListLayout</string>
														<UDim name="Padding">
															<S>0</S>
															<O>0</O>
														</UDim>
														<token name="SortOrder">2</token>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
														<token name="VerticalAlignment">1</token>
														<token name="VerticalFlex">0</token>
														<bool name="Wraps">false</bool>
													</Properties>
												</Item>
											</Item>
										</Item>
										<Item class="TextButton" referent="RBXECA7C572BB63413AA0685D8BC9DD678A">
											<Properties>
												<bool name="Active">true</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoButtonColor">false</bool>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">3</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0.105882362</R>
													<G>0.164705887</G>
													<B>0.207843155</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">1</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">false</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<Font name="FontFace">
													<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
												</Font>
												<Ref name="HoverHapticEffect">null</Ref>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<float name="LineHeight">1</float>
												<string name="LocalizationMatchIdentifier"></string>
												<string name="LocalizationMatchedSourceText"></string>
												<int name="MaxVisibleGraphemes">-1</int>
												<bool name="Modal">false</bool>
												<string name="Name">ContextActionButton</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<string name="OpenTypeFeatures"></string>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<Ref name="PressHapticEffect">null</Ref>
												<bool name="RichText">false</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">true</bool>
												<bool name="Selected">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>1</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<token name="Style">0</token>
												<BinaryString name="Tags"></BinaryString>
												<string name="Text"></string>
												<Color3 name="TextColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="TextDirection">0</token>
												<bool name="TextScaled">false</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">false</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
											<Item class="TextLabel" referent="RBXE9D95F97FE304D968EE2E1D7829EB1A2">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Font name="FontFace">
														<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
														<Weight>400</Weight>
														<Style>Normal</Style>
													</Font>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<float name="LineHeight">1</float>
													<string name="LocalizationMatchIdentifier"></string>
													<string name="LocalizationMatchedSourceText"></string>
													<int name="MaxVisibleGraphemes">-1</int>
													<string name="Name">Text</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<string name="OpenTypeFeatures"></string>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="RichText">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
													<string name="Text">Drop Item</string>
													<Color3 name="TextColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<token name="TextDirection">0</token>
													<bool name="TextScaled">false</bool>
													<float name="TextSize">15</float>
													<Color3 name="TextStrokeColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="TextStrokeTransparency">1</float>
													<float name="TextTransparency">0</float>
													<token name="TextTruncate">0</token>
													<bool name="TextWrapped">false</bool>
													<token name="TextXAlignment">2</token>
													<token name="TextYAlignment">1</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
											</Item>
											<Item class="UIPadding" referent="RBX8A8B9F5198EC44B281B02AE6C116B7EB">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIPadding</string>
													<UDim name="PaddingBottom">
														<S>0</S>
														<O>8</O>
													</UDim>
													<UDim name="PaddingLeft">
														<S>0</S>
														<O>10</O>
													</UDim>
													<UDim name="PaddingRight">
														<S>0</S>
														<O>10</O>
													</UDim>
													<UDim name="PaddingTop">
														<S>0</S>
														<O>7</O>
													</UDim>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
										<Item class="CanvasGroup" referent="RBXD0AB34588E984BA78F291757E0113A23">
											<Properties>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>1</X>
													<Y>0</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">3</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">true</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<Color3 name="GroupColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="GroupTransparency">0</float>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<string name="Name">ButtonHint</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>1</XS>
													<XO>10</XO>
													<YS>0</YS>
													<YO>-10</YO>
												</UDim2>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
											<Item class="ImageLabel" referent="RBX7EA6CA7BD3AD4819BBFE32AD308D34E4">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="BackgroundTransparency">0</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Content name="Image"><url>rbxasset://textures/ui/Controls/DefaultController/ButtonY@2x.png</url></Content>
													<Color3 name="ImageColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<Vector2 name="ImageRectOffset">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<Vector2 name="ImageRectSize">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<float name="ImageTransparency">0</float>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<string name="Name">Image</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="ResampleMode">0</token>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<token name="ScaleType">0</token>
													<bool name="Selectable">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>25</XO>
														<YS>0</YS>
														<YO>25</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<Rect2D name="SliceCenter">
														<min>
															<X>0</X>
															<Y>0</Y>
														</min>
														<max>
															<X>0</X>
															<Y>0</Y>
														</max>
													</Rect2D>
													<float name="SliceScale">1</float>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
													<UDim2 name="TileSize">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
												<Item class="UIStroke" referent="RBXECEDAFC3EF774EADBBC69C20F15CECDE">
													<Properties>
														<token name="ApplyStrokeMode">0</token>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<UDim name="BorderOffset">
															<S>0</S>
															<O>0</O>
														</UDim>
														<token name="BorderStrokePosition">0</token>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<Color3 name="Color">
															<R>0</R>
															<G>0</G>
															<B>0</B>
														</Color3>
														<bool name="DefinesCapabilities">false</bool>
														<bool name="Enabled">true</bool>
														<token name="LineJoinMode">0</token>
														<string name="Name">UIStroke</string>
														<int64 name="SourceAssetId">-1</int64>
														<token name="StrokeSizingMode">0</token>
														<BinaryString name="Tags"></BinaryString>
														<float name="Thickness">1</float>
														<float name="Transparency">0</float>
														<int name="ZIndex">1</int>
													</Properties>
												</Item>
												<Item class="UICorner" referent="RBXFF000F9330134396B9E46DEC9D67D54E">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<UDim name="CornerRadius">
															<S>0.5</S>
															<O>0</O>
														</UDim>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UICorner</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="UIPadding" referent="RBX400D986038B84F09A92C37F1D224E5DD">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIPadding</string>
													<UDim name="PaddingBottom">
														<S>0</S>
														<O>1</O>
													</UDim>
													<UDim name="PaddingLeft">
														<S>0</S>
														<O>1</O>
													</UDim>
													<UDim name="PaddingRight">
														<S>0</S>
														<O>1</O>
													</UDim>
													<UDim name="PaddingTop">
														<S>0</S>
														<O>1</O>
													</UDim>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX6B8D186A4E3C4578A46D6362D16A0508">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">_Index</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX242944D11B414DCBB674FC6B155D1436">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">hexcede_fusion-utils@0.1.2</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXF57095C2FEDC45288C3032045359EC5F">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Fusion</string>
												<string name="ScriptGuid">{EBBA434F-9C7A-4421-9773-6720ECA09745}</string>
												<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["elttob_fusion@0.2.0"]["fusion"])
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXB4EE0C024B5D48DE8343FC0A1DC7DF98">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">fusion-utils</string>
												<string name="ScriptGuid">{98B0E1F4-2238-486F-B1B2-8DA9B168BBF8}</string>
												<ProtectedString name="Source"><![CDATA[return {
	Attribute = require(script.Attribute);
	AttributeOut = require(script.AttributeOut);
	ChildRef = require(script.ChildRef);
	Child = require(script.Child);
	defer = require(script.defer);
	Observe = require(script.Observe);
	ObserveSignal = require(script.ObserveSignal);
	unwrap = require(script.unwrap);
	map = require(script.map);
	With = require(script.With);
	WithItems = require(script.WithItems);
	Without = require(script.Without);
	Bind = require(script.Bind);
}]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBXD6B8D20346C84B0D883BED7A85A71885">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">Attribute</string>
													<string name="ScriptGuid">{4171CB94-2931-4F7B-9D16-F28C66FEDE76}</string>
													<ProtectedString name="Source"><![CDATA[local Observe = require(script.Parent.Observe)

local Attribute = {
	type = "SpecialKey";
	kind = "Attribute";
	stage = "self";

	apply = function(self, value, applyTo, cleanupTasks)
		local attribute = self.attribute

		if type(value) == "table" and value.get then
			table.insert(cleanupTasks, Observe(value, function(newValue)
				applyTo:SetAttribute(attribute, newValue)
			end))
		else
			applyTo:SetAttribute(attribute, value)
		end
	end;
}
Attribute.__index = Attribute

return function(attribute: string)
	return setmetatable({ attribute = attribute; }, Attribute)
end
]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXC0EDB2A8782A4E62B0BDDC725A754D5E">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">AttributeOut</string>
													<string name="ScriptGuid">{18DE4F04-B09B-4CAE-B157-ECB8E468B244}</string>
													<ProtectedString name="Source"><![CDATA[local defer = require(script.Parent.defer)

local AttributeOut = {
	type = "SpecialKey";
	kind = "AttributeOut";
	stage = "self";

	apply = function(self, value, applyTo, cleanupTasks)
		local attribute = self.attribute
		table.insert(cleanupTasks, applyTo:GetAttributeChangedSignal(attribute):Connect(defer(function()
			value:set(applyTo:GetAttribute(attribute))
		end)))
	end;
}
AttributeOut.__index = AttributeOut

return function(attribute: string)
	return setmetatable({ attribute = attribute; }, AttributeOut)
end
]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX1B7508D4296C4A61A7BBEBD74A0C64AD">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">Bind</string>
													<string name="ScriptGuid">{95ADE114-015F-4E2E-8AA1-9FCEE99E85B1}</string>
													<ProtectedString name="Source"><![CDATA[local function Bind(callback, ...)
	local bound = table.pack(...)
	return function(...)
		local extra = table.pack(...)
		return callback(table.unpack(table.move(extra, 1, extra.n, bound.n + 1, table.clone(bound)), 1, bound.n + extra.n))
	end
end

return Bind]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX5F65409F42494005973C2FE7AE3FC6DD">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">Child</string>
													<string name="ScriptGuid">{20CD1D0D-C9F6-4973-89F8-340DBEF12E3F}</string>
													<ProtectedString name="Source"><![CDATA[local Fusion = require(script.Parent.Parent.Fusion)

local Value = Fusion.Value
local Hydrate = Fusion.Hydrate
local Cleanup = Fusion.Cleanup

local ChildRef = require(script.Parent.ChildRef)
local Observe = require(script.Parent.Observe)

local Child = {
	type = "SpecialKey";
	kind = "Child";
	stage = "descendants";

	apply = function(self, value, applyTo, cleanupTasks)
		local childRef = Value()
		Hydrate(applyTo) {
			[ChildRef(self.childName)] = childRef
		}

		local isHydrated = {}
		local result = Observe(childRef, function(child)
			if not child then return end
			if isHydrated[child] then return end
			isHydrated[child] = true

			-- Bind to child
			Hydrate(child)(value)

			-- Bind to cleanup of child
			Hydrate(child) {
				[Cleanup] = function()
					isHydrated[child] = nil
				end;
			}
		end)

		table.insert(cleanupTasks, result)
		table.insert(cleanupTasks, function()
			childRef = nil
		end)
	end;
}
Child.__index = Child

return function(childName: string)
	return setmetatable({ childName = childName; }, Child)
end
]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX5AE52AEB852D4DAE809EF38B97735358">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">ChildRef</string>
													<string name="ScriptGuid">{E45CC202-F698-40FD-A62C-1117EE240033}</string>
													<ProtectedString name="Source"><![CDATA[local ChildRef = {
	type = "SpecialKey";
	kind = "ChildRef";
	stage = "descendants";

	apply = function(self, value, applyTo, cleanupTasks)
		local childName = self.childName

		if not applyTo then return end

		value:set(applyTo:FindFirstChild(childName))
		table.insert(cleanupTasks, applyTo.ChildAdded:Connect(function(newChild)
			if newChild.Name == childName then
				value:set(newChild)
			end
		end))
	end;
}
ChildRef.__index = ChildRef

return function(childName: string)
	return setmetatable({ childName = childName; }, ChildRef)
end
]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXCCF6CF3CBBD94B80A4F1A9BBA2F7263B">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">Observe</string>
													<string name="ScriptGuid">{6066C679-A8E1-4DCE-BA75-F30F7AE15F0C}</string>
													<ProtectedString name="Source"><![CDATA[local Fusion = require(script.Parent.Parent.Fusion)
local Observer = Fusion.Observer

local defer = require(script.Parent.defer)

local function Observe<T, Args...>(stateObject: Fusion.StateObject<T>, callback: (value: T, Args...) -> ...any, ...)
	local extraArguments = table.pack(...)
	local function handleChange()
		callback(stateObject:get(), table.unpack(extraArguments, 1, extraArguments.n))
	end

	return Observer(stateObject):onChange(defer(handleChange))
end

return Observe]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX8F68C97ADAE5446E9D4603F9F74E34EE">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">ObserveSignal</string>
													<string name="ScriptGuid">{368E3B4C-37CF-42B8-95A8-6186DFC1B337}</string>
													<ProtectedString name="Source"><![CDATA[local defer = require(script.Parent.defer)

local function ObserveSignal<T>(signal: RBXScriptSignal<T>, callback: (value: T?, ...any) -> ...any, ...)
	local connection = signal:Connect(defer(callback, ...))
	return function()
		connection:Disconnect()
	end
end

return ObserveSignal
]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXFE2E4D99BA04410D8E1D8D879183BF52">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">With</string>
													<string name="ScriptGuid">{40D7F07F-F6E5-4442-B6CB-21E358A08EFC}</string>
													<ProtectedString name="Source"><![CDATA[local unwrap = require(script.Parent.unwrap)

local function With(source)
	return function(with)
		local destination = table.clone(unwrap(source))
		if type(with) == "table" then
			for index, value in pairs(unwrap(with)) do
				destination[index] = value
			end
		end
		return destination
	end
end

return With]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX058DFF38E8404485B33F6CE77E27B1BD">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">WithItems</string>
													<string name="ScriptGuid">{2410AA11-41DA-4255-8878-9030108D38AE}</string>
													<ProtectedString name="Source"><![CDATA[local unwrap = require(script.Parent.unwrap)

local function WithItems(source)
	return function(with)
		local destination = table.clone(unwrap(source))
		if type(with) == "table" then
			local withUnwrapped = unwrap(with)
			table.move(withUnwrapped, 1, #withUnwrapped, #destination + 1, destination)
		end
		return destination
	end
end

return WithItems]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXFF828BABDDD948D686AC188D2353B974">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">Without</string>
													<string name="ScriptGuid">{55918AB7-8641-4594-A1FB-0BDD0F8392CF}</string>
													<ProtectedString name="Source"><![CDATA[local unwrap = require(script.Parent.unwrap)

local function Without(source)
	return function(with)
		local destination = table.clone(unwrap(source))
		if type(with) == "table" then
			for _, index in ipairs(unwrap(with)) do
				destination[index] = nil
			end
		end
		return destination
	end
end

return Without]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXBD45255AA9224DBFBB5477431C1558EE">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">defer</string>
													<string name="ScriptGuid">{A232B49B-A6AB-43B1-AD0E-A7BD025D1BDB}</string>
													<ProtectedString name="Source"><![CDATA[local function defer(callback, ...)
	task.defer(callback, ...)
	return callback
end

return defer]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX4AD3387DAF424BAAB622A55BCFCB515C">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">map</string>
													<string name="ScriptGuid">{330322A4-4CB9-4909-ACFC-D58AC7192979}</string>
													<ProtectedString name="Source"><![CDATA[local Fusion = require(script.Parent.Parent.Fusion)
local Computed = Fusion.Computed

local function map(state, callback)
	if type(state) == "table" and type(state.get) == "function" then
		return Computed(function()
			return callback(state:get())
		end)
	end

	return callback(state)
end

return map]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXE386D8B59B4E4135A8398A85249FC693">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">unwrap</string>
													<string name="ScriptGuid">{7277CDA6-9764-4CB6-B6F0-FD38EB58D68D}</string>
													<ProtectedString name="Source"><![CDATA[local Fusion = require(script.Parent.Parent.Fusion)

local function unwrap<T>(value: Fusion.CanBeState<T>, default: T?): T
	if type(value) == "table" and type(value.get) == "function" then
		return value:get()
	end
	return if value == nil then default :: T else value :: T
end

return unwrap]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX20025C8D8CB049718F244A854BC732AE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">elttob_fusion@0.2.0</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXEE63B19FEA4A40128AC5082473E33A83">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">fusion</string>
												<string name="ScriptGuid">{BECB3D74-6299-4821-8712-1502BDA89CC5}</string>
												<ProtectedString name="Source"><![CDATA[--!strict

--[[
	The entry point for the Fusion library.
]]

local PubTypes = require(script.PubTypes)
local restrictRead = require(script.Utility.restrictRead)

export type StateObject<T> = PubTypes.StateObject<T>
export type CanBeState<T> = PubTypes.CanBeState<T>
export type Symbol = PubTypes.Symbol
export type Value<T> = PubTypes.Value<T>
export type Computed<T> = PubTypes.Computed<T>
export type ForPairs<KO, VO> = PubTypes.ForPairs<KO, VO>
export type ForKeys<KI, KO> = PubTypes.ForKeys<KI, KO>
export type ForValues<VI, VO> = PubTypes.ForKeys<VI, VO>
export type Observer = PubTypes.Observer
export type Tween<T> = PubTypes.Tween<T>
export type Spring<T> = PubTypes.Spring<T>

type Fusion = {
	version: PubTypes.Version,

	New: (className: string) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Hydrate: (target: Instance) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Ref: PubTypes.SpecialKey,
	Cleanup: PubTypes.SpecialKey,
	Children: PubTypes.SpecialKey,
	Out: PubTypes.SpecialKey,
	OnEvent: (eventName: string) -> PubTypes.SpecialKey,
	OnChange: (propertyName: string) -> PubTypes.SpecialKey,

	Value: <T>(initialValue: T) -> Value<T>,
	Computed: <T>(callback: () -> T, destructor: (T) -> ()?) -> Computed<T>,
	ForPairs: <KI, VI, KO, VO, M>(inputTable: CanBeState<{[KI]: VI}>, processor: (KI, VI) -> (KO, VO, M?), destructor: (KO, VO, M?) -> ()?) -> ForPairs<KO, VO>,
	ForKeys: <KI, KO, M>(inputTable: CanBeState<{[KI]: any}>, processor: (KI) -> (KO, M?), destructor: (KO, M?) -> ()?) -> ForKeys<KO, any>,
	ForValues: <VI, VO, M>(inputTable: CanBeState<{[any]: VI}>, processor: (VI) -> (VO, M?), destructor: (VO, M?) -> ()?) -> ForValues<any, VO>,
	Observer: (watchedState: StateObject<any>) -> Observer,

	Tween: <T>(goalState: StateObject<T>, tweenInfo: TweenInfo?) -> Tween<T>,
	Spring: <T>(goalState: StateObject<T>, speed: number?, damping: number?) -> Spring<T>,

	cleanup: (...any) -> (),
	doNothing: (...any) -> ()
}

return restrictRead("Fusion", {
	version = {major = 0, minor = 2, isRelease = true},

	New = require(script.Instances.New),
	Hydrate = require(script.Instances.Hydrate),
	Ref = require(script.Instances.Ref),
	Out = require(script.Instances.Out),
	Cleanup = require(script.Instances.Cleanup),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	Value = require(script.State.Value),
	Computed = require(script.State.Computed),
	ForPairs = require(script.State.ForPairs),
	ForKeys = require(script.State.ForKeys),
	ForValues = require(script.State.ForValues),
	Observer = require(script.State.Observer),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring),

	cleanup = require(script.Utility.cleanup),
	doNothing = require(script.Utility.doNothing)
}) :: Fusion
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX52C5906B54E0429B909E50E438C29300">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">PubTypes</string>
													<string name="ScriptGuid">{7B91CF4E-7566-44EC-8A91-E9E3F45044C5}</string>
													<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores common public-facing type information for Fusion APIs.
]]

type Set<T> = {[T]: any}

--[[
	General use types
]]

-- A unique symbolic value.
export type Symbol = {
	type: string, -- replace with "Symbol" when Luau supports singleton types
	name: string
}

-- Types that can be expressed as vectors of numbers, and so can be animated.
export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

-- A task which can be accepted for cleanup.
export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

-- Script-readable version information.
export type Version = {
	major: number,
	minor: number,
	isRelease: boolean
}
--[[
	Generic reactive graph types
]]

-- A graph object which can have dependents.
export type Dependency = {
	dependentSet: Set<Dependent>
}

-- A graph object which can have dependencies.
export type Dependent = {
	update: (Dependent) -> boolean,
	dependencySet: Set<Dependency>
}

-- An object which stores a piece of reactive state.
export type StateObject<T> = Dependency & {
	type: string, -- replace with "State" when Luau supports singleton types
	kind: string,
	get: (StateObject<T>, asDependency: boolean?) -> T
}

-- Either a constant value of type T, or a state object containing type T.
export type CanBeState<T> = StateObject<T> | T

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type Value<T> = StateObject<T> & {
	-- kind: "State" (add this when Luau supports singleton types)
 	set: (Value<T>, newValue: any, force: boolean?) -> ()
}

-- A state object whose value is derived from other objects using a callback.
export type Computed<T> = StateObject<T> & Dependent & {
	-- kind: "Computed" (add this when Luau supports singleton types)
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs<KO, VO> = StateObject<{ [KO]: VO }> & Dependent & {
	-- kind: "ForPairs" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForKeys<KO, V> = StateObject<{ [KO]: V }> & Dependent & {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForValues<K, VO> = StateObject<{ [K]: VO }> & Dependent & {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using tweens.
export type Tween<T> = StateObject<T> & Dependent & {
	-- kind: "Tween" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using spring simulation.
export type Spring<T> = StateObject<T> & Dependent & {
	-- kind: "Spring" (add this when Luau supports singleton types)
	-- Uncomment when ENABLE_PARAM_SETTERS is enabled
	-- setPosition: (Spring<T>, newValue: Animatable) -> (),
	-- setVelocity: (Spring<T>, newValue: Animatable) -> (),
	-- addVelocity: (Spring<T>, deltaValue: Animatable) -> ()
}

-- An object which can listen for updates on another state object.
export type Observer = Dependent & {
	-- kind: "Observer" (add this when Luau supports singleton types)
  	onChange: (Observer, callback: () -> ()) -> (() -> ())
}

--[[
	Instance related types
]]

-- Denotes children instances in an instance or component's property table.
export type SpecialKey = {
	type: string, -- replace with "SpecialKey" when Luau supports singleton types
	kind: string,
	stage: string, -- replace with "self" | "descendants" | "ancestor" | "observer" when Luau supports singleton types
	apply: (SpecialKey, value: any, applyTo: Instance, cleanupTasks: {Task}) -> ()
}

-- A collection of instances that may be parented to another instance.
export type Children = Instance | StateObject<Children> | {[any]: Children}

-- A table that defines an instance's properties, handlers and children.
export type PropertyTable = {[string | SpecialKey]: any}

return nil]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX0E307985BA6A430AB586A41F697AD272">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">Types</string>
													<string name="ScriptGuid">{28F9A0FD-77DA-4602-BCF0-023C08923407}</string>
													<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores common type information used internally.

	These types may be used internally so Fusion code can type-check, but
	should never be exposed to public users, as these definitions are fair game
	for breaking changes.
]]

local Package = script.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}

--[[
	General use types
]]

-- A symbol that represents the absence of a value.
export type None = PubTypes.Symbol & {
	-- name: "None" (add this when Luau supports singleton types)
}

-- Stores useful information about Luau errors.
export type Error = {
	type: string, -- replace with "Error" when Luau supports singleton types
	raw: string,
	message: string,
	trace: string
}

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type State<T> = PubTypes.Value<T> & {
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type Computed<T> = PubTypes.Computed<T> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_callback: () -> T,
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs<KI, VI, KO, VO, M> = PubTypes.ForPairs<KO, VO> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (KI, VI) -> (KO, VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [KI]: VI }>,
	_oldInputTable: { [KI]: VI },
	_outputTable: { [KO]: VO },
	_oldOutputTable: { [KO]: VO },
	_keyIOMap: { [KI]: KO },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForKeys<KI, KO, M> = PubTypes.ForKeys<KO, any> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (KI) -> (KO),
	_destructor: (KO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [KI]: KO }>,
	_oldInputTable: { [KI]: KO },
	_outputTable: { [KO]: any },
	_keyOIMap: { [KO]: KI },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForValues<VI, VO, M> = PubTypes.ForValues<any, VO> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (VI) -> (VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [VI]: VO }>,
	_outputTable: { [any]: VI },
	_valueCache: { [VO]: any },
	_oldValueCache: { [VO]: any },
	_meta: { [VO]: M? },
	_valueData: {
		[VI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object which follows another state object using tweens.
export type Tween<T> = PubTypes.Tween<T> & {
	_goalState: State<T>,
	_tweenInfo: TweenInfo,
	_prevValue: T,
	_nextValue: T,
	_currentValue: T,
	_currentTweenInfo: TweenInfo,
	_currentTweenDuration: number,
	_currentTweenStartTime: number,
	_currentlyAnimating: boolean
}

-- A state object which follows another state object using spring simulation.
export type Spring<T> = PubTypes.Spring<T> & {
	_speed: PubTypes.CanBeState<number>,
	_speedIsState: boolean,
	_lastSpeed: number,
	_damping: PubTypes.CanBeState<number>,
	_dampingIsState: boolean,
	_lastDamping: number,
	_goalState: State<T>,
	_goalValue: T,
	_currentType: string,
	_currentValue: T,
	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

-- An object which can listen for updates on another state object.
export type Observer = PubTypes.Observer & {
	_changeListeners: Set<() -> ()>,
	_numChangeListeners: number
}

return nil]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="Folder" referent="RBXE191A112AB6F483AA39EADF9856F2689">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Animation</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBXBF3BC72C2908486792C5CD746A882636">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Spring</string>
														<string name="ScriptGuid">{6DACC79C-2CE5-4DA9-9535-4B163B562CF9}</string>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local xtypeof = require(Package.Utility.xtypeof)
local unwrap = require(Package.State.unwrap)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Sets the position of the internal springs, meaning the value of this
	Spring will jump to the given value. This doesn't affect velocity.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setPosition(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springPositions = unpackType(newValue, newType)
	self._currentValue = newValue
	SpringScheduler.add(self)
	updateAll(self)
end

--[[
	Sets the velocity of the internal springs, overwriting the existing velocity
	of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setVelocity(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springVelocities = unpackType(newValue, newType)
	SpringScheduler.add(self)
end

--[[
	Adds to the velocity of the internal springs, on top of the existing
	velocity of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:addVelocity(deltaValue: PubTypes.Animatable)
	local deltaType = typeof(deltaValue)
	if deltaType ~= self._currentType then
		logError("springTypeMismatch", nil, deltaType, self._currentType)
	end

	local springDeltas = unpackType(deltaValue, deltaType)
	for index, delta in ipairs(springDeltas) do
		self._springVelocities[index] += delta
	end
	SpringScheduler.add(self)
end

--[[
	Called when the goal state changes value, or when the speed or damping has
	changed.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- figure out if this was a goal change or a speed/damping change
	if goalValue == self._goalValue then
		-- speed/damping change
		local damping = unwrap(self._damping)
		if typeof(damping) ~= "number" then
			logErrorNonFatal("mistypedSpringDamping", nil, typeof(damping))
		elseif damping < 0 then
			logErrorNonFatal("invalidSpringDamping", nil, damping)
		else
			self._currentDamping = damping
		end

		local speed = unwrap(self._speed)
		if typeof(speed) ~= "number" then
			logErrorNonFatal("mistypedSpringSpeed", nil, typeof(speed))
		elseif speed < 0 then
			logErrorNonFatal("invalidSpringSpeed", nil, speed)
		else
			self._currentSpeed = speed
		end

		return false
	else
		-- goal change - reconfigure spring to target new goal
		self._goalValue = goalValue

		local oldType = self._currentType
		local newType = typeof(goalValue)
		self._currentType = newType

		local springGoals = unpackType(goalValue, newType)
		local numSprings = #springGoals
		self._springGoals = springGoals

		if newType ~= oldType then
			-- if the type changed, snap to the new value and rebuild the
			-- position and velocity tables
			self._currentValue = self._goalValue

			local springPositions = table.create(numSprings, 0)
			local springVelocities = table.create(numSprings, 0)
			for index, springGoal in ipairs(springGoals) do
				springPositions[index] = springGoal
			end
			self._springPositions = springPositions
			self._springVelocities = springVelocities

			-- the spring may have been animating before, so stop that
			SpringScheduler.remove(self)
			return true

			-- otherwise, the type hasn't changed, just the goal...
		elseif numSprings == 0 then
			-- if the type isn't animatable, snap to the new value
			self._currentValue = self._goalValue
			return true

		else
			-- if it's animatable, let it animate to the goal
			SpringScheduler.add(self)
			return false
		end
	end
end

local function Spring<T>(
	goalState: PubTypes.Value<T>,
	speed: PubTypes.CanBeState<number>?,
	damping: PubTypes.CanBeState<number>?
): Types.Spring<T>
	-- apply defaults for speed and damping
	if speed == nil then
		speed = 10
	end
	if damping == nil then
		damping = 1
	end

	local dependencySet = {[goalState] = true}
	if xtypeof(speed) == "State" then
		dependencySet[speed] = true
	end
	if xtypeof(damping) == "State" then
		dependencySet[damping] = true
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,
		_currentSpeed = unwrap(speed),
		_currentDamping = unwrap(damping),

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXB508A12E7797450B916C8C841036C4A8">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">SpringScheduler</string>
														<string name="ScriptGuid">{D9AF55B0-B97C-49EA-85DC-22C1083D4828}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

type Set<T> = {[T]: any}
type Spring = Types.Spring<any>

local SpringScheduler = {}

local EPSILON = 0.0001
local activeSprings: Set<Spring> = {}
local lastUpdateTime = os.clock()

function SpringScheduler.add(spring: Spring)
	-- we don't necessarily want to use the most accurate time - here we snap to
	-- the last update time so that springs started within the same frame have
	-- identical time steps
	spring._lastSchedule = lastUpdateTime
	spring._startDisplacements = {}
	spring._startVelocities = {}
	for index, goal in ipairs(spring._springGoals) do
		spring._startDisplacements[index] = spring._springPositions[index] - goal
		spring._startVelocities[index] = spring._springVelocities[index]
	end

	activeSprings[spring] = true
end

function SpringScheduler.remove(spring: Spring)
	activeSprings[spring] = nil
end


local function updateAllSprings()
	local springsToSleep: Set<Spring> = {}
	lastUpdateTime = os.clock()

	for spring in pairs(activeSprings) do
		local posPos, posVel, velPos, velVel = springCoefficients(lastUpdateTime - spring._lastSchedule, spring._currentDamping, spring._currentSpeed)

		local positions = spring._springPositions
		local velocities = spring._springVelocities
		local startDisplacements = spring._startDisplacements
		local startVelocities = spring._startVelocities
		local isMoving = false

		for index, goal in ipairs(spring._springGoals) do
			local oldDisplacement = startDisplacements[index]
			local oldVelocity = startVelocities[index]
			local newDisplacement = oldDisplacement * posPos + oldVelocity * posVel
			local newVelocity = oldDisplacement * velPos + oldVelocity * velVel

			if math.abs(newDisplacement) > EPSILON or math.abs(newVelocity) > EPSILON then
				isMoving = true
			end

			positions[index] = newDisplacement + goal
			velocities[index] = newVelocity
		end

		if not isMoving then
			springsToSleep[spring] = true
		end
	end

	for spring in pairs(activeSprings) do
		spring._currentValue = packType(spring._springPositions, spring._currentType)
		updateAll(spring)
	end

	for spring in pairs(springsToSleep) do
		activeSprings[spring] = nil
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX6863C0C946584002958E41AA7D31CDC9">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Tween</string>
														<string name="ScriptGuid">{56262F3D-85AD-4D49-97F3-CF51BD8219F1}</string>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local xtypeof = require(Package.Utility.xtypeof)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- if the goal hasn't changed, then this is a TweenInfo change.
	-- in that case, if we're not currently animating, we can skip everything
	if goalValue == self._nextValue and not self._currentlyAnimating then
		return false
	end

	local tweenInfo = self._tweenInfo
	if self._tweenInfoIsState then
		tweenInfo = tweenInfo:get()
	end

	-- if we receive a bad TweenInfo, then error and stop the update
	if typeof(tweenInfo) ~= "TweenInfo" then
		logErrorNonFatal("mistypedTweenInfo", nil, typeof(tweenInfo))
		return false
	end

	self._prevValue = self._currentValue
	self._nextValue = goalValue

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = tweenInfo

	local tweenDuration = tweenInfo.DelayTime + tweenInfo.Time
	if tweenInfo.Reverses then
		tweenDuration += tweenInfo.Time
	end
	tweenDuration *= tweenInfo.RepeatCount + 1
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)

	return false
end

local function Tween<T>(
	goalState: PubTypes.StateObject<PubTypes.Animatable>,
	tweenInfo: PubTypes.CanBeState<TweenInfo>?
): Types.Tween<T>
	local currentValue = goalState:get(false)

	-- apply defaults for tween info
	if tweenInfo == nil then
		tweenInfo = TweenInfo.new()
	end

	local dependencySet = {[goalState] = true}
	local tweenInfoIsState = xtypeof(tweenInfo) == "State"

	if tweenInfoIsState then
		dependencySet[tweenInfo] = true
	end

	local startingTweenInfo = tweenInfo
	if tweenInfoIsState then
		startingTweenInfo = startingTweenInfo:get()
	end

	-- If we start with a bad TweenInfo, then we don't want to construct a Tween
	if typeof(startingTweenInfo) ~= "TweenInfo" then
		logError("mistypedTweenInfo", nil, typeof(startingTweenInfo))
	end

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo,
		_tweenInfoIsState = tweenInfoIsState,

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0,
		_currentlyAnimating = false
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX093981F762B04B87A754AAC78583FE9D">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">TweenScheduler</string>
														<string name="ScriptGuid">{059D5B45-6967-47AB-935A-0BC53F101015}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Set<T> = {[T]: any}
type Tween = Types.Tween<any>

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Set<Tween> = {}
setmetatable(allTweens, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	-- FIXME: Typed Luau doesn't understand this loop yet
	for tween: Tween in pairs(allTweens :: any) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			tween._currentlyAnimating = false
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			tween._currentlyAnimating = true
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX75E5A72ED20C466AA2D8D07C2EFFCBAD">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">getTweenRatio</string>
														<string name="ScriptGuid">{02D2BF8D-22E5-4E0F-912B-BC2ED5DAA42B}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numCycles = 1 + tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numCycles then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime <= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX0F019DD31B07438CB639A8FE3C1467D4">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">lerpType</string>
														<string name="ScriptGuid">{79248308-34A8-401B-8661-0DC4584C53E4}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: any, to: any, ratio: number): any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			local to, from = to :: number, from :: number
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			local to, from = to :: CFrame, from :: CFrame
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local to, from = to :: Color3, from :: Color3
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local to, from = to :: ColorSequenceKeypoint, from :: ColorSequenceKeypoint
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			local to, from = to :: DateTime, from :: DateTime
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			local to, from = to :: NumberRange, from :: NumberRange
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			local to, from = to :: NumberSequenceKeypoint, from :: NumberSequenceKeypoint
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			local to, from = to :: PhysicalProperties, from :: PhysicalProperties
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			local to, from = to :: Ray, from :: Ray
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio)
			)

		elseif typeString == "Rect" then
			local to, from = to :: Rect, from :: Rect
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			local to, from = to :: Region3, from :: Region3
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			local to, from = to :: Region3int16, from :: Region3int16
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			local to, from = to :: UDim, from :: UDim
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			local to, from = to :: UDim2, from :: UDim2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			local to, from = to :: Vector2, from :: Vector2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			local to, from = to :: Vector2int16, from :: Vector2int16
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			local to, from = to :: Vector3, from :: Vector3
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			local to, from = to :: Vector3int16, from :: Vector3int16
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio < 0.5 then
		return from
	else
		return to
	end
end

return lerpType]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX6456412FA7194F0F94CD5E7BA22DDCB7">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">packType</string>
														<string name="ScriptGuid">{CC602E75-C8B4-42E4-8677-9098E61BAC98}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): PubTypes.Animatable?
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	else
		return nil
	end
end

return packType]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX9A9691BE2CA546AC997A3A8B7937E3A5">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">springCoefficients</string>
														<string name="ScriptGuid">{BE309F49-38B8-4318-B6D4-725FCB814F31}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Returns a 2x2 matrix of coefficients for a given time, damping and speed.
	Specifically, this returns four coefficients - posPos, posVel, velPos, and
	velVel - which can be multiplied with position and velocity like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	Special thanks to AxisAngle for helping to improve numerical precision.
]]

local function springCoefficients(time: number, damping: number, speed: number): (number, number, number, number)
	-- if time or speed is 0, then the spring won't move
	if time == 0 or speed == 0 then
		return 1, 0, 0, 1
	end
	local posPos, posVel, velPos, velVel

	if damping > 1 then
		-- overdamped spring
		-- solution to the characteristic equation:
		-- z = -  Sqrt[^2 - 1] 
		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)
		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local scaledTime = time * speed
		local alpha = math.sqrt(damping^2 - 1)
		local scaledInvAlpha = -0.5 / alpha
		local z1 = -alpha - damping
		local z2 = 1 / z1
		local expZ1 = math.exp(scaledTime * z1)
		local expZ2 = math.exp(scaledTime * z2)

		posPos = (expZ2*z1 - expZ1*z2) * scaledInvAlpha
		posVel = (expZ1 - expZ2) * scaledInvAlpha / speed
		velPos = (expZ2 - expZ1) * scaledInvAlpha * speed
		velVel = (expZ1*z1 - expZ2*z2) * scaledInvAlpha

	elseif damping == 1 then
		-- critically damped spring
		-- x[t] -> x0(e^-t)(1+t) + v0(e^-t)t
		-- v[t] -> x0(t ^2)(-e^-t) + v0(1 - t)(e^-t)

		local scaledTime = time * speed
		local expTerm = math.exp(-scaledTime)

		posPos = expTerm * (1 + scaledTime)
		posVel = expTerm * time
		velPos = expTerm * (-scaledTime*speed)
		velVel = expTerm * (1 - scaledTime)

	else
		-- underdamped spring
		-- factored out of the solutions to the characteristic equation:
		--  = Sqrt[1 - ^2]
		-- x[t] -> x0(e^-t)( Cos[t] +  Sin[t])/
		--       + v0(e^-t)(Sin[t])/
		-- v[t] -> x0(-e^-t)(^2 + ^2 ^2)(Sin[t])/
		--       + v0(e^-t)( Cos[t] -  Sin[t])/

		local scaledTime = time * speed
		local alpha = math.sqrt(1 - damping^2)
		local invAlpha = 1 / alpha
		local alphaTime = alpha * scaledTime
		local expTerm = math.exp(-scaledTime*damping)
		local sinTerm = expTerm * math.sin(alphaTime)
		local cosTerm = expTerm * math.cos(alphaTime)
		local sinInvAlpha = sinTerm*invAlpha
		local sinInvAlphaDamp = sinInvAlpha*damping

		posPos = sinInvAlphaDamp + cosTerm
		posVel = sinInvAlpha
		velPos = -(sinInvAlphaDamp*damping + sinTerm*alpha)
		velVel = cosTerm - sinInvAlphaDamp
	end

	return posPos, posVel, velPos, velVel
end

return springCoefficients
]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXDEAFD8B5389041D79E8A6619561998DB">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">unpackType</string>
														<string name="ScriptGuid">{9DCA8869-2EF8-478E-A925-3D5DCF71763B}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: any, typeString: string): {number}
	if typeString == "number" then
		local value = value :: number
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBX50799B83324D4010B3AF4AA943BA7ED7">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Colour</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX93CF107C40D3489EB204313A913FD9F2">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Oklab</string>
														<string name="ScriptGuid">{43A6AEAA-FAC1-449B-B931-38398F49D40D}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

	local lRoot = l ^ (1/3)
	local mRoot = m ^ (1/3)
	local sRoot = s ^ (1/3)

	return Vector3.new(
		lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
		lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
		lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
	local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
	local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

	local l = lRoot ^ 3
	local m = mRoot ^ 3
	local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab
]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBX064BD1EB3BFF4897860B4BBC2F8E0B10">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Dependencies</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX5CE7BA7088FD4BBDB2E5D2D10FD3ABED">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">captureDependencies</string>
														<string name="ScriptGuid">{56EFD185-F777-4B35-A4BA-CB49AB848AB0}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.

	NOTE: any calls to useDependency() inside the callback (even if inside any
	nested captureDependencies() call) will not be included in the set, to avoid
	self-dependencies.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

type Set<T> = {[T]: any}

local initialisedStack = sharedState.initialisedStack
local initialisedStackCapacity = 0

local function captureDependencies(
	saveToSet: Set<PubTypes.Dependency>,
	callback: (...any) -> any,
	...
): (boolean, any)

	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet
	if initialisedStackSize > initialisedStackCapacity then
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	local data = table.pack(xpcall(callback, parseError, ...))

	sharedState.dependencySet = prevDependencySet
	sharedState.initialisedStackSize -= 1

	return table.unpack(data, 1, data.n)
end

return captureDependencies
]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX3D63A1AFCF8C49B78959B378DDE0511C">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">initDependency</string>
														<string name="ScriptGuid">{5CDA5EAB-226F-437F-9F40-FA79F28C2F79}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: PubTypes.Dependency)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXB11C2CFE720D43A087C80FAF0CF9CFC6">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">sharedState</string>
														<string name="ScriptGuid">{05E99AD0-2482-4803-91FE-93E77B9EE02B}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}

-- The set where used dependencies should be saved to.
local dependencySet: Set<PubTypes.Dependency>? = nil

-- A stack of sets where newly created dependencies should be stored.
local initialisedStack: {Set<PubTypes.Dependency>} = {}
local initialisedStackSize = 0

return {
	dependencySet = dependencySet,
	initialisedStack = initialisedStack,
	initialisedStackSize = initialisedStackSize
}]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX29E6DFBECBE7449F8EF3C45CCB052159">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">updateAll</string>
														<string name="ScriptGuid">{5B73C866-CEEF-458B-BC29-0E1EAF800A6C}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}
type Descendant = (PubTypes.Dependent & PubTypes.Dependency) | PubTypes.Dependent

-- Credit: https://blog.elttob.uk/2022/11/07/sets-efficient-topological-search.html
local function updateAll(root: PubTypes.Dependency)
	local counters: {[Descendant]: number} = {}
	local flags: {[Descendant]: boolean} = {}
	local queue: {Descendant} = {}
	local queueSize = 0
	local queuePos = 1

	for object in root.dependentSet do
		queueSize += 1
		queue[queueSize] = object
		flags[object] = true
	end

	-- Pass 1: counting up
	while queuePos <= queueSize do
		local next = queue[queuePos]
		local counter = counters[next]
		counters[next] = if counter == nil then 1 else counter + 1
		if (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				queueSize += 1
				queue[queueSize] = object
			end
		end
		queuePos += 1
	end

	-- Pass 2: counting down + processing
	queuePos = 1
	while queuePos <= queueSize do
		local next = queue[queuePos]
		local counter = counters[next] - 1
		counters[next] = counter
		if counter == 0 and flags[next] and next:update() and (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				flags[object] = true
			end
		end
		queuePos += 1
	end
end

return updateAll]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXCCDE9DF4A4E14492825452CFEE981ED7">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">useDependency</string>
														<string name="ScriptGuid">{1DF36922-4658-4C78-B834-CE4E28C5CB83}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: PubTypes.Dependency)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBX86A94A9644A9454CB98D22B6F92DEC35">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Instances</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX8EC5DC22FF1A4036A9B517858593700F">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Children</string>
														<string name="ScriptGuid">{34C5671B-B878-4956-80A0-1A6B76D3A3B5}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which parents any given descendants into
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logWarn = require(Package.Logging.logWarn)
local Observer = require(Package.State.Observer)
local xtypeof = require(Package.Utility.xtypeof)

type Set<T> = {[T]: boolean}

-- Experimental flag: name children based on the key used in the [Children] table
local EXPERIMENTAL_AUTO_NAMING = false

local Children = {}
Children.type = "SpecialKey"
Children.kind = "Children"
Children.stage = "descendants"

function Children:apply(propValue: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	local newParented: Set<Instance> = {}
	local oldParented: Set<Instance> = {}

	-- save disconnection functions for state object observers
	local newDisconnects: {[PubTypes.StateObject<any>]: () -> ()} = {}
	local oldDisconnects: {[PubTypes.StateObject<any>]: () -> ()} = {}

	local updateQueued = false
	local queueUpdate: () -> ()

	-- Rescans this key's value to find new instances to parent and state objects
	-- to observe for changes; then unparents instances no longer found and
	-- disconnects observers for state objects no longer present.
	local function updateChildren()
		if not updateQueued then
			return -- this update may have been canceled by destruction, etc.
		end
		updateQueued = false

		oldParented, newParented = newParented, oldParented
		oldDisconnects, newDisconnects = newDisconnects, oldDisconnects
		table.clear(newParented)
		table.clear(newDisconnects)

		local function processChild(child: any, autoName: string?)
			local kind = xtypeof(child)

			if kind == "Instance" then
				-- case 1; single instance

				newParented[child] = true
				if oldParented[child] == nil then
					-- wasn't previously present

					-- TODO: check for ancestry conflicts here
					child.Parent = applyTo
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldParented[child] = nil
				end

				if EXPERIMENTAL_AUTO_NAMING and autoName ~= nil then
					child.Name = autoName
				end

			elseif kind == "State" then
				-- case 2; state object

				local value = child:get(false)
				-- allow nil to represent the absence of a child
				if value ~= nil then
					processChild(value, autoName)
				end

				local disconnect = oldDisconnects[child]
				if disconnect == nil then
					-- wasn't previously present
					disconnect = Observer(child):onChange(queueUpdate)
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldDisconnects[child] = nil
				end

				newDisconnects[child] = disconnect

			elseif kind == "table" then
				-- case 3; table of objects

				for key, subChild in pairs(child) do
					local keyType = typeof(key)
					local subAutoName: string? = nil

					if keyType == "string" then
						subAutoName = key
					elseif keyType == "number" and autoName ~= nil then
						subAutoName = autoName .. "_" .. key
					end

					processChild(subChild, subAutoName)
				end

			else
				logWarn("unrecognisedChildType", kind)
			end
		end

		if propValue ~= nil then
			-- `propValue` is set to nil on cleanup, so we don't process children
			-- in that case
			processChild(propValue)
		end

		-- unparent any children that are no longer present
		for oldInstance in pairs(oldParented) do
			oldInstance.Parent = nil
		end

		-- disconnect observers which weren't reused
		for oldState, disconnect in pairs(oldDisconnects) do
			disconnect()
		end
	end

	queueUpdate = function()
		if not updateQueued then
			updateQueued = true
			task.defer(updateChildren)
		end
	end

	table.insert(cleanupTasks, function()
		propValue = nil
		updateQueued = true
		updateChildren()
	end)

	-- perform initial child parenting
	updateQueued = true
	updateChildren()
end

return Children :: PubTypes.SpecialKey]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXDA9212A971B340C3B8819BBC3EEF9E58">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Cleanup</string>
														<string name="ScriptGuid">{38CE2D15-7377-44B1-B28E-776F78F9C743}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which adds user-specified tasks to be run
	when the instance is destroyed.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

local Cleanup = {}
Cleanup.type = "SpecialKey"
Cleanup.kind = "Cleanup"
Cleanup.stage = "observer"

function Cleanup:apply(userTask: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	table.insert(cleanupTasks, userTask)
end

return Cleanup]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX232DBDEA5A034C4BA9099189B974F331">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Hydrate</string>
														<string name="ScriptGuid">{7321CC55-E442-4006-AC55-765CF9BAFC07}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Processes and returns an existing instance, with options for setting
	properties, event handlers and other attributes on the instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)

local function Hydrate(target: Instance)
	return function(props: PubTypes.PropertyTable): Instance
		applyInstanceProps(props, target)
		return target
	end
end

return Hydrate]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXE25C121CE61E4809B3B1B386A28A8F99">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">New</string>
														<string name="ScriptGuid">{95CFEF91-196D-4292-957F-21E57701566B}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local defaultProps = require(Package.Instances.defaultProps)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)
local logError= require(Package.Logging.logError)

local function New(className: string)
	return function(props: PubTypes.PropertyTable): Instance
		local ok, instance = pcall(Instance.new, className)

		if not ok then
			logError("cannotCreateClass", nil, className)
		end

		local classDefaults = defaultProps[className]
		if classDefaults ~= nil then
			for defaultProp, defaultValue in pairs(classDefaults) do
				instance[defaultProp] = defaultValue
			end
		end

		applyInstanceProps(props, instance)

		return instance
	end
end

return New]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX4A7592CDA634461F968D1AA39865A842">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">OnChange</string>
														<string name="ScriptGuid">{3AA6AF6A-F0EF-45D2-BB9F-3604CA16C63D}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs special keys for property tables which connect property change
	listeners to an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function OnChange(propertyName: string): PubTypes.SpecialKey
	local changeKey = {}
	changeKey.type = "SpecialKey"
	changeKey.kind = "OnChange"
	changeKey.stage = "observer"

	function changeKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("cannotConnectChange", nil, applyTo.ClassName, propertyName)
		elseif typeof(callback) ~= "function" then
			logError("invalidChangeHandler", nil, propertyName)
		else
			table.insert(cleanupTasks, event:Connect(function()
				callback((applyTo :: any)[propertyName])
			end))
		end
	end

	return changeKey
end

return OnChange]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXC981A752BCBB4BF1B51FDACB3EA39FDA">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">OnEvent</string>
														<string name="ScriptGuid">{C5311178-5E2C-451F-8E17-899393D01EA6}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs special keys for property tables which connect event listeners to
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function getProperty_unsafe(instance: Instance, property: string)
	return (instance :: any)[property]
end

local function OnEvent(eventName: string): PubTypes.SpecialKey
	local eventKey = {}
	eventKey.type = "SpecialKey"
	eventKey.kind = "OnEvent"
	eventKey.stage = "observer"

	function eventKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(getProperty_unsafe, applyTo, eventName)
		if not ok or typeof(event) ~= "RBXScriptSignal" then
			logError("cannotConnectEvent", nil, applyTo.ClassName, eventName)
		elseif typeof(callback) ~= "function" then
			logError("invalidEventHandler", nil, eventName)
		else
			table.insert(cleanupTasks, event:Connect(callback))
		end
	end

	return eventKey
end

return OnEvent]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX37495688861043659349AD2D12E56886">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Out</string>
														<string name="ScriptGuid">{391C90CF-DF37-41A6-A30A-F406E9A9D31B}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which allows users to extract values from
	an instance into an automatically-updated Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local function Out(propertyName: string): PubTypes.SpecialKey
	local outKey = {}
	outKey.type = "SpecialKey"
	outKey.kind = "Out"
	outKey.stage = "observer"

	function outKey:apply(outState: any, applyTo: Instance, cleanupTasks: { PubTypes.Task })
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("invalidOutProperty", nil, applyTo.ClassName, propertyName)
		elseif xtypeof(outState) ~= "State" or outState.kind ~= "Value" then
			logError("invalidOutType")
		else
			outState:set((applyTo :: any)[propertyName])
			table.insert(
				cleanupTasks,
				event:Connect(function()
					outState:set((applyTo :: any)[propertyName])
				end)
			)
			table.insert(cleanupTasks, function()
				outState:set(nil)
			end)
		end
	end

	return outKey
end

return Out
]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX0F9326267CC948AFA2F9F913879720CA">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Ref</string>
														<string name="ScriptGuid">{A22DA89F-ADAF-49FD-A8E2-D14F57F28AAA}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which stores a reference to the instance
	in a user-provided Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local Ref = {}
Ref.type = "SpecialKey"
Ref.kind = "Ref"
Ref.stage = "observer"

function Ref:apply(refState: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	if xtypeof(refState) ~= "State" or refState.kind ~= "Value" then
		logError("invalidRefType")
	else
		refState:set(applyTo)
		table.insert(cleanupTasks, function()
			refState:set(nil)
		end)
	end
end

return Ref]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXEFD72671F533481FAE5B4EF46848B771">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">applyInstanceProps</string>
														<string name="ScriptGuid">{74F53C23-3907-40B8-B707-D5B8D19B84E7}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Applies a table of properties to an instance, including binding to any
	given state objects and applying any special keys.

	No strong reference is kept by default - special keys should take care not
	to accidentally hold strong references to instances forever.

	If a key is used twice, an error will be thrown. This is done to avoid
	double assignments or double bindings. However, some special keys may want
	to enable such assignments - in which case unique keys should be used for
	each occurence.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local cleanup = require(Package.Utility.cleanup)
local xtypeof = require(Package.Utility.xtypeof)
local logError = require(Package.Logging.logError)
local Observer = require(Package.State.Observer)

local function setProperty_unsafe(instance: Instance, property: string, value: any)
	(instance :: any)[property] = value
end

local function testPropertyAssignable(instance: Instance, property: string)
	(instance :: any)[property] = (instance :: any)[property]
end

local function setProperty(instance: Instance, property: string, value: any)
	if not pcall(setProperty_unsafe, instance, property, value) then
		if not pcall(testPropertyAssignable, instance, property) then
			if instance == nil then
				-- reference has been lost
				logError("setPropertyNilRef", nil, property, tostring(value))
			else
				-- property is not assignable
				logError("cannotAssignProperty", nil, instance.ClassName, property)
			end
		else
			-- property is assignable, but this specific assignment failed
			-- this typically implies the wrong type was received
			local givenType = typeof(value)
			local expectedType = typeof((instance :: any)[property])
			logError("invalidPropertyType", nil, instance.ClassName, property, expectedType, givenType)
		end
	end
end

local function bindProperty(instance: Instance, property: string, value: PubTypes.CanBeState<any>, cleanupTasks: {PubTypes.Task})
	if xtypeof(value) == "State" then
		-- value is a state object - assign and observe for changes
		local willUpdate = false
		local function updateLater()
			if not willUpdate then
				willUpdate = true
				task.defer(function()
					willUpdate = false
					setProperty(instance, property, value:get(false))
				end)
			end
		end

		setProperty(instance, property, value:get(false))
		table.insert(cleanupTasks, Observer(value :: any):onChange(updateLater))
	else
		-- value is a constant - assign once only
		setProperty(instance, property, value)
	end
end

local function applyInstanceProps(props: PubTypes.PropertyTable, applyTo: Instance)
	local specialKeys = {
		self = {} :: {[PubTypes.SpecialKey]: any},
		descendants = {} :: {[PubTypes.SpecialKey]: any},
		ancestor = {} :: {[PubTypes.SpecialKey]: any},
		observer = {} :: {[PubTypes.SpecialKey]: any}
	}
	local cleanupTasks = {}

	for key, value in pairs(props) do
		local keyType = xtypeof(key)

		if keyType == "string" then
			if key ~= "Parent" then
				bindProperty(applyTo, key :: string, value, cleanupTasks)
			end
		elseif keyType == "SpecialKey" then
			local stage = (key :: PubTypes.SpecialKey).stage
			local keys = specialKeys[stage]
			if keys == nil then
				logError("unrecognisedPropertyStage", nil, stage)
			else
				keys[key] = value
			end
		else
			-- we don't recognise what this key is supposed to be
			logError("unrecognisedPropertyKey", nil, xtypeof(key))
		end
	end

	for key, value in pairs(specialKeys.self) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.descendants) do
		key:apply(value, applyTo, cleanupTasks)
	end

	if props.Parent ~= nil then
		bindProperty(applyTo, "Parent", props.Parent, cleanupTasks)
	end

	for key, value in pairs(specialKeys.ancestor) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.observer) do
		key:apply(value, applyTo, cleanupTasks)
	end

	applyTo.Destroying:Connect(function()
		cleanup(cleanupTasks)
	end)
end

return applyInstanceProps]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX5D0E4B51E57548E6A119D1E20DF8DA64">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">defaultProps</string>
														<string name="ScriptGuid">{D9575B38-CFC7-4E07-864E-3C6C1801BC85}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

return {
	ScreenGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	BillboardGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	SurfaceGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

		SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
		PixelsPerStud = 50
	},

	Frame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ScrollingFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ScrollBarImageColor3 = Color3.new(0, 0, 0)
	},

	TextLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextBox = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ClearTextOnFocus = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	ImageLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ImageButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false
	},

	ViewportFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	VideoFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},
	
	CanvasGroup = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
}
]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBX28E0AA390FA4496EA07E04B97625B40C">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Logging</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX7FA40B7156C44BCFB8BBED87638548AC">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">logError</string>
														<string name="ScriptGuid">{C3584DC5-7A35-4249-81D1-9139FA396948}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific error.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXFC3F145C8274457DBFDB39A9965633E6">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">logErrorNonFatal</string>
														<string name="ScriptGuid">{E4DB4066-5AFB-4ADB-A376-D23FA4B7EB8E}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX90E12FEC0D074B6CB64CD190FD460D09">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">logWarn</string>
														<string name="ScriptGuid">{505B999D-3C63-4A5F-8208-14271E9795BC}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(messageID, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...))
end

return logWarn]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX18E0931229CC484F956FF8E2A893B3C1">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">messages</string>
														<string name="ScriptGuid">{B22CE2C6-3E0E-46D9-A493-C8D12C0734C0}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores templates for different kinds of logging messages.
]]

return {
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	destructorNeededValue = "To save instances into Values, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededComputed = "To return instances from Computeds, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	multiReturnComputed = "Returning multiple values from Computeds is discouraged, as behaviour will change soon - see discussion #189 on GitHub.",
	destructorNeededForKeys = "To return instances from ForKeys, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForValues = "To return instances from ForValues, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForPairs = "To return instances from ForPairs, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	duplicatePropertyKey = "",
	forKeysProcessorError = "ForKeys callback error: ERROR_MESSAGE",
	forKeysKeyCollision = "ForKeys should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previously input key: '%s'; New input key: '%s'",
	forKeysDestructorError = "ForKeys destructor error: ERROR_MESSAGE",
	forPairsDestructorError = "ForPairs destructor error: ERROR_MESSAGE",
	forPairsKeyCollision = "ForPairs should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previous input pair: '[%s] = %s'; New input pair: '[%s] = %s'",
	forPairsProcessorError = "ForPairs callback error: ERROR_MESSAGE",
	forValuesProcessorError = "ForValues callback error: ERROR_MESSAGE",
	forValuesDestructorError = "ForValues destructor error: ERROR_MESSAGE",
	invalidChangeHandler = "The change handler for the '%s' property must be a function.",
	invalidEventHandler = "The handler for the '%s' event must be a function.",
	invalidPropertyType = "'%s.%s' expected a '%s' type, but got a '%s' type.",
	invalidRefType = "Instance refs must be Value objects.",
	invalidOutType = "[Out] properties must be given Value objects.",
	invalidOutProperty = "The %s class doesn't have a property called '%s'.",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	mistypedSpringDamping = "The damping ratio for a spring must be a number. (got a %s)",
	mistypedSpringSpeed = "The speed of a spring must be a number. (got a %s)",
	mistypedTweenInfo = "The tween info of a tween must be a TweenInfo. (got a %s)",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted by `[Children]`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in property tables.",
	unrecognisedPropertyStage = "'%s' isn't a valid stage for a special key to be applied at."
}]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXEA44C7556FCA47A38CF3016E3C84B638">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">parseError</string>
														<string name="ScriptGuid">{55D995FE-911F-429E-A9E5-07B5E5C5A283}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.

	TODO: this should have a 'type' field for runtime type checking!
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		type = "Error",
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBXDB78F87238FC4368BB7FCD3D2228B3D6">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">State</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX28B89E014B7B434CA8817BD82F02E979">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Computed</string>
														<string name="ScriptGuid">{EBF54EEE-252E-4F7F-9E2E-52D7416FA89E}</string>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local isSimilar = require(Package.Utility.isSimilar)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update(): boolean
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue, newMetaValue = captureDependencies(self.dependencySet, self._processor)

	if ok then
		if self._destructor == nil and needsDestruction(newValue) then
			logWarn("destructorNeededComputed")
		end

		if newMetaValue ~= nil then
			logWarn("multiReturnComputed")
		end

		local oldValue = self._value
		local similar = isSimilar(oldValue, newValue)
		if self._destructor ~= nil then
			self._destructor(oldValue)
		end
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return not similar
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed<T>(processor: () -> T, destructor: ((T) -> ())?): Types.Computed<T>
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_processor = processor,
		_destructor = destructor,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX8564E800755B45AFA4D1A67CA650736B">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">ForKeys</string>
														<string name="ScriptGuid">{AFEC50D4-AE27-4B52-8CD3-E1A8B1DB8D23}</string>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForKeys state object which maps keys of an array using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up
	calculated keys. If omitted, the default cleanup function will be used instead.

	Optionally, a `meta` value can be returned in the processor function as the
	second value to pass data from the processor to the destructor.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForKeys object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end


--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those key pairs, storing information about any
	dependencies used in the processor callback during output key generation,
	and save the new key to the output array with the same value. If it is
	overwriting an older value, that older value will be passed to the
	destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their output keys from the output table and pass them to the destructor.
]]

function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable
	local outputTable = self._outputTable

	local keyOIMap = self._keyOIMap
	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find keys that changed or were not previously present
	for newInKey, value in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end

		-- check if the key is new
		local shouldRecalculate = oldInputTable[newInKey] == nil

		-- check if the key's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output key if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForKeys")
				end

				local oldInKey = keyOIMap[newOutKey]
				local oldOutKey = keyIOMap[newInKey]

				-- check for key collision
				if oldInKey ~= newInKey and newInputTable[oldInKey] ~= nil then
					logError("forKeysKeyCollision", nil, tostring(newOutKey), tostring(oldInKey), tostring(newOutKey))
				end

				-- check for a changed output key
				if oldOutKey ~= newOutKey and keyOIMap[oldOutKey] == newInKey then
					-- clean up the old calculated value
					local oldMetaValue = meta[oldOutKey]

					local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldMetaValue)
					if not destructOK then
						logErrorNonFatal("forKeysDestructorError", err)
					end

					keyOIMap[oldOutKey] = nil
					outputTable[oldOutKey] = nil
					meta[oldOutKey] = nil
				end

				-- update the stored data for this key
				oldInputTable[newInKey] = value
				meta[newOutKey] = newMetaValue
				keyOIMap[newOutKey] = newInKey
				keyIOMap[newInKey] = newOutKey
				outputTable[newOutKey] = value

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forKeysProcessorError", newOutKey)
			end
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find keys that were removed
	for outputKey, inputKey in pairs(keyOIMap) do
		if newInputTable[inputKey] == nil then
			-- clean up the old calculated value
			local oldMetaValue = meta[outputKey]

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, outputKey, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forKeysDestructorError", err)
			end

			-- remove data
			oldInputTable[inputKey] = nil
			meta[outputKey] = nil
			keyOIMap[outputKey] = nil
			keyIOMap[inputKey] = nil
			outputTable[outputKey] = nil
			self._keyData[inputKey] = nil

			-- if we removed a key, then the table/state changed
			didChange = true
		end
	end

	return didChange
end

local function ForKeys<KI, KO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: any }>,
	processor: (KI) -> (KO, M?),
	destructor: (KO, M?) -> ()?
): Types.ForKeys<KI, KO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForKeys",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_keyOIMap = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForKeys]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX64196EA270974F95B7424C3080DD9CA4">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">ForPairs</string>
														<string name="ScriptGuid">{8E7184B4-C3E0-4EE7-8FDB-ADFE0F0CDE3F}</string>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForPairs object which maps pairs of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new key/value pair to the output array. If it is overwriting an
	older key/value pair, that older pair will be passed to the destructor
	for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their key/value pairs from the output table and pass them to the destructor.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable

	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- clean out output table
	self._oldOutputTable, self._outputTable = self._outputTable, self._oldOutputTable

	local oldOutputTable = self._oldOutputTable
	local newOutputTable = self._outputTable
	table.clear(newOutputTable)

	-- Step 1: find key/value pairs that changed or were not previously present

	for newInKey, newInValue in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end


		-- check if the pair is new or changed
		local shouldRecalculate = oldInputTable[newInKey] ~= newInValue

		-- check if the pair's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output pair if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newOutValue, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey,
				newInValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForPairs")
				end

				-- if this key was already written to on this run-through, throw a fatal error.
				if newOutputTable[newOutKey] ~= nil then
					-- figure out which key/value pair previously wrote to this key
					local previousNewKey, previousNewValue
					for inKey, outKey in pairs(keyIOMap) do
						if outKey == newOutKey then
							previousNewValue = newInputTable[inKey]
							if previousNewValue ~= nil then
								previousNewKey = inKey
								break
							end
						end
					end

					if previousNewKey ~= nil then
						logError(
							"forPairsKeyCollision",
							nil,
							tostring(newOutKey),
							tostring(previousNewKey),
							tostring(previousNewValue),
							tostring(newInKey),
							tostring(newInValue)
						)
					end
				end

				local oldOutValue = oldOutputTable[newOutKey]

				if oldOutValue ~= newOutValue then
					local oldMetaValue = meta[newOutKey]
					if oldOutValue ~= nil then
						local destructOK, err = xpcall(self._destructor or cleanup, parseError, newOutKey, oldOutValue, oldMetaValue)
						if not destructOK then
							logErrorNonFatal("forPairsDestructorError", err)
						end
					end

					oldOutputTable[newOutKey] = nil
				end

				-- update the stored data for this key/value pair
				oldInputTable[newInKey] = newInValue
				keyIOMap[newInKey] = newOutKey
				meta[newOutKey] = newMetaValue
				newOutputTable[newOutKey] = newOutValue

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forPairsProcessorError", newOutKey)
			end
		else
			local storedOutKey = keyIOMap[newInKey]

			-- check for key collision
			if newOutputTable[storedOutKey] ~= nil then
				-- figure out which key/value pair previously wrote to this key
				local previousNewKey, previousNewValue
				for inKey, outKey in pairs(keyIOMap) do
					if storedOutKey == outKey then
						previousNewValue = newInputTable[inKey]

						if previousNewValue ~= nil then
							previousNewKey = inKey
							break
						end
					end
				end

				if previousNewKey ~= nil then
					logError(
						"forPairsKeyCollision",
						nil,
						tostring(storedOutKey),
						tostring(previousNewKey),
						tostring(previousNewValue),
						tostring(newInKey),
						tostring(newInValue)
					)
				end
			end

			-- copy the stored key/value pair into the new output table
			newOutputTable[storedOutKey] = oldOutputTable[storedOutKey]
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end

	-- STEP 2: find keys that were removed
	for oldOutKey, oldOutValue in pairs(oldOutputTable) do
		-- check if this key/value pair is in the new output table
		if newOutputTable[oldOutKey] ~= oldOutValue then
			-- clean up the old output pair
			local oldMetaValue = meta[oldOutKey]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldOutValue, oldMetaValue)
				if not destructOK then
					logErrorNonFatal("forPairsDestructorError", err)
				end
			end

			-- check if the key was completely removed from the output table
			if newOutputTable[oldOutKey] == nil then
				meta[oldOutKey] = nil
				self._keyData[oldOutKey] = nil
			end

			didChange = true
		end
	end

	for key in pairs(oldInputTable) do
		if newInputTable[key] == nil then
			oldInputTable[key] = nil
			keyIOMap[key] = nil
		end
	end

	return didChange
end

local function ForPairs<KI, VI, KO, VO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: VI }>,
	processor: (KI, VI) -> (KO, VO, M?),
	destructor: (KO, VO, M?) -> ()?
): Types.ForPairs<KI, VI, KO, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForPairs]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX614E1DD918A542D190037E3A39D89EA7">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">ForValues</string>
														<string name="ScriptGuid">{7FB6602D-AB37-46E2-BEF0-307C7BC05F7C}</string>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForValues object which maps values of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]
local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForValues object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any values meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those values, storing information about any dependencies
	used in the processor callback during value generation, and save the new value
	to the output array with the same key. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find values that are no longer present, and remove
	their values from the output table and pass them to the destructor. You can re-use
	the same value multiple times and this will function will update them as little as
	possible; reusing the same values where possible.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local inputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local outputValues = {}

	local didChange = false

	-- clean out value cache
	self._oldValueCache, self._valueCache = self._valueCache, self._oldValueCache
	local newValueCache = self._valueCache
	local oldValueCache = self._oldValueCache
	table.clear(newValueCache)

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find values that changed or were not previously present
	for inKey, inValue in pairs(inputTable) do
		-- check if the value is new or changed
		local oldCachedValues = oldValueCache[inValue]
		local shouldRecalculate = oldCachedValues == nil

		-- get a cached value and its dependency/meta data if available
		local value, valueData, meta

		if type(oldCachedValues) == "table" and #oldCachedValues > 0 then
			local valueInfo = table.remove(oldCachedValues, #oldCachedValues)
			value = valueInfo.value
			valueData = valueInfo.valueData
			meta = valueInfo.meta

			if #oldCachedValues <= 0 then
				oldValueCache[inValue] = nil
			end
		elseif oldCachedValues ~= nil then
			oldValueCache[inValue] = nil
			shouldRecalculate = true
		end

		if valueData == nil then
			valueData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
		end

		-- check if the value's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(valueData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- recalculate the output value if necessary
		if shouldRecalculate then
			valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet
			table.clear(valueData.dependencySet)

			local processOK, newOutValue, newMetaValue = captureDependencies(
				valueData.dependencySet,
				self._processor,
				inValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForValues")
				end

				-- pass the old value to the destructor if it exists
				if value ~= nil then
					local destructOK, err = xpcall(self._destructor or cleanup, parseError, value, meta)
					if not destructOK then
						logErrorNonFatal("forValuesDestructorError", err)
					end
				end

				-- store the new value and meta data
				value = newOutValue
				meta = newMetaValue
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet

				logErrorNonFatal("forValuesProcessorError", newOutValue)
			end
		end


		-- store the value and its dependency/meta data
		local newCachedValues = newValueCache[inValue]
		if newCachedValues == nil then
			newCachedValues = {}
			newValueCache[inValue] = newCachedValues
		end

		table.insert(newCachedValues, {
			value = value,
			valueData = valueData,
			meta = meta,
		})

		outputValues[inKey] = value


		-- save dependency values and add to main dependency set
		for dependency in pairs(valueData.dependencySet) do
			valueData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find values that were removed
	-- for tables of data, we just need to check if it's still in the cache
	for _oldInValue, oldCachedValueInfo in pairs(oldValueCache) do
		for _, valueInfo in ipairs(oldCachedValueInfo) do
			local oldValue = valueInfo.value
			local oldMetaValue = valueInfo.meta

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldValue, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forValuesDestructorError", err)
			end

			didChange = true
		end

		table.clear(oldCachedValueInfo)
	end

	self._outputTable = outputValues

	return didChange
end

local function ForValues<VI, VO, M>(
	inputTable: PubTypes.CanBeState<{ [any]: VI }>,
	processor: (VI) -> (VO, M?),
	destructor: (VO, M?) -> ()?
): Types.ForValues<VI, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForValues",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_outputTable = {},
		_valueCache = {},
		_oldValueCache = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForValues]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX718F4F2D633A4D049958C5203EB8517A">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Observer</string>
														<string name="ScriptGuid">{7F86C30F-1E8D-4CAF-8562-269B432E5154}</string>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new state object which can listen for updates on another state
	object.

	FIXME: enabling strict types here causes free types to leak
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local initDependency = require(Package.Dependencies.initDependency)

type Set<T> = {[T]: any}

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Observer objects in memory.
local strongRefs: Set<Types.Observer> = {}

--[[
	Called when the watched state changes value.
]]
function class:update(): boolean
	for _, callback in pairs(self._changeListeners) do
		task.spawn(callback)
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Observer
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ()): () -> ()
	local uniqueIdentifier = {}

	self._numChangeListeners += 1
	self._changeListeners[uniqueIdentifier] = callback

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[uniqueIdentifier] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Observer(watchedState: PubTypes.Value<any>): Types.Observer
	local self = setmetatable({
		type = "State",
		kind = "Observer",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0,
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Observer]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX988A1BD7CC9C4ACE9818083462730379">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">Value</string>
														<string name="ScriptGuid">{5F9CAFE2-B98A-4983-97E5-6C4DD17400F1}</string>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local isSimilar = require(Package.Utility.isSimilar)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	local oldValue = self._value
	if force or not isSimilar(oldValue, newValue) then
		self._value = newValue
		updateAll(self)
	end
end

local function Value<T>(initialValue: T): Types.State<T>
	local self = setmetatable({
		type = "State",
		kind = "Value",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return Value]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX12827785375D4361BE4A92F000E8E5C0">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">unwrap</string>
														<string name="ScriptGuid">{55D39244-51BE-4FCE-AB65-D072BE0D47F7}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A common interface for accessing the values of state objects or constants.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local xtypeof = require(Package.Utility.xtypeof)

local function unwrap<T>(item: PubTypes.CanBeState<T>, useDependency: boolean?): T
	return if xtypeof(item) == "State" then (item :: PubTypes.StateObject<T>):get(useDependency) else (item :: T)
end

return unwrap]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBXC3D9EE16D0D249838F7572C99FFF4553">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Utility</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX648207650B21415C8DED2237DADCF131">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">None</string>
														<string name="ScriptGuid">{31E1B828-3FAE-4FE3-94C9-E496AE04666F}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

return {
	type = "Symbol",
	name = "None"
} :: Types.None]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXCC4DCD5C50EC49689ACB939ED7460833">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">cleanup</string>
														<string name="ScriptGuid">{BA50F78A-3F71-4E93-BBBD-1F60DF60B098}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Cleans up the tasks passed in as the arguments.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

local function cleanupOne(task: any)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanupOne(subtask)
			end
		end
	end
end

local function cleanup(...: any)
	for index = 1, select("#", ...) do
		cleanupOne(select(index, ...))
	end
end

return cleanup]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX8AC1B4481EA14DB79544C89C29E83E1D">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">doNothing</string>
														<string name="ScriptGuid">{1062ADD4-7EAF-4CBD-A7FD-31A180479932}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	An empty function. Often used as a destructor to indicate no destruction.
]]

local function doNothing(...: any)
end

return doNothing]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXD00F5EB8ABE0412B95049C2F81063D2D">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">isSimilar</string>
														<string name="ScriptGuid">{2929A341-90D4-4D94-8982-FB0884C05AE5}</string>
														<ProtectedString name="Source"><![CDATA[--!strict
--[[
    Returns true if A and B are 'similar' - i.e. any user of A would not need
    to recompute if it changed to B.
]]

local function isSimilar(a: any, b: any): boolean
    -- HACK: because tables are mutable data structures, don't make assumptions
    -- about similarity from equality for now (see issue #44)
    if typeof(a) == "table" then
        return false
    else
        return a == b
    end
end

return isSimilar]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX5731626513834038BC12240C23E77A5B">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">needsDestruction</string>
														<string name="ScriptGuid">{19DDB5A2-71EF-4E87-8936-6853B625A848}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
    Returns true if the given value is not automatically memory managed, and
    requires manual cleanup.
]]

local function needsDestruction(x: any): boolean
    return typeof(x) == "Instance"
end

return needsDestruction]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX8BD558E021264C3D97130BD987350AE7">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">restrictRead</string>
														<string name="ScriptGuid">{CBFE330F-959A-426E-98B6-60435C5F8846}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

type table = {[any]: any}

local function restrictRead(tableName: string, strictTable: table): table
	-- FIXME: Typed Luau doesn't recognise this correctly yet
	local metatable = getmetatable(strictTable :: any)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX3C1CDCE8217345A294F343EB578D8858">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<Content name="LinkedSource"><null></null></Content>
														<string name="Name">xtypeof</string>
														<string name="ScriptGuid">{D0832200-805A-47BD-AEB6-900E12E03A6A}</string>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Extended typeof, designed for identifying custom objects.
	If given a table with a `type` string, returns that.
	Otherwise, returns `typeof()` the argument.
]]

local function xtypeof(x: any)
	local typeString = typeof(x)

	if typeString == "table" and typeof(x.type) == "string" then
		return x.type
	else
		return typeString
	end
end

return xtypeof]]></ProtectedString>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX4C7F1416C4C444D684ABE8337396CB9D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{3B206766-A0DF-4A98-ACE4-B000FA5708FC}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "NeoHotbar",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 15617827028,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: ImAvafe (Avafe)"},
		{Text = "Description: NeoHotBar is an advanced roblox inventory library, this library is very usefull when it comes to making a custom inventory system, providing a complex and advanced range of features."},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Advanced scripting knowledge"}
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX5B630AF662EB4F15B4088C3B08C95985">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">MuchachoHitbox</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX9659016FBDC54664934B98A96EC67D45">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MuchachoHitbox</string>
							<string name="ScriptGuid">{80D99C78-EC60-4076-B3ED-5837177C6609}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

--[[


   _____            __    _ __  ___           __           
  / ___/__  _______/ /_  (_)  |/  /___ ______/ /____  _____
  \__ \/ / / / ___/ __ \/ / /|_/ / __ `/ ___/ __/ _ \/ ___/
 ___/ / /_/ (__  ) / / / / /  / / /_/ (__  ) /_/  __/ /    
/____/\__,_/____/_/ /_/_/_/  /_/\__,_/____/\__/\___/_/     
                                                           




____________________________________________________________________________________________________________________________________________________________________________
				
	[ UPDATE LOG v1.1 :]
1. New property!!
	Hitbox.Key = "insert anything you want here"
		--- This property will be used for the new function | module:FindHitbox(key)
		
2. New function!!
	Module:FindHitbox(Key)
		--- Returns a hitbox using specified Key, nil otherwise
		
3. New detection mode! | "ConstantDetection"
	Hitbox.DetectionMode = "ConstantDetection"
		--- The same as the default detection mode but no hit pool / debounce
		--- You're free to customize the debounce anyway you want
		
4, Made the scripts cleaner
____________________________________________________________________________________________________________________________________________________________________________
	
	[ UPDATE LOG v1.2 :]
1. Made the code better

____________________________________________________________________________________________________________________________________________________________________________
	
	[ UPDATE LOG v1.3 :]
1. New property
	HitboxObject.AutoDestroy = true (Default)
		---  With the value being false you can keep using Stop() 
		and Start() without the hitbox being destroyed.

2. New metamethod
	HitboxObject:Destroy()
		---  This destroys the hitbox. You only need to use this
			 When having AutoDestroy's value set to false.
			 
3. Minor bug fixes
			 
____________________________________________________________________________________________________________________________________________________________________________

	[ UPDATE LOG v1.4  Experimental:]
1. New event
	HitboxObject.TouchEnded:Connect(instance)
				Description
					--- The event fires once a part stops touching the hitbox
				Arguments
					--- Instance part: Returns the part that the hitbox stopped touching
					
____________________________________________________________________________________________________________________________________________________________________________

		 UPDATE LOG v1.5  Stable:]
1. Reverted touch ended, will add back after the bug is fixed

____________________________________________________________________________________________________________________________________________________________________________

		 UPDATE LOG v1.6  Stable:]
1. Touch ended is back! It has been fixed
2. HitboxObject.Key is now generated automatically
3. Minor changes

____________________________________________________________________________________________________________________________________________________________________________

		 UPDATE LOG v2.0 Experimental:]
1. Added VelocityPrediction and VelocityPredictionTime property
2. You can now set the color and transparency of a hitbox
2. Minor fixes
3. Code now uses type checking
____________________________________________________________________________________________________________________________________________________________________________

	Example code:
		local module = require(game.ServerStorage.MuchachoHitbox)

		local hitbox = module.CreateHitbox()
		hitbox.Size = Vector3.new(10,10,10)
		hitbox.CFrame = workspace.Part
		
		-- IF YOU WANT TO ADD VELOCITY PREDICTION
		hitbox.VelocityPrediction = true
		hitbox.VelocityPredictionTime = .2

		hitbox.Touched:Connect(function(hit, hum)
			print(hit)
			hum:TakeDamage(10)
		end)
		
		hitbox:Start()
	
	
	Alright thats all for the example code, its a pretty simple module, you could make a module similar to this yourself.
	And maybe even make it better.
	
	If you encounter any bugs, please tell me in the comment section, or you could DM me on discord
	sushimaster#7840
	
	 SushiMaster
____________________________________________________________________________________________________________________________________________________________________________
	
	
	[MuchachoHitbox Documentation]

		* local Module = require(MuchachoHitbox)
				--- Require the module


			[ FUNCTIONS ]

		* Module.CreateHitbox()
				Description
					--- Creates a hitbox
					
		* Module:FindHitbox(Key)
				Description
					--- Returns a hitbox with specified Key

		* HitboxObject:Start()
				Description
					--- Starts the hitbox. 
					
		* HitboxObject:Stop()
				Description
					--- Stops the hitbox and resets the debounce.
					
		* HitboxObject:Destroy()
				Description
					--- Destroys the hitbox. Use this when you have
						HitboxObject.AutoDestroy set to false
					
			[ EVENTS ]

		* HitboxObject.Touched:Connect(hit, humanoid)
				Description
					--- If the hitbox touches a humanoid, it'll return information on them
					--- The hitbox can detect parts depending on the detection mode
				Arguments
					--- Instance part: Returns the part that the hitbox hit first
					--- Instance humanoid: Returns the Humanoid object 
					
		* HitboxObject.TouchEnded:Connect(instance)
				Description
					--- The event fires once a part stops touching the hitbox
				Arguments
					--- Instance part: Returns the part that the hitbox stopped touching
					
			[ PROPERTIES ]

		* HitboxObject.OverlapParams: OverlapParams
				Description
					--- Takes in a OverlapParams object

		* HitboxObject.Visualizer: boolean
				Description
					--- Turns on or off the visualizer part

		* HitboxObject.CFrame: CFrame / Instance
				Description
					--- Sets the hitbox CFrame to the CFrame
					--- If its an instance, then the hitbox would follow the instance
					
		* HitboxObject.Shape: Enum.PartType.Block / Enum.PartType.Ball
				Description
					--- Defaults to block
					--- Sets the hitbox shape to the property
					
		* HitboxObject.Size: Vector3 / number 
				Description
					--- Sets the size of the hitbox
					--- It uses Vector3 if the shape is block
					--- It uses number if the shape is ball
					
		* HitboxObject.Offset: CFrame
				Description
					--- Hitbox offset

		* HitboxObject.DetectionMode: string | "Default" , "HitOnce" , "HitParts" , "ConstantDetection"
				Description
					--- Default value set to "Default"
					--- Changes on how the detection works
					
		* HitboxObject.Key: String
				Description
					--- The key property for the find hitbox function
					--- MuchachoHitbox automatically generates a randomized key for you but you can change it. The module will save the hitbox, and can be found using | Module:FindHitbox(Key)
					
		* HitboxObject.AutoDestroy: boolean
				Description
					--- Default value is set to true
					--- When set to true, :Stop() atomatically destroys the hitbox.
					--- Does not destroy the hitbox when set to false. You'll 
						have to use :Destroy() to delete the hitbox.
						
		* HitboxObject.VelocityPrediction: boolean
				Description
					--- Default value is set to false
					--- When set to true, hitbox automatically predicts the velocity of the CFrame property if it is an instance. By "VelocityPredictionTime" amount of time
					
		* HitboxObject.VelocityPredictionTime: number
				Description
					--- Default value is set to 0.1
					--- When "VelocityPrediction" is set to true, this property determines how far in the future the hitbox will check for parts.

		* HitboxObject.VisualizerColor: Color3
				Description
					--- Sets the color of the visualizer part
					
		* HitboxObject.VisualizerTransparency: number
				Description
					--- Sets the transparency of the visualizer part

			[ DETECTION MODES ]

		* Default
				Description
					--- Checks if a humanoid exists when this hitbox touches a part. The hitbox will not return humanoids it has already hit for the duration
					--- the hitbox has been active.

		* HitParts
				Description
					--- OnHit will return every hit part, regardless if it's ascendant has a humanoid or not.
					--- OnHit will no longer return a humanoid so you will have to check it. The hitbox will not return parts it has already hit for the
					--- duration the hitbox has been active.

		* HitOnce
				Description
					--- Hitbox will stop as soon as it detects a humanoid
					
		* ConstantDetection
				Description
					--- The default detection mode but no hitlist / debounce
					
____________________________________________________________________________________________________________________________________________________________________________

]]
local rs = game:GetService("RunService")
local hs = game:GetService("HttpService")

local GoodSignal = require(script.GoodSignal)
local DictDiff = require(script.DictDiff)
local Types = require(script.Types)

local muchacho_hitbox = {}
muchacho_hitbox.__index = muchacho_hitbox

local adornment_form = {
	["Proportion"] = {
		[Enum.PartType.Ball] = "Radius",
		[Enum.PartType.Block] = "Size",
	},

	["Shape"] = {
		[Enum.PartType.Ball] = "SphereHandleAdornment",
		[Enum.PartType.Block] = "BoxHandleAdornment",
	},
}

local get_CFrame = {
	["Instance"] = function(point)
		return point.CFrame
	end,

	["CFrame"] = function(point)
		return point
	end,
}


local hitboxes = {}

-- public functions
function muchacho_hitbox.CreateHitbox()
	local self = setmetatable({}, muchacho_hitbox) :: Types.Hitbox
	self.DetectionMode = "Default"
	self.AutoDestroy = true
	
	self.Visualizer = true
	self.VisualizerColor = Color3.fromRGB(255,0,0)
	self.VisualizerTransparency = .8

	self.VelocityPrediction = false
	self.VelocityPredictionTime = 0.1
	
	self.OverlapParams = OverlapParams.new()
	
	self.Size = Vector3.new(0,0,0)
	self.Shape = Enum.PartType.Block
	self.CFrame = CFrame.new(0,0,0)
	self.Offset = CFrame.new(0,0,0)
	
	self.Key = hs:GenerateGUID(false)

	self.HitList = {}
	self.TouchingParts = {}
	
	self.Touched = GoodSignal.new()
	self.TouchEnded = GoodSignal.new()

	return self
end

function muchacho_hitbox:FindHitbox(key) -- deprecated
	if hitboxes[key] then
		return hitboxes[key]
	else
		return nil
	end
end

-- public methods
function muchacho_hitbox.Start(self: Types.Hitbox)
	if hitboxes[self.Key] then
		error("A hitbox with this Key has already been started. Change the key if you want to start this hitbox.")
	end

	hitboxes[self.Key] = self

	-- looping the hitbox
	task.spawn(function()	
		self._Connection = rs.Heartbeat:Connect(function()
			self:_visualize()
			self:_cast()
		end)
	end)
end

function muchacho_hitbox.Stop(self: Types.Hitbox)
	local hitbox = muchacho_hitbox:FindHitbox(self.Key)

	if not hitbox then
		error("Hitbox has already been stopped")
	end

	-- clear hitbox
	self:_clear()

	if not self.AutoDestroy then return end

	-- terminate hitbox
	self.Touched:DisconnectAll()
	self.TouchEnded:DisconnectAll()
	--setmetatable(self, nil)
end

function muchacho_hitbox:Destroy()
	local hitbox: Types.Hitbox = muchacho_hitbox:FindHitbox(self.Key)

	if not hitbox then
		error("Hitbox has already been destroyed")
	end

	-- clear hitbox
	self:_clear()

	-- terminate hitbox
	self.Touched:DisconnectAll()
	self.TouchEnded:DisconnectAll()
	--setmetatable(self, nil)
end


-- private methods
function muchacho_hitbox._CastSpatialQuery(self: Types.Hitbox) : {BasePart}?
	local point_type: CFrame | string = typeof(self.CFrame)
	local point_cframe: CFrame = self:_PredictVelocity() or get_CFrame[point_type](self.CFrame)

	local parts
	local hitboxCFrame: CFrame = point_cframe * self.Offset
	
	if self.Shape == Enum.PartType.Block then
		parts = workspace:GetPartBoundsInBox(hitboxCFrame, self.Size, self.OverlapParams)
	elseif self.Shape == Enum.PartType.Ball then
		parts = workspace:GetPartBoundsInRadius(hitboxCFrame.Position, self.Size, self.OverlapParams)
	else
		error("Part type: " .. self.Shape .. " isn't compatible with muchachoHitbox")
	end

	return parts
end

function muchacho_hitbox._cast(self: Types.Hitbox, part: BasePart)
	local mode = self.DetectionMode
	local parts = self:_CastSpatialQuery()

	self:_FindTouchEnded(parts)

	for _, hit in pairs(parts) do
		local character: Model = hit:FindFirstAncestorOfClass("Model") or hit.Parent
		local humanoid: Humanoid? = character:FindFirstChildOfClass("Humanoid")

		-- detection mode
		if mode == "Default" then
			if humanoid and not table.find(self.HitList, humanoid) then
				table.insert(self.HitList, humanoid)
				
				self:_InsertTouchingParts(hit)

				self.Touched:Fire(hit, humanoid)
			end

		elseif mode == "ConstantDetection" then

			if humanoid then
				self:_InsertTouchingParts(hit)

				self.Touched:Fire(hit, humanoid)
			end

		elseif mode == "HitOnce" then

			if humanoid then
				self:_InsertTouchingParts(hit)

				self.Touched:Fire(hit, humanoid)
				self.TouchEnded:Fire(hit)

				self:Destroy()
				break
			end

		elseif mode == "HitParts" then
			self:_InsertTouchingParts(hit)

			self.Touched:Fire(hit, nil)

		end
	end
end

function muchacho_hitbox._visualize(self: Types.Hitbox)
	if not self.Visualizer then return end

	local predictedCFrame = self:_PredictVelocity()
	
	local point_type: string = typeof(self.CFrame)
	local point_cframe: CFrame = predictedCFrame or get_CFrame[point_type](self.CFrame)

	local proportion = adornment_form.Proportion[self.Shape]

	if not self._Box then
		local newBox = Instance.new(adornment_form.Shape[self.Shape])
		newBox.Name = "Visualizer"
		newBox.Adornee = workspace.Terrain
		newBox[proportion] = self.Size
		newBox.CFrame = point_cframe * self.Offset
		newBox.Color3 = self.VisualizerColor
		newBox.Transparency = self.VisualizerTransparency
		newBox.Parent = workspace.Terrain
		self._Box = newBox
	else
		self._Box.CFrame = point_cframe * self.Offset
	end
end

function muchacho_hitbox._PredictVelocity(self: Types.Hitbox): CFrame | nil
	if self.VelocityPrediction then
		local PredictionTime: number = self.VelocityPredictionTime
		local part: BasePart = self.CFrame
		local constant: number = 1/PredictionTime

		if PredictionTime > 0 and typeof(part) == "Instance" then
			--local velocityVector =  part.CFrame:VectorToObjectSpace(part.AssemblyLinearVelocity) / constant
			--local predictedCFrame = part.CFrame * CFrame.new(velocityVector)
			local Velocity = part.AssemblyLinearVelocity --// Normally this would be their ping
			local PredictedPosition = part.Position + Velocity * PredictionTime
			local PredictedCFrame = CFrame.new(PredictedPosition) * (part.CFrame - part.Position)

			
			return PredictedCFrame
		end
	end
	
	return nil
end

function muchacho_hitbox:_clear()
	self.HitList = {}

	if self._Connection then
		self._Connection:Disconnect()
	end

	if self.Key then
		hitboxes[self.Key] = nil
	end

	if self._Box then
		self._Box:Destroy()
		self.Box = nil
	end
end

function muchacho_hitbox._InsertTouchingParts(self: Types.Hitbox, part)
	if table.find(self.TouchingParts, part) then return end

	table.insert(self.TouchingParts, part)
end

function muchacho_hitbox._FindTouchEnded(self: Types.Hitbox, parts: {BasePart}?)
	if #self.TouchingParts == 0 then return end

	local mode = self.DetectionMode
	local differences = DictDiff.difference(self.TouchingParts, parts)

	if differences then
		for _, diff in ipairs(differences) do
			self.TouchEnded:Fire(diff)
			table.remove(self.TouchingParts, table.find(self.TouchingParts, diff))
		end
	end
end



return muchacho_hitbox
]]></ProtectedString>
							<int64 name="SourceAssetId">9645263113</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXF504EABEB97E4567BA6006996793EEDF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">DictDiff</string>
								<string name="ScriptGuid">{F65C6871-C63B-42B7-BF98-3AF7F7701382}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

local function find(a, tbl)
	for _, a_ in ipairs(tbl) do 
		if a_==a then return true end 
	end
end

function module.difference(a, b)
	local ret = {}
	for _, v in ipairs(a) do
		if not find(v,b) then table.insert(ret, v) end
	end
	
	return ret
end


return module

]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2C0A7879A06D431DBBE61AE83E7C3F1C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">GoodSignal</string>
								<string name="ScriptGuid">{13FF9849-B2C3-453A-83C5-837F694D882D}</string>
								<ProtectedString name="Source"><![CDATA[-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	A Signal is a data structure that allows events to be dispatched
	and observed.

	This implementation is a direct copy of the de facto standard, [GoodSignal](https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063),
	with some added methods and typings.

	For example:
	```lua
	local signal = Signal.new()

	-- Subscribe to a signal:
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	-- Dispatch an event:
	signal:Fire("Hello world!")
	```
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
		_yieldedThreads = nil,
	}, Signal)

	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)

	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)

	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	```
]=]
function Signal:Connect(fn)
	local connection = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_next = false,
	}, Connection)

	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	return connection
end

--[=[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]=]
function Signal:Once(fn)
	local connection
	local done = false

	connection = self:Connect(function(...)
		if done then
			return
		end

		done = true
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

function Signal:GetConnections()
	local items = {}

	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end

	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	local yieldedThreads = rawget(self, "_yieldedThreads")
	if yieldedThreads then
		for thread in yieldedThreads do
			if coroutine.status(thread) == "suspended" then
				warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
				task.cancel(thread)
			end
		end
		table.clear(self._yieldedThreads)
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		local conn = item
		task.defer(function(...)
			if conn.Connected then
				conn._fn(...)
			end
		end, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]=]
function Signal:Wait()
	local yieldedThreads = rawget(self, "_yieldedThreads")
	if not yieldedThreads then
		yieldedThreads = {}
		rawset(self, "_yieldedThreads", yieldedThreads)
	end

	local thread = coroutine.running()
	yieldedThreads[thread] = true

	self:Once(function(...)
		yieldedThreads[thread] = nil
		task.spawn(thread, ...)
	end)

	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]=]
function Signal:Destroy()
	self:DisconnectAll()

	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return table.freeze({
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
})
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2697156C824A492F8027D25AA57A0CDE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{DFDAE8F6-ED8D-4411-AB31-571DE3902542}</string>
								<ProtectedString name="Source"><![CDATA[local Goodsignal = require(script.Parent.GoodSignal)

local types = {}

export type HitboxProperties = {
	Visualizer: boolean,
	DetectionMode: ("Default" | "ConstantDetection" | "HitOnce" | "HitParts"),
	AutoDestroy: boolean,	
	Key: string,

	OverlapParams: OverlapParams,

	Size: Vector3,
	Shape: Enum.PartType,
	CFrame: CFrame,
	Offset: CFrame,

	VelocityPredictionTime: number?,
	VelocityPrediction: boolean?,
	
	Touched: Goodsignal.Signal<BasePart, Humanoid?>,
	TouchEnded: Goodsignal.Signal<BasePart, Humanoid?>,
} & any

export type Hitbox = {
	-- properties
	Visualizer: boolean,
	VisualizerColor: Color3?,
	VisualizerTransparency: number,
	
	DetectionMode: ("Default" | "ConstantDetection" | "HitOnce" | "HitParts"),
	AutoDestroy: boolean,	
	Key: string,

	OverlapParams: OverlapParams,

	Size: Vector3,
	Shape: Enum.PartType,
	CFrame: CFrame,
	Offset: CFrame,
	
	VelocityPredictionTime: number?,
	VelocityPrediction: boolean?,
	
	-- events
	Touched: Goodsignal.Signal<BasePart, Humanoid?>,
	TouchEnded: Goodsignal.Signal<BasePart, Humanoid?>,
	
	-- methods
	Start: (self: Hitbox) -> (),
	Stop: (self: Hitbox) -> (),
	Destroy: (self: Hitbox) -> (boolean),

	-- dev
	HitList: {Model}?,
	TouchingParts: {BasePart}?,
	Connection: RBXScriptConnection?,
	Box: BoxHandleAdornment? | SphereHandleAdornment?,
} & any

return types]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX404AAB8BB36F4F289752A1B1DCCDC772">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{C153A9F2-E273-472C-9017-FF9BBD68EF19}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "MuchachoHitbox",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Sushimaster"},
		{Text = "Description: A powerful hitbox library, usefull for any game, easy to use and understand."},
		{Text = "Version: 2.0 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX47339BF2EA2C4471828A718C2D532A73">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CustomPack</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX8A1B5BE0D4F04FB89CA11559D9BF9D28">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{6B68AD52-8EDE-4531-B4A2-324C3ECAA631}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "CustomPack",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 91433402964621,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Berge99075"},
		{Text = "Description: A Powerful backpack library."},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Above-basic scripting knowledge"}
	}
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Model" referent="RBXBDFA94051C1748AA830E4CC05267EB2F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<token name="LevelOfDetail">0</token>
							<CoordinateFrame name="ModelMeshCFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<Vector3 name="ModelMeshSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="ModelStreamingMode">0</token>
							<string name="Name">CustomPack</string>
							<bool name="NeedsPivotMigration">false</bool>
							<Ref name="PrimaryPart">null</Ref>
							<float name="ScaleFactor">1</float>
							<SharedString name="SlimHash">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<int64 name="SourceAssetId">91433402964621</int64>
							<BinaryString name="Tags"></BinaryString>
							<OptionalCoordinateFrame name="WorldPivotData">
								<CFrame>
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CFrame>
							</OptionalCoordinateFrame>
						</Properties>
						<Item class="LocalScript" referent="RBX70072C83C58C48E8A9608A013D1E89F6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Loader</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{0C4A8E1E-69DE-4CC8-9F19-BE76FA4B1A1C}</string>
								<ProtectedString name="Source"><![CDATA[--[[
                                                                                                                                     
                                                                                                                                  
                                                                                                                                  
                                                                                                                                  
              ################                                                                                                    
             ###             ##                                                                                                   
             ###             ##                                                                                                   
             ##################                                                                                                   
     ##################################                                                                                           
    ###                             ####     ########## #####   #####  ######### #############  ##########   ######   ######   
    ####################################    ########### #####   ##### ##########  ###########  ############  ####### #######   
    ####################################   #####        #####   ##### ########       #####     ####    ####  ###############    
    ###                             ####   #####        #####   #####  ##########    #####     ####    ####  ###############    
    ####################################    #####       #####   #####       #####    #####     ####    ####  #### ##### ####    
    ####################################    ###########  ###########  ###########    #####     ############  ####  ###  ####   
    ####################################      #########   #########    #########     #####      #########    ####       ####      
    ####################################                                                                                          
    ####################################                                                                                          
    ####################################    #################################################################################     
    ####################################    #################################################################################     
    ####################################                                                                                          
    ####################################                     #######       ####         #####    ###     ####                     
    ####################################                    ###########   ######     ########### ####  ######                     
    ####################################                    ##### ###### #######    ######   ### ##########                       
    ####################################                    ##### ###############  #####         ########                         
    ###                             ####                    ########### #### ##### #####         ########                         
    ####################################                    #####      ###########  #####        #########                        
    ####################################                    #####     #############  ########### ####  #####                      
    ####                           #####                    #####     ####      ####   ########  ####    #####                    
    ####################################                                                                                          
    ####################################                                                                                          
     ##################################                                                                                           
                                                                                                                                  
                                                                                                                                                                                                              
	Settings is in the "Main" ModuleScript under the "Attributes" section.


--]]


-- Initialize the script
require(script.Main)]]></ProtectedString>
								<int64 name="SourceAssetId">91433402964621</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX5BF28DAC0D6F470C806386D07E2A4500">
								<Properties>
									<BinaryString name="AttributesSerialize"><![CDATA[EwAAAA8AAABCYWNrZ3JvdW5kQ29sb3IPgYAAPomICD6dnBw+FgAAAEJhY2tncm91bmRUcmFu
c3BhcmVuY3kGAAAAAAAA0D8LAAAAQm9yZGVyQ29sb3IPAACAPwAAgD8AAIA/DAAAAENvcm5l
clJhZGl1cwkAAAAACAAAAA4AAABEcmFnZ2FibGVDb2xvcg/y8PA98vDwPY2MDD4NAAAARXF1
aXBwZWRDb2xvcg9qvLQ+jZcOP+f7aT8JAAAARnVsbFNsb3RzBgAAAAAAACRACQAAAExhYmVs
Rm9udCGQAQAYAAAAcmJ4YXNzZXRpZDovLzE2NjU4MjIxNDI4AAAAAAkAAABNaW5pU2xvdHMG
AAAAAAAACEAOAAAAU2VhcmNoQm94Q29sb3IPkZCQPZGQkD2pqKg9FQAAAFNlYXJjaEJveFRy
YW5zcGFyZW5jeQYAAAAAAADgPxYAAABTZWFyY2hQbGFjZWhvbGRlckNvbG9yD7OyMj+zsjI/
s7IyPw8AAABTZWFyY2hUZXh0Q29sb3IPAACAPwAAgD8AAIA/GAAAAFNsb3RFcXVpcFN0cm9r
ZVRoaWNrbmVzcwYAAAAAAAAIQAgAAABTbG90Rm9udCFYAgAYAAAAcmJ4YXNzZXRpZDovLzE2
NjU4MjIxNDI4AAAAABYAAABTbG90TG9ja2VkVHJhbnNwYXJlbmN5BgAAAAAAANA/CQAAAFRl
eHRDb2xvcg8AAIA/AACAPwAAgD8IAAAAVGV4dFNpemUGAAAAAAAALEALAAAAVG9vbFRpcEZv
bnQhvAIAGAAAAHJieGFzc2V0aWQ6Ly8xNjY1ODIyMTQyOAAAAAA=]]></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Main</string>
									<string name="ScriptGuid">{0EDCFB95-6289-40CD-BD39-21B425A02366}</string>
									<ProtectedString name="Source"><![CDATA[--[[
                                                                                                                                     
                                                                                                                                  
                                                                                                                                  
                                                                                                                                  
              ################                                                                                                    
             ###             ##                                                                                                   
             ###             ##                                                                                                   
             ##################                                                                                                   
     ##################################                                                                                           
    ###                             ####     ########## #####   #####  ######### #############  ##########   ######   ######   
    ####################################    ########### #####   ##### ##########  ###########  ############  ####### #######   
    ####################################   #####        #####   ##### ########       #####     ####    ####  ###############    
    ###                             ####   #####        #####   #####  ##########    #####     ####    ####  ###############    
    ####################################    #####       #####   #####       #####    #####     ####    ####  #### ##### ####    
    ####################################    ###########  ###########  ###########    #####     ############  ####  ###  ####   
    ####################################      #########   #########    #########     #####      #########    ####       ####      
    ####################################                                                                                          
    ####################################                                                                                          
    ####################################    #################################################################################     
    ####################################    #################################################################################     
    ####################################                                                                                          
    ####################################                     #######       ####         #####    ###     ####                     
    ####################################                    ###########   ######     ########### ####  ######                     
    ####################################                    ##### ###### #######    ######   ### ##########                       
    ####################################                    ##### ###############  #####         ########                         
    ###                             ####                    ########### #### ##### #####         ########                         
    ####################################                    #####      ###########  #####        #########                        
    ####################################                    #####     #############  ########### ####  #####                      
    ####                           #####                    #####     ####      ####   ########  ####    #####                    
    ####################################                                                                                          
    ####################################                                                                                          
     ##################################                                                                                           
                                                                                                                                  
                                                                                                                                                                                                              
	CustomPack Main Module
	Experienced Scripters only beyond this point.


--]]


print("This game uses CustomPack v1.5.2\nCustomPack is made by Berge99075\nGrab a copy at https://devforum.roblox.com/t/custompack-customizable-backpacks-made-simple/3255258/")

local BackpackScript = {}
BackpackScript.Version = "1.5.2"
BackpackScript.OpenClose = nil -- Function to toggle open/close
BackpackScript.IsOpen = false
BackpackScript.StateChanged = Instance.new("BindableEvent") -- Fires after any open/close, passes IsNowOpen
BackpackScript.SelectedSlotChanged = Instance.new("BindableEvent") -- Fires after any slot is selected

BackpackScript.ModuleName = "Backpack"
BackpackScript.KeepVRTopbarOpen = true
BackpackScript.VRIsExclusive = true
BackpackScript.VRClosesNonExclusive = true

local ICON_SIZE = 60
local FONT_SIZE = script:GetAttribute("TextSize")
local ICON_BUFFER = 5

local BACKGROUND_FADE = script:GetAttribute("BackgroundTransparency")
local BACKGROUND_COLOR = script:GetAttribute("BackgroundColor")

local VR_FADE_TIME = 1
local VR_PANEL_RESOLUTION = 100

local SLOT_DRAGGABLE_COLOR = script:GetAttribute("DraggableColor")
local SLOT_EQUIP_COLOR = script:GetAttribute("EquippedColor")
local SLOT_EQUIP_THICKNESS = 3 -- Relative
local SLOT_FADE_LOCKED = script:GetAttribute("SlotLockedTransparency") -- Locked means undraggable
local SLOT_BORDER_COLOR = script:GetAttribute("BorderColor") -- Appears when dragging

local TOOLTIP_BUFFER = 24
local TOOLTIP_HEIGHT = 24
local TOOLTIP_OFFSET = -28 -- From top

local SLOT_EQUIP_SOUND = Instance.new("Sound")
local SLOT_UNEQUIP_SOUND = Instance.new("Sound")

local ARROW_IMAGE_OPEN = 'rbxasset://textures/ui/TopBar/inventoryOn.png'
local ARROW_IMAGE_CLOSE = 'rbxasset://textures/ui/TopBar/inventoryOff.png'
local ARROW_HOTKEY = {Enum.KeyCode.Backquote, Enum.KeyCode.DPadUp} --TODO: Hookup '~' too?

local HOTBAR_SLOTS_FULL = script:GetAttribute("FullSlots")
local HOTBAR_SLOTS_VR = script:GetAttribute("EmptySlots")
local HOTBAR_SLOTS_MINI = 3
local HOTBAR_SLOTS_WIDTH_CUTOFF = 1024 -- Anything smaller is MINI
local HOTBAR_OFFSET_FROMBOTTOM = -30 -- Offset to make room for the Health GUI

local INVENTORY_ROWS_FULL = 4
local INVENTORY_ROWS_VR = 3
local INVENTORY_ROWS_MINI = 2
local INVENTORY_HEADER_SIZE = 40
local INVENTORY_ARROWS_BUFFER_VR = 40

local SEARCH_BUFFER = 5
local SEARCH_WIDTH = 200
local SEARCH_TEXT = "Search"

local SEARCH_TEXT_OFFSET_FROMLEFT = 0
local SEARCH_BACKGROUND_COLOR = script:GetAttribute("SearchBoxColor")
local SEARCH_TEXT_COLOR = script:GetAttribute("SearchTextColor")
local SEARCH_BACKGROUND_FADE = script:GetAttribute("SearchBoxTransparency")

local DOUBLE_CLICK_TIME = 0.5


local activeSlot = nil

local GetScreenResolution = function ()
	local I = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
	local Frame = Instance.new("Frame", I)
	Frame.BackgroundTransparency = 1
	Frame.Size = UDim2.new(1,0,1,0)
	local AbsoluteSize = Frame.AbsoluteSize
	I:Destroy()
	return AbsoluteSize
end
local ZERO_KEY_VALUE = Enum.KeyCode.Zero.Value
local DROP_HOTKEY_VALUE = Enum.KeyCode.Backspace.Value
	local ICON_MODULE = script:WaitForChild("Icon")
local GAMEPAD_INPUT_TYPES =
	{
		[Enum.UserInputType.Gamepad1] = true;
		[Enum.UserInputType.Gamepad2] = true;
		[Enum.UserInputType.Gamepad3] = true;
		[Enum.UserInputType.Gamepad4] = true;
		[Enum.UserInputType.Gamepad5] = true;
		[Enum.UserInputType.Gamepad6] = true;
		[Enum.UserInputType.Gamepad7] = true;
		[Enum.UserInputType.Gamepad8] = true;
	}

local UserInputService = game:GetService('UserInputService')
local PlayersService = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local StarterGui = game:GetService('StarterGui')
local GuiService = game:GetService('GuiService')
local CoreGui = PlayersService.LocalPlayer.PlayerGui

local TopbarPlusReference = ReplicatedStorage:FindFirstChild("TopbarPlusReference")
local BackpackEnabled = true

if TopbarPlusReference then
	ICON_MODULE = TopbarPlusReference.Value
end

local RobloxGui = Instance.new("ScreenGui", CoreGui)
RobloxGui.DisplayOrder = 120
RobloxGui.IgnoreGuiInset = true
RobloxGui.ResetOnSpawn = false
RobloxGui.Name = "BackpackGui"

local ContextActionService = game:GetService("ContextActionService")
local RunService = game:GetService('RunService')
local VRService = game:GetService('VRService')
local Utility = require(script.Utility)
local GameTranslator = require(script.GameTranslator)
local Themes = require(ICON_MODULE.Themes)
local Icon = require(ICON_MODULE)

local FFlagBackpackScriptUseFormatByKey = true
local FFlagCoreScriptTranslateGameText2 = true
local FFlagRobloxGuiSiblingZindexs = true
local IsTenFootInterface = GuiService:IsTenFootInterface()

if IsTenFootInterface then
	ICON_SIZE = 100
	FONT_SIZE = 24
end

local GamepadActionsBound = false

local IS_PHONE = UserInputService.TouchEnabled and GetScreenResolution().X < HOTBAR_SLOTS_WIDTH_CUTOFF

local Player = PlayersService.LocalPlayer

local MainFrame = nil
local HotbarFrame = nil
local InventoryFrame = nil
local VRInventorySelector = nil
local ScrollingFrame = nil
local UIGridFrame = nil
local UIGridLayout = nil
local ScrollUpInventoryButton = nil
local ScrollDownInventoryButton = nil

local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")
local Backpack = Player:WaitForChild("Backpack")

local InventoryIcon = Icon.new()
InventoryIcon:setImage(ARROW_IMAGE_CLOSE, "deselected")
InventoryIcon:setImage(ARROW_IMAGE_OPEN, "selected")
InventoryIcon:bindToggleKey(ARROW_HOTKEY[1], ARROW_HOTKEY[2])
InventoryIcon:setName("InventoryIcon")
InventoryIcon:setImageScale(1.12)
InventoryIcon:setOrder(-5)
InventoryIcon:setCaption("Toggle the backpack.")
InventoryIcon.deselectWhenOtherIconSelected = false

local Slots = {} -- List of all Slots by index
local LowestEmptySlot = nil
local SlotsByTool = {} -- Map of Tools to their assigned Slots
local HotkeyFns = {} -- Map of KeyCode values to their assigned behaviors
local Dragging = {} -- Only used to check if anything is being dragged, to disable other input
local FullHotbarSlots = 0 -- Now being used to also determine whether or not LB and RB on the gamepad are enabled.
local StarterToolFound = false -- Special handling is required for the gear currently equipped on the site
local WholeThingEnabled = false
local TextBoxFocused = false -- ANY TextBox, not just the search box
local ViewingSearchResults = false -- If the results of a search are currently being viewed
local HotkeyStrings = {} -- Used for eating/releasing hotkeys
local CharConns = {} -- Holds character Connections to be cleared later
local GamepadEnabled = false -- determines if our gui needs to be gamepad friendly
local TimeOfLastToolChange = 0

local IsVR = VRService.VREnabled -- Are we currently using a VR device?
local NumberOfHotbarSlots = IsVR and HOTBAR_SLOTS_VR or (IS_PHONE and HOTBAR_SLOTS_MINI or HOTBAR_SLOTS_FULL) -- Number of slots shown at the bottom
local NumberOfInventoryRows = IsVR and INVENTORY_ROWS_VR or (IS_PHONE and INVENTORY_ROWS_MINI or INVENTORY_ROWS_FULL) -- How many rows in the popped-up inventory
local BackpackPanel = nil
local lastEquippedSlot = nil

local function EvaluateBackpackPanelVisibility(enabled)
	return enabled and InventoryIcon.enabled and BackpackEnabled and VRService.VREnabled
end

local function ShowVRBackpackPopup()
	if BackpackPanel and EvaluateBackpackPanelVisibility(true) then
		BackpackPanel:ForceShowForSeconds(2)
	end
end

local function NewGui(className, objectName)
	local newGui = Instance.new(className)
	newGui.Name = objectName
	newGui.BackgroundColor3 = Color3.new(0, 0, 0)
	newGui.BackgroundTransparency = 1
	newGui.BorderColor3 = Color3.new(0, 0, 0)
	newGui.BorderSizePixel = 0
	newGui.Size = UDim2.new(1, 0, 1, 0)
	if className:match('Text') then
		newGui.TextColor3 = Color3.new(1, 1, 1)
		newGui.Text = ''
		newGui.FontFace = script:GetAttribute("LabelFont")
		newGui.TextSize = FONT_SIZE
		newGui.TextWrapped = true
		if className == 'TextButton' then
			newGui.FontFace = script:GetAttribute("SlotFont")
		end
	end
	return newGui
end

local function FindLowestEmpty()
	for i = 1, NumberOfHotbarSlots do
		local slot = Slots[i]
		if not slot.Tool then
			return slot
		end
	end
	return nil
end

local function isInventoryEmpty()
	for i = NumberOfHotbarSlots + 1, #Slots do
		local slot = Slots[i]
		if slot and slot.Tool then
			return false
		end
	end
	return true
end

local function UseGazeSelection()
	return UserInputService.VREnabled
end

local function AdjustHotbarFrames()
	local inventoryOpen = InventoryFrame.Visible -- (Show all)
	local visualTotal = (inventoryOpen) and NumberOfHotbarSlots or FullHotbarSlots
	local visualIndex = 0
	local hotbarIsVisible = (visualTotal >= 1)

	for i = 1, NumberOfHotbarSlots do
		local slot = Slots[i]
		if slot.Tool or inventoryOpen then
			visualIndex = visualIndex + 1
			slot:Readjust(visualIndex, visualTotal)
			slot.Frame.Visible = true
		else
			slot.Frame.Visible = false
		end
	end
end

local function UpdateScrollingFrameCanvasSize()
	local countX = math.floor(ScrollingFrame.AbsoluteSize.X/(ICON_SIZE + ICON_BUFFER))
	local maxRow = math.ceil((#UIGridFrame:GetChildren() - 1)/countX)
	local canvasSizeY = maxRow*(ICON_SIZE + ICON_BUFFER) + ICON_BUFFER
	ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, canvasSizeY)
end

local function AdjustInventoryFrames()
	for i = NumberOfHotbarSlots + 1, #Slots do
		local slot = Slots[i]
		slot.Frame.LayoutOrder = slot.Index
		slot.Frame.Visible = (slot.Tool ~= nil)
	end
	UpdateScrollingFrameCanvasSize()
end

local function UpdateBackpackLayout()
	HotbarFrame.Size = UDim2.new(0, ICON_BUFFER + (NumberOfHotbarSlots * (ICON_SIZE + ICON_BUFFER)), 0, ICON_BUFFER + ICON_SIZE + ICON_BUFFER)
	HotbarFrame.Position = UDim2.new(0.5, -HotbarFrame.Size.X.Offset / 2, 1, -HotbarFrame.Size.Y.Offset)
	InventoryFrame.Size = UDim2.new(0, HotbarFrame.Size.X.Offset, 0, (HotbarFrame.Size.Y.Offset * NumberOfInventoryRows) + INVENTORY_HEADER_SIZE + (IsVR and 2*INVENTORY_ARROWS_BUFFER_VR or 0))
	InventoryFrame.Position = UDim2.new(0.5, -InventoryFrame.Size.X.Offset / 2, 1, HotbarFrame.Position.Y.Offset - InventoryFrame.Size.Y.Offset)

	ScrollingFrame.Size = UDim2.new(1, ScrollingFrame.ScrollBarThickness + 1, 1, -INVENTORY_HEADER_SIZE - (IsVR and 2*INVENTORY_ARROWS_BUFFER_VR or 0))
	ScrollingFrame.Position = UDim2.new(0, 0, 0, INVENTORY_HEADER_SIZE + (IsVR and INVENTORY_ARROWS_BUFFER_VR or 0))
	AdjustHotbarFrames()
	AdjustInventoryFrames()
end

local function Clamp(low, high, num)
	return math.min(high, math.max(low, num))
end

local function CheckBounds(guiObject, x, y)
	local pos = guiObject.AbsolutePosition
	local size = guiObject.AbsoluteSize
	return (x > pos.X and x <= pos.X + size.X and y > pos.Y and y <= pos.Y + size.Y)
end

local function GetOffset(guiObject, point)
	local centerPoint = guiObject.AbsolutePosition + (guiObject.AbsoluteSize / 2)
	return (centerPoint - point).magnitude
end

local function UnequipAllTools() --NOTE: HopperBin
	if Humanoid then
		Humanoid:UnequipTools()
	end
end


local function EquipNewTool(tool) --NOTE: HopperBin
	UnequipAllTools()
	--Humanoid:EquipTool(tool) --NOTE: This would also unequip current Tool
	tool.Parent = Character --TODO: Switch back to above line after EquipTool is fixed!
end

local function IsEquipped(tool)
	return tool and tool.Parent == Character --NOTE: HopperBin
end

local function MakeSlot(parent, index)
	index = index or (#Slots + 1)

	-- Slot Definition --

	local slot = {}
	slot.Tool = nil
	slot.Index = index
	slot.Frame = nil

	local LocalizedName = nil --remove with FFlagCoreScriptTranslateGameText2
	local LocalizedToolTip = nil --remove with FFlagCoreScriptTranslateGameText2

	local SlotFrameParent = nil
	local SlotFrame = nil
	local FakeSlotFrame = nil
	local ToolIcon = nil
	local ToolName = nil
	local ToolChangeConn = nil
	local HighlightFrame = nil
	local SelectionObj = nil

	--NOTE: The following are only defined for Hotbar Slots
	local ToolTip = nil
	local SlotNumber = nil

	-- Slot Functions --

	local function UpdateSlotFading()
		if VRService.VREnabled and BackpackPanel then
			local panelTransparency = BackpackPanel.transparency
			local slotTransparency = SLOT_FADE_LOCKED

			-- This equation multiplies the two transparencies together.
			local finalTransparency = panelTransparency + slotTransparency - panelTransparency * slotTransparency

			SlotFrame.BackgroundTransparency = finalTransparency
			SlotFrame.TextTransparency = finalTransparency
			if ToolIcon then
				ToolIcon.ImageTransparency = InventoryFrame.Visible and 0 or panelTransparency
			end
			if HighlightFrame then
				for _, child in pairs(HighlightFrame:GetChildren()) do
					child.BackgroundTransparency = finalTransparency
				end
			end

			SlotFrame.SelectionImageObject = SelectionObj
		else
			SlotFrame.SelectionImageObject = nil
			SlotFrame.BackgroundTransparency = (SlotFrame.Draggable) and 0 or SLOT_FADE_LOCKED
		end
		SlotFrame.BackgroundColor3 = (SlotFrame.Draggable) and SLOT_DRAGGABLE_COLOR or BACKGROUND_COLOR
	end

	function slot:Readjust(visualIndex, visualTotal) --NOTE: Only used for Hotbar slots
		local centered = HotbarFrame.Size.X.Offset / 2
		local sizePlus = ICON_BUFFER + ICON_SIZE
		local midpointish = (visualTotal / 2) + 0.5
		local factor = visualIndex - midpointish
		SlotFrame.Position = UDim2.new(0, centered - (ICON_SIZE / 2) + (sizePlus * factor), 0, ICON_BUFFER)
	end

	function slot:Fill(tool)
		if not tool then
			return self:Clear()
		end

		self.Tool = tool

		local function assignToolData()
			if FFlagCoreScriptTranslateGameText2 then
				local icon = tool.TextureId
				ToolIcon.Image = icon

				if icon ~= "" then
					ToolName.Visible = false
				end

				ToolName.Text = tool.Name


				if ToolTip and tool:IsA('Tool') then --NOTE: HopperBin
					ToolTip.Text = tool.ToolTip
					local width = ToolTip.TextBounds.X + TOOLTIP_BUFFER
					ToolTip.Size = UDim2.new(0, width, 0, TOOLTIP_HEIGHT)
					ToolTip.Position = UDim2.new(0.5, -width / 2, 0, TOOLTIP_OFFSET)
				end
			else
				LocalizedName = tool.Name
				LocalizedToolTip = nil

				local icon = tool.TextureId
				ToolIcon.Image = icon
				if icon ~= '' then
					ToolName.Text = LocalizedName
				else
					ToolName.Text = ""
				end -- (Only show name if no icon)
				if ToolTip and tool:IsA('Tool') then --NOTE: HopperBin
					LocalizedToolTip = GameTranslator:TranslateGameText(tool, tool.ToolTip)
					ToolTip.Text = tool.ToolTip
					local width = ToolTip.TextBounds.X + TOOLTIP_BUFFER
					ToolTip.Size = UDim2.new(0, width, 0, TOOLTIP_HEIGHT)
					ToolTip.Position = UDim2.new(0.5, -width / 2, 0, TOOLTIP_OFFSET)
				end
			end
		end
		assignToolData()

		if ToolChangeConn then
			ToolChangeConn:disconnect()
			ToolChangeConn = nil
		end

		ToolChangeConn = tool.Changed:connect(function(property)
			if property == 'TextureId' or property == 'Name' or property == 'ToolTip' then
				assignToolData()
			end
		end)

		local hotbarSlot = (self.Index <= NumberOfHotbarSlots)
		local inventoryOpen = InventoryFrame.Visible

		if (not hotbarSlot or inventoryOpen) and not UserInputService.VREnabled then
			SlotFrame.Draggable = true
		end

		self:UpdateEquipView()

		if hotbarSlot then
			FullHotbarSlots = FullHotbarSlots + 1
			-- If using a controller, determine whether or not we can enable BindCoreAction("RBXHotbarEquip", etc)
			if WholeThingEnabled then
				if FullHotbarSlots >= 1 and not GamepadActionsBound then
					-- Player added first item to a hotbar slot, enable BindCoreAction
					GamepadActionsBound = true
					ContextActionService:BindAction("RBXHotbarEquip", changeToolFunc, false, Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonR1)
				end
			end
		end

		SlotsByTool[tool] = self
		LowestEmptySlot = FindLowestEmpty()
	end

	function slot:Clear()
		if not self.Tool then return end

		if ToolChangeConn then
			ToolChangeConn:disconnect()
			ToolChangeConn = nil
		end

		ToolIcon.Image = ''
		ToolName.Text = ''
		if ToolTip then
			ToolTip.Text = ''
			ToolTip.Visible = false
		end
		SlotFrame.Draggable = false

		self:UpdateEquipView(true) -- Show as unequipped

		if self.Index <= NumberOfHotbarSlots then
			FullHotbarSlots = FullHotbarSlots - 1
			if FullHotbarSlots < 1 then
				-- Player removed last item from hotbar; UnbindCoreAction("RBXHotbarEquip"), allowing the developer to use LB and RB.
				GamepadActionsBound = false
				ContextActionService:UnbindAction("RBXHotbarEquip")
			end
		end

		SlotsByTool[self.Tool] = nil
		self.Tool = nil
		LowestEmptySlot = FindLowestEmpty()
	end

	function slot:UpdateEquipView(unequippedOverride)
		if not unequippedOverride and IsEquipped(self.Tool) then -- Equipped
			lastEquippedSlot = slot
			if not HighlightFrame then
				HighlightFrame = NewGui('Frame', 'Equipped')
				HighlightFrame.ZIndex = SlotFrame.ZIndex
				local edgecorner = Instance.new("UICorner")
				edgecorner.CornerRadius = script:GetAttribute("CornerRadius")
				edgecorner.Parent = HighlightFrame
				local t = SLOT_EQUIP_THICKNESS

				local edgeFrame = Instance.new("UIStroke")
				edgeFrame.Color = SLOT_EQUIP_COLOR
				
				edgeFrame.Thickness = t
				edgeFrame.Parent = HighlightFrame
			end
			HighlightFrame.Parent = SlotFrame
		else -- In the Backpack
			if HighlightFrame then
				HighlightFrame.Parent = nil
			end
		end
		UpdateSlotFading()
	end

	function slot:IsEquipped()
		return IsEquipped(self.Tool)
	end

	function slot:Delete()
		SlotFrame:Destroy() --NOTE: Also clears connections
		table.remove(Slots, self.Index)
		local newSize = #Slots

		-- Now adjust the rest (both visually and representationally)
		for i = self.Index, newSize do
			Slots[i]:SlideBack()
		end

		UpdateScrollingFrameCanvasSize()
	end

	function slot:Swap(targetSlot) --NOTE: This slot (self) must not be empty!
		local myTool, otherTool = self.Tool, targetSlot.Tool
		self:Clear()
		if otherTool then -- (Target slot might be empty)
			targetSlot:Clear()
			self:Fill(otherTool)
		end
		if myTool then
			targetSlot:Fill(myTool)
		else
			targetSlot:Clear()
		end
	end

	function slot:SlideBack() -- For inventory slot shifting
		self.Index = self.Index - 1
		SlotFrame.Name = self.Index
		SlotFrame.LayoutOrder = self.Index
	end

	function slot:TurnNumber(on)
		if SlotNumber then
			SlotNumber.Visible = on
		end
	end

	function slot:SetClickability(on) -- (Happens on open/close arrow)
		if self.Tool then
			if UserInputService.VREnabled then
				SlotFrame.Draggable = false
			else
				SlotFrame.Draggable = not on
			end
			UpdateSlotFading()
		end
	end

	function slot:CheckTerms(terms)
		local hits = 0
		local function checkEm(str, term)
			local _, n = str:lower():gsub(term, '')
			hits = hits + n
		end
		local tool = self.Tool
		if tool then
			for term in pairs(terms) do
				if FFlagCoreScriptTranslateGameText2 then
					checkEm(ToolName.Text, term)
					if tool:IsA('Tool') then --NOTE: HopperBin
						local toolTipText = ToolTip and ToolTip.Text or ""
						checkEm(toolTipText, term)
					end
				else
					checkEm(LocalizedName, term)
					if tool:IsA('Tool') then --NOTE: HopperBin
						checkEm(LocalizedToolTip, term)
					end
				end
			end
		end
		return hits
	end

	-- Slot select logic, activated by clicking or pressing hotkey
	function slot:Select()
		local tool = slot.Tool
		if tool then
			if IsEquipped(tool) then --NOTE: HopperBin
				UnequipAllTools()
				SLOT_UNEQUIP_SOUND:Play()
				activeSlot = nil
			elseif tool.Parent == Backpack then
				SLOT_EQUIP_SOUND:Play()
				EquipNewTool(tool)
				activeSlot = slot
			end
			if activeSlot then
				BackpackScript.SelectedSlotChanged:Fire({
					["SlotNumber"] = activeSlot.Index,
					["Tool"] = activeSlot.Tool,
					["IsEquipped"] = activeSlot:IsEquipped(),
				})
			else
				BackpackScript.SelectedSlotChanged:Fire(nil)
			end
		end
	end

	-- Slot Init Logic --

	SlotFrame = NewGui('TextButton', index)
	local newStroke = Instance.new("UIStroke")
	newStroke.Parent = SlotFrame
	local newRadius = Instance.new("UICorner")
	newRadius.CornerRadius = script:GetAttribute("CornerRadius")
	newRadius.Parent = SlotFrame
	newStroke.Thickness = 0
	SlotFrame.BackgroundColor3 = BACKGROUND_COLOR
	newStroke.Color = SLOT_BORDER_COLOR
	
	SlotFrame.Text = ""
	SlotFrame.AutoButtonColor = false
	SlotFrame.BorderSizePixel = 0
	SlotFrame.Size = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)
	SlotFrame.Active = true
	SlotFrame.Draggable = false
	SlotFrame.BackgroundTransparency = SLOT_FADE_LOCKED
	SlotFrame.MouseButton1Click:connect(function() changeSlot(slot) end)
	slot.Frame = SlotFrame

	do
		local selectionObjectClipper = NewGui('Frame', 'SelectionObjectClipper')
		selectionObjectClipper.Visible = false
		selectionObjectClipper.Parent = SlotFrame

		SelectionObj = NewGui('ImageLabel', 'Selector')
		SelectionObj.Size = UDim2.new(1, 0, 1, 0)
		SelectionObj.Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png"
		SelectionObj.ScaleType = Enum.ScaleType.Slice
		SelectionObj.SliceCenter = Rect.new(12,12,52,52)
		SelectionObj.Parent = selectionObjectClipper
	end


	ToolIcon = NewGui('ImageLabel', 'Icon')
	ToolIcon.Size = UDim2.new(0.8, 0, 0.8, 0)
	ToolIcon.Position = UDim2.new(0.1, 0, 0.1, 0)
	ToolIcon.Parent = SlotFrame

	ToolName = NewGui('TextLabel', 'ToolName')
	ToolName.Size = UDim2.new(1, -2, 1, -2)
	ToolName.Position = UDim2.new(0, 1, 0, 1)
	ToolName.Parent = SlotFrame

	slot.Frame.LayoutOrder = slot.Index

	if index <= NumberOfHotbarSlots then -- Hotbar-Specific Slot Stuff
		-- ToolTip stuff
		ToolTip = NewGui('TextLabel', 'ToolTip')
		ToolTip.ZIndex = 2
		ToolTip.FontFace = script:GetAttribute("ToolTipFont")
		ToolTip.TextWrapped = false
		ToolTip.TextYAlignment = Enum.TextYAlignment.Center
		ToolTip.BackgroundColor3 = Color3.new(0.4, 0.4, 0.4)
		ToolTip.BackgroundTransparency = 0
		ToolTip.Visible = false
		ToolTip.Parent = SlotFrame
		local ToolTipStroke = Instance.new("UICorner")
		ToolTipStroke.CornerRadius = script:GetAttribute("CornerRadius")
		ToolTipStroke.Parent = ToolTip
		SlotFrame.MouseEnter:connect(function()
			if ToolTip.Text ~= '' then
				ToolTip.Visible = true
			end
		end)
		SlotFrame.MouseLeave:connect(function() ToolTip.Visible = false end)

		function slot:MoveToInventory()
			if slot.Index <= NumberOfHotbarSlots then -- From a Hotbar slot
				local tool = slot.Tool
				self:Clear() --NOTE: Order matters here
				local newSlot = MakeSlot(UIGridFrame)
				newSlot:Fill(tool)
				if IsEquipped(tool) then -- Also unequip it --NOTE: HopperBin
					UnequipAllTools()
				end
				-- Also hide the inventory slot if we're showing results right now
				if ViewingSearchResults then
					newSlot.Frame.Visible = false
					newSlot.Parent = InventoryFrame
				end
			end
		end

		-- Show label and assign hotkeys for 1-9 and 0 (zero is always last slot when > 10 total)
		if index < 10 or index == NumberOfHotbarSlots then -- NOTE: Hardcoded on purpose!
			local slotNum = (index < 10) and index or 0
			SlotNumber = NewGui('TextLabel', 'Number')
			SlotNumber.Text = slotNum
			SlotNumber.Size = UDim2.new(0, 15, 0, 15)
			SlotNumber.Visible = false
			SlotNumber.Parent = SlotFrame
			HotkeyFns[ZERO_KEY_VALUE + slotNum] = slot.Select
		end
	end

	do -- Dragging Logic
		local startPoint = SlotFrame.Position
		local lastUpTime = 0
		local startParent = nil

		SlotFrame.DragBegin:connect(function(dragPoint)
			Dragging[SlotFrame] = true
			startPoint = dragPoint

			newStroke.Thickness = 2
			InventoryIcon:lock()

			-- Raise above other slots
			SlotFrame.ZIndex = 2
			ToolIcon.ZIndex = 2
			ToolName.ZIndex = 2
			if FFlagRobloxGuiSiblingZindexs then
				SlotFrame.Parent.ZIndex = 2
			end
			if SlotNumber then
				SlotNumber.ZIndex = 2
			end
			if HighlightFrame then
				HighlightFrame.ZIndex = 2
				for _, child in pairs(HighlightFrame:GetChildren()) do
					if not child:IsA("UICorner") and not child:IsA("UIStroke") then
						child.ZIndex = 2
					end
				end
			end

			-- Circumvent the ScrollingFrame's ClipsDescendants property
			startParent = SlotFrame.Parent
			if startParent == UIGridFrame then
				local oldAbsolutPos = SlotFrame.AbsolutePosition
				local newPosition = UDim2.new(0, SlotFrame.AbsolutePosition.X - InventoryFrame.AbsolutePosition.X, 0, SlotFrame.AbsolutePosition.Y - InventoryFrame.AbsolutePosition.Y)
				SlotFrame.Parent = InventoryFrame
				SlotFrame.Position = newPosition

				FakeSlotFrame = NewGui('Frame', 'FakeSlot')
				FakeSlotFrame.LayoutOrder = SlotFrame.LayoutOrder
				FakeSlotFrame.Size = SlotFrame.Size
				FakeSlotFrame.BackgroundTransparency = 1
				FakeSlotFrame.Parent = UIGridFrame
			end
		end)

		SlotFrame.DragStopped:connect(function(x, y)
			if FakeSlotFrame then
				FakeSlotFrame:Destroy()
			end

			local now = tick()
			SlotFrame.Position = startPoint
			SlotFrame.Parent = startParent

			newStroke.Thickness = 0
			InventoryIcon:unlock()

			-- Restore height
			SlotFrame.ZIndex = 1
			ToolIcon.ZIndex = 1
			ToolName.ZIndex = 1
			if FFlagRobloxGuiSiblingZindexs then
				startParent.ZIndex = 1
			end
			if SlotNumber then
				SlotNumber.ZIndex = 1
			end
			if HighlightFrame then
				HighlightFrame.ZIndex = 1
				for _, child in pairs(HighlightFrame:GetChildren()) do
					if not child:IsA("UICorner") and not child:IsA("UIStroke") then
						child.ZIndex = 1
					end
				end
			end

			Dragging[SlotFrame] = nil

			-- Make sure the tool wasn't dropped
			if not slot.Tool then
				return
			end

			-- Check where we were dropped
			if CheckBounds(InventoryFrame, x, y) then
				if slot.Index <= NumberOfHotbarSlots then
					slot:MoveToInventory()
				end
				-- Check for double clicking on an inventory slot, to move into empty hotbar slot
				if slot.Index > NumberOfHotbarSlots and now - lastUpTime < DOUBLE_CLICK_TIME then
					if LowestEmptySlot then
						local myTool = slot.Tool
						slot:Clear()
						LowestEmptySlot:Fill(myTool)
						slot:Delete()
					end
					now = 0 -- Resets the timer
				end
			elseif CheckBounds(HotbarFrame, x, y) then
				local closest = {math.huge, nil}
				for i = 1, NumberOfHotbarSlots do
					local otherSlot = Slots[i]
					local offset = GetOffset(otherSlot.Frame, Vector2.new(x, y))
					if offset < closest[1] then
						closest = {offset, otherSlot}
					end
				end
				local closestSlot = closest[2]
				if closestSlot ~= slot then
					slot:Swap(closestSlot)
					if slot.Index > NumberOfHotbarSlots then
						local tool = slot.Tool
						if not tool then -- Clean up after ourselves if we're an inventory slot that's now empty
							slot:Delete()
						else -- Moved inventory slot to hotbar slot, and gained a tool that needs to be unequipped
							if IsEquipped(tool) then --NOTE: HopperBin
								UnequipAllTools()
							end
							-- Also hide the inventory slot if we're showing results right now
							if ViewingSearchResults then
								slot.Frame.Visible = false
								slot.Frame.Parent = InventoryFrame
							end
						end
					end
				end
			else
				-- local tool = slot.Tool
				-- if tool.CanBeDropped then --TODO: HopperBins
				-- tool.Parent = workspace
				-- --TODO: Move away from character
				-- end
				if slot.Index <= NumberOfHotbarSlots then
					slot:MoveToInventory() --NOTE: Temporary
				end
			end

			lastUpTime = now
		end)
	end

	-- All ready!
	SlotFrame.Parent = parent
	Slots[index] = slot

	if index > NumberOfHotbarSlots then
		UpdateScrollingFrameCanvasSize()
		-- Scroll to new inventory slot, if we're open and not viewing search results
		if InventoryFrame.Visible and not ViewingSearchResults then
			local offset = ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteSize.Y
			ScrollingFrame.CanvasPosition = Vector2.new(0, math.max(0, offset))
		end
	end

	return slot
end

local function OnChildAdded(child) -- To Character or Backpack
	if not child:IsA('Tool') then --NOTE: HopperBin
		if child:IsA('Humanoid') and child.Parent == Character then
			Humanoid = child
		end
		return
	end
	local tool = child

	if tool.Parent == Character then
		ShowVRBackpackPopup()
		TimeOfLastToolChange = tick()
	end

	--TODO: Optimize / refactor / do something else
	if not StarterToolFound and tool.Parent == Character and not SlotsByTool[tool] then
		local starterGear = Player:FindFirstChild('StarterGear')
		if starterGear then
			if starterGear:FindFirstChild(tool.Name) then
				StarterToolFound = true
				local slot = LowestEmptySlot or MakeSlot(UIGridFrame)
				for i = slot.Index, 1, -1 do
					local curr = Slots[i] -- An empty slot, because above
					local pIndex = i - 1
					if pIndex > 0 then
						local prev = Slots[pIndex] -- Guaranteed to be full, because above
						prev:Swap(curr)
					else
						curr:Fill(tool)
					end
				end
				-- Have to manually unequip a possibly equipped tool
				for _, child in pairs(Character:GetChildren()) do
					if child:IsA('Tool') and child ~= tool then
						child.Parent = Backpack
					end
				end
				AdjustHotbarFrames()
				return -- We're done here
			end
		end
	end

	-- The tool is either moving or new
	local slot = SlotsByTool[tool]
	if slot then
		slot:UpdateEquipView()
	else -- New! Put into lowest hotbar slot or new inventory slot
		slot = LowestEmptySlot or MakeSlot(UIGridFrame)
		slot:Fill(tool)
		if slot.Index <= NumberOfHotbarSlots and not InventoryFrame.Visible then
			AdjustHotbarFrames()
		end
	end
end

local function OnChildRemoved(child) -- From Character or Backpack
	if not child:IsA('Tool') then --NOTE: HopperBin
		return
	end
	local tool = child

	ShowVRBackpackPopup()
	TimeOfLastToolChange = tick()

	-- Ignore this event if we're just moving between the two
	local newParent = tool.Parent
	if newParent == Character or newParent == Backpack then
		return
	end

	local slot = SlotsByTool[tool]
	if slot then
		slot:Clear()
		if slot.Index > NumberOfHotbarSlots then -- Inventory slot
			slot:Delete()
		elseif not InventoryFrame.Visible then
			AdjustHotbarFrames()
		end
	end
end

local function OnCharacterAdded(character)
	-- First, clean up any old slots
	for i = #Slots, 1, -1 do
		local slot = Slots[i]
		if slot.Tool then
			slot:Clear()
		end
		if i > NumberOfHotbarSlots then
			slot:Delete()
		end
	end

	-- And any old Connections
	for _, conn in pairs(CharConns) do
		conn:Disconnect()
	end
	CharConns = {}

	-- Hook up the new character
	Character = character
	table.insert(CharConns, character.ChildRemoved:Connect(OnChildRemoved))
	table.insert(CharConns, character.ChildAdded:Connect(OnChildAdded))
	for _, child in pairs(character:GetChildren()) do
		OnChildAdded(child)
	end
	--NOTE: Humanoid is set inside OnChildAdded

	-- And the new backpack, when it gets here
	Backpack = Player:WaitForChild('Backpack')
	table.insert(CharConns, Backpack.ChildRemoved:Connect(OnChildRemoved))
	table.insert(CharConns, Backpack.ChildAdded:Connect(OnChildAdded))
	for _, child in pairs(Backpack:GetChildren()) do
		OnChildAdded(child)
	end
	
	AdjustHotbarFrames()
end

local function OnInputBegan(input, isProcessed)
	-- Pass through keyboard hotkeys when not typing into a TextBox and not disabled (except for the Drop key)
	if input.UserInputType == Enum.UserInputType.Keyboard and not TextBoxFocused and (WholeThingEnabled or input.KeyCode.Value == DROP_HOTKEY_VALUE) then
		local hotkeyBehavior = HotkeyFns[input.KeyCode.Value]
		if hotkeyBehavior then
			hotkeyBehavior(isProcessed)
		end
	end

	local inputType = input.UserInputType
	if not isProcessed then
		if inputType == Enum.UserInputType.MouseButton1 or inputType == Enum.UserInputType.Touch then
			if InventoryFrame.Visible then
				InventoryIcon:deselect()
			end
		end
	end
end

local function OnUISChanged(property)
	if property == 'KeyboardEnabled' or property == "VREnabled" then
		local on = UserInputService.KeyboardEnabled and not UserInputService.VREnabled
		for i = 1, NumberOfHotbarSlots do
			Slots[i]:TurnNumber(on)
		end
	end
end

local lastChangeToolInputObject = nil
local lastChangeToolInputTime = nil
local maxEquipDeltaTime = 0.06
local noOpFunc = function() end
local selectDirection = Vector2.new(0,0)
local hotbarVisible = false

function unbindAllGamepadEquipActions()
	ContextActionService:UnbindAction("RBXBackpackHasGamepadFocus")
	ContextActionService:UnbindAction("RBXCloseInventory")
end

local function setHotbarVisibility(visible, isInventoryScreen)
	for i = 1, NumberOfHotbarSlots do
		local hotbarSlot = Slots[i]
		if hotbarSlot and hotbarSlot.Frame and (isInventoryScreen or hotbarSlot.Tool) then
			hotbarSlot.Frame.Visible = visible
		end
	end
end

local function getInputDirection(inputObject)
	local buttonModifier = 1
	if inputObject.UserInputState == Enum.UserInputState.End then
		buttonModifier = -1
	end

	if inputObject.KeyCode == Enum.KeyCode.Thumbstick1 then

		local magnitude = inputObject.Position.magnitude

		if magnitude > 0.98 then
			local normalizedVector = Vector2.new(inputObject.Position.x / magnitude, -inputObject.Position.y / magnitude)
			selectDirection =  normalizedVector
		else
			selectDirection = Vector2.new(0,0)
		end
	elseif inputObject.KeyCode == Enum.KeyCode.DPadLeft then
		selectDirection = Vector2.new(selectDirection.x - 1 * buttonModifier, selectDirection.y)
	elseif inputObject.KeyCode == Enum.KeyCode.DPadRight then
		selectDirection = Vector2.new(selectDirection.x + 1 * buttonModifier, selectDirection.y)
	elseif inputObject.KeyCode == Enum.KeyCode.DPadUp then
		selectDirection = Vector2.new(selectDirection.x, selectDirection.y - 1 * buttonModifier)
	elseif inputObject.KeyCode == Enum.KeyCode.DPadDown then
		selectDirection = Vector2.new(selectDirection.x, selectDirection.y + 1 * buttonModifier)
	else
		selectDirection = Vector2.new(0,0)
	end

	return selectDirection
end

local selectToolExperiment = function(actionName, inputState, inputObject)
	local inputDirection = getInputDirection(inputObject)

	if inputDirection == Vector2.new(0,0) then
		return
	end

	local angle = math.atan2(inputDirection.y, inputDirection.x) - math.atan2(-1, 0)
	if angle < 0 then
		angle = angle + (math.pi * 2)
	end

	local quarterPi = (math.pi * 0.25)

	local index = (angle/quarterPi) + 1
	index = math.floor(index + 0.5) -- round index to whole number
	if index > NumberOfHotbarSlots then
		index = 1
	end

	if index > 0 then
		local selectedSlot = Slots[index]
		if selectedSlot and selectedSlot.Tool and not selectedSlot:IsEquipped() then
			selectedSlot:Select()
		end
	else
		UnequipAllTools()
	end
end

changeToolFunc = function(actionName, inputState, inputObject)
	if inputState ~= Enum.UserInputState.Begin then return end

	if lastChangeToolInputObject then
		if (lastChangeToolInputObject.KeyCode == Enum.KeyCode.ButtonR1 and
			inputObject.KeyCode == Enum.KeyCode.ButtonL1) or
			(lastChangeToolInputObject.KeyCode == Enum.KeyCode.ButtonL1 and
				inputObject.KeyCode == Enum.KeyCode.ButtonR1) then
			if (tick() - lastChangeToolInputTime) <= maxEquipDeltaTime then
				UnequipAllTools()
				lastChangeToolInputObject = inputObject
				lastChangeToolInputTime = tick()
				return
			end
		end
	end

	lastChangeToolInputObject = inputObject
	lastChangeToolInputTime = tick()

	delay(maxEquipDeltaTime, function()
		if lastChangeToolInputObject ~= inputObject then return end

		local moveDirection = 0
		if (inputObject.KeyCode == Enum.KeyCode.ButtonL1) then
			moveDirection = -1
		else
			moveDirection = 1
		end

		for i = 1, NumberOfHotbarSlots do
			local hotbarSlot = Slots[i]
			if hotbarSlot:IsEquipped() then

				local newSlotPosition = moveDirection + i
				local hitEdge = false
				if newSlotPosition > NumberOfHotbarSlots then
					newSlotPosition = 1
					hitEdge = true
				elseif newSlotPosition < 1 then
					newSlotPosition = NumberOfHotbarSlots
					hitEdge = true
				end

				local origNewSlotPos = newSlotPosition
				while not Slots[newSlotPosition].Tool do
					newSlotPosition = newSlotPosition + moveDirection
					if newSlotPosition == origNewSlotPos then return end

					if newSlotPosition > NumberOfHotbarSlots then
						newSlotPosition = 1
						hitEdge = true
					elseif newSlotPosition < 1 then
						newSlotPosition = NumberOfHotbarSlots
						hitEdge = true
					end
				end

				if hitEdge then
					UnequipAllTools()
					lastEquippedSlot = nil
				else
					Slots[newSlotPosition]:Select()
				end
				return
			end
		end

		if lastEquippedSlot and lastEquippedSlot.Tool then
			lastEquippedSlot:Select()
			return
		end

		local startIndex = moveDirection == -1 and NumberOfHotbarSlots or 1
		local endIndex = moveDirection == -1 and 1 or NumberOfHotbarSlots
		for i = startIndex, endIndex, moveDirection do
			if Slots[i].Tool then
				Slots[i]:Select()
				return
			end
		end
	end)
end

function getGamepadSwapSlot()
	for i = 1, #Slots do
		if Slots[i].Frame:WaitForChild("UIStroke").Thickness > 0 then
			return Slots[i]
		end
	end
end

function changeSlot(slot)
	local swapInVr = not VRService.VREnabled or InventoryFrame.Visible

	if slot.Frame == GuiService.SelectedObject and swapInVr then
		local currentlySelectedSlot = getGamepadSwapSlot()

		if currentlySelectedSlot then
			currentlySelectedSlot.Frame:WaitForChild("UIStroke").Thickness = 0
			if currentlySelectedSlot ~= slot then
				slot:Swap(currentlySelectedSlot)
				VRInventorySelector.SelectionImageObject.Visible = false

				if slot.Index > NumberOfHotbarSlots and not slot.Tool then
					if GuiService.SelectedObject == slot.Frame then
						GuiService.SelectedObject = currentlySelectedSlot.Frame
					end
					slot:Delete()
				end

				if currentlySelectedSlot.Index > NumberOfHotbarSlots and not currentlySelectedSlot.Tool then
					if GuiService.SelectedObject == currentlySelectedSlot.Frame then
						GuiService.SelectedObject = slot.Frame
					end
					currentlySelectedSlot:Delete()
				end
			end
		else
			local startSize = slot.Frame.Size
			local startPosition = slot.Frame.Position
			slot.Frame:TweenSizeAndPosition(startSize + UDim2.new(0, 10, 0, 10), startPosition - UDim2.new(0, 5, 0, 5), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, .1, true, function() slot.Frame:TweenSizeAndPosition(startSize, startPosition, Enum.EasingDirection.In, Enum.EasingStyle.Quad, .1, true) end)
			slot.Frame:WaitForChild("UIStroke").Thickness = 3
			VRInventorySelector.SelectionImageObject.Visible = true
		end
	else
		slot:Select()
		VRInventorySelector.SelectionImageObject.Visible = false
	end
end

function vrMoveSlotToInventory()
	if not VRService.VREnabled then
		return
	end

	local currentlySelectedSlot = getGamepadSwapSlot()
	if currentlySelectedSlot and currentlySelectedSlot.Tool then
		currentlySelectedSlot:WaitForChild("UIStroke").Thickness = 0
		currentlySelectedSlot:MoveToInventory()
		VRInventorySelector.SelectionImageObject.Visible = false
	end
end

function enableGamepadInventoryControl()
	local goBackOneLevel = function(actionName, inputState, inputObject)
		if inputState ~= Enum.UserInputState.Begin then return end

		local selectedSlot = getGamepadSwapSlot()
		if selectedSlot then
			local selectedSlot = getGamepadSwapSlot()
			if selectedSlot then
				selectedSlot:WaitForChild("UIStroke").Thickness = 0
				return
			end
		elseif InventoryFrame.Visible then
			InventoryIcon:deselect()
		end
	end

	ContextActionService:BindAction("RBXBackpackHasGamepadFocus", noOpFunc, false, Enum.UserInputType.Gamepad1)
	ContextActionService:BindAction("RBXCloseInventory", goBackOneLevel, false, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonStart)

	-- Gaze select will automatically select the object for us!
	if not UseGazeSelection() then
		GuiService.SelectedObject = HotbarFrame:FindFirstChild("1")
	end
end


function disableGamepadInventoryControl()
	unbindAllGamepadEquipActions()

	for i = 1, NumberOfHotbarSlots do
		local hotbarSlot = Slots[i]
		if hotbarSlot and hotbarSlot.Frame then
			hotbarSlot.Frame:WaitForChild("UIStroke").Thickness = 0
		end
	end

	if GuiService.SelectedObject and GuiService.SelectedObject:IsDescendantOf(MainFrame) then
		GuiService.SelectedObject = nil
	end
end


local function bindBackpackHotbarAction()
	if WholeThingEnabled and not GamepadActionsBound then
		GamepadActionsBound = true
		ContextActionService:BindAction("RBXHotbarEquip", changeToolFunc, false, Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonR1)
	end
end

local function unbindBackpackHotbarAction()
	disableGamepadInventoryControl()
	GamepadActionsBound = false
	ContextActionService:UnbindAction("RBXHotbarEquip")
end

function gamepadDisconnected()
	GamepadEnabled = false
	disableGamepadInventoryControl()
end

function gamepadConnected()
	GamepadEnabled = true

	if FullHotbarSlots >= 1 then
		bindBackpackHotbarAction()
	end

	if InventoryFrame.Visible then
		enableGamepadInventoryControl()
	end
end

local function OnIconChanged(enabled)
	-- Check for enabling/disabling the whole thing
	enabled = enabled and StarterGui:GetCore("TopbarEnabled")
	InventoryIcon:setEnabled(enabled and not GuiService.MenuIsOpen)
	WholeThingEnabled = enabled
	MainFrame.Visible = enabled

	-- Eat/Release hotkeys (Doesn't affect UserInputService)
	for _, keyString in pairs(HotkeyStrings) do
		if enabled then
			--GuiService:AddKey(keyString)
		else
			--GuiService:RemoveKey(keyString)
		end
	end

	if enabled then
		if FullHotbarSlots >=1 then
			bindBackpackHotbarAction()
		end
	else
		unbindBackpackHotbarAction()
	end
end


local function MakeVRRoundButton(name, image)
	local newButton = NewGui('ImageButton', name)
	newButton.Size = UDim2.new(0, 40, 0, 40)
	newButton.Image = "rbxasset://textures/ui/Keyboard/close_button_background.png";

	local buttonIcon = NewGui('ImageLabel', 'Icon')
	buttonIcon.Size = UDim2.new(0.5,0,0.5,0);
	buttonIcon.Position = UDim2.new(0.25,0,0.25,0);
	buttonIcon.Image = image;
	buttonIcon.Parent = newButton;

	local buttonSelectionObject = NewGui('ImageLabel', 'Selection')
	buttonSelectionObject.Size = UDim2.new(0.9,0,0.9,0);
	buttonSelectionObject.Position = UDim2.new(0.05,0,0.05,0);
	buttonSelectionObject.Image = "rbxasset://textures/ui/Keyboard/close_button_selection.png";
	newButton.SelectionImageObject = buttonSelectionObject

	return newButton, buttonIcon, buttonSelectionObject
end


-- Make the main frame, which (mostly) covers the screen
MainFrame = NewGui('Frame', 'Backpack')
MainFrame.Visible = false
MainFrame.Parent = RobloxGui

-- Make the HotbarFrame, which holds only the Hotbar Slots
HotbarFrame = NewGui('Frame', 'Hotbar')
HotbarFrame.Parent = MainFrame

-- Make all the Hotbar Slots
for i = 1, NumberOfHotbarSlots do
	local slot = MakeSlot(HotbarFrame, i)
	slot.Frame.Visible = false

	if not LowestEmptySlot then
		LowestEmptySlot = slot
	end
end

InventoryIcon.selected:Connect(function()
	if not GuiService.MenuIsOpen then
		BackpackScript.OpenClose()
	end
end)
InventoryIcon.deselected:Connect(function()
	if InventoryFrame.Visible then
		BackpackScript.OpenClose()
	end
end)

LeftBumperButton = NewGui('ImageLabel', 'LeftBumper')
LeftBumperButton.Size = UDim2.new(0, 40, 0, 40)
LeftBumperButton.Position = UDim2.new(0, -LeftBumperButton.Size.X.Offset, 0.5, -LeftBumperButton.Size.Y.Offset/2)

RightBumperButton = NewGui('ImageLabel', 'RightBumper')
RightBumperButton.Size = UDim2.new(0, 40, 0, 40)
RightBumperButton.Position = UDim2.new(1, 0, 0.5, -RightBumperButton.Size.Y.Offset/2)

-- Make the Inventory, which holds the ScrollingFrame, the header, and the search box
InventoryFrame = NewGui('Frame', 'Inventory')
local newIRadius = Instance.new("UICorner")
newIRadius.CornerRadius = script:GetAttribute("CornerRadius")
newIRadius.Parent = InventoryFrame
InventoryFrame.BackgroundTransparency = BACKGROUND_FADE
InventoryFrame.BackgroundColor3 = BACKGROUND_COLOR
InventoryFrame.Active = true
InventoryFrame.Visible = false
InventoryFrame.Parent = MainFrame

VRInventorySelector = NewGui('TextButton', 'VRInventorySelector')
VRInventorySelector.Position = UDim2.new(0, 0, 0, 0)
VRInventorySelector.Size = UDim2.new(1, 0, 1, 0)
VRInventorySelector.BackgroundTransparency = 1
VRInventorySelector.Text = ""
VRInventorySelector.Parent = InventoryFrame

local GroupTitle = NewGui('TextLabel', 'GroupTitle')

GroupTitle.Size = UDim2.new(0, 100, 0, INVENTORY_HEADER_SIZE - 20)
GroupTitle.Position = UDim2.new(0, 8, 0, 8)
GroupTitle.Text = "All Items"
GroupTitle.TextXAlignment = Enum.TextXAlignment.Left
GroupTitle.FontFace = script:GetAttribute("LabelFont")
GroupTitle.TextSize = 18
GroupTitle.TextColor3 = script:GetAttribute("TextColor")
GroupTitle.BackgroundTransparency = 1
GroupTitle.ZIndex = 2
GroupTitle.Parent = InventoryFrame

local selectorImage = NewGui('ImageLabel', 'Selector')
selectorImage.Size = UDim2.new(1, 0, 1, 0)
selectorImage.Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png"
selectorImage.ScaleType = Enum.ScaleType.Slice
selectorImage.SliceCenter = Rect.new(12,12,52,52)
selectorImage.Visible = false
VRInventorySelector.SelectionImageObject = selectorImage

VRInventorySelector.MouseButton1Click:Connect(function()
	vrMoveSlotToInventory()
end)

-- Make the ScrollingFrame, which holds the rest of the Slots (however many)
ScrollingFrame = NewGui('ScrollingFrame', 'ScrollingFrame')
ScrollingFrame.Selectable = false
ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
ScrollingFrame.Parent = InventoryFrame

UIGridFrame = NewGui('Frame', 'UIGridFrame')
UIGridFrame.Selectable = false
UIGridFrame.Size = UDim2.new(1, -(ICON_BUFFER*2), 1, 0)
UIGridFrame.Position = UDim2.new(0, ICON_BUFFER, 0, 0)
UIGridFrame.Parent = ScrollingFrame

UIGridLayout = Instance.new("UIGridLayout")
UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIGridLayout.CellSize = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)
UIGridLayout.CellPadding = UDim2.new(0, ICON_BUFFER, 0, ICON_BUFFER)
UIGridLayout.Parent = UIGridFrame

ScrollUpInventoryButton = MakeVRRoundButton('ScrollUpButton', 'rbxasset://textures/ui/Backpack/ScrollUpArrow.png')
ScrollUpInventoryButton.Size = UDim2.new(0, 34, 0, 34)
ScrollUpInventoryButton.Position = UDim2.new(0.5, -ScrollUpInventoryButton.Size.X.Offset/2, 0, INVENTORY_HEADER_SIZE + 3)
ScrollUpInventoryButton.Icon.Position = ScrollUpInventoryButton.Icon.Position - UDim2.new(0,0,0,2)
ScrollUpInventoryButton.MouseButton1Click:Connect(function()
	ScrollingFrame.CanvasPosition = Vector2.new(
		ScrollingFrame.CanvasPosition.X,
		Clamp(0, ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteWindowSize.Y, ScrollingFrame.CanvasPosition.Y - (ICON_BUFFER + ICON_SIZE)))
end)

ScrollDownInventoryButton = MakeVRRoundButton('ScrollDownButton', 'rbxasset://textures/ui/Backpack/ScrollUpArrow.png')
ScrollDownInventoryButton.Rotation = 180
ScrollDownInventoryButton.Icon.Position = ScrollDownInventoryButton.Icon.Position - UDim2.new(0,0,0,2)
ScrollDownInventoryButton.Size = UDim2.new(0, 34, 0, 34)
ScrollDownInventoryButton.Position = UDim2.new(0.5, -ScrollDownInventoryButton.Size.X.Offset/2, 1, -ScrollDownInventoryButton.Size.Y.Offset - 3)
ScrollDownInventoryButton.MouseButton1Click:Connect(function()
	ScrollingFrame.CanvasPosition = Vector2.new(
		ScrollingFrame.CanvasPosition.X,
		Clamp(0, ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteWindowSize.Y, ScrollingFrame.CanvasPosition.Y + (ICON_BUFFER + ICON_SIZE)))
end)

ScrollingFrame.Changed:Connect(function(prop)
	if prop == 'AbsoluteWindowSize' or prop == 'CanvasPosition' or prop == 'CanvasSize' then
		local canScrollUp = ScrollingFrame.CanvasPosition.Y ~= 0
		local canScrollDown = ScrollingFrame.CanvasPosition.Y < ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteWindowSize.Y

		ScrollUpInventoryButton.Visible = canScrollUp
		ScrollDownInventoryButton.Visible = canScrollDown
	end
end)

-- Position the frames and sizes for the Backpack GUI elements
UpdateBackpackLayout()

--Make the gamepad hint frame
local gamepadHintsFrame = Utility:Create'Frame'
{
	Name = "GamepadHintsFrame",
	Size = UDim2.new(0, HotbarFrame.Size.X.Offset, 0, (IsTenFootInterface and 95 or 60)),
	BackgroundTransparency = 1,
	Visible = false,
	Parent = MainFrame
}

local function addGamepadHint(hintImage, hintImageLarge, hintText)
	local hintFrame = Utility:Create'Frame'
	{
		Name = "HintFrame",
		Size = UDim2.new(1, 0, 1, -5),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundTransparency = 1,
		Parent = gamepadHintsFrame
	}

	local hintImage = Utility:Create'ImageLabel'
	{
		Name = "HintImage",
		Size = (IsTenFootInterface and UDim2.new(0,90,0,90) or UDim2.new(0,60,0,60)),
		BackgroundTransparency = 1,
		Image = (IsTenFootInterface and hintImageLarge or hintImage),
		Parent = hintFrame
	}

	local hintText = Utility:Create'TextLabel'
	{
		Name = "HintText",
		Position = UDim2.new(0, (IsTenFootInterface and 100 or 70), 0, 0),
		Size = UDim2.new(1, -(IsTenFootInterface and 100 or 70), 1, 0),
		Font = Enum.Font.SourceSansBold,
		FontSize = (IsTenFootInterface and Enum.FontSize.Size36 or Enum.FontSize.Size24),
		BackgroundTransparency = 1,
		Text = hintText,
		TextColor3 = Color3.new(1,1,1),
		TextXAlignment = Enum.TextXAlignment.Left,
		TextWrapped = true,
		Parent = hintFrame
	}
	local textSizeConstraint = Instance.new("UITextSizeConstraint", hintText)
	textSizeConstraint.MaxTextSize = hintText.TextSize
end

local function resizeGamepadHintsFrame()
	gamepadHintsFrame.Size = UDim2.new(HotbarFrame.Size.X.Scale, HotbarFrame.Size.X.Offset, 0, (IsTenFootInterface and 95 or 60))
	gamepadHintsFrame.Position = UDim2.new(HotbarFrame.Position.X.Scale, HotbarFrame.Position.X.Offset, InventoryFrame.Position.Y.Scale, InventoryFrame.Position.Y.Offset - gamepadHintsFrame.Size.Y.Offset)

	local spaceTaken = 0

	local gamepadHints = gamepadHintsFrame:GetChildren()
	--First get the total space taken by all the hints
	for i = 1, #gamepadHints do
		gamepadHints[i].Size = UDim2.new(1, 0, 1, -5)
		gamepadHints[i].Position = UDim2.new(0, 0, 0, 0)
		spaceTaken = spaceTaken + (gamepadHints[i].HintText.Position.X.Offset + gamepadHints[i].HintText.TextBounds.X)
	end

	--The space between all the frames should be equal
	local spaceBetweenElements = (gamepadHintsFrame.AbsoluteSize.X - spaceTaken)/(#gamepadHints - 1)
	for i = 1, #gamepadHints do
		gamepadHints[i].Position = (i == 1 and UDim2.new(0, 0, 0, 0) or UDim2.new(0, gamepadHints[i-1].Position.X.Offset + gamepadHints[i-1].Size.X.Offset + spaceBetweenElements, 0, 0))
		gamepadHints[i].Size = UDim2.new(0, (gamepadHints[i].HintText.Position.X.Offset + gamepadHints[i].HintText.TextBounds.X), 1, -5)
	end
end

addGamepadHint("rbxasset://textures/ui/Settings/Help/XButtonDark.png", "rbxasset://textures/ui/Settings/Help/XButtonDark@2x.png", "Remove From Hotbar")
addGamepadHint("rbxasset://textures/ui/Settings/Help/AButtonDark.png", "rbxasset://textures/ui/Settings/Help/AButtonDark@2x.png", "Select/Swap")
addGamepadHint("rbxasset://textures/ui/Settings/Help/BButtonDark.png", "rbxasset://textures/ui/Settings/Help/BButtonDark@2x.png", "Close Backpack")

do -- Search stuff
	local searchFrame = NewGui('Frame', 'Search')
	local newRadius = Instance.new("UICorner")
	newRadius.CornerRadius = UDim.new(0,4)
	newRadius.Parent = searchFrame
	searchFrame.BackgroundColor3 = SEARCH_BACKGROUND_COLOR
	searchFrame.BackgroundTransparency = SEARCH_BACKGROUND_FADE
	searchFrame.Size = UDim2.new(0, SEARCH_WIDTH - (SEARCH_BUFFER * 2), 0, INVENTORY_HEADER_SIZE - (SEARCH_BUFFER * 2))
	searchFrame.Position = UDim2.new(1, -searchFrame.Size.X.Offset - SEARCH_BUFFER, 0, SEARCH_BUFFER)
	searchFrame.Parent = InventoryFrame
	local stroke = Instance.new("UIStroke")
	stroke.Color = Color3.fromRGB(73, 77, 90)
	stroke.Thickness = 2
	stroke.Parent = searchFrame

	local searchBox = NewGui('TextBox', 'TextBox')
	searchBox.PlaceholderText = SEARCH_TEXT
	searchBox.TextColor3 = SEARCH_TEXT_COLOR
	searchBox.ClearTextOnFocus = false
	searchBox.FontSize = Enum.FontSize.Size24
	searchBox.TextXAlignment = Enum.TextXAlignment.Left
	searchBox.PlaceholderColor3 = script:GetAttribute("SearchPlaceholderColor")

	local searchImage = Instance.new("ImageLabel")
	searchImage.Parent = searchFrame
	searchImage.BackgroundTransparency = 1
	searchImage.Size = UDim2.fromScale(1,1)
	searchImage.SizeConstraint = Enum.SizeConstraint.RelativeYY
	searchImage.Parent = searchFrame
	searchImage.Image = "rbxassetid://16884179038"
	searchImage.ImageRectSize = Vector2.new(108, 108)
	searchImage.ImageRectOffset = Vector2.new(798, 660)
	local uipadding = Instance.new("UIPadding")
	uipadding.Parent = searchBox
	uipadding.PaddingLeft = UDim.new(0, 8)
	searchBox.Size = searchFrame.Size - UDim2.fromOffset(34, SEARCH_TEXT_OFFSET_FROMLEFT)
	searchBox.Position = UDim2.new(0, SEARCH_TEXT_OFFSET_FROMLEFT + (searchImage.AbsoluteSize.X + 30), 0, 0)
	searchBox.Parent = searchFrame
	local xButton = NewGui('TextButton', 'X')
	local newRadius2 = Instance.new("UICorner")
	newRadius2.CornerRadius = script:GetAttribute("CornerRadius")
	newRadius2.Parent = xButton
	xButton.Font = Enum.Font.Arial
	xButton.Text = 'x'
	xButton.ZIndex = 10
	xButton.TextColor3 = SLOT_EQUIP_COLOR
	xButton.FontSize = Enum.FontSize.Size24
	xButton.TextYAlignment = Enum.TextYAlignment.Bottom
	xButton.BackgroundColor3 = SEARCH_BACKGROUND_COLOR
	xButton.BackgroundTransparency = 0
	xButton.Size = UDim2.new(0, searchFrame.Size.Y.Offset - (SEARCH_BUFFER * 2), 0, searchFrame.Size.Y.Offset - (SEARCH_BUFFER * 2))
	xButton.Position = UDim2.new(1, -xButton.Size.X.Offset - (SEARCH_BUFFER * 2), 0.5, -xButton.Size.Y.Offset / 2)
	xButton.Visible = false
	xButton.BorderSizePixel = 0
	xButton.Parent = searchFrame

	local function search()
		local terms = {}
		for word in searchBox.Text:gmatch('%S+') do
			terms[word:lower()] = true
		end

		local hitTable = {}
		for i = NumberOfHotbarSlots + 1, #Slots do -- Only search inventory slots
			local slot = Slots[i]
			local hits = slot:CheckTerms(terms)
			table.insert(hitTable, {slot, hits})
			slot.Frame.Visible = false
			slot.Frame.Parent = InventoryFrame
		end

		table.sort(hitTable, function(left, right)
			return left[2] > right[2]
		end)
		ViewingSearchResults = true

		local hitCount = 0
		for i, data in ipairs(hitTable) do
			local slot, hits = data[1], data[2]
			if hits > 0 then
				slot.Frame.Visible = true
				slot.Frame.Parent = UIGridFrame
				slot.Frame.LayoutOrder = NumberOfHotbarSlots + hitCount
				hitCount = hitCount + 1
			end
		end

		ScrollingFrame.CanvasPosition = Vector2.new(0, 0)
		UpdateScrollingFrameCanvasSize()

		xButton.ZIndex = 3
	end

	local function clearResults()
		if xButton.ZIndex > 0 then
			ViewingSearchResults = false
			for i = NumberOfHotbarSlots + 1, #Slots do
				local slot = Slots[i]
				slot.Frame.LayoutOrder = slot.Index
				slot.Frame.Parent = UIGridFrame
				slot.Frame.Visible = true
			end
			xButton.ZIndex = 0
		end
		UpdateScrollingFrameCanvasSize()
	end

	local function reset()
		clearResults()
		searchBox.Text = ''
	end

	local function onChanged(property)
		if property == 'Text' then
			local text = searchBox.Text
			if text == '' then
				clearResults()
			elseif text ~= SEARCH_TEXT then
				search()
			end
			xButton.Visible = false
		end
	end

	local function focusLost(enterPressed)
		if enterPressed then
			--TODO: Could optimize
			search()
		end
	end

	xButton.MouseButton1Click:Connect(reset)
	searchBox.Changed:Connect(onChanged)
	searchBox.FocusLost:Connect(focusLost)

	BackpackScript.StateChanged.Event:Connect(function(isNowOpen)

		if not isNowOpen then
			reset()
			if not InventoryFrame.Visible then
				InventoryIcon:deselect()
			end
		end
	end)
	
	HotkeyFns[Enum.KeyCode.Escape.Value] = function(isProcessed)
		if isProcessed then -- Pressed from within a TextBox
			reset()
		elseif InventoryFrame.Visible then
			InventoryIcon:deselect()
		end
	end

	local function detectGamepad(lastInputType)
		if lastInputType == Enum.UserInputType.Gamepad1 and not UserInputService.VREnabled then
			searchFrame.Visible = false
		else
			searchFrame.Visible = true
		end
	end
	UserInputService.LastInputTypeChanged:Connect(detectGamepad)
end

GuiService.MenuOpened:Connect(function()
	if InventoryFrame.Visible then
		InventoryIcon:deselect()
	end
end)


do -- Make the Inventory expand/collapse arrow (unless TopBar)
	local removeHotBarSlot = function(name, state, input)
		if state ~= Enum.UserInputState.Begin then return end
		if not GuiService.SelectedObject then return end

		for i = 1, NumberOfHotbarSlots do
			if Slots[i].Frame == GuiService.SelectedObject and Slots[i].Tool then
				Slots[i]:MoveToInventory()
				return
			end
		end
	end

	local function openClose()
		if not next(Dragging) then -- Only continue if nothing is being dragged
			InventoryFrame.Visible = not InventoryFrame.Visible
			local nowOpen = InventoryFrame.Visible
			AdjustHotbarFrames()
			HotbarFrame.Active = not HotbarFrame.Active
			for i = 1, NumberOfHotbarSlots do
				Slots[i]:SetClickability(not nowOpen)
			end
		end

		if InventoryFrame.Visible then
			if GamepadEnabled then
				if GAMEPAD_INPUT_TYPES[UserInputService:GetLastInputType()] then
					resizeGamepadHintsFrame()
					gamepadHintsFrame.Visible = not UserInputService.VREnabled
				end
				enableGamepadInventoryControl()
			end
			if BackpackPanel and VRService.VREnabled then
				BackpackPanel:SetVisible(true)
				BackpackPanel:RequestPositionUpdate()
			end
		else
			if GamepadEnabled then
				gamepadHintsFrame.Visible = false
			end
			disableGamepadInventoryControl()
		end

		if InventoryFrame.Visible then
			ContextActionService:BindAction("RBXRemoveSlot", removeHotBarSlot, false, Enum.KeyCode.ButtonX)
		else
			ContextActionService:UnbindAction("RBXRemoveSlot")
		end

		BackpackScript.IsOpen = InventoryFrame.Visible
		BackpackScript.StateChanged:Fire(InventoryFrame.Visible)
	end

	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
	BackpackScript.OpenClose = openClose -- Exposed
end

-- Now that we're done building the GUI, we Connect to all the major events

-- Wait for the player if LocalPlayer wasn't ready earlier
while not Player do
	wait()
	Player = PlayersService.LocalPlayer
end

-- Listen to current and all future characters of our player
Player.CharacterAdded:Connect(OnCharacterAdded)
if Player.Character then
	OnCharacterAdded(Player.Character)
end

do -- Hotkey stuff
	
	-- Listen to key down
	UserInputService.InputBegan:Connect(OnInputBegan)

	-- Listen to ANY TextBox gaining or losing focus, for disabling all hotkeys
	UserInputService.TextBoxFocused:Connect(function() TextBoxFocused = true end)
	UserInputService.TextBoxFocusReleased:Connect(function() TextBoxFocused = false end)

	-- Manual unequip for HopperBins on drop button pressed
	HotkeyFns[DROP_HOTKEY_VALUE] = function() --NOTE: HopperBin
		UnequipAllTools()
	end

	-- Listen to keyboard status, for showing/hiding hotkey labels
	UserInputService.Changed:Connect(OnUISChanged)
	OnUISChanged('KeyboardEnabled')

	-- Listen to gamepad status, for allowing gamepad style selection/equip
	if UserInputService:GetGamepadConnected(Enum.UserInputType.Gamepad1) then
		gamepadConnected()
	end
	UserInputService.GamepadConnected:Connect(function(gamepadEnum)
		if gamepadEnum == Enum.UserInputType.Gamepad1 then
			gamepadConnected()
		end
	end)
	UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
		if gamepadEnum == Enum.UserInputType.Gamepad1 then
			gamepadDisconnected()
		end
	end)
end

function BackpackScript:SetBackpackEnabled(Enabled)
	BackpackEnabled = Enabled
end

function BackpackScript:IsOpened()
	return BackpackScript.IsOpen
end

function BackpackScript:GetBackpackEnabled()
	return BackpackEnabled
end

function BackpackScript:GetStateChangedEvent()
	return BackpackScript.StateChanged
end

RunService.Heartbeat:Connect(function()
	OnIconChanged(BackpackEnabled)
end)
-- Table to store group assignments: [tool] = groupName
local ToolGroups = {}
-- Table to store group contents: [groupName] = {tool1, tool2, ...}
local Groups = {}

-- Group Icon Mapping: [groupName] = iconAssetId
local GroupIcons = {}


-- UI: Group Button Bar
local GroupButtonBar = nil
local GroupButtons = {}
local SelectedGroup = nil


-- Table to store group assignments: [tool] = groupName
local ToolGroups = {}
-- Table to store group contents: [groupName] = {tool1, tool2, ...}
local Groups = {}

-- Group Icon Mapping: [groupName] = iconAssetId
local GroupIcons = {}

-- UI: Group Button Bar
local GroupButtonBar = nil
local GroupButtons = {}
local SelectedGroup = nil

-- Implement group assignment logic
function BackpackScript:SetToolGroup(tool, groupName)
	-- Remove from previous group if exists
	local oldGroup = ToolGroups[tool]
	if oldGroup then
		local groupTable = Groups[oldGroup]
		if groupTable then
			for i, t in groupTable do
				if t == tool then
					table.remove(groupTable, i)
					break
				end
			end
		end
	end
	-- Assign to new group
	ToolGroups[tool] = groupName
	if not Groups[groupName] then
		Groups[groupName] = {}
	end
	table.insert(Groups[groupName], tool)
	if RefreshGroupButtons then RefreshGroupButtons() end
end

function BackpackScript:RemoveToolGroup(tool)
	local groupName = ToolGroups[tool]
	if groupName then
		local groupTable = Groups[groupName]
		if groupTable then
			for i, t in groupTable do
				if t == tool then
					table.remove(groupTable, i)
					break
				end
			end
		end
		ToolGroups[tool] = nil
	end
	if RefreshGroupButtons then RefreshGroupButtons() end
end

function BackpackScript:ClearAllGroups()
	ToolGroups = {}
	Groups = {}
	if RefreshGroupButtons then RefreshGroupButtons() end
end

-- Get the group name for a tool
function BackpackScript:GetToolGroup(tool)
	return ToolGroups[tool]
end

-- Get all group names
function BackpackScript:GetAllGroups()
	local groupList = {}
	for groupName, _ in Groups do
		table.insert(groupList, groupName)
	end
	return groupList
end

-- Get all tools in a group
function BackpackScript:GetToolsInGroup(groupName)
	return Groups[groupName] or {}
end

-- Function to filter inventory slots by group
local function FilterInventoryByGroup(groupName)
	SelectedGroup = groupName
	for i = NumberOfHotbarSlots + 1, #Slots do
		local slot = Slots[i]
		local tool = slot.Tool
		local show = false
		if not groupName then
			show = true
		elseif tool and BackpackScript:GetToolGroup(tool) == groupName then
			show = true
		end
		slot.Frame.Visible = show
	end
	UpdateScrollingFrameCanvasSize()
end

-- Function to refresh group buttons
function RefreshGroupButtons()
	
	if not GroupButtonBar then return end
	-- Clear old buttons
	for _, btn in GroupButtons do
		btn:Destroy()
	end
	GroupButtons = {}

	local groups = BackpackScript:GetAllGroups()
	if #groups == 0 then
		GroupTitle.Visible = false
		return
	else
		GroupTitle.Visible = true
	end
	table.sort(groups, function(a, b) return tostring(a) < tostring(b) end)
	
	local y = 0
	local BUTTON_SIZE = 48
	local BUTTON_PADDING = 8

	-- Add "All" button
	local allBtn = Instance.new("ImageButton")
	allBtn.Name = "AllGroups"
	allBtn.Size = UDim2.new(0, BUTTON_SIZE, 0, BUTTON_SIZE)
	allBtn.Position = UDim2.new(0, 0, 0, y)
	allBtn.BackgroundTransparency = BACKGROUND_FADE
	allBtn.Image = "rbxassetid://12988755627" -- generic grid icon
	allBtn.Parent = GroupButtonBar
	allBtn.BackgroundColor3 = BACKGROUND_COLOR
	allBtn.MouseButton1Click:Connect(function()
		FilterInventoryByGroup(nil)
		GroupTitle.Text = "All Items"
	end)
	local allBtnRadius = Instance.new("UICorner")
	allBtnRadius.CornerRadius = script:GetAttribute("CornerRadius")
	allBtnRadius.Parent = allBtn
	table.insert(GroupButtons, allBtn)
	y = y + BUTTON_SIZE + BUTTON_PADDING

	-- Add a button for each group
	for _, groupName in groups do
		local btn = Instance.new("ImageButton")
		btn.Name = "Group_" .. tostring(groupName)
		btn.Size = UDim2.new(0, BUTTON_SIZE, 0, BUTTON_SIZE)
		btn.Position = UDim2.new(0, 0, 0, y)
		btn.BackgroundTransparency = BACKGROUND_FADE
		btn.BackgroundColor3 = BACKGROUND_COLOR
		btn.Image = GroupIcons[groupName] or "" -- default folder icon
		btn.Parent = GroupButtonBar
		local btnPadding = Instance.new("UIPadding")
		btnPadding.PaddingLeft = UDim.new(0, 8)
		btnPadding.PaddingRight = UDim.new(0, 8)
		btnPadding.PaddingTop = UDim.new(0, 8)
		btnPadding.PaddingBottom = UDim.new(0, 8)
		btnPadding.Parent = btn
		btn.MouseButton1Click:Connect(function()
			FilterInventoryByGroup(groupName)
			GroupTitle.Text = groupName
		end)
		local btnRadius = Instance.new("UICorner")
		btnRadius.CornerRadius = script:GetAttribute("CornerRadius")
		btnRadius.Parent = btn
		if not GroupIcons[groupName] then
			local text = Instance.new("TextLabel")
			text.Parent = btn
			text.Size = UDim2.new(1, 0, 1, 0)
			text.BackgroundTransparency = 1
			text.Text = groupName
			text.TextColor3 = script:GetAttribute("TextColor")
			text.TextSize = 18
			text.FontFace = script:GetAttribute("LabelFont")
			text.TextXAlignment = Enum.TextXAlignment.Center
			text.TextYAlignment = Enum.TextYAlignment.Center
			text.TextTruncate = Enum.TextTruncate.AtEnd
			text.TextWrapped = true
		end
		table.insert(GroupButtons, btn)
		y = y + BUTTON_SIZE + BUTTON_PADDING
	end
end

-- Function to set group icon
function BackpackScript:SetGroupIcon(groupName, iconAssetId)
	GroupIcons[groupName] = iconAssetId
	if RefreshGroupButtons then
		RefreshGroupButtons()
	end
end

-- Function to get group icon
function BackpackScript:GetGroupIcon(groupName)
	return GroupIcons[groupName]
end

-- Create the GroupButtonBar UI and insert into InventoryFrame
do
	
	GroupButtonBar = Instance.new("ScrollingFrame")
	GroupButtonBar.Name = "GroupButtonBar"
	GroupButtonBar.CanvasSize = UDim2.new(0, 0, 0, 0)
	GroupButtonBar.AutomaticSize = Enum.AutomaticSize.Y
	GroupButtonBar.Size = UDim2.new(0, 56, 1, 0)
	GroupButtonBar.Position = UDim2.new(0, -56, 0, 0)
	GroupButtonBar.BackgroundTransparency = 1
	GroupButtonBar.Parent = InventoryFrame
	RefreshGroupButtons()
end


local APIRemote = Instance.new("BindableFunction")
APIRemote.Parent = game.ReplicatedStorage
APIRemote.Name = "CustomPackAPI"
local apifunctions = {
	SetBackpackEnabled = function(enabled :boolean)
		BackpackScript:SetBackpackEnabled(enabled)
	end,
	SetInventoryOpen = function(enabled :boolean)
		BackpackScript.IsOpen = enabled
	end,
	ToggleInventoryOpen = function()
		BackpackScript.OpenClose()
	end,
	IsInventoryOpen = function()
		return BackpackScript:IsInventoryOpen()
	end,
	GetBackpackEnabled = function()
		return BackpackEnabled
	end,
	GetStateChangedEvent = function()
		return BackpackScript:GetStateChangedEvent()
	end,
	GetSelectedSlotChangedEvent = function()
		return BackpackScript.SelectedSlotChanged
	end,
	GetVersion = function()
		return BackpackScript.Version
	end,
	SetGroupIcon = function(groupName, iconAssetId)
		BackpackScript:SetGroupIcon(groupName, iconAssetId)
	end,
	GetEquipSound = function()
		return SLOT_EQUIP_SOUND
	end,
	GetUnequipSound = function()
		return SLOT_UNEQUIP_SOUND
	end,
	GetSlot = function(slotnumber :number)
		local slot = Slots[slotnumber]
		return {
			["SlotNumber"] = slot.Index,
			["Tool"] = slot.Tool,
			["IsEquipped"] = slot:IsEquipped(),
		}
	end,
	GetAllSlots = function()
		local finalslots = {}
		for i, v in pairs(Slots) do
			table.insert(finalslots, {
				["SlotNumber"] = v.Index,
				["Tool"] = v.Tool,
				["IsEquipped"] = v:IsEquipped(),
			})
		end
		return finalslots
	end,
	GetEquippedSlot = function()
		if activeSlot then
			return {
				["SlotNumber"] = activeSlot.Index,
				["Tool"] = activeSlot.Tool,
				["IsEquipped"] = activeSlot:IsEquipped(),
			}
		end
		return nil
	end,
	
	IsSlotEquipped = function(slotnumber :number)
		return Slots[slotnumber]:IsEquipped()
	end,
	GetGroupIcon = function(groupName)
		return BackpackScript:GetGroupIcon(groupName)
	end,
	GetToolsInGroup = function(groupName)
		return BackpackScript:GetToolsInGroup(groupName)
	end,
	GetAllGroups = function()
		return BackpackScript:GetAllGroups()
	end,
	GetToolGroup = function(tool)
		return BackpackScript:GetToolGroup(tool)
	end,
	RemoveToolGroup = function(tool)
		BackpackScript:RemoveToolGroup(tool)
	end,
	SetToolGroup = function(tool, groupName)
		BackpackScript:SetToolGroup(tool, groupName)
	end,
}
APIRemote.OnInvoke = function (name, data)
	assert(apifunctions[name], ("API Function \"%s\" doesn't exist."):format(tostring(name)))
	if apifunctions[name] then
		return apifunctions[name](table.unpack(data or {}))
	end
end

return BackpackScript

]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXFBB783C20ECF41C3A880BD72A7C4F6C1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Utility</string>
										<string name="ScriptGuid">{1359BBAA-8D6F-41B7-A690-93FE93D50465}</string>
										<ProtectedString name="Source"><![CDATA[--[[
		Filename: Utility.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Utility module for CoreScripts
--]]

------------------ CONSTANTS --------------------
local SELECTED_COLOR = Color3.fromRGB(0,162,255)
local NON_SELECTED_COLOR = Color3.fromRGB(78,84,96)

local ARROW_COLOR = Color3.fromRGB(204, 204, 204)
local ARROW_COLOR_HOVER = Color3.fromRGB(255, 255, 255)
local ARROW_COLOR_TOUCH = ARROW_COLOR_HOVER
local ARROW_COLOR_INACTIVE = Color3.fromRGB(150, 150, 150)

local SELECTED_LEFT_IMAGE = "rbxasset://textures/ui/Settings/Slider/SelectedBarLeft.png"
local NON_SELECTED_LEFT_IMAGE = "rbxasset://textures/ui/Settings/Slider/BarLeft.png"
local SELECTED_RIGHT_IMAGE = "rbxasset://textures/ui/Settings/Slider/SelectedBarRight.png"
local NON_SELECTED_RIGHT_IMAGE= "rbxasset://textures/ui/Settings/Slider/BarRight.png"

local CONTROLLER_SCROLL_DELTA = 0.2
local CONTROLLER_THUMBSTICK_DEADZONE = 0.8

local DROPDOWN_BG_TRANSPARENCY = 0.2

------------- SERVICES ----------------
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local CoreGui = game.Players.LocalPlayer.PlayerGui
local RobloxGui = CoreGui:WaitForChild("BackpackGui")
local ContextActionService = game:GetService("ContextActionService")
local VRService = game:GetService("VRService")

--------------- FLAGS ----------------

local success, result = pcall(function() return false end)
local FFlagUseNotificationsLocalization = success and result

------------------ VARIABLES --------------------
local tenFootInterfaceEnabled = false

----------- UTILITIES --------------
local Util = {}
do
	function Util.Create(instanceType)
		return function(data)
			local obj = Instance.new(instanceType)
			local parent = nil
			for k, v in pairs(data) do
				if type(k) == 'number' then
					v.Parent = obj
				elseif k == 'Parent' then
					parent = v
				else
					obj[k] = v
				end
			end
			if parent then
				obj.Parent = parent
			end
			return obj
		end
	end
end

local onResizedCallbacks = {}
setmetatable(onResizedCallbacks, { __mode = 'k' })

-- used by several guis to show no selection adorn
local noSelectionObject = Util.Create'ImageLabel'
{
	Image = "",
	BackgroundTransparency = 1
};


-- MATH --
function clamp(low, high, input)
	return math.max(low, math.min(high, input))
end

function ClampVector2(low, high, input)
	return Vector2.new(clamp(low.x, high.x, input.x), clamp(low.y, high.y, input.y))
end

---- TWEENZ ----
local function Linear(t, b, c, d)
	if t >= d then
		return b + c
	end

	return c*t/d + b
end

local function EaseOutQuad(t, b, c, d)
	if t >= d then
		return b + c
	end

	t = t/d
	return b - c*t*(t - 2)
end

local function EaseInOutQuad(t, b, c, d)
	if t >= d then
		return b + c
	end

	t = t/d
	if t < 1/2 then
		return 2*c*t*t + b
	end
	return b + c*(2*(2 - t)*t - 1)
end

function PropertyTweener(instance, prop, start, final, duration, easingFunc, cbFunc)
	local this = {}
	this.StartTime = tick()
	this.EndTime = this.StartTime + duration
	this.Cancelled = false

	local finished = false
	local percentComplete = 0

	local function finalize()
		if instance then
			instance[prop] = easingFunc(1, start, final - start, 1)
		end
		finished = true
		percentComplete = 1
		if cbFunc then
			cbFunc()
		end
	end

	-- Initial set
	instance[prop] = easingFunc(0, start, final - start, duration)
	coroutine.wrap(function()
		local now = tick()
		while now < this.EndTime and instance do
			if this.Cancelled then
				return
			end
			instance[prop] = easingFunc(now - this.StartTime, start, final - start, duration)
			percentComplete = clamp(0, 1, (now - this.StartTime) / duration)
			RunService.RenderStepped:wait()
			now = tick()
		end
		if this.Cancelled == false and instance then
			finalize()
		end
	end)()

	function this:GetFinal()
		return final
	end

	function this:GetPercentComplete()
		return percentComplete
	end

	function this:IsFinished()
		return finished
	end

	function this:Finish()
		if not finished then
			self:Cancel()
			finalize()
		end
	end

	function this:Cancel()
		this.Cancelled = true
	end

	return this
end

----------- CLASS DECLARATION --------------

local function CreateSignal()
	local sig = {}

	local mSignaler = Instance.new('BindableEvent')

	local mArgData = nil
	local mArgDataCount = nil

	function sig:fire(...)
		mArgData = {...}
		mArgDataCount = select('#', ...)
		mSignaler:Fire()
	end

	function sig:connect(f)
		if not f then error("connect(nil)", 2) end
		return mSignaler.Event:Connect(function()
			f(unpack(mArgData, 1, mArgDataCount))
		end)
	end

	function sig:wait()
		mSignaler.Event:wait()
		if not mArgData then
			error("Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
		end
		return unpack(mArgData, 1, mArgDataCount)
	end

	return sig
end

local function getViewportSize()
	while not workspace.CurrentCamera do
		workspace.Changed:wait()
	end

	-- ViewportSize is initally set to 1, 1 in Camera.cpp constructor.
	-- Also check against 0, 0 incase this is changed in the future.
	while workspace.CurrentCamera.ViewportSize == Vector2.new(0,0) or
		workspace.CurrentCamera.ViewportSize == Vector2.new(1,1) do
		workspace.CurrentCamera.Changed:wait()
	end

	return workspace.CurrentCamera.ViewportSize
end

local function isSmallTouchScreen()
	local viewportSize = getViewportSize()
	return UserInputService.TouchEnabled and (viewportSize.Y < 500 or viewportSize.X < 700)
end

local function isPortrait()
	local viewport = getViewportSize()
	return viewport.Y > viewport.X
end

local function isTenFootInterface()
	return tenFootInterfaceEnabled
end

local function usesSelectedObject()
	--VR does not use selected objects (in the same way as gamepad)
	if VRService.VREnabled then return false end
	--Touch does not use selected objects unless there's also a gamepad
	if UserInputService.TouchEnabled and not UserInputService.GamepadEnabled then return false end
	--PC with gamepad, console... does use selected objects
	return true
end

local function isPosOverGui(pos, gui, debug) -- does not account for rotation
	local ax, ay = gui.AbsolutePosition.x, gui.AbsolutePosition.y
	local sx, sy = gui.AbsoluteSize.x, gui.AbsoluteSize.y
	local bx, by = ax+sx, ay+sy

	return pos.x > ax and pos.x < bx and pos.y > ay and pos.y < by
end

local function isPosOverGuiWithClipping(pos, gui) -- isPosOverGui, accounts for clipping and visibility, does not account for rotation
	if not isPosOverGui(pos, gui) then
		return false
	end

	local clipping = false
	local check = gui
	while true do
		if check == nil or (not check:IsA'GuiObject' and not check:IsA'LayerCollector') then
			clipping = true
			if check and check:IsA'CoreGui' then
				clipping = false
			end
			break
		end

		if check:IsA'GuiObject' and not check.Visible then
			clipping = true
			break
		end
		if check:IsA'LayerCollector' or check.ClipsDescendants then
			if not isPosOverGui(pos, check) then
				clipping = true
				break
			end
		end

		check = check.Parent
	end

	return not clipping
end

local function areGuisIntersecting(a, b) -- does not account for rotation
	local aax, aay = a.AbsolutePosition.x, a.AbsolutePosition.y
	local asx, asy = a.AbsoluteSize.x, a.AbsoluteSize.y
	local abx, aby = aax+asx, aay+asy
	local bax, bay = b.AbsolutePosition.x, b.AbsolutePosition.y
	local bsx, bsy = b.AbsoluteSize.x, b.AbsoluteSize.y
	local bbx, bby = bax+bsx, bay+bsy

	local intersectingX = aax < bbx and abx > bax
	local intersectingY = aay < bby and aby > bay
	local intersecting = intersectingX and intersectingY

	return intersecting
end

local function isGuiVisible(gui, debug) -- true if any part of the gui is visible on the screen, considers clipping, does not account for rotation
	local clipping = false
	local check = gui
	while true do
		if check == nil or not check:IsA'GuiObject' and not check:IsA'LayerCollector' then
			clipping = true
			if check and check:IsA'CoreGui' then
				clipping = false
			end
			break
		end

		if check:IsA'GuiObject' and not check.Visible then
			clipping = true
			break
		end
		if check:IsA'LayerCollector' or check.ClipsDescendants then
			if not areGuisIntersecting(check, gui) then
				clipping = true
				break
			end
		end

		check = check.Parent
	end

	return not clipping
end

local function addHoverState(button, instance, onNormalButtonState, onHoverButtonState)
	local function onNormalButtonStateCallback()
        if button.Active then
            onNormalButtonState(instance)
        end
	end
	local function onHoverButtonStateCallback()
        if button.Active then
            onHoverButtonState(instance)
        end
	end

	button.MouseEnter:Connect(onHoverButtonStateCallback)
	button.SelectionGained:Connect(onHoverButtonStateCallback)
	button.MouseLeave:Connect(onNormalButtonStateCallback)
	button.SelectionLost:Connect(onNormalButtonStateCallback)

	onNormalButtonState(instance)
end

local function addOnResizedCallback(key, callback)
	onResizedCallbacks[key] = callback
	callback(getViewportSize(), isPortrait())
end

local gamepadSet = {
	[Enum.UserInputType.Gamepad1] = true;
	[Enum.UserInputType.Gamepad2] = true;
	[Enum.UserInputType.Gamepad3] = true;
	[Enum.UserInputType.Gamepad4] = true;
	[Enum.UserInputType.Gamepad5] = true;
	[Enum.UserInputType.Gamepad6] = true;
	[Enum.UserInputType.Gamepad7] = true;
	[Enum.UserInputType.Gamepad8] = true;
}

local function MakeDefaultButton(name, size, clickFunc, pageRef, hubRef)
	local SelectionOverrideObject = Util.Create'ImageLabel'
	{
		Image = "",
		BackgroundTransparency = 1,
	};

	local button = Util.Create'ImageButton'
	{
		Name = name .. "Button",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		AutoButtonColor = false,
		BackgroundTransparency = 1,
		Size = size,
		ZIndex = 2,
		SelectionImageObject = SelectionOverrideObject
	};

	local enabled = Util.Create'BoolValue'
	{
		Name = 'Enabled',
		Parent = button,
		Value = true
	}

	if clickFunc then
		button.MouseButton1Click:Connect(function()
			clickFunc(gamepadSet[UserInputService:GetLastInputType()] or false)
		end)
	end

	local function isPointerInput(inputObject)
		return inputObject.UserInputType == Enum.UserInputType.MouseMovement or inputObject.UserInputType == Enum.UserInputType.Touch
	end

	local rowRef = nil
	local function setRowRef(ref)
		rowRef = ref
	end

	local function selectButton()
		local hub = hubRef
		if hub == nil then
			if pageRef then
				hub = pageRef.HubRef
			end
		end

		if (hub and hub.Active) or hub == nil then
			button.Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButtonSelected.png"

			local scrollTo = button
			if rowRef then
				scrollTo = rowRef
			end
			if hub then
				hub:ScrollToFrame(scrollTo)
			end
		end
	end

	local function deselectButton()
		button.Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png"
	end

	button.InputBegan:Connect(function(inputObject)
		if button.Selectable and isPointerInput(inputObject) then
			selectButton()
		end
	end)
	button.InputEnded:Connect(function(inputObject)
		if button.Selectable and GuiService.SelectedCoreObject ~= button and isPointerInput(inputObject) then
			deselectButton()
		end
	end)


	button.SelectionGained:Connect(function()
		selectButton()
	end)
	button.SelectionLost:Connect(function()
		deselectButton()
	end)

	local guiServiceCon = GuiService.Changed:Connect(function(prop)
		if prop ~= "SelectedCoreObject" then return end
		if not usesSelectedObject() then return end

		if GuiService.SelectedCoreObject == nil or GuiService.SelectedCoreObject ~= button then
			deselectButton()
			return
		end

		if button.Selectable then
			selectButton()
		end
	end)

	return button, setRowRef
end

local function MakeButton(name, text, size, clickFunc, pageRef, hubRef)
	local button, setRowRef = MakeDefaultButton(name, size, clickFunc, pageRef, hubRef)

	local textLabel = Util.Create'TextLabel'
	{
		Name = name .. "TextLabel",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, -8),
		Position = UDim2.new(0,0,0,0),
		TextColor3 = Color3.fromRGB(255,255,255),
		TextYAlignment = Enum.TextYAlignment.Center,
		Font = Enum.Font.SourceSansBold,
		TextSize = 24,
		Text = text,
		TextScaled = true,
		TextWrapped = true,
		ZIndex = 2,
		Parent = button
	};
	local constraint = Instance.new("UITextSizeConstraint",textLabel)

	if isSmallTouchScreen() then
		textLabel.TextSize = 18
	elseif isTenFootInterface() then
		textLabel.TextSize = 36
	end
	constraint.MaxTextSize = textLabel.TextSize

	return button, textLabel, setRowRef
end

local function MakeImageButton(name, image, size, imageSize, clickFunc, pageRef, hubRef)
	local button, setRowRef = MakeDefaultButton(name, size, clickFunc, pageRef, hubRef)

	local imageLabel = Util.Create'ImageLabel'
	{
		Name = name .. "ImageLabel",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = imageSize,
		Position = UDim2.new(0.5, 0, 0.5, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		Image = image,
		ZIndex = 2,
		Parent = button
	};

	return button, imageLabel, setRowRef
end

local function AddButtonRow(pageToAddTo, name, text, size, clickFunc, hubRef)
	local button, textLabel, setRowRef = MakeButton(name, text, size, clickFunc, pageToAddTo, hubRef)
	local row = Util.Create'Frame'
	{
		Name = name .. "Row",
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, size.Y.Scale, size.Y.Offset),
		Parent = pageToAddTo.Page
	}
	button.Parent = row
	button.AnchorPoint = Vector2.new(1, 0)
	button.Position = UDim2.new(1, -20, 0, 0)
	return row, button, textLabel, setRowRef
end

local function CreateDropDown(dropDownStringTable, startPosition, settingsHub)
	-------------------- CONSTANTS ------------------------
	local DEFAULT_DROPDOWN_TEXT = "Choose One"
	local SCROLLING_FRAME_PIXEL_OFFSET = 25
	local SELECTION_TEXT_COLOR_NORMAL = Color3.fromRGB(178,178,178)
	local SELECTION_TEXT_COLOR_NORMAL_VR = Color3.fromRGB(229,229,229)
	local SELECTION_TEXT_COLOR_HIGHLIGHTED = Color3.fromRGB(255,255,255)

	-------------------- VARIABLES ------------------------
	local lastSelectedCoreObject = nil

	-------------------- SETUP ------------------------
	local this = {}
	this.CurrentIndex = nil

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	if type(dropDownStringTable) ~= "table" then
		error("CreateDropDown dropDownStringTable (first arg) is not a table", 2)
		return this
	end

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	local interactable = true
	local guid = HttpService:GenerateGUID(false)
	local dropDownButtonEnabled
	local lastStringTable = dropDownStringTable

	----------------- GUI SETUP ------------------------
	local DropDownFullscreenFrame = Util.Create'ImageButton'
	{
		Name = "DropDownFullscreenFrame",
		BackgroundTransparency = DROPDOWN_BG_TRANSPARENCY,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = Color3.fromRGB(0,0,0),
		ZIndex = 10,
		Active = true,
		Visible = false,
		Selectable = false,
		AutoButtonColor = false,
		Parent = CoreGui.RobloxGui
	};

	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			DropDownFullscreenFrame.Parent = Panel3D.Get("SettingsMenu"):GetGUI()
			DropDownFullscreenFrame.BackgroundTransparency = 1
		else
			DropDownFullscreenFrame.Parent = CoreGui.RobloxGui
			DropDownFullscreenFrame.BackgroundTransparency = DROPDOWN_BG_TRANSPARENCY
		end

		--Force the gui to update, but only if onVREnabled is fired later on
		if this.UpdateDropDownList then
			this:UpdateDropDownList(lastStringTable)
		end
	end
	VRService.Changed:Connect(onVREnabled)
	onVREnabled("VREnabled")

	local DropDownSelectionFrame = Util.Create'ImageLabel'
	{
		Name = "DropDownSelectionFrame",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		BackgroundTransparency = 1,
		Size = UDim2.new(0.6, 0, 0.9, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		ZIndex = 10,
		Parent = DropDownFullscreenFrame
	};

	local DropDownScrollingFrame = Util.Create'ScrollingFrame'
	{
		Name = "DropDownScrollingFrame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, -20, 1, -SCROLLING_FRAME_PIXEL_OFFSET),
		Position = UDim2.new(0, 10, 0, 10),
		ZIndex = 10,
		Parent = DropDownSelectionFrame
	};

	local guiServiceChangeCon = nil
	local active = false
	local hideDropDownSelection = function(name, inputState)
		if name ~= nil and inputState ~= Enum.UserInputState.Begin then return end
		this.DropDownFrame.Selectable = interactable

		--Make sure to set the hub to Active again so selecting the
		--dropdown button will highlight it
		settingsHub:SetActive(true)

		if DropDownFullscreenFrame.Visible and usesSelectedObject() then
			GuiService.SelectedCoreObject = lastSelectedCoreObject
		end
		DropDownFullscreenFrame.Visible = false
		if guiServiceChangeCon then guiServiceChangeCon:Disconnect() end
		ContextActionService:UnbindAction(guid .. "Action")
		ContextActionService:UnbindAction(guid .. "FreezeAction")

		dropDownButtonEnabled.Value = interactable
		active = false

		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(DropDownFullscreenFrame, 0)
		end
	end
	local noOpFunc = function() end

	local DropDownFrameClicked = function()
		if not interactable then return end

		this.DropDownFrame.Selectable = false
		active = true

		DropDownFullscreenFrame.Visible = true
		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(DropDownFullscreenFrame, 0.5)
		end

		lastSelectedCoreObject = this.DropDownFrame
		if this.CurrentIndex and this.CurrentIndex > 0 then
			GuiService.SelectedCoreObject = this.Selections[this.CurrentIndex]
		end

		guiServiceChangeCon = GuiService:GetPropertyChangedSignal("SelectedCoreObject"):Connect(function()
			for i = 1, #this.Selections do
				if GuiService.SelectedCoreObject == this.Selections[i] then
					this.Selections[i].TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
				else
					this.Selections[i].TextColor3 = VRService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL
				end
			end
		end)

		ContextActionService:BindActionAtPriority(guid .. "FreezeAction", noOpFunc, false, Enum.ContextActionPriority.High.Value, Enum.UserInputType.Keyboard, Enum.UserInputType.Gamepad1)
		ContextActionService:BindActionAtPriority(guid .. "Action", hideDropDownSelection, false, Enum.ContextActionPriority.High.Value, Enum.KeyCode.ButtonB, Enum.KeyCode.Escape)

		settingsHub:SetActive(false)

		dropDownButtonEnabled.Value = false
	end

	local dropDownFrameSize = UDim2.new(0.6, 0, 0, 50)
	this.DropDownFrame = MakeButton("DropDownFrame", DEFAULT_DROPDOWN_TEXT, dropDownFrameSize, DropDownFrameClicked, nil, settingsHub)
	this.DropDownFrame.Position = UDim2.new(1, 0, 0.5, 0)
	this.DropDownFrame.AnchorPoint = Vector2.new(1, 0.5)

	dropDownButtonEnabled = this.DropDownFrame.Enabled
	local selectedTextLabel = this.DropDownFrame.DropDownFrameTextLabel
	selectedTextLabel.Position = UDim2.new(0, 15, 0, 0)
	selectedTextLabel.Size = UDim2.new(1, -50, 1, -8)
	selectedTextLabel.ClipsDescendants = true
	selectedTextLabel.TextXAlignment = Enum.TextXAlignment.Left
	local dropDownImage = Util.Create'ImageLabel'
	{
		Name = "DropDownImage",
		Image = "rbxasset://textures/ui/Settings/DropDown/DropDown.png",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(1, 0.5),
		Size = UDim2.new(0,15,0,10),
		Position = UDim2.new(1,-12,0.5,0),
		ZIndex = 2,
		Parent = this.DropDownFrame
	};
	this.DropDownImage = dropDownImage


	---------------------- FUNCTIONS -----------------------------------
	local function setSelection(index)
		local shouldFireChanged = false
		for i, selectionLabel in pairs(this.Selections) do
			if i == index then
				selectedTextLabel.Text = selectionLabel.Text
				this.CurrentIndex = i

				shouldFireChanged = true
			end
		end

		if shouldFireChanged then
			indexChangedEvent:Fire(index)
		end
	end

	local function setSelectionByValue(value)
		local shouldFireChanged = false
		for i, selectionLabel in pairs(this.Selections) do
			if selectionLabel.Text == value then
				selectedTextLabel.Text = selectionLabel.Text
				this.CurrentIndex = i

				shouldFireChanged = true
			end
		end

		if shouldFireChanged then
			indexChangedEvent:Fire(this.CurrentIndex)
		end
		return shouldFireChanged
	end

	local enterIsDown = false
	local function processInput(input)
		if input.UserInputState == Enum.UserInputState.Begin then
			if input.KeyCode == Enum.KeyCode.Return then
				if GuiService.SelectedCoreObject == this.DropDownFrame or this.SelectionInfo and this.SelectionInfo[GuiService.SelectedCoreObject] then
					enterIsDown = true
				end
			end
		elseif input.UserInputState == Enum.UserInputState.End then
			if input.KeyCode == Enum.KeyCode.Return and enterIsDown then
				enterIsDown = false
				if GuiService.SelectedCoreObject == this.DropDownFrame then
					DropDownFrameClicked()
				elseif this.SelectionInfo and this.SelectionInfo[GuiService.SelectedCoreObject] then
					local info = this.SelectionInfo[GuiService.SelectedCoreObject]
					info.Clicked()
				end
			end
		end
	end

	local function setIsFaded(isFaded)
		if isFaded then
			this.DropDownFrame.DropDownFrameTextLabel.TextTransparency = 0.5
			this.DropDownFrame.ImageTransparency = 0.5
			this.DropDownImage.ImageTransparency = 0.5
		else
			this.DropDownFrame.DropDownFrameTextLabel.TextTransparency = 0
			this.DropDownFrame.ImageTransparency = 0
			this.DropDownImage.ImageTransparency = 0
		end
	end


	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.IndexChanged = indexChangedEvent.Event

	function this:SetSelectionIndex(newIndex)
		setSelection(newIndex)
	end

	function this:SetSelectionByValue(value)
		return setSelectionByValue(value)
	end

	function this:ResetSelectionIndex()
		this.CurrentIndex = nil
		selectedTextLabel.Text = DEFAULT_DROPDOWN_TEXT
		hideDropDownSelection()
	end

	function this:GetSelectedIndex()
		return this.CurrentIndex
	end

	function this:SetZIndex(newZIndex)
		this.DropDownFrame.ZIndex = newZIndex
		dropDownImage.ZIndex = newZIndex
		selectedTextLabel.ZIndex = newZIndex
	end

	function this:SetInteractable(value)
		interactable = value
		this.DropDownFrame.Selectable = interactable

		if not interactable then
			hideDropDownSelection()
			setIsFaded(VRService.VREnabled)
			if not VRService.VREnabled then
				this:SetZIndex(1)
			end
		else
			setIsFaded(false)
			if not VRService.VREnabled then
				this:SetZIndex(2)
			end
		end

		dropDownButtonEnabled.Value = value and not active
	end


	function this:UpdateDropDownList(dropDownStringTable)
		lastStringTable = dropDownStringTable

		if this.Selections then
			for i = 1, #this.Selections do
				this.Selections[i]:Destroy()
			end
		end

		this.Selections = {}
		this.SelectionInfo = {}

		local vrEnabled = VRService.VREnabled
		local font = vrEnabled and Enum.Font.SourceSansBold or Enum.Font.SourceSans
		local textSize = vrEnabled and 36 or 24

		local itemHeight = vrEnabled and 70 or 50
		local itemSpacing = itemHeight + 1

		local dropDownWidth = vrEnabled and 600 or 400

		for i,v in pairs(dropDownStringTable) do
			local SelectionOverrideObject =	Util.Create'Frame'
			{
				BackgroundTransparency = 0.7,
				BorderSizePixel = 0,
				Size = UDim2.new(1, 0, 1, 0)
			};

			local nextSelection = Util.Create'TextButton'
			{
				Name = "Selection" .. tostring(i),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				AutoButtonColor = false,
				Size = UDim2.new(1, -28, 0, itemHeight),
				Position = UDim2.new(0,14,0, (i - 1) * itemSpacing),
				TextColor3 = VRService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL,
				Font = font,
				TextSize = textSize,
				Text = v,
				ZIndex = 10,
				SelectionImageObject = SelectionOverrideObject,
				Parent = DropDownScrollingFrame
			};

			if i == startPosition then
				this.CurrentIndex = i
				selectedTextLabel.Text = v
				nextSelection.TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
			elseif not startPosition and i == 1 then
				nextSelection.TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
			end

			local clicked = function()
				selectedTextLabel.Text = nextSelection.Text
				hideDropDownSelection()
				this.CurrentIndex = i
				indexChangedEvent:Fire(i)
			end

			nextSelection.MouseButton1Click:Connect(clicked)

			nextSelection.MouseEnter:Connect(function()
				if usesSelectedObject() then
					GuiService.SelectedCoreObject = nextSelection
				end
			end)

			this.Selections[i] = nextSelection
			this.SelectionInfo[nextSelection] = {Clicked = clicked}
		end

		GuiService:RemoveSelectionGroup(guid)
		GuiService:AddSelectionTuple(guid, unpack(this.Selections))

		DropDownScrollingFrame.CanvasSize = UDim2.new(1,-20,0,#dropDownStringTable * itemSpacing)

		local function updateDropDownSize()
			if DropDownScrollingFrame.CanvasSize.Y.Offset < (DropDownFullscreenFrame.AbsoluteSize.Y - 10) then
				DropDownSelectionFrame.Size = UDim2.new(0, dropDownWidth,
														0,DropDownScrollingFrame.CanvasSize.Y.Offset + SCROLLING_FRAME_PIXEL_OFFSET)
			else
				DropDownSelectionFrame.Size = UDim2.new(0, dropDownWidth, 0.9, 0)
			end
		end

		DropDownFullscreenFrame.Changed:Connect(function(prop)
			if prop ~= "AbsoluteSize" then return end
			updateDropDownSize()
		end)

		updateDropDownSize()
	end

	----------------------- CONNECTIONS/SETUP --------------------------------
	this:UpdateDropDownList(dropDownStringTable)

	DropDownFullscreenFrame.MouseButton1Click:Connect(hideDropDownSelection)

	settingsHub.PoppedMenu:Connect(function(poppedMenu)
		if poppedMenu == DropDownFullscreenFrame then
			hideDropDownSelection()
		end
	end)

	return this
end


local function CreateSelector(selectionStringTable, startPosition)

	-------------------- VARIABLES ------------------------
	local lastInputDirection = 0
	local TweenTime = 0.15

	-------------------- SETUP ------------------------
	local this = {}
	this.HubRef = nil

	if type(selectionStringTable) ~= "table" then
		error("CreateSelector selectionStringTable (first arg) is not a table", 2)
		return this
	end

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	local interactable = true

	this.CurrentIndex = 0

	----------------- GUI SETUP ------------------------
	this.SelectorFrame = Util.Create'ImageButton'
	{
		Name = "Selector",
		Image = "",
		AutoButtonColor = false,
		NextSelectionLeft = this.SelectorFrame,
		NextSelectionRight = this.SelectorFrame,
		BackgroundTransparency = 1,
		Size = UDim2.new(0.6,0,0,50),
		Position = UDim2.new(1, 0, 0.5, 0),
		AnchorPoint = Vector2.new(1, 0.5),
		ZIndex = 2,
		SelectionImageObject = noSelectionObject
	};

	local leftButton = Util.Create'ImageButton'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0, 0.5),
		Position = UDim2.new(0,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = this.SelectorFrame
	};
	local rightButton = Util.Create'ImageButton'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(1, 0.5),
		Position = UDim2.new(1,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = this.SelectorFrame
	};

	local leftButtonImage = Util.Create'ImageLabel'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Left.png",
		ImageColor3 = ARROW_COLOR,
		ZIndex = 4,
		Parent = leftButton
	};
	local rightButtonImage = Util.Create'ImageLabel'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Right.png",
		ImageColor3 = ARROW_COLOR,
		ZIndex = 4,
		Parent = rightButton
	};
	if not UserInputService.TouchEnabled then
		local applyNormal, applyHover =
			function(instance) instance.ImageColor3 = ARROW_COLOR end,
			function(instance) instance.ImageColor3 = ARROW_COLOR_HOVER end
		addHoverState(leftButton, leftButtonImage, applyNormal, applyHover)
		addHoverState(rightButton, rightButtonImage, applyNormal, applyHover)
	end


	this.Selections = {}
	local isSelectionLabelVisible = {}
	local isAutoSelectButton = {}

	local autoSelectButton = Util.Create'ImageButton'{
		Name = 'AutoSelectButton',
		BackgroundTransparency = 1,
		Image = '',
		Position = UDim2.new(0, leftButton.Size.X.Offset, 0, 0),
		Size = UDim2.new(1, leftButton.Size.X.Offset * -2, 1, 0),
		Parent = this.SelectorFrame,
		ZIndex = 2,
		SelectionImageObject = noSelectionObject
	}
	autoSelectButton.MouseButton1Click:Connect(function()
		if not interactable then return end
		if #this.Selections <= 1 then return end
		local newIndex = this.CurrentIndex + 1
		if newIndex > #this.Selections then
			newIndex = 1
		end
		this:SetSelectionIndex(newIndex)
		if usesSelectedObject() then
			GuiService.SelectedCoreObject = this.SelectorFrame
		end
	end)
	isAutoSelectButton[autoSelectButton] = true

	---------------------- FUNCTIONS -----------------------------------
	local function setSelection(index, direction)
		for i, selectionLabel in pairs(this.Selections) do
			local isSelected = (i == index)

			local leftButtonUDim = UDim2.new(0,leftButton.Size.X.Offset,0,0)
			local tweenPos = UDim2.new(0,leftButton.Size.X.Offset * direction * 3,0,0)

			if isSelectionLabelVisible[selectionLabel] then
				tweenPos = UDim2.new(0,leftButton.Size.X.Offset * -direction * 3,0,0)
			end

			if tweenPos.X.Offset < 0 then
				tweenPos = UDim2.new(0,tweenPos.X.Offset + (selectionLabel.AbsoluteSize.X/4),0,0)
			end

			if isSelected then
				isSelectionLabelVisible[selectionLabel] = true
				selectionLabel.Position = tweenPos
				selectionLabel.Visible = true
				PropertyTweener(selectionLabel, "TextTransparency", 1, 0, TweenTime * 1.1, EaseOutQuad)
				if selectionLabel:IsDescendantOf(game) then
					selectionLabel:TweenPosition(leftButtonUDim, Enum.EasingDirection.In, Enum.EasingStyle.Quad, TweenTime, true)
				else
					selectionLabel.Position = leftButtonUDim
				end
				this.CurrentIndex = i
				indexChangedEvent:Fire(index)
			elseif isSelectionLabelVisible[selectionLabel] then
				isSelectionLabelVisible[selectionLabel] = false
				PropertyTweener(selectionLabel, "TextTransparency", 0, 1, TweenTime * 1.1, EaseOutQuad)
				if selectionLabel:IsDescendantOf(game) then
					selectionLabel:TweenPosition(tweenPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, TweenTime * 0.9, true)
				else
					selectionLabel.Position = UDim2.new(tweenPos)
				end
			end
		end
	end

	local function stepFunc(inputObject, step)
		if not interactable then return end

		if inputObject ~= nil and inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 and
			inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Gamepad2 and
			inputObject.UserInputType ~= Enum.UserInputType.Gamepad3 and inputObject.UserInputType ~= Enum.UserInputType.Gamepad4 and
			inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end

		if usesSelectedObject() then
			GuiService.SelectedCoreObject = this.SelectorFrame
		end

		local newIndex = step + this.CurrentIndex

		local direction = 0
		if newIndex > this.CurrentIndex then
			direction = 1
		else
			direction = -1
		end

		if newIndex > #this.Selections then
			newIndex = 1
		elseif newIndex < 1 then
			newIndex = #this.Selections
		end

		setSelection(newIndex, direction)
	end

	local guiServiceCon = nil
	local function connectToGuiService()
		guiServiceCon = GuiService:GetPropertyChangedSignal("SelectedCoreObject"):Connect(function()
			if #this.Selections <= 0 then
				return
			end

			if GuiService.SelectedCoreObject == this.SelectorFrame then
				this.Selections[this.CurrentIndex].TextTransparency = 0
			else
				if GuiService.SelectedCoreObject ~= nil and isAutoSelectButton[GuiService.SelectedCoreObject] then
					if VRService.VREnabled then
						this.Selections[this.CurrentIndex].TextTransparency = 0
					else
						GuiService.SelectedCoreObject = this.SelectorFrame
					end
				else
					this.Selections[this.CurrentIndex].TextTransparency = 0.5
				end
			end
		end)
	end

	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.IndexChanged = indexChangedEvent.Event

	function this:SetSelectionIndex(newIndex)
		setSelection(newIndex, 1)
	end

	function this:GetSelectedIndex()
		return this.CurrentIndex
	end

	function this:SetZIndex(newZIndex)
		leftButton.ZIndex = newZIndex
		rightButton.ZIndex = newZIndex
		leftButtonImage.ZIndex = newZIndex
		rightButtonImage.ZIndex = newZIndex

		for i = 1, #this.Selections do
			this.Selections[i].ZIndex = newZIndex
		end
	end

	function this:SetInteractable(value)
		interactable = value
		this.SelectorFrame.Selectable = interactable

		leftButton.Active = interactable
		rightButton.Active = interactable

		if not interactable then
			for i, selectionLabel in pairs(this.Selections) do
				selectionLabel.TextColor3 = Color3.fromRGB(49, 49, 49)
			end
			leftButtonImage.ImageColor3 = ARROW_COLOR_INACTIVE
            rightButtonImage.ImageColor3 = ARROW_COLOR_INACTIVE
		else
			for i, selectionLabel in pairs(this.Selections) do
				selectionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			end
			leftButtonImage.ImageColor3 = ARROW_COLOR
            rightButtonImage.ImageColor3 = ARROW_COLOR
		end
	end

	function this:UpdateOptions(selectionStringTable)
		for i,v in pairs(this.Selections) do
			v:Destroy()
		end

		isSelectionLabelVisible = {}
		this.Selections = {}

		for i,v in pairs(selectionStringTable) do
			local nextSelection = Util.Create'TextLabel'
			{
				Name = "Selection" .. tostring(i),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Size = UDim2.new(1,leftButton.Size.X.Offset * -2, 1, 0),
				Position = UDim2.new(1,0,0,0),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextYAlignment = Enum.TextYAlignment.Center,
				TextTransparency = 0.5,
				Font = Enum.Font.SourceSans,
				TextSize = 24,
				Text = v,
				ZIndex = 2,
				Visible = false,
				Parent = this.SelectorFrame
			};
			if isTenFootInterface() then
				nextSelection.TextSize = 36
			end

			if i == startPosition then
				this.CurrentIndex = i
				nextSelection.Position = UDim2.new(0,leftButton.Size.X.Offset,0,0)
				nextSelection.Visible = true

				isSelectionLabelVisible[nextSelection] = true
			else
				isSelectionLabelVisible[nextSelection] = false
			end

			this.Selections[i] = nextSelection
		end

		local hasMoreThanOneSelection = #this.Selections > 1
		leftButton.Visible = hasMoreThanOneSelection
		rightButton.Visible = hasMoreThanOneSelection
	end

	--------------------- SETUP -----------------------
	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		local vrEnabled = VRService.VREnabled
		leftButton.Selectable = vrEnabled
		rightButton.Selectable = vrEnabled
		autoSelectButton.Selectable = vrEnabled
	end
	VRService.Changed:Connect(onVREnabled)
	onVREnabled("VREnabled")

	leftButton.InputBegan:Connect(function(inputObject)
		if inputObject.UserInputType == Enum.UserInputType.Touch then
			stepFunc(nil, -1)
		end
	end)
	leftButton.MouseButton1Click:Connect(function()
		if not UserInputService.TouchEnabled then
			stepFunc(nil, -1)
		end
	end)
	rightButton.InputBegan:Connect(function(inputObject)
		if inputObject.UserInputType == Enum.UserInputType.Touch then
			stepFunc(nil, 1)
		end
	end)
	rightButton.MouseButton1Click:Connect(function()
		if not UserInputService.TouchEnabled then
			stepFunc(nil, 1)
		end
	end)

	local isInTree = true
	this:UpdateOptions(selectionStringTable)

	UserInputService.InputBegan:Connect(function(inputObject)
		if not interactable then return end
		if not isInTree then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		if GuiService.SelectedCoreObject ~= this.SelectorFrame then return end

		if inputObject.KeyCode == Enum.KeyCode.DPadLeft or inputObject.KeyCode == Enum.KeyCode.Left or inputObject.KeyCode == Enum.KeyCode.A then
			stepFunc(inputObject, -1)
		elseif inputObject.KeyCode == Enum.KeyCode.DPadRight or inputObject.KeyCode == Enum.KeyCode.Right or inputObject.KeyCode == Enum.KeyCode.D then
			stepFunc(inputObject, 1)
		end
	end)

	UserInputService.InputChanged:Connect(function(inputObject)
		if not interactable then return end
		if not isInTree then lastInputDirection = 0 return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 then return end

		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SelectorFrame.Parent) then return end

		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end


		if inputObject.Position.X > CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X > 0 and lastInputDirection ~= 1 then
			lastInputDirection = 1
			stepFunc(inputObject, lastInputDirection)
		elseif inputObject.Position.X < -CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X < 0 and lastInputDirection ~= -1 then
			lastInputDirection = -1
			stepFunc(inputObject, lastInputDirection)
		elseif math.abs(inputObject.Position.X) < CONTROLLER_THUMBSTICK_DEADZONE then
			lastInputDirection = 0
		end
	end)

	this.SelectorFrame.AncestryChanged:Connect(function(child, parent)
		isInTree = parent
		if not isInTree then
			if guiServiceCon then guiServiceCon:Disconnect() end
		else
			connectToGuiService()
		end
	end)

	local function onResized(viewportSize, portrait)
		local textSize = 0
		if portrait then
			textSize = 16
		else
			textSize = isTenFootInterface() and 36 or 24
		end

		for i, selection in pairs(this.Selections) do
			selection.TextSize = textSize
		end
	end
	addOnResizedCallback(this.SelectorFrame, onResized)

	connectToGuiService()

	return this
end

local function ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
	local parent = CoreGui.RobloxGui
	if parent:FindFirstChild("AlertViewFullScreen") then return end

	--Declare AlertViewBacking so onVREnabled can take it as an upvalue
	local AlertViewBacking = nil

	--Handle VR toggle while alert is open
	--Future consideration: maybe rebuild gui when VR toggles mid-game; right now only subpaneling is handled rather than visual style
	local function onVREnabled(prop)
		if prop ~= "VREnabled" then return end
		local Panel3D, settingsPanel = nil, nil
		if VRService.VREnabled then
			Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			settingsPanel = Panel3D.Get("SettingsMenu")
			parent = settingsPanel:GetGUI()
		else
			parent = CoreGui.RobloxGui
		end
		if AlertViewBacking and AlertViewBacking.Parent ~= nil then
			AlertViewBacking.Parent = parent
			if VRService.VREnabled then
				settingsPanel:SetSubpanelDepth(AlertViewBacking, 0.5)
			end
		end
	end
	local vrEnabledConn = VRService.Changed:Connect(onVREnabled)

	local NON_SELECTED_TEXT_COLOR = Color3.fromRGB(59, 166, 241)
	local SELECTED_TEXT_COLOR = Color3.fromRGB(255, 255, 255)

	AlertViewBacking = Util.Create'ImageLabel'
	{
		Name = "AlertViewBacking",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		BackgroundTransparency = 1,

		ImageTransparency = 1,
		Size = UDim2.new(0, 400, 0, 350),
		Position = UDim2.new(0.5, -200, 0.5, -175),
		ZIndex = 9,
		Parent = parent
	};
	onVREnabled("VREnabled")
	if hasBackground or VRService.VREnabled then
		AlertViewBacking.ImageTransparency = 0
	else
		AlertViewBacking.Size = UDim2.new(0.8, 0, 0, 350)
		AlertViewBacking.Position = UDim2.new(0.1, 0, 0.1, 0)
	end

	if CoreGui.RobloxGui.AbsoluteSize.Y <= AlertViewBacking.Size.Y.Offset then
		AlertViewBacking.Size = UDim2.new(AlertViewBacking.Size.X.Scale, AlertViewBacking.Size.X.Offset,
											AlertViewBacking.Size.Y.Scale, CoreGui.RobloxGui.AbsoluteSize.Y)
		AlertViewBacking.Position = UDim2.new(AlertViewBacking.Position.X.Scale, -AlertViewBacking.Size.X.Offset/2, 0.5, -AlertViewBacking.Size.Y.Offset/2)
	end

	local AlertViewText = Util.Create'TextLabel'
	{
		Name = "AlertViewText",
		BackgroundTransparency = 1,
		Size = UDim2.new(0.95, 0, 0.6, 0),
		Position = UDim2.new(0.025, 0, 0.05, 0),
		Font = Enum.Font.SourceSansBold,
		TextSize = 36,
		Text = alertMessage,
		TextWrapped = true,
		TextColor3 = Color3.fromRGB(255, 255, 255),
		TextXAlignment = Enum.TextXAlignment.Center,
		TextYAlignment = Enum.TextYAlignment.Center,
		ZIndex = 10,
		Parent = AlertViewBacking
	};

	local SelectionOverrideObject = Util.Create'ImageLabel'
	{
		Image = "",
		BackgroundTransparency = 1
	};

	local removeId = HttpService:GenerateGUID(false)

	local destroyAlert = function(actionName, inputState)
		if VRService.VREnabled and (inputState == Enum.UserInputState.Begin or inputState == Enum.UserInputState.Cancel) then
			return
		end
		if not AlertViewBacking then
			return
		end
		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(AlertViewBacking, 0)
		end
		AlertViewBacking:Destroy()
		AlertViewBacking = nil
		if okPressedFunc then
			okPressedFunc()
		end
		ContextActionService:UnbindAction(removeId)
		GuiService.SelectedCoreObject = nil
		if settingsHub then
			settingsHub:ShowBar()
		end
		if vrEnabledConn then
			vrEnabledConn:Disconnect()
		end
	end

	local AlertViewButtonSize = UDim2.new(1, -20, 0, 60)
	local AlertViewButtonPosition = UDim2.new(0, 10, 0.65, 0)
	if not hasBackground then
		AlertViewButtonSize = UDim2.new(0, 200, 0, 50)
		AlertViewButtonPosition = UDim2.new(0.5, -100, 0.65, 0)
	end

	local AlertViewButton, AlertViewText = MakeButton("AlertViewButton", okButtonText, AlertViewButtonSize, destroyAlert)
	AlertViewButton.Position = AlertViewButtonPosition
	AlertViewButton.NextSelectionLeft = AlertViewButton
	AlertViewButton.NextSelectionRight = AlertViewButton
	AlertViewButton.NextSelectionUp = AlertViewButton
	AlertViewButton.NextSelectionDown = AlertViewButton
	AlertViewButton.ZIndex = 9
	AlertViewText.ZIndex = AlertViewButton.ZIndex
	AlertViewButton.Parent = AlertViewBacking

	if usesSelectedObject() then
		GuiService.SelectedCoreObject = AlertViewButton
	end

	GuiService.SelectedCoreObject = AlertViewButton

	ContextActionService:BindActionAtPriority(removeId, destroyAlert, false, Enum.ContextActionPriority.High.Value, Enum.KeyCode.Escape, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonA)

	if settingsHub and not VRService.VREnabled then
		settingsHub:HideBar()
		settingsHub.Pages.CurrentPage:Hide(1, 1)
	end
end

local function CreateNewSlider(numOfSteps, startStep, minStep)
	-------------------- SETUP ------------------------
	local this = {}

	local spacing = 4
	local initialSpacing = 8
	local steps = tonumber(numOfSteps)
	local currentStep = startStep

	local lastInputDirection = 0
	local timeAtLastInput = nil

	local interactable = true

	local renderStepBindName = HttpService:GenerateGUID(false)

	-- this is done to prevent using these values below (trying to keep the variables consistent)
	numOfSteps = ""
	startStep = ""

	if steps <= 0 then
		error("CreateNewSlider failed because numOfSteps (first arg) is 0 or negative, please supply a positive integer", 2)
		return
	end

	local valueChangedEvent = Instance.new("BindableEvent")
	valueChangedEvent.Name = "ValueChanged"

	----------------- GUI SETUP ------------------------
	this.SliderFrame = Util.Create'ImageButton'
	{
		Name = "Slider",
		Image = "",
		AutoButtonColor = false,
		NextSelectionLeft = this.SliderFrame,
		NextSelectionRight = this.SliderFrame,
		BackgroundTransparency = 1,
		Size = UDim2.new(0.6, 0, 0, 50),
		Position = UDim2.new(1, 0, 0.5, 0),
		AnchorPoint = Vector2.new(1, 0.5),
		SelectionImageObject = noSelectionObject,
		ZIndex = 2
	};

	this.StepsContainer = Util.Create "Frame"
	{
		Name = "StepsContainer",
		Position = UDim2.new(0.5, 0, 0.5, 0),
		Size = UDim2.new(1, -100, 1, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		Parent = this.SliderFrame,
	}

	local leftButton = Util.Create'ImageButton'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0, 0.5),
		Position = UDim2.new(0,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Active = true,
		Parent = this.SliderFrame
	};
	local rightButton = Util.Create'ImageButton'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(1, 0.5),
		Position = UDim2.new(1,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Active = true,
		Parent = this.SliderFrame
	};

	local leftButtonImage = Util.Create'ImageLabel'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,30,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Less.png",
		ZIndex = 4,
		Parent = leftButton,
		ImageColor3 = UserInputService.TouchEnabled and ARROW_COLOR_TOUCH or ARROW_COLOR
	};
	local rightButtonImage = Util.Create'ImageLabel'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,30,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/More.png",
		ZIndex = 4,
		Parent = rightButton,
		ImageColor3 = UserInputService.TouchEnabled and ARROW_COLOR_TOUCH or ARROW_COLOR
	};
	if not UserInputService.TouchEnabled then
		local onNormalButtonState, onHoverButtonState =
			function(instance) instance.ImageColor3 = ARROW_COLOR end,
			function(instance) instance.ImageColor3 = ARROW_COLOR_HOVER end

		addHoverState(leftButton, leftButtonImage, onNormalButtonState, onHoverButtonState)
		addHoverState(rightButton, rightButtonImage, onNormalButtonState, onHoverButtonState)
	end

	this.Steps = {}
	local stepXSize = 35
	if isSmallTouchScreen() then
		stepXSize = 25
	end

	local stepXScale = 1 / steps
	stepXSize = 0

	for i = 1, steps do
		local nextStep = Util.Create'ImageButton'
		{
			Name = "Step" .. tostring(i),
			BackgroundColor3 = SELECTED_COLOR,
			BackgroundTransparency = 0.36,
			BorderSizePixel = 0,
			AutoButtonColor = false,
			Active = false,
			AnchorPoint = Vector2.new(0, 0.5),
			Position = UDim2.new((i - 1) * stepXScale, spacing / 2, 0.5, 0),
			Size =  UDim2.new(stepXScale,-spacing, 24 / 50, 0),
			Image =  "",
			ZIndex = 3,
			Selectable = false,
			ImageTransparency = 0.36,
			Parent = this.StepsContainer,
			SelectionImageObject = noSelectionObject
		};

		if i > currentStep then
			nextStep.BackgroundColor3 = NON_SELECTED_COLOR
		end

		if i == 1 or i == steps then
			nextStep.BackgroundTransparency = 1
			nextStep.ScaleType = Enum.ScaleType.Slice
			nextStep.SliceCenter = Rect.new(3,3,32,21)

			if i <= currentStep then
				if i == 1 then
					nextStep.Image = SELECTED_LEFT_IMAGE
				else
					nextStep.Image = SELECTED_RIGHT_IMAGE
				end
			else
				if i == 1 then
					nextStep.Image = NON_SELECTED_LEFT_IMAGE
				else
					nextStep.Image = NON_SELECTED_RIGHT_IMAGE
				end
			end
		end

		this.Steps[#this.Steps + 1] = nextStep
	end


	------------------- FUNCTIONS ---------------------
	local function hideSelection()
		for i = 1, steps do
			this.Steps[i].BackgroundColor3 = NON_SELECTED_COLOR
			if i == 1 then
				this.Steps[i].Image = NON_SELECTED_LEFT_IMAGE
			elseif i == steps then
				this.Steps[i].Image = NON_SELECTED_RIGHT_IMAGE
			end
		end
	end
	local function showSelection()
		for i = 1, steps do
			if i > currentStep then break end
			this.Steps[i].BackgroundColor3 = SELECTED_COLOR
			if i == 1 then
				this.Steps[i].Image = SELECTED_LEFT_IMAGE
			elseif i == steps then
				this.Steps[i].Image = SELECTED_RIGHT_IMAGE
			end
		end
	end
	local function modifySelection(alpha)
		for i = 1, steps do
			if i == 1 or i == steps then
				this.Steps[i].ImageTransparency = alpha
			else
				this.Steps[i].BackgroundTransparency = alpha
			end
		end
	end

	local function setCurrentStep(newStepPosition)
		if not minStep then minStep = 0 end

		leftButton.Visible = true
		rightButton.Visible = true

		if newStepPosition <= minStep then
			newStepPosition = minStep
			leftButton.Visible = false
		end
		if newStepPosition >= steps then
			newStepPosition = steps
			rightButton.Visible = false
		end

		if currentStep == newStepPosition then return end

		currentStep = newStepPosition

		hideSelection()
		showSelection()

		timeAtLastInput = tick()
		valueChangedEvent:Fire(currentStep)
	end

	local function isActivateEvent(inputObject)
		if not inputObject then return false end
		return inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch or (inputObject.UserInputType == Enum.UserInputType.Gamepad1 and inputObject.KeyCode == Enum.KeyCode.ButtonA)
	end
	local function mouseDownFunc(inputObject, newStepPos, repeatAction)
		if not interactable then return end

		if inputObject == nil then return end

		if not isActivateEvent(inputObject) then return end

		if usesSelectedObject() and not VRService.VREnabled then
			GuiService.SelectedCoreObject = this.SliderFrame
		end

		if not VRService.VREnabled then
			if repeatAction then
				lastInputDirection = newStepPos - currentStep
			else
				lastInputDirection = 0

				local mouseInputMovedCon = nil
				local mouseInputEndedCon = nil

				mouseInputMovedCon = UserInputService.InputChanged:Connect(function(inputObject)
					if inputObject.UserInputType ~= Enum.UserInputType.MouseMovement then return end

					local mousePos = inputObject.Position.X
					for i = 1, steps do
						local stepPosition = this.Steps[i].AbsolutePosition.X
						local stepSize = this.Steps[i].AbsoluteSize.X
						if mousePos >= stepPosition and mousePos <= stepPosition + stepSize then
							setCurrentStep(i)
							break
						elseif i == 1 and mousePos < stepPosition then
							setCurrentStep(0)
							break
						elseif i == steps and mousePos >= stepPosition then
							setCurrentStep(i)
							break
						end
					end
				end)
				mouseInputEndedCon = UserInputService.InputEnded:Connect(function(inputObject)
					if not isActivateEvent(inputObject) then return end

					lastInputDirection = 0
					mouseInputEndedCon:Disconnect()
					mouseInputMovedCon:Disconnect()
				end)
			end
		else
			lastInputDirection = 0
		end

		setCurrentStep(newStepPos)
	end

	local function mouseUpFunc(inputObject)
		if not interactable then return end
		if not isActivateEvent(inputObject) then return end

		lastInputDirection = 0
	end

	local function touchClickFunc(inputObject, newStepPos, repeatAction)
		mouseDownFunc(inputObject, newStepPos, repeatAction)
	end

	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.ValueChanged = valueChangedEvent.Event

	function this:SetValue(newValue)
		setCurrentStep(newValue)
	end

	function this:GetValue()
		return currentStep
	end

	function this:SetInteractable(value)
		lastInputDirection = 0
		interactable = value
		this.SliderFrame.Selectable = value
		if not interactable then
			hideSelection()
		else
			showSelection()
		end
	end

	function this:SetZIndex(newZIndex)
		leftButton.ZIndex = newZIndex
		rightButton.ZIndex = newZIndex
		leftButtonImage.ZIndex = newZIndex
		rightButtonImage.ZIndex = newZIndex

		for i = 1, #this.Steps do
			this.Steps[i].ZIndex = newZIndex
		end
	end

	function this:SetMinStep(newMinStep)
		if newMinStep >= 0 and newMinStep <= steps then
			minStep = newMinStep
		end

		if currentStep <= minStep then
			currentStep = minStep
			leftButton.Visible = false
		end
		if currentStep >= steps then
			currentStep = steps
			rightButton.Visible = false
		end
	end

	--------------------- SETUP -----------------------

	leftButton.InputBegan:Connect(function(inputObject) mouseDownFunc(inputObject, currentStep - 1, true) end)
	leftButton.InputEnded:Connect(function(inputObject) mouseUpFunc(inputObject) end)
	rightButton.InputBegan:Connect(function(inputObject) mouseDownFunc(inputObject, currentStep + 1, true) end)
	rightButton.InputEnded:Connect(function(inputObject) mouseUpFunc(inputObject) end)

	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		if VRService.VREnabled then
			leftButton.Selectable = interactable
			rightButton.Selectable = interactable
			this.SliderFrame.Selectable = interactable

			for i = 1, steps do
				this.Steps[i].Selectable = interactable
				this.Steps[i].Active = interactable
			end
		else
			leftButton.Selectable = false
			rightButton.Selectable = false
			this.SliderFrame.Selectable = interactable
			for i = 1, steps do
				this.Steps[i].Selectable = false
				this.Steps[i].Active = false
			end
		end
	end
	VRService.Changed:Connect(onVREnabled)
	onVREnabled("VREnabled")

	for i = 1, steps do
		this.Steps[i].InputBegan:Connect(function(inputObject)
			mouseDownFunc(inputObject, i)
		end)
		this.Steps[i].InputEnded:Connect(function(inputObject)
		 mouseUpFunc(inputObject) end)
	end

	this.SliderFrame.InputBegan:Connect(function(inputObject)
		if VRService.VREnabled then
			local selected = GuiService.SelectedCoreObject
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end
		end
		mouseDownFunc(inputObject, currentStep)
	end)
	this.SliderFrame.InputEnded:Connect(function(inputObject)
		if VRService.VREnabled then
			local selected = GuiService.SelectedCoreObject
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end
		end
		mouseUpFunc(inputObject)
	end)


	local stepSliderFunc = function()
		if timeAtLastInput == nil then return end

		local currentTime = tick()
		local timeSinceLastInput = currentTime - timeAtLastInput
		if timeSinceLastInput >= CONTROLLER_SCROLL_DELTA then
			setCurrentStep(currentStep + lastInputDirection)
		end
	end

	local isInTree = true

	local navigateLeft = -1 --these are just for differentiation, the actual value isn't important as long as they coerce to boolean true (all numbers do in Lua)
	local navigateRight = 1
	local navigationKeyCodes = {
		[Enum.KeyCode.Thumbstick1] = true, --thumbstick can be either direction
		[Enum.KeyCode.DPadLeft] = navigateLeft,
		[Enum.KeyCode.DPadRight] = navigateRight,
		[Enum.KeyCode.Left] = navigateLeft,
		[Enum.KeyCode.Right] = navigateRight,
		[Enum.KeyCode.A] = navigateLeft,
		[Enum.KeyCode.D] = navigateRight,
		[Enum.KeyCode.ButtonA] = true --buttonA can be either direction
	}
	UserInputService.InputBegan:Connect(function(inputObject)
		if not interactable then return end
		if not isInTree then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end

		if navigationKeyCodes[inputObject.KeyCode] == navigateLeft then
			lastInputDirection = -1
			setCurrentStep(currentStep - 1)
		elseif navigationKeyCodes[inputObject.KeyCode] == navigateRight then
			lastInputDirection = 1
			setCurrentStep(currentStep + 1)
		end
	end)

	UserInputService.InputEnded:Connect(function(inputObject)
		if not interactable then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end

		if navigationKeyCodes[inputObject.KeyCode] then --detect any keycode considered a navigation key
			lastInputDirection = 0
		end
	end)

	UserInputService.InputChanged:Connect(function(inputObject)
		if not interactable then
			lastInputDirection = 0
			return
		end
		if not isInTree then
			lastInputDirection = 0
			return
		end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 then return end
		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end
		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end

		if inputObject.Position.X > CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X > 0 and lastInputDirection ~= 1 then
			lastInputDirection = 1
			setCurrentStep(currentStep + 1)
		elseif inputObject.Position.X < -CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X < 0 and lastInputDirection ~= -1 then
			lastInputDirection = -1
			setCurrentStep(currentStep - 1)
		elseif math.abs(inputObject.Position.X) < CONTROLLER_THUMBSTICK_DEADZONE then
			lastInputDirection = 0
		end
	end)

	local isBound = false
	GuiService.Changed:Connect(function(prop)
		if prop ~= "SelectedCoreObject" then return end

		local selected = GuiService.SelectedCoreObject
		local isThisSelected = selected and selected:IsDescendantOf(this.SliderFrame.Parent)
		if isThisSelected then
			modifySelection(0)
			if not isBound then
				isBound = true
				timeAtLastInput = tick()
				RunService:BindToRenderStep(renderStepBindName, Enum.RenderPriority.Input.Value + 1, stepSliderFunc)
			end
		else
			modifySelection(0.36)
			if isBound then
				isBound = false
				RunService:UnbindFromRenderStep(renderStepBindName)
			end
		end
	end)

	this.SliderFrame.AncestryChanged:Connect(function(child, parent)
		isInTree = parent
	end)

	setCurrentStep(currentStep)

	return this
end

local ROW_HEIGHT = 50
if isTenFootInterface() then ROW_HEIGHT = 90 end

local nextPosTable = {}
local function AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
	local nextRowPositionY = 0
	local isARealRow = selectionType ~= 'TextBox' -- Textboxes are constructed in this function - they don't have an associated class.

	if nextPosTable[pageToAddTo] then
		nextRowPositionY = nextPosTable[pageToAddTo]
	end

	local RowFrame = nil
	RowFrame = Util.Create'ImageButton'
	{
		Name = rowDisplayName .. "Frame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(2, 2, 18, 18),
		ImageTransparency = 1,
		Active = false,
		AutoButtonColor = false,
		Size = UDim2.new(1,0,0,ROW_HEIGHT),
		Position = UDim2.new(0,0,0,nextRowPositionY),
		ZIndex = 2,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = pageToAddTo.Page
	};
	RowFrame.ImageColor3 = RowFrame.BackgroundColor3

	if RowFrame and extraSpacing then
		RowFrame.Position = UDim2.new(RowFrame.Position.X.Scale,RowFrame.Position.X.Offset,
			RowFrame.Position.Y.Scale,RowFrame.Position.Y.Offset + extraSpacing)
	end

	local RowLabel = nil
	RowLabel = Util.Create'TextLabel'
	{
		Name = rowDisplayName .. "Label",
		Text = rowDisplayName,
		Font = Enum.Font.SourceSansBold,
		TextSize = 16,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,200,1,0),
		Position = UDim2.new(0,10,0,0),
		ZIndex = 2,
		Parent = RowFrame
	};

	local RowLabelTextSizeConstraint = Instance.new("UITextSizeConstraint")
	if FFlagUseNotificationsLocalization then
		RowLabel.Size = UDim2.new(0.35,0,1,0)
		RowLabel.TextScaled = true
		RowLabel.TextWrapped = true
		RowLabelTextSizeConstraint.Parent = RowLabel
		RowLabelTextSizeConstraint.MaxTextSize = 16
	end

	if not isARealRow then
		RowLabel.Text = ''
	end

	local function onResized(viewportSize, portrait)
		if portrait then
			RowLabel.TextSize = 16
		else
			RowLabel.TextSize = isTenFootInterface() and 36 or 24
		end
		RowLabelTextSizeConstraint.MaxTextSize = RowLabel.TextSize
	end
	onResized(getViewportSize(), isPortrait())
	addOnResizedCallback(RowFrame, onResized)

	local ValueChangerSelection = nil
	local ValueChangerInstance = nil
	if selectionType == "Slider" then
		ValueChangerInstance = CreateNewSlider(rowValues, rowDefault)
		ValueChangerInstance.SliderFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.SliderFrame
	elseif selectionType == "Selector" then
		ValueChangerInstance = CreateSelector(rowValues, rowDefault)
		ValueChangerInstance.SelectorFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.SelectorFrame
	elseif selectionType == "DropDown" then
		ValueChangerInstance = CreateDropDown(rowValues, rowDefault, pageToAddTo.HubRef)
		ValueChangerInstance.DropDownFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.DropDownFrame
	elseif selectionType == "TextBox" then
		local isMouseOverRow = false
		local forceReturnSelectionOnFocusLost = false
		local SelectionOverrideObject = Util.Create'ImageLabel'
		{
			Image = "",
			BackgroundTransparency = 1,
		};

		ValueChangerInstance = {}
		ValueChangerInstance.HubRef = nil

		local box = Util.Create'TextBox'
		{
			AnchorPoint = Vector2.new(1, 0.5),
			Size = UDim2.new(0.6,0,1,0),
			Position = UDim2.new(1,0,0.5,0),
			Text = rowDisplayName,
			TextColor3 = Color3.fromRGB(49, 49, 49),
			BackgroundTransparency = 0.5,
			BorderSizePixel = 0,
			TextYAlignment = Enum.TextYAlignment.Top,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextWrapped = true,
			Font = Enum.Font.SourceSans,
			TextSize = 24,
			ZIndex = 2,
			SelectionImageObject = SelectionOverrideObject,
			ClearTextOnFocus = false,
			Parent = RowFrame
		};
		ValueChangerSelection = box

		box.Focused:Connect(function()
			if usesSelectedObject() then
				GuiService.SelectedCoreObject = box
			end

			if box.Text == rowDisplayName then
				box.Text = ""
			end
		end)
		box.FocusLost:Connect(function(enterPressed, inputObject)
			forceReturnSelectionOnFocusLost = false
		end)
		if extraSpacing then
			box.Position = UDim2.new(box.Position.X.Scale,box.Position.X.Offset,
				box.Position.Y.Scale,box.Position.Y.Offset + extraSpacing)
		end

		ValueChangerSelection.SelectionGained:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.1

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(ValueChangerSelection)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.5
			end
		end)

		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerSelection

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
				isMouseOverRow = true
			end
		end
		local function processInput(input)
			if input.UserInputState == Enum.UserInputState.Begin then
				if input.KeyCode == Enum.KeyCode.Return then
					if GuiService.SelectedCoreObject == ValueChangerSelection then
						forceReturnSelectionOnFocusLost = true
						box:CaptureFocus()
					end
				end
			end
		end
		box.MouseEnter:Connect(setRowSelection)

		UserInputService.InputBegan:Connect(processInput)

	elseif selectionType == "TextEntry" then
		local isMouseOverRow = false
		local forceReturnSelectionOnFocusLost = false
		local SelectionOverrideObject = Util.Create'ImageLabel'
		{
			Image = "",
			BackgroundTransparency = 1,
		};

		ValueChangerInstance = {}
		ValueChangerInstance.HubRef = nil

		local box = Util.Create'TextBox'
		{
			AnchorPoint = Vector2.new(1, 0.5),
			Size = UDim2.new(0.4,-10,0,40),
			Position = UDim2.new(1,0,0.5,0),
			Text = rowDisplayName,
			TextColor3 = Color3.fromRGB(178, 178, 178),
			BackgroundTransparency = 1.0,
			BorderSizePixel = 0,
			TextYAlignment = Enum.TextYAlignment.Center,
			TextXAlignment = Enum.TextXAlignment.Center,
			TextWrapped = false,
			Font = Enum.Font.SourceSans,
			TextSize = 24,
			ZIndex = 2,
			SelectionImageObject = SelectionOverrideObject,
			ClearTextOnFocus = false,
			Parent = RowFrame
		};
		ValueChangerSelection = box

		box.Focused:Connect(function()
			if usesSelectedObject() then
				GuiService.SelectedCoreObject = box
			end

			if box.Text == rowDisplayName then
				box.Text = ""
			end
		end)
		box.FocusLost:Connect(function(enterPressed, inputObject)
			forceReturnSelectionOnFocusLost = false
		end)
		if extraSpacing then
			box.Position = UDim2.new(box.Position.X.Scale,box.Position.X.Offset,
										box.Position.Y.Scale,box.Position.Y.Offset + extraSpacing)
		end

		ValueChangerSelection.SelectionGained:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.8

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(ValueChangerSelection)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 1.0
			end
		end)

		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerSelection

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
				isMouseOverRow = true
			end
		end
		local function processInput(input)
			if input.UserInputState == Enum.UserInputState.Begin then
				if input.KeyCode == Enum.KeyCode.Return then
					if GuiService.SelectedCoreObject == ValueChangerSelection then
						forceReturnSelectionOnFocusLost = true
						box:CaptureFocus()
					end
				end
			end
		end
		RowFrame.MouseEnter:Connect(setRowSelection)

		function ValueChangerInstance:SetZIndex(newZIndex)
			box.ZIndex = newZIndex
		end

		function ValueChangerInstance:SetInteractable(interactable)
			box.Selectable = interactable
			if not interactable then
				box.TextColor3 = Color3.fromRGB(49,49,49)
				box.ZIndex = 1
			else
				box.TextColor3 = Color3.fromRGB(178,178,178)
				box.ZIndex = 2
			end
		end

		function ValueChangerInstance:SetValue(value) -- should this do more?
			box.Text = value
		end

		local valueChangedEvent = Instance.new("BindableEvent")
		valueChangedEvent.Name = "ValueChanged"

		box.FocusLost:Connect(function()
			valueChangedEvent:Fire(box.Text)
		end)

		ValueChangerInstance.ValueChanged = valueChangedEvent.Event

		UserInputService.InputBegan:Connect(processInput)
	end

	ValueChangerInstance.Name = rowDisplayName .. "ValueChanger"

	nextRowPositionY = nextRowPositionY + ROW_HEIGHT
	if extraSpacing then
		nextRowPositionY = nextRowPositionY + extraSpacing
	end

	nextPosTable[pageToAddTo] = nextRowPositionY

	if isARealRow then
		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerInstance.SliderFrame
			if not valueFrame then
				valueFrame = ValueChangerInstance.SliderFrame
			end
			if not valueFrame then
				valueFrame = ValueChangerInstance.DropDownFrame
			end
			if not valueFrame then
				valueFrame = ValueChangerInstance.SelectorFrame
			end

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
			end
		end
		RowFrame.MouseEnter:Connect(setRowSelection)

		--Could this be cleaned up even more?
		local function onVREnabled(prop)
			if prop == "VREnabled" then
				if VRService.VREnabled then
					RowFrame.Selectable = true
					RowFrame.Active = true
					ValueChangerSelection.Active = true
					GuiService.Changed:Connect(function(prop)
						if prop == "SelectedCoreObject" then
							local selected = GuiService.SelectedCoreObject
							if selected and (selected == RowFrame or selected:IsDescendantOf(RowFrame)) then
								RowFrame.ImageTransparency = 0.5
								RowFrame.BackgroundTransparency = 1
							else
								RowFrame.ImageTransparency = 1
								RowFrame.BackgroundTransparency = 1
							end
						end
					end)
				else
					RowFrame.Selectable = false
					RowFrame.Active = false
				end
			end
		end
		VRService.Changed:Connect(onVREnabled)
		onVREnabled("VREnabled")

		ValueChangerSelection.SelectionGained:Connect(function()
			if usesSelectedObject() then
				if VRService.VREnabled then
					RowFrame.ImageTransparency = 0.5
					RowFrame.BackgroundTransparency = 1
				else
					RowFrame.ImageTransparency = 1
					RowFrame.BackgroundTransparency = 0.5
				end

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(RowFrame)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:Connect(function()
			if usesSelectedObject() then
				RowFrame.ImageTransparency = 1
				RowFrame.BackgroundTransparency = 1
			end
		end)
	end

	pageToAddTo:AddRow(RowFrame, RowLabel, ValueChangerInstance, extraSpacing, false)

	ValueChangerInstance.Selection = ValueChangerSelection

	return RowFrame, RowLabel, ValueChangerInstance
end

local function AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
	local nextRowPositionY = 0

	if nextPosTable[pageToAddTo] then
		nextRowPositionY = nextPosTable[pageToAddTo]
	end

	local RowFrame = Util.Create'ImageButton'
	{
		Name = rowDisplayName .. "Frame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(10,10,10,10),
		ImageTransparency = 1,
		Active = false,
		AutoButtonColor = false,
		Size = UDim2.new(1,0,0,ROW_HEIGHT),
		Position = UDim2.new(0,0,0,nextRowPositionY),
		ZIndex = 2,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = pageToAddTo.Page
	};
	RowFrame.ImageColor3 = RowFrame.BackgroundColor3
	RowFrame.SelectionGained:Connect(function()
		RowFrame.BackgroundTransparency = 0.5
	end)
	RowFrame.SelectionLost:Connect(function()
		RowFrame.BackgroundTransparency = 1
	end)

	local RowLabel = Util.Create'TextLabel'
	{
		Name = rowDisplayName .. "Label",
		Text = rowDisplayName,
		Font = Enum.Font.SourceSansBold,
		TextSize = 16,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,200,1,0),
		Position = UDim2.new(0,10,0,0),
		ZIndex = 2,
		Parent = RowFrame
	};
	local function onResized(viewportSize, portrait)
		if portrait then
			RowLabel.TextSize = 16
		else
			RowLabel.TextSize = isTenFootInterface() and 36 or 24
		end
	end
	addOnResizedCallback(RowFrame, onResized)

	if extraSpacing then
		RowFrame.Position = UDim2.new(RowFrame.Position.X.Scale,RowFrame.Position.X.Offset,
			RowFrame.Position.Y.Scale,RowFrame.Position.Y.Offset + extraSpacing)
	end

	nextRowPositionY = nextRowPositionY + ROW_HEIGHT
	if extraSpacing then
		nextRowPositionY = nextRowPositionY + extraSpacing
	end

	nextPosTable[pageToAddTo] = nextRowPositionY

	local setRowSelection = function()
		if RowFrame.Visible then
			GuiService.SelectedCoreObject = RowFrame
		end
	end
	RowFrame.MouseEnter:Connect(setRowSelection)

	rowObject.SelectionImageObject = noSelectionObject

	rowObject.SelectionGained:Connect(function()
		if VRService.VREnabled then
			RowFrame.ImageTransparency = 0.5
			RowFrame.BackgroundTransparency = 1
		else
			RowFrame.ImageTransparency = 1
			RowFrame.BackgroundTransparency = 0.5
		end
	end)
	rowObject.SelectionLost:Connect(function()
		RowFrame.ImageTransparency = 1
		RowFrame.BackgroundTransparency = 1
	end)

	rowObject.Parent = RowFrame

	pageToAddTo:AddRow(RowFrame, RowLabel, rowObject, extraSpacing, true)
	return RowFrame
end

-------- public facing API ----------------
local moduleApiTable = {}

function moduleApiTable:Create(instanceType)
	return function(data)
		local obj = Instance.new(instanceType)
		local parent = nil
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			elseif k == 'Parent' then
				parent = v
			else
				obj[k] = v
			end
		end
		if parent then
			obj.Parent = parent
		end
		return obj
	end
end

-- RayPlaneIntersection (shortened)
-- http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
function moduleApiTable:RayPlaneIntersection(ray, planeNormal, pointOnPlane)
	planeNormal = planeNormal.unit
	ray = ray.Unit

	local Vd = planeNormal:Dot(ray.Direction)
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	return ray.Origin + ray.Direction * t
end

function moduleApiTable:GetEaseLinear()
	return Linear
end
function moduleApiTable:GetEaseOutQuad()
	return EaseOutQuad
end
function moduleApiTable:GetEaseInOutQuad()
	return EaseInOutQuad
end

function moduleApiTable:CreateNewSlider(numOfSteps, startStep, minStep)
	return CreateNewSlider(numOfSteps, startStep, minStep)
end

function moduleApiTable:CreateNewSelector(selectionStringTable, startPosition)
	return CreateSelector(selectionStringTable, startPosition)
end

function moduleApiTable:CreateNewDropDown(dropDownStringTable, startPosition)
	return CreateDropDown(dropDownStringTable, startPosition, nil)
end

function moduleApiTable:AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
	return AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
end

function moduleApiTable:AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
	return AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
end

function moduleApiTable:ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
	ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
end

function moduleApiTable:IsSmallTouchScreen()
	return isSmallTouchScreen()
end

function moduleApiTable:IsPortrait()
	return isPortrait()
end

function moduleApiTable:MakeStyledButton(name, text, size, clickFunc, pageRef, hubRef)
	return MakeButton(name, text, size, clickFunc, pageRef, hubRef)
end

function moduleApiTable:MakeStyledImageButton(name, image, size, imageSize, clickFunc, pageRef, hubRef)
	return MakeImageButton(name, image, size, imageSize, clickFunc, pageRef, hubRef)
end

function moduleApiTable:AddButtonRow(pageToAddTo, name, text, size, clickFunc, hubRef)
	return AddButtonRow(pageToAddTo, name, text, size, clickFunc, hubRef)
end

function moduleApiTable:CreateSignal()
	return CreateSignal()
end

function  moduleApiTable:UsesSelectedObject()
	return usesSelectedObject()
end

function moduleApiTable:TweenProperty(instance, prop, start, final, duration, easingFunc, cbFunc)
	return PropertyTweener(instance, prop, start, final, duration, easingFunc, cbFunc)
end

function moduleApiTable:OnResized(key, callback)
	return addOnResizedCallback(key, callback)
end

function moduleApiTable:FireOnResized()
	local newSize = getViewportSize()
	local portrait = moduleApiTable:IsPortrait()

	for key, callback in pairs(onResizedCallbacks) do
		callback(newSize, portrait)
	end
end

-- Returns an interpolation between position0 and position1.
--	Returns position0 when t = 0, and position1 when t = 1.
function moduleApiTable:Lerp(t, position0, position1)
	return (1 - t) * position0 + t * position1
end

-- Returns a rounded number
function moduleApiTable:Round(n)
	return n % 1 >= 0.5 and math.ceil(n) or math.floor(n)
end


return moduleApiTable
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9FD9870746F840CEB1F0151E89F22104">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">GameTranslator</string>
										<string name="ScriptGuid">{CA21C7ED-AB31-43BC-94FC-2CBBB889181E}</string>
										<ProtectedString name="Source"><![CDATA[local LocalizationService = game:GetService("LocalizationService")
local Players = game:GetService("Players")
local CoreGui = game.Players.LocalPlayer.PlayerGui
local RobloxGui = CoreGui:WaitForChild("BackpackGui")

local CoreScriptTranslateGameText = false

local playerTranslator = nil
local player = nil
local localeId = nil
local localeIdConnection = nil
local localeChangedEvent = Instance.new("BindableEvent")

local function handlePlayerOrLocaleChanged()
    if player and player.LocaleId ~= localeId then
        localeId = player.LocaleId
        localeChangedEvent:Fire(localeId)
    end
end

local function reset()
    playerTranslator = nil
    player = nil

    if localeIdConnection then
        localeIdConnection:Disconnect()
        localeIdConnection = nil
    end
end

local function getTranslator()
    if not playerTranslator then
        player = Players.LocalPlayer
        if player then
            playerTranslator = LocalizationService:GetTranslatorForPlayer(player)

            handlePlayerOrLocaleChanged()
            localeIdConnection = player:GetPropertyChangedSignal("LocaleId"):Connect(handlePlayerOrLocaleChanged)
        end
    end
    return playerTranslator
end

local registryInfoMap = {}

local function unregisterGui(element)
    registryInfoMap[element].connection:Disconnect()
    registryInfoMap[element] = nil
end

local function makeAncestryChangedHandler(element, info)
    return function(child, parent)
        if not game:IsAncestorOf(element) then
            if info.hasBeenAdded then
                unregisterGui(element)
            end
        else
            info.hasBeenAdded = true
        end
    end
end

local function updateRegistryInfo(info, context, text)
    info.context = context
    info.text = text
end

local function makeRegistryInfo(element, context, text)
    local info = { hasBeenAdded = game:IsAncestorOf(element) }
    updateRegistryInfo(info, context, text)
    info.connection = element.AncestryChanged:Connect(
        makeAncestryChangedHandler(element, info))
    return info
end

local function registerGui(element, context, text)
    if registryInfoMap[element] == nil then
        registryInfoMap[element] = makeRegistryInfo(element, context, text)
    else
        updateRegistryInfo(registryInfoMap[element], context, text)
    end
end

if CoreScriptTranslateGameText then
    Players:GetPropertyChangedSignal("LocalPlayer"):Connect(function()
        reset()
        getTranslator()
    end)
end

local GameTranslator = {}

GameTranslator.LocaleChanged = localeChangedEvent.Event

-- This is meant for translating user game text that appears under CoreGui.
-- It uses Player.LocaleId and the LocalizationTables under LocalizationService.
-- This includes team names, score names, tool names, and notification toasts.
-- DO NOT USE THIS TO TRANSLATE ROBLOX TEXT IN ROBLOX GUIS!!!
-- Text from Roblox in Roblox guis should use LocalizationService.RobloxLocaleId
-- and the CoreScriptLocalization table, NOT user tables with the game locale ID.

function GameTranslator:TranslateGameText(context, text)
    if CoreScriptTranslateGameText then
        local translator = getTranslator()
        if translator then
            return translator:RobloxOnlyTranslate(context, text)
        else
            return text
        end
    else
        return text
    end
end

local function retranslateAll()
    for element, info in pairs(registryInfoMap) do
        element.Text = GameTranslator:TranslateGameText(info.context, info.text)
    end
end

if CoreScriptTranslateGameText then
    LocalizationService.AutoTranslateWillRun:Connect(retranslateAll)
end

function GameTranslator:TranslateAndRegister(element, context, text)
    if CoreScriptTranslateGameText then
        element.Text = self:TranslateGameText(context, text)
        registerGui(element, context, text)
    end

    return text
end

return GameTranslator
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX5745706FFA2E4CDFB3A4B3BF892C9665">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">RobloxTranslator</string>
										<string name="ScriptGuid">{903C44F8-F0F7-4396-877E-5792B66E1784}</string>
										<ProtectedString name="Source"><![CDATA[local LocalizationService = game:GetService("LocalizationService")
local CoreGui = game.Players.LocalPlayer.PlayerGui
local RobloxGui = CoreGui:WaitForChild("BackpackGui")
local Players = game:GetService("Players")
local FFlagCoreScriptEnableRobloxTranslatorFallback = false

local FALLBACK_ENGLISH_TRANSLATOR
if FFlagCoreScriptEnableRobloxTranslatorFallback then
    FALLBACK_ENGLISH_TRANSLATOR = false
end

-- Waiting for the player ensures that the RobloxLocaleId has been set.
if Players.LocalPlayer == nil then
    Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
end

local coreScriptTableTranslator
local function getTranslator()
    if coreScriptTableTranslator == nil then
        coreScriptTableTranslator = CoreGui.CoreScriptLocalization:GetTranslator(
            LocalizationService.RobloxLocaleId)
    end
    return coreScriptTableTranslator
end

local translatorsCache = {}

local function getTranslatorForLocale(locale)
    local translator = translatorsCache[locale]
    if translator then
        return translator
    end

    translator = CoreGui.CoreScriptLocalization:GetTranslator(locale)
    translatorsCache[locale] = translator

    return translator
end

local function formatByKeyWithFallback(key, args, translator)
    local success, result = pcall(function()
        return translator:FormatByKey(key, args)
    end)

    if success then
        return result
    else
        return FALLBACK_ENGLISH_TRANSLATOR:FormatByKey(key, args)
    end
end

local RobloxTranslator = {}

function RobloxTranslator:FormatByKey(key, args)
    if FFlagCoreScriptEnableRobloxTranslatorFallback then
        return formatByKeyWithFallback(key, args, getTranslator())
    else
        return getTranslator():FormatByKey(key, args)
    end
end

function RobloxTranslator:FormatByKeyForLocale(key, locale, args)
    if FFlagCoreScriptEnableRobloxTranslatorFallback then
        return formatByKeyWithFallback(key, args, getTranslatorForLocale(locale))
    else
        return getTranslatorForLocale(locale):FormatByKey(key, args)
    end
end

return RobloxTranslator
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX494B306B832345F198A6C0FEC97F2092">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Icon</string>
										<string name="ScriptGuid">{AF7308D7-DEB7-4BBF-A54F-8E4AD4A08103}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	
	The majority of this code is an interface designed to make it easy for you to
	work with TopbarPlus (most methods for instance reference :modifyTheme()).
	The processing overhead mainly consists of applying themes and calculating 
	appearance (such as size and width of labels) which is handled in about
	200 lines of code here and the Widget UI module. This has been achieved
	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
	features like UIListLayouts.


	v3 provides inbuilt support for controllers (simply press DPadUp),
	touch devices (phones, tablets , etc), localization (automatic resizing
	of widgets, autolocalize for relevant labels), backwards compatability
	with the old topbar, and more.


	My primary goals for the v3 re-write have been to:
		
	1. Improve code readability and organisation (reduced lines of code within
	   Icon+IconController from 3200 to ~950, separated UI elements, etc)
		
	2. Improve ease-of-use (themes now actually make sense and can account
	   for any modifications you want, converted to a package for
	   quick installation and easy-comparisons of new updates, etc)
	
	3. Provide support for all key features of the new Roblox topbar
	   while improving performance of the module (deferring and collecting
	   changes then calling as a singular, utilizing inbuilt Roblox features
	   such as UILIstLayouts, etc)

--]]



-- SERVICES
local LocalizationService = game:GetService("LocalizationService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TextService = game:GetService("TextService")
local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")



-- REFERENCE HANDLER
-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
-- therefore this ensures that the first required package becomes the dominant and only functioning module
local iconModule = script
local Reference = require(iconModule.Reference)
local referenceObject = Reference.getObject()
local leadPackage = referenceObject and referenceObject.Value
if leadPackage and leadPackage ~= iconModule then
	return require(leadPackage)
end
if not referenceObject then
	Reference.addToReplicatedStorage()
end



-- MODULES
local Signal = require(iconModule.Packages.GoodSignal)
local Janitor = require(iconModule.Packages.Janitor)
local Utility = require(iconModule.Utility)
local Attribute = require(iconModule.Attribute)
local Themes = require(iconModule.Features.Themes)
local Gamepad = require(iconModule.Features.Gamepad)
local Overflow = require(iconModule.Features.Overflow)
local Icon = {}
Icon.__index = Icon



--- LOCAL
local localPlayer = Players.LocalPlayer
local themes = iconModule.Features.Themes
local playerGui = localPlayer:WaitForChild("PlayerGui")
local iconsDict = {}
local anyIconSelected = Signal.new()
local elements = iconModule.Elements
local totalCreatedIcons = 0



-- PRESETUP
-- This is only used to determine if we need to apply the old topbar theme
-- I'll be removing this and associated functions once all games have
-- fully transitioned over to the new topbar
if GuiService.TopbarInset.Height == 0 then
	GuiService:GetPropertyChangedSignal("TopbarInset"):Wait()
end



-- PUBLIC VARIABLES
Icon.baseDisplayOrderChanged = Signal.new()
Icon.baseDisplayOrder = 10
Icon.baseTheme = require(themes.Default)
Icon.isOldTopbar = GuiService.TopbarInset.Height == 36
Icon.iconsDictionary = iconsDict
Icon.container = require(elements.Container)(Icon)
Icon.topbarEnabled = true
Icon.iconAdded = Signal.new()
Icon.iconRemoved = Signal.new()
Icon.iconChanged = Signal.new()



-- PUBLIC FUNCTIONS
function Icon.getIcons()
	return Icon.iconsDictionary
end

function Icon.getIconByUID(UID)
	local match = Icon.iconsDictionary[UID]
	if match then
		return match
	end
end

function Icon.getIcon(nameOrUID)
	local match = Icon.getIconByUID(nameOrUID)
	if match then
		return match
	end
	for _, icon in pairs(iconsDict) do
		if icon.name == nameOrUID then
			return icon
		end
	end
end

function Icon.setTopbarEnabled(bool, isInternal)
	if typeof(bool) ~= "boolean" then
		bool = Icon.topbarEnabled
	end
	if not isInternal then
		Icon.topbarEnabled = bool
	end
	for _, screenGui in pairs(Icon.container) do
		screenGui.Enabled = bool
	end
end

function Icon.modifyBaseTheme(modifications)
	modifications = Themes.getModifications(modifications)
	for _, modification in pairs(modifications) do
		for _, detail in pairs(Icon.baseTheme) do
			Themes.merge(detail, modification)
		end
	end
	for _, icon in pairs(iconsDict) do
		icon:setTheme(Icon.baseTheme)
	end
end

function Icon.setDisplayOrder(int)
	Icon.baseDisplayOrder = int
	Icon.baseDisplayOrderChanged:Fire(int)
end



-- SETUP
task.defer(Gamepad.start, Icon)
task.defer(Overflow.start, Icon)
for _, screenGui in pairs(Icon.container) do
	screenGui.Parent = playerGui
end
if Icon.isOldTopbar then
	Icon.modifyBaseTheme(require(themes.Classic))
end



-- CONSTRUCTOR
function Icon.new()
	local self = {}
	setmetatable(self, Icon)

	--- Janitors (for cleanup)
	local janitor = Janitor.new()
	self.janitor = janitor
	self.themesJanitor = janitor:add(Janitor.new())
	self.singleClickJanitor = janitor:add(Janitor.new())
	self.captionJanitor = janitor:add(Janitor.new())
	self.joinJanitor = janitor:add(Janitor.new())
	self.menuJanitor = janitor:add(Janitor.new())
	self.dropdownJanitor = janitor:add(Janitor.new())

	-- Register
	local iconUID = Utility.generateUID()
	iconsDict[iconUID] = self
	janitor:add(function()
		iconsDict[iconUID] = nil
	end)

	-- Signals (events)
	self.selected = janitor:add(Signal.new())
	self.deselected = janitor:add(Signal.new())
	self.toggled = janitor:add(Signal.new())
	self.viewingStarted = janitor:add(Signal.new())
	self.viewingEnded = janitor:add(Signal.new())
	self.stateChanged = janitor:add(Signal.new())
	self.notified = janitor:add(Signal.new())
	self.noticeStarted = janitor:add(Signal.new())
	self.noticeChanged = janitor:add(Signal.new())
	self.endNotices = janitor:add(Signal.new())
	self.toggleKeyAdded = janitor:add(Signal.new())
	self.fakeToggleKeyChanged = janitor:add(Signal.new())
	self.alignmentChanged = janitor:add(Signal.new())
	self.updateSize = janitor:add(Signal.new())
	self.resizingComplete = janitor:add(Signal.new())
	self.joinedParent = janitor:add(Signal.new())
	self.menuSet = janitor:add(Signal.new())
	self.dropdownSet = janitor:add(Signal.new())
	self.updateMenu = janitor:add(Signal.new())
	self.startMenuUpdate = janitor:add(Signal.new())
	self.childThemeModified = janitor:add(Signal.new())
	self.indicatorSet = janitor:add(Signal.new())
	self.dropdownChildAdded = janitor:add(Signal.new())
	self.menuChildAdded = janitor:add(Signal.new())

	-- Properties
	self.iconModule = iconModule
	self.UID = iconUID
	self.isEnabled = true
	self.isSelected = false
	self.isViewing = false
	self.joinedFrame = false
	self.parentIconUID = false
	self.deselectWhenOtherIconSelected = true
	self.totalNotices = 0
	self.activeState = "Deselected"
	self.alignment = ""
	self.originalAlignment = ""
	self.appliedTheme = {}
	self.appearance = {}
	self.cachedInstances = {}
	self.cachedNamesToInstances = {}
	self.cachedCollectives = {}
	self.bindedToggleKeys = {}
	self.customBehaviours = {}
	self.toggleItems = {}
	self.bindedEvents = {}
	self.notices = {}
	self.menuIcons = {}
	self.dropdownIcons = {}
	self.childIconsDict = {}
	self.isOldTopbar = Icon.isOldTopbar
	self.creationTime = os.clock()

	-- Widget is the new name for an icon
	local widget = janitor:add(require(elements.Widget)(self, Icon))
	self.widget = widget
	self:setAlignment()
	
	-- It's important we set an order otherwise icons will not align
	-- correctly within menus
	totalCreatedIcons += 1
	local ourOrder = totalCreatedIcons
	self:setOrder(ourOrder)

	-- This applies the default them
	self:setTheme(Icon.baseTheme)

	-- Button Clicked (for states "Selected" and "Deselected")
	local clickRegion = self:getInstance("ClickRegion")
	local function handleToggle()
		if self.locked then
			return
		end
		if self.isSelected then
			self:deselect("User", self)
		else
			self:select("User", self)
		end
	end
	local isTouchTapping = false
	local isClicking = false
	clickRegion.MouseButton1Click:Connect(function()
		if isTouchTapping then
			return
		end
		isClicking = true
		task.delay(0.01, function()
			isClicking = false
		end)
		handleToggle()
	end)
	clickRegion.TouchTap:Connect(function()
		-- This resolves the bug report by @28Pixels:
		-- https://devforum.roblox.com/t/topbarplus/1017485/1104
		if isClicking then
			return
		end
		isTouchTapping = true
		task.delay(0.01, function()
			isTouchTapping = false
		end)
		handleToggle()
	end)

	-- Keys can be bound to toggle between Selected and Deselected
	janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
		if self.locked then
			return
		end
		if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
			handleToggle()
		end
	end))

	-- Button Hovering (for state "Viewing")
	-- Hovering is a state only for devices with keyboards
	-- and controllers (not touchpads)
	local function viewingStarted(dontSetState)
		if self.locked then
			return
		end
		self.isViewing = true
		self.viewingStarted:Fire(true)
		if not dontSetState then
			self:setState("Viewing", "User", self)
		end
	end
	local function viewingEnded()
		if self.locked then
			return
		end
		self.isViewing = false
		self.viewingEnded:Fire(true)
		self:setState(nil, "User", self)
	end
	self.joinedParent:Connect(function()
		if self.isViewing then
			viewingEnded()
		end
	end)
	clickRegion.MouseEnter:Connect(function()
		local dontSetState = not UserInputService.KeyboardEnabled
		viewingStarted(dontSetState)
	end)
	local touchCount = 0
	janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
	clickRegion.MouseLeave:Connect(viewingEnded)
	clickRegion.SelectionGained:Connect(viewingStarted)
	clickRegion.SelectionLost:Connect(viewingEnded)
	clickRegion.MouseButton1Down:Connect(function()
		if not self.locked and UserInputService.TouchEnabled then
			touchCount += 1
			local myTouchCount = touchCount
			task.delay(0.2, function()
				if myTouchCount == touchCount then
					viewingStarted()
				end
			end)
		end
	end)
	clickRegion.MouseButton1Up:Connect(function()
		touchCount += 1
	end)

	-- Handle overlay on viewing
	local iconOverlay = self:getInstance("IconOverlay")
	self.viewingStarted:Connect(function()
		iconOverlay.Visible = not self.overlayDisabled
	end)
	self.viewingEnded:Connect(function()
		iconOverlay.Visible = false
	end)

	-- Deselect when another icon is selected
	janitor:add(anyIconSelected:Connect(function(incomingIcon)
		if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
			self:deselect("AutoDeselect", incomingIcon)
		end
	end))

	-- This checks if the script calling this module is a descendant of a ScreenGui
	-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
	-- client respawns. This solves one of the most asked about questions on the post
	-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
	-- the LocalScript rests within
	local source =  debug.info(2, "s")
	local sourcePath = string.split(source, ".")
	local origin = game
	local originsScreenGui
	for i, sourceName in pairs(sourcePath) do
		origin = origin:FindFirstChild(sourceName)
		if not origin then
			break
		end
		if origin:IsA("ScreenGui") then
			originsScreenGui = origin
		end
	end
	if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
		Utility.localPlayerRespawned(function()
			self:destroy()
		end)
	end

	-- Additional children behaviour when toggled (mostly notices)
	local noticeLabel = self:getInstance("NoticeLabel")
	self.toggled:Connect(function(isSelected)
		self.noticeChanged:Fire(self.totalNotices)
		for childIconUID, _ in pairs(self.childIconsDict) do
			local childIcon = Icon.getIconByUID(childIconUID)
			childIcon.noticeChanged:Fire(childIcon.totalNotices)
			if not isSelected and childIcon.isSelected then
				-- If an icon within a menu or dropdown is also
				-- a dropdown or menu, then close it
				for _, _ in pairs(childIcon.childIconsDict) do
					childIcon:deselect("HideParentFeature", self)
				end
			end
		end
	end)
	
	-- This closes/reopens the chat or playerlist if the icon is a dropdown
	-- In the future I'd prefer to use the position+size of the chat
	-- to determine whether to close dropdown (instead of non-right-set)
	-- but for reasons mentioned here it's unreliable at the time of
	-- writing this: https://devforum.roblox.com/t/here/2794915
	-- I could also make this better by accounting for multiple
	-- dropdowns being open (not just this one) but this will work
	-- fine for almost every use case for now.
	self.selected:Connect(function()
		local isDropdown = #self.dropdownIcons > 0
		if isDropdown then
			if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
				self.chatWasPreviouslyActive = true
				StarterGui:SetCore("ChatActive", false)
			end
			if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
				self.playerlistWasPreviouslyActive = true
				StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
			end
		end
	end)
	self.deselected:Connect(function()
		if self.chatWasPreviouslyActive then
			self.chatWasPreviouslyActive = nil
			StarterGui:SetCore("ChatActive", true)
		end
		if self.playerlistWasPreviouslyActive then
			self.playerlistWasPreviouslyActive = nil
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
		end
	end)
	
	-- There's a rare occassion where the appearance is not
	-- fully set to deselected so this ensures the icons
	-- appearance is fully as it should be
	--print("self.activeState =", self.activeState)
	task.delay(0.1, function()
		if self.activeState == "Deselected" then
			self.stateChanged:Fire("Deselected")
			self:refresh()
		end
	end)
	
	-- Call icon added
	Icon.iconAdded:Fire(self)

	return self
end



-- METHODS
function Icon:setName(name)
	self.widget.Name = name
	self.name = name
	return self
end

function Icon:setState(incomingStateName, fromSource, sourceIcon)
	-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
	-- a users mouse enters the widget), then informing other systems of this state change to then act upon
	-- (such as the theme handler applying the theme which corresponds to that state).
	if not incomingStateName then
		incomingStateName = (self.isSelected and "Selected") or "Deselected"
	end
	local stateName = Utility.formatStateName(incomingStateName)
	local previousStateName = self.activeState
	if previousStateName == stateName then
		return
	end
	local currentIsSelected = self.isSelected
	self.activeState = stateName
	if stateName == "Deselected" then
		self.isSelected = false
		if currentIsSelected then
			self.toggled:Fire(false, fromSource, sourceIcon)
			self.deselected:Fire(fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(false, fromSource, sourceIcon)
	elseif stateName == "Selected" then
		self.isSelected = true
		if not currentIsSelected then
			self.toggled:Fire(true, fromSource, sourceIcon)
			self.selected:Fire(fromSource, sourceIcon)
			anyIconSelected:Fire(self, fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(true, fromSource, sourceIcon)
	end
	self.stateChanged:Fire(stateName, fromSource, sourceIcon)
end

function Icon:getInstance(name)
	-- This enables us to easily retrieve instances located within the icon simply by passing its name.
	-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
	-- We cache the result for more performant retrieval in the future.
	local instance = self.cachedNamesToInstances[name]
	if instance then
		return instance
	end
	local function cacheInstance(childName, child)
		local currentCache = self.cachedInstances[child]
		if not currentCache then
			local collectiveName = child:GetAttribute("Collective")
			local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
			if cachedCollective then
				table.insert(cachedCollective, child)
			end
			self.cachedNamesToInstances[childName] = child
			self.cachedInstances[child] = true
			child.Destroying:Once(function()
				self.cachedNamesToInstances[childName] = nil
				self.cachedInstances[child] = nil
			end)
		end
	end
	local widget = self.widget
	cacheInstance("Widget", widget)
	if name == "Widget" then
		return widget
	end

	local returnChild
	local function scanChildren(parentInstance)
		for _, child in pairs(parentInstance:GetChildren()) do
			local widgetUID = child:GetAttribute("WidgetUID")
			if widgetUID and widgetUID ~= self.UID then
				-- This prevents instances within other icons from being recorded
				-- (for instance when other icons are added to this icons menu)
				continue
			end
			-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
			-- then its important we scan the real original instance instead of this clone
			local previousChild = child
			local realChild = Themes.getRealInstance(child)
			if realChild then
				child = realChild
			end
			-- Finally scan its children
			scanChildren(child)
			if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
				local childName = child.Name
				cacheInstance(childName, child)
				if childName == name then
					returnChild = child
				end
			end
		end
	end
	scanChildren(widget)
	return returnChild
end

function Icon:getCollective(name)
	-- A collective is an array of instances within the Widget that have been
	-- grouped together based on a given name. This just makes it easy
	-- to act on multiple instances at once which share similar behaviours.
	-- For instance, if we want to change the icons corner size, all corner instances
	-- with the attribute "Collective" and value "WidgetCorner" could be updated
	-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
	local collective = self.cachedCollectives[name]
	if collective then
		return collective
	end
	collective = {}
	for instance, _ in pairs(self.cachedInstances) do
		if instance:GetAttribute("Collective") == name then
			table.insert(collective, instance)
		end
	end
	self.cachedCollectives[name] = collective
	return collective
end

function Icon:getInstanceOrCollective(collectiveOrInstanceName)
	-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
	-- an array of instances instead of a single instance
	local instances = {}
	local instance = self:getInstance(collectiveOrInstanceName)
	if instance then
		table.insert(instances, instance)
	end
	if #instances == 0 then
		instances = self:getCollective(collectiveOrInstanceName)
	end
	return instances
end

function Icon:getStateGroup(iconState)
	local chosenState = iconState or self.activeState
	local stateGroup = self.appearance[chosenState]
	if not stateGroup then
		stateGroup = {}
		self.appearance[chosenState] = stateGroup
	end
	return stateGroup
end

function Icon:refreshAppearance(instance, specificProperty)
	Themes.refresh(self, instance, specificProperty)
	return self
end

function Icon:refresh()
	self:refreshAppearance(self.widget)
	self.updateSize:Fire()
	return self
end

function Icon:updateParent()
	local parentIcon = Icon.getIconByUID(self.parentIconUID)
	if parentIcon then
		parentIcon.updateSize:Fire()
	end
end

function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
	-- You can specify your own custom callback to handle custom logic just before
	-- an instances property is changed by using :setBehaviour()
	local key = collectiveOrInstanceName.."-"..property
	self.customBehaviours[key] = callback
	if refreshAppearance then
		local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
		for _, instance in pairs(instances) do
			self:refreshAppearance(instance, property)
		end
	end
end

function Icon:modifyTheme(modifications, modificationUID)
	local modificationUID = Themes.modify(self, modifications, modificationUID)
	return self, modificationUID
end

function Icon:modifyChildTheme(modifications, modificationUID)
	-- Same as modifyTheme except for its children (i.e. icons
	-- within its dropdown or menu)
	self.childModifications = modifications
	self.childModificationsUID = modificationUID
	for childIconUID, _ in pairs(self.childIconsDict) do
		local childIcon = Icon.getIconByUID(childIconUID)
		childIcon:modifyTheme(modifications, modificationUID)
	end
	self.childThemeModified:Fire()
	return self
end

function Icon:removeModification(modificationUID)
	Themes.remove(self, modificationUID)
	return self
end

function Icon:removeModificationWith(instanceName, property, state)
	Themes.removeWith(self, instanceName, property, state)
	return self
end

function Icon:setTheme(theme)
	Themes.set(self, theme)
	return self
end

function Icon:setEnabled(bool)
	self.isEnabled = bool
	self.widget.Visible = bool
	self:updateParent()
	return self
end

function Icon:select(fromSource, sourceIcon)
	self:setState("Selected", fromSource, sourceIcon)
	return self
end

function Icon:deselect(fromSource, sourceIcon)
	self:setState("Deselected", fromSource, sourceIcon)
	return self
end

function Icon:notify(customClearSignal, noticeId)
	-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
	-- users of changes/updates within your UI such as a Catalog
	-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
	-- Roblox event (e.g. Instance.new("BindableEvent").Event)
	local notice = self.notice
	if not notice then
		notice = require(elements.Notice)(self, Icon)
		self.notice = notice
	end
	self.noticeStarted:Fire(customClearSignal, noticeId)
	return self
end

function Icon:clearNotices()
	self.endNotices:Fire()
	return self
end

function Icon:disableOverlay(bool)
	self.overlayDisabled = bool
	return self
end
Icon.disableStateOverlay = Icon.disableOverlay

function Icon:setImage(imageId, iconState)
	self:modifyTheme({"IconImage", "Image", imageId, iconState})
	return self
end

function Icon:setLabel(text, iconState)
	self:modifyTheme({"IconLabel", "Text", text, iconState})
	return self
end

function Icon:setOrder(int, iconState)
	self:modifyTheme({"Widget", "LayoutOrder", int, iconState})
	return self
end

function Icon:setCornerRadius(udim, iconState)
	self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
	return self
end

function Icon:align(leftCenterOrRight, isFromParentIcon)
	-- Determines the side of the screen the icon will be ordered
	local direction = tostring(leftCenterOrRight):lower()
	if direction == "mid" or direction == "centre" then
		direction = "center"
	end
	if direction ~= "left" and direction ~= "center" and direction ~= "right" then
		direction = "left"
	end
	local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
	local holders = screenGui.Holders
	local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
	if not isFromParentIcon then
		self.originalAlignment = finalDirection
	end
	local joinedFrame = self.joinedFrame
	local alignmentHolder = holders[finalDirection]
	self.screenGui = screenGui
	self.alignmentHolder = alignmentHolder
	if not self.isDestroyed then
		self.widget.Parent = joinedFrame or alignmentHolder
	end
	self.alignment = finalDirection
	self.alignmentChanged:Fire(finalDirection)
	Icon.iconChanged:Fire(self)
	return self
end
Icon.setAlignment = Icon.align

function Icon:setLeft()
	self:setAlignment("Left")
	return self
end

function Icon:setMid()
	self:setAlignment("Center")
	return self
end

function Icon:setRight()
	self:setAlignment("Right")
	return self
end

function Icon:setWidth(offsetMinimum, iconState)
	-- This sets a minimum X offset size for the widget, useful
	-- for example if you're constantly changing the label
	-- but don't want the icon to resize every time
	local newSize = UDim2.fromOffset(offsetMinimum, self.widget.Size.Y.Offset)
	self:modifyTheme({"Widget", "Size", newSize, iconState})
	self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
	return self
end

function Icon:setImageScale(number, iconState)
	self:modifyTheme({"IconImageScale", "Value", number, iconState})
	return self
end

function Icon:setImageRatio(number, iconState)
	self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
	return self
end

function Icon:setTextSize(number, iconState)
	self:modifyTheme({"IconLabel", "TextSize", number, iconState})
	return self
end

function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
	fontWeight = fontWeight or Enum.FontWeight.Regular
	fontStyle = fontStyle or Enum.FontStyle.Normal
	local fontFace
	local fontType = typeof(font)
	if fontType == "number" then
		fontFace = Font.fromId(font, fontWeight, fontStyle)
	elseif fontType == "EnumItem" then
		fontFace = Font.fromEnum(font)
	elseif fontType == "string" then
		if not font:match("rbxasset") then
			fontFace = Font.fromName(font, fontWeight, fontStyle)
		end
	end
	if not fontFace then
		fontFace = Font.new(font, fontWeight, fontStyle)
	end
	self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
	return self
end

function Icon:bindToggleItem(guiObjectOrLayerCollector)
	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
		error("Toggle item must be a GuiObject or LayerCollector!")
	end
	self.toggleItems[guiObjectOrLayerCollector] = true
	self:_updateSelectionInstances()
	return self
end

function Icon:unbindToggleItem(guiObjectOrLayerCollector)
	self.toggleItems[guiObjectOrLayerCollector] = nil
	self:_updateSelectionInstances()
	return self
end

function Icon:_updateSelectionInstances()
	-- This is to assist with controller navigation and selection
	-- It converts the value true to an array
	for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
		local buttonInstancesArray = {}
		for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
			if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
				table.insert(buttonInstancesArray, instance)
			end
		end
		self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
	end
end

function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
	for toggleItem, _ in pairs(self.toggleItems) do
		if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
			local property = "Visible"
			if toggleItem:IsA("LayerCollector") then
				property = "Enabled"
			end
			toggleItem[property] = bool
		end
	end
end

function Icon:bindEvent(iconEventName, eventFunction)
	local event = self[iconEventName]
	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
	self.bindedEvents[iconEventName] = event:Connect(function(...)
		eventFunction(self, ...)
	end)
	return self
end

function Icon:unbindEvent(iconEventName)
	local eventConnection = self.bindedEvents[iconEventName]
	if eventConnection then
		eventConnection:Disconnect()
		self.bindedEvents[iconEventName] = nil
	end
	return self
end

function Icon:bindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = true
	self.toggleKeyAdded:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:unbindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = nil
	return self
end

function Icon:call(callback, ...)
	local packedArgs = table.pack(...)
	task.spawn(function()
		callback(self, table.unpack(packedArgs))
	end)
	return self
end

function Icon:addToJanitor(callback)
	self.janitor:add(callback)
	return self
end

function Icon:lock()
	-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = false
	self.locked = true
	return self
end

function Icon:unlock()
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = true
	self.locked = false
	return self
end

function Icon:debounce(seconds)
	self:lock()
	task.wait(seconds)
	self:unlock()
	return self
end

function Icon:autoDeselect(bool)
	-- When set to true the icon will deselect itself automatically whenever
	-- another icon is selected
	if bool == nil then
		bool = true
	end
	self.deselectWhenOtherIconSelected = bool
	return self
end

function Icon:oneClick(bool)
	-- When set to true the icon will automatically deselect when selected, this creates
	-- the effect of a single click button
	local singleClickJanitor = self.singleClickJanitor
	singleClickJanitor:clean()
	if bool or bool == nil then
		singleClickJanitor:add(self.selected:Connect(function()
			self:deselect("OneClick", self)
		end))
	end
	self.oneClickEnabled = true
	return self
end

function Icon:setCaption(text)
	if text == "_hotkey_" and (self.captionText) then
		return self
	end
	local captionJanitor = self.captionJanitor
	self.captionJanitor:clean()
	if not text or text == "" then
		self.caption = nil
		self.captionText = nil
		return self
	end
	local caption = captionJanitor:add(require(elements.Caption)(self))
	caption:SetAttribute("CaptionText", text)
	self.caption = caption
	self.captionText = text
	return self
end

function Icon:setCaptionHint(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.fakeToggleKey = keyCodeEnum
	self.fakeToggleKeyChanged:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:leave()
	local joinJanitor = self.joinJanitor
	joinJanitor:clean()
	return self
end

function Icon:joinMenu(parentIcon)
	Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
	parentIcon.menuChildAdded:Fire(self)
	return self
end

function Icon:setMenu(arrayOfIcons)
	self.menuSet:Fire(arrayOfIcons)
	return self
end

function Icon:setFrozenMenu(arrayOfIcons)
	self:freezeMenu(arrayOfIcons)
	self:setMenu(arrayOfIcons)
end

function Icon:freezeMenu()
	-- A frozen menu is a menu which is permanently locked in the
	-- the selected state (with its toggle hidden)
	self:select("FrozenMenu", self)
	self:bindEvent("deselected", function(icon)
		icon:select("FrozenMenu", self)
	end)
	self:modifyTheme({"IconSpot", "Visible", false})
end

function Icon:joinDropdown(parentIcon)
	parentIcon:getDropdown()
	Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
	parentIcon.dropdownChildAdded:Fire(self)
	return self
end

function Icon:getDropdown()
	local dropdown = self.dropdown
	if not dropdown then
		dropdown = require(elements.Dropdown)(self)
		self.dropdown = dropdown
		self:clipOutside(dropdown)
	end
	return dropdown
end

function Icon:setDropdown(arrayOfIcons)
	self:getDropdown()
	self.dropdownSet:Fire(arrayOfIcons)
	return self
end

function Icon:clipOutside(instance)
	-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
	-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
	-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
	-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
	-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
	local instanceClone = Utility.clipOutside(self, instance)
	self:refreshAppearance(instance)
	return self, instanceClone
end

function Icon:setIndicator(keyCode)
	-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
	-- with controllers to show the user what button to press to highlight the topbar. You don't need
	-- to set an indicator for controllers as this is handled internally within the Gamepad module
	local indicator = self.indicator
	if not indicator then
		indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
		self.indicator = indicator
	end
	self.indicatorSet:Fire(keyCode)
end



-- DESTROY/CLEANUP
function Icon:destroy()
	if self.isDestroyed then
		return
	end
	self:clearNotices()
	if self.parentIconUID then
		self:leave()
	end
	self.isDestroyed = true
	self.janitor:clean()
	Icon.iconRemoved:Fire(self)
end
Icon.Destroy = Icon.destroy



return Icon]]></ProtectedString>
										<int64 name="SourceAssetId">16049574146</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX64CF1735581D4F6DB5887D716EEB1195">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Attribute</string>
											<string name="ScriptGuid">{921C1913-94ED-429B-B0B1-49AEA1BEBC95}</string>
											<ProtectedString name="Source"><![CDATA[-- v3 alone has taken 250+ hours so please consider keeping this
-- required attribute and linking to TopbarPlus within your games
-- description or devforum post. An in-game readable version also
-- makes it easier for me to debug and compare differences betewen
-- live places. Thanks! ~Ben

local RunService = game:GetService("RunService")
local GroupService = game:GetService("GroupService")
local Players = game:GetService("Players")
if not RunService:IsStudio() then
	print(` Running TopbarPlus {require(script.Parent.VERSION)} by ForeverHD`)
end

return {}]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX10527E3EF17C4A038E3D2502B3661496">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Reference</string>
											<string name="ScriptGuid">{C034798A-6302-450A-88FE-F4B64B7E1CBE}</string>
											<ProtectedString name="Source"><![CDATA[-- This module enables you to place Icon wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
-- cause icons to overlap with each other

local replicatedStorage = game:GetService("ReplicatedStorage")
local Reference = {}
Reference.objectName = "TopbarPlusReference"

function Reference.addToReplicatedStorage()
	local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
	objectValue.Name = Reference.objectName
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    return objectValue
end

function Reference.getObject()
	local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
    if objectValue then
        return objectValue
    end
    return false
end

return Reference]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXFF38CAF9D6D941CA8D109CB1A7C77B88">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">VERSION</string>
											<string name="ScriptGuid">{829F4B00-2CCA-4F6A-A15C-C6CD116E4FA5}</string>
											<ProtectedString name="Source">return &quot;v3.0.2&quot;</ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX34D7E6F3FE39428884B6B9F609F39F60">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Utility</string>
											<string name="ScriptGuid">{3A75CFAF-424B-44AD-8955-6E5B7584B4A5}</string>
											<ProtectedString name="Source"><![CDATA[-- Just generic utility functions which I use and repeat across all my projects



-- LOCAL
local Utility = {}
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer



-- FUNCTIONS
function Utility.createStagger(delayTime, callback, delayInitially)
	-- This creates and returns a function which when called
	-- acts identically to callback, however will only be called
	-- for a maximum of once per delayTime. If the returned function
	-- is called more than once during the delayTime, then it will
	-- wait until the expiryTime then perform another recall.
	-- This is useful for visual interfaces and effects which may be
	-- triggered multiple times within a frame or short period, but which
	-- we don't necessary need to (for performance reasons).
	local staggerActive = false
	local multipleCalls = false
	if not delayTime or delayTime == 0 then
		-- We make 0.01 instead of 0 because devices can now run at
		-- different frame rates
		delayTime = 0.01
	end
	local function staggeredCallback(...)
		if staggerActive then
			multipleCalls = true
			return
		end
		local packedArgs = table.pack(...)
		staggerActive = true
		multipleCalls = false
		task.spawn(function()
			if delayInitially then
				task.wait(delayTime)
			end
			callback(table.unpack(packedArgs))
		end)
		task.delay(delayTime, function()
			staggerActive = false
			if multipleCalls then
				-- This means it has been called at least once during
				-- the stagger period, so call again
				staggeredCallback(table.unpack(packedArgs))
			end
		end)
	end
	return staggeredCallback
end

function Utility.round(n)
	-- Credit to Darkmist101 for this
	return math.floor(n + 0.5)
end

function Utility.reverseTable(t)
	for i = 1, math.floor(#t/2) do
		local j = #t - i + 1
		t[i], t[j] = t[j], t[i]
	end
end

function Utility.copyTable(t)
	-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = Utility.copyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end

local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
function Utility.generateUID(length)
	length = length or 8
	local UID = ""
	local list = validCharacters
	local total = #list
	for i = 1, length do
		local randomCharacter = list[math.random(1, total)]
		UID = UID..randomCharacter
	end
	return UID
end

local instanceTrackers = {}
function Utility.setVisible(instance, bool, sourceUID)
	-- This effectively works like a buff object but
	-- incredibly simplified. It stacks false values
	-- so that if there is more than more than, the 
	-- instance remains hidden even if set visible true
	local tracker = instanceTrackers[instance]
	if not tracker then
		tracker = {}
		instanceTrackers[instance] = tracker
		instance.Destroying:Once(function()
			instanceTrackers[instance] = nil
		end)
	end
	if not bool then
		tracker[sourceUID] = true
	else
		tracker[sourceUID] = nil
	end
	local isVisible = bool
	if bool then
		for sourceUID, _ in pairs(tracker) do
			isVisible = false
			break
		end
	end
	instance.Visible = isVisible
end

function Utility.formatStateName(incomingStateName)
	return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
end

function Utility.localPlayerRespawned(callback)
	-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
	-- In these scenarios, traditional methods like CharacterAdded won't be called by the
	-- time the localscript has been destroyed, therefore we listen for removing instead
	-- If humanoid and health == 0, then reset/died normally, else was
	-- forcefully reset via a method such as LoadCharacter
	-- We wrap this behaviour in case any additional quirks need to be accounted for
	localPlayer.CharacterRemoving:Connect(callback)
end

function Utility.getClippedContainer(screenGui)
	-- We always want clipped items to display in front hence
	-- why we have this
	local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
	if not clippedContainer then
		clippedContainer = Instance.new("Folder")
		clippedContainer.Name = "ClippedContainer"
		clippedContainer.Parent = screenGui
	end
	return clippedContainer
end

local Janitor = require(script.Parent.Packages.Janitor)
local GuiService = game:GetService("GuiService")
function Utility.clipOutside(icon, instance)
	local cloneJanitor = icon.janitor:add(Janitor.new())
	instance.Destroying:Once(function()
		cloneJanitor:Destroy()
	end)
	icon.janitor:add(instance)

	local originalParent = instance.Parent
	local clone = cloneJanitor:add(Instance.new("Frame"))
	clone:SetAttribute("IsAClippedClone", true)
	clone.Name = instance.Name
	clone.AnchorPoint = instance.AnchorPoint
	clone.Size = instance.Size
	clone.Position = instance.Position
	clone.BackgroundTransparency = 1
	clone.LayoutOrder = instance.LayoutOrder
	clone.Parent = originalParent

	local valueInstance = Instance.new("ObjectValue")
	valueInstance.Name = "OriginalInstance"
	valueInstance.Value = instance
	valueInstance.Parent = clone

	local valueInstanceCopy = valueInstance:Clone()
	instance:SetAttribute("HasAClippedClone", true)
	valueInstanceCopy.Name = "ClippedClone"
	valueInstanceCopy.Value = clone
	valueInstanceCopy.Parent = instance

	local screenGui
	local function updateScreenGui()
		local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
		screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else originalScreenGui.Parent[originalScreenGui.Name.."Clipped"]
		instance.AnchorPoint = Vector2.new(0, 0)
		instance.Parent = Utility.getClippedContainer(screenGui)
	end
	cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
	updateScreenGui()

	-- Lets copy over children that modify size
	for _, child in pairs(instance:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			child:Clone().Parent = clone
		end
	end

	-- If the icon is hidden, its important we are too (as
	-- setting a parent to visible = false no longer makes
	-- this hidden)
	local widget = icon.widget
	local isOutsideParent = false
	local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
	local function updateVisibility()
		if ignoreVisibilityUpdater then
			return
		end
		local isVisible = widget.Visible
		
		if isOutsideParent then
			isVisible = false
		end
		Utility.setVisible(instance, isVisible, "ClipHandler")
	end
	cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))

	local previousScroller
	local Icon = require(icon.iconModule)
	local function checkIfOutsideParentXBounds()
		-- Defer so that roblox's properties reflect their true values
		task.defer(function()
			-- If the instance is within a parent item (such as a dropdown or menu)
			-- then we hide it if it exceeds the bounds of that parent
			local parentInstance
			local ourUID = icon.UID
			local nextIconUID = ourUID
			local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
			if shouldClipToParent then
				for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
					local nextIcon = Icon.getIconByUID(nextIconUID)
					if not nextIcon then
						break
					end
					local nextParentInstance = nextIcon.joinedFrame
					nextIconUID = nextIcon.parentIconUID
					if not nextParentInstance then
						break
					end
					parentInstance = nextParentInstance
				end
			end
			if not parentInstance then
				isOutsideParent = false
				updateVisibility()
				return
			end
			local pos = instance.AbsolutePosition
			local halfSize = instance.AbsoluteSize/2
			local parentPos = parentInstance.AbsolutePosition
			local parentSize = parentInstance.AbsoluteSize
			local posHalf = (pos + halfSize)
			local exceededLeft = posHalf.X < parentPos.X
			local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
			local exceededTop = posHalf.Y < parentPos.Y
			local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
			local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
			if hasExceeded ~= isOutsideParent then
				isOutsideParent = hasExceeded
				updateVisibility()
			end
			if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
				previousScroller = parentInstance
				local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
					checkIfOutsideParentXBounds()
				end)
				cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
			end
		end)
	end

	local camera = workspace.CurrentCamera
	local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
	local function trackProperty(property)
		local absoluteProperty = "Absolute"..property
		local function updateProperty()
			local cloneValue = clone[absoluteProperty]
			local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
			if property == "Position" then

				-- This binds the instances within the bounds of the screen
				local SIDE_PADDING = 4
				local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
				local inputX = absoluteValue.X.Offset
				if inputX < SIDE_PADDING then
					inputX = SIDE_PADDING
				elseif inputX > limitX then
					inputX = limitX
				end
				absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)

				-- AbsolutePosition does not perfectly match with TopbarInsets enabled
				-- This corrects this
				local topbarInset = GuiService.TopbarInset
				local viewportWidth = workspace.CurrentCamera.ViewportSize.X
				local guiWidth = screenGui.AbsoluteSize.X
				local guiOffset = screenGui.AbsolutePosition.X
				local widthDifference = guiOffset - topbarInset.Min.X
				local oldTopbarCenterOffset = 0--widthDifference/30 -- I have no idea why this works, it just does
				local offsetX = if icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset
				
				-- Also add additionalOffset
				offsetX -= additionalOffsetX
				absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)

				-- Finally check if within its direct parents bounds
				checkIfOutsideParentXBounds()

			end
			instance[property] = absoluteValue
		end
		
		-- This defer is essential as the listener may be in a different screenGui to the actor
		local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))
		
		-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
		-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
		-- within this type of screenGui DO NOT accurately update to match their new
		-- real world position; instead they jump around almost randomly for a few frames.
		-- I have spent way too many hours trying to solve this bug, I think the only way
		-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
		-- have time to redesign the entire system around that at the moment.
		-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
		local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))
		
	end
	task.delay(0.1, checkIfOutsideParentXBounds)
	checkIfOutsideParentXBounds()
	updateVisibility()
	trackProperty("Position")
	
	-- Track visiblity changes
	cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
		--print("Visiblity changed:", instance, clone, instance.Visible)
		--clone.Visible = instance.Visible
	end))

	-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
	local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
	if shouldTrackCloneSize then
		trackProperty("Size")
	else
		cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			local absolute = instance.AbsoluteSize
			clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end))
	end

	return clone
end

function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)

	-- This is resonsible for moving the icon under a feature like a dropdown
	local joinJanitor = originalIcon.joinJanitor
	joinJanitor:clean()
	if not scrollingFrameOrFrame then
		originalIcon:leave()
		return
	end
	originalIcon.parentIconUID = parentIcon.UID
	originalIcon.joinedFrame = scrollingFrameOrFrame
	local function updateAlignent()
		local parentAlignment = parentIcon.alignment
		if parentAlignment == "Center" then
			parentAlignment = "Left"
		end
		originalIcon:setAlignment(parentAlignment, true)
	end
	joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
	updateAlignent()
	originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
	originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
	if parentIcon.childModifications then
		-- We defer so that the default values (such as dropdown
		-- minimum width can be applied before any custom
		-- child modifications from the user)
		task.defer(function()
			originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
		end)
	end
	--
	local clickRegion = originalIcon:getInstance("ClickRegion")
	local function makeSelectable()
		clickRegion.Selectable = parentIcon.isSelected
	end
	joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
	task.defer(makeSelectable)
	joinJanitor:add(function()
		clickRegion.Selectable = true
	end)
	--

	-- We track icons in arrays and dictionaries using their UID instead of the icon
	-- itself to prevent heavy cyclical tables when printing the icons
	local originalIconUID = originalIcon.UID
	table.insert(iconsArray, originalIconUID)
	parentIcon:autoDeselect(false)
	parentIcon.childIconsDict[originalIconUID] = true
	if not parentIcon.isEnabled then
		parentIcon:setEnabled(true)
	end
	originalIcon.joinedParent:Fire(parentIcon)

	-- This is responsible for removing it from that feature and updating
	-- their parent icon so its informed of the icon leaving it
	joinJanitor:add(function()
		local joinedFrame = originalIcon.joinedFrame
		if not joinedFrame then
			return
		end
		for i, iconUID in pairs(iconsArray) do
			if iconUID == originalIconUID then
				table.remove(iconsArray, i)
				break
			end
		end
		local Icon = require(originalIcon.iconModule)
		local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
		if not parentIcon then
			return
		end
		originalIcon:setAlignment(originalIcon.originalAlignment)
		originalIcon.parentIconUID = false
		originalIcon.joinedFrame = false
		originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
		originalIcon:removeModification("JoinModification")
		
		local parentHasNoChildren = true
		local parentChildIcons = parentIcon.childIconsDict
		parentChildIcons[originalIconUID] = nil
		for childIconUID, _ in pairs(parentChildIcons) do
			parentHasNoChildren = false
			break
		end
		if parentHasNoChildren and not parentIcon.isAnOverflow then
			parentIcon:setEnabled(false)
		end
		updateAlignent()

	end)

end



return Utility]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX32184DB893E045398E33624DF60FC5E1">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Themes</string>
											<string name="ScriptGuid">{17C3B1B3-99F4-43A8-A698-7E43921E4714}</string>
											<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX8A1E29F1443741A2A1D88A4F39FD66A1">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Classic</string>
												<string name="ScriptGuid">{61055A5A-3EEE-48B8-AB2D-B81A36F31D9D}</string>
												<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXD4EA39A52A0E473AA251D612608876DE">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Default</string>
												<string name="ScriptGuid">{A642E8FD-1E4D-4414-BBA4-4E3463F8F9D7}</string>
												<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
	{"IconButton", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.3, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Medium, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.925, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
	{"Dropdown", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.3, "Deselected"},
	{"Dropdown", "MaxIcons", 4, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="PackageLink" referent="RBXDEB776EF6F474368BB94AEE1FA4747E0">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoUpdate">false</bool>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<string name="DefaultName"></string>
											<bool name="DefinesCapabilities">false</bool>
											<int name="ModifiedState">1</int>
											<string name="Name">PackageLink</string>
											<Content name="PackageIdSerialize"><url>rbxassetid://16049574146</url></Content>
											<BinaryString name="SerializedDefaultAttributes"></BinaryString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<int64 name="VersionIdSerialize">20</int64>
										</Properties>
									</Item>
									<Item class="Folder" referent="RBXA6AD9C6ABE234380A60037B9BAF79564">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Elements</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXBAE03922DCAB4CB6B6E07B423D001FA2">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Caption</string>
												<string name="ScriptGuid">{0BCA3AFF-CD66-43CB-A4C5-D311B4ACCAD3}</string>
												<ProtectedString name="Source"><![CDATA[return function(icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local clickRegion = icon:getInstance("ClickRegion")
	local caption = Instance.new("CanvasGroup")
	caption.Name = "Caption"
	caption.AnchorPoint = Vector2.new(0.5, 0)
	caption.BackgroundTransparency = 1
	caption.BorderSizePixel = 0
	caption.GroupTransparency = 1
	caption.Position = UDim2.fromOffset(0, 0)
	caption.Visible = true
	caption.ZIndex = 30
	caption.Parent = clickRegion

	local box = Instance.new("Frame")
	box.Name = "Box"
	box.AutomaticSize = Enum.AutomaticSize.XY
	box.BackgroundColor3 = Color3.fromRGB(101, 102, 104)
	box.Position = UDim2.fromOffset(4, 7)
	box.ZIndex = 12
	box.Parent = caption

	local header = Instance.new("TextLabel")
	header.Name = "Header"
	header.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	header.Text = "Caption"
	header.TextColor3 = Color3.fromRGB(255, 255, 255)
	header.TextSize = 14
	header.TextTruncate = Enum.TextTruncate.None
	header.TextWrapped = false
	header.TextXAlignment = Enum.TextXAlignment.Left
	header.AutomaticSize = Enum.AutomaticSize.X
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Size = UDim2.fromOffset(0, 16)
	header.ZIndex = 18
	header.Parent = box

	local layout = Instance.new("UIListLayout")
	layout.Name = "Layout"
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = box

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "CaptionCorner"
	UICorner.Parent = box

	local padding = Instance.new("UIPadding")
	padding.Name = "Padding"
	padding.PaddingBottom = UDim.new(0, 12)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingTop = UDim.new(0, 12)
	padding.Parent = box

	local hotkeys = Instance.new("Frame")
	hotkeys.Name = "Hotkeys"
	hotkeys.AutomaticSize = Enum.AutomaticSize.Y
	hotkeys.BackgroundTransparency = 1
	hotkeys.LayoutOrder = 3
	hotkeys.Size = UDim2.fromScale(1, 0)
	hotkeys.Visible = false
	hotkeys.Parent = box

	local layout1 = Instance.new("UIListLayout")
	layout1.Name = "Layout1"
	layout1.Padding = UDim.new(0, 6)
	layout1.FillDirection = Enum.FillDirection.Vertical
	layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout1.HorizontalFlex = Enum.UIFlexAlignment.None
	layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
	layout1.VerticalFlex = Enum.UIFlexAlignment.None
	layout1.SortOrder = Enum.SortOrder.LayoutOrder
	layout1.Parent = hotkeys

	local keyTag1 = Instance.new("ImageLabel")
	keyTag1.Name = "Key1"
	keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
	keyTag1.ImageTransparency = 0.7
	keyTag1.ScaleType = Enum.ScaleType.Slice
	keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
	keyTag1.AutomaticSize = Enum.AutomaticSize.X
	keyTag1.BackgroundTransparency = 1
	keyTag1.LayoutOrder = 1
	keyTag1.Size = UDim2.fromOffset(0, 30)
	keyTag1.ZIndex = 15
	keyTag1.Parent = hotkeys

	local inset = Instance.new("UIPadding")
	inset.Name = "Inset"
	inset.PaddingLeft = UDim.new(0, 8)
	inset.PaddingRight = UDim.new(0, 8)
	inset.Parent = keyTag1

	local labelContent = Instance.new("TextLabel")
	labelContent.AutoLocalize = false
	labelContent.Name = "LabelContent"
	labelContent.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	labelContent.Text = ""
	labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
	labelContent.TextSize = 14
	labelContent.AutomaticSize = Enum.AutomaticSize.X
	labelContent.BackgroundTransparency = 1
	labelContent.Position = UDim2.fromOffset(0, -1)
	labelContent.Size = UDim2.fromScale(1, 1)
	labelContent.ZIndex = 16
	labelContent.Parent = keyTag1
	
	local caret = Instance.new("ImageLabel")
	caret.Name = "Caret"
	caret.Image = "rbxasset://LuaPackages/Packages/_Index/UIBlox/UIBlox/AppImageAtlas/img_set_1x_1.png"
	caret.ImageColor3 = Color3.fromRGB(101, 102, 104)
	caret.ImageRectOffset = Vector2.new(260, 440)
	caret.ImageRectSize = Vector2.new(16, 8)
	caret.AnchorPoint = Vector2.new(0, 0.5)
	caret.BackgroundTransparency = 1
	caret.Position = UDim2.new(0, 0, 0, 4)
	caret.Rotation = 180
	caret.Size = UDim2.fromOffset(16, 8)
	caret.ZIndex = 12
	caret.Parent = caption

	local dropShadow = Instance.new("ImageLabel")
	dropShadow.Name = "DropShadow"
	dropShadow.Image = "rbxasset://LuaPackages/Packages/_Index/UIBlox/UIBlox/AppImageAtlas/img_set_1x_1.png"
	dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	dropShadow.ImageRectOffset = Vector2.new(217, 486)
	dropShadow.ImageRectSize = Vector2.new(25, 25)
	dropShadow.ImageTransparency = 0.45
	dropShadow.ScaleType = Enum.ScaleType.Slice
	dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
	dropShadow.BackgroundTransparency = 1
	dropShadow.Position = UDim2.fromOffset(0, 5)
	dropShadow.Size = UDim2.new(1, 0, 0, 48)
	dropShadow.Parent = caption
	box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
	end)
	
	-- It's important we match the sizes as this is not
	-- handles within clipOutside (as it assumes the sizes
	-- are already the same)
	local captionJanitor = icon.captionJanitor
	local _, captionClone = icon:clipOutside(caption)
	captionClone.AutomaticSize = Enum.AutomaticSize.None
	local function matchSize()
		local absolute = caption.AbsoluteSize
		captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
	end
	captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
	matchSize()
	
	
	
	local isCompletelyEnabled = false
	-- This handles the appearing/disappearing/positioning of the caption
	local captionHeader = caption.Box.Header
	local UserInputService = game:GetService("UserInputService")
	local function updateHotkey(keyCodeEnum)
		local hasKeyboard = UserInputService.KeyboardEnabled
		local text = caption:GetAttribute("CaptionText") or ""
		local hideHeader = text == "_hotkey_"
		if not hasKeyboard and hideHeader then
			icon:setCaption()
			return
		end
		captionHeader.Text = text
		captionHeader.Visible = not hideHeader
		if keyCodeEnum then
			labelContent.Text = keyCodeEnum.Name
			hotkeys.Visible = true
		end
		if not hasKeyboard then
			hotkeys.Visible = false
		end
	end
	caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)

	local EASING_STYLE = Enum.EasingStyle.Quad
	local TWEEN_SPEED = 0.2
	local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
	local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local function getCaptionPosition(customEnabled)
		local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
		local yOut = 2
		local yIn = yOut + 8
		local yOffset = if enabled then yIn else yOut
		return UDim2.new(0.5, 0, 1, yOffset)
	end
	local function updatePosition(forcedEnabled)
		
		-- Ignore changes if not enabled to reduce redundant calls
		if not isCompletelyEnabled then
			return
		end
		
		-- Currently the one thing which isn't accounted for are the bounds of the screen
		-- This would be an issue if someone sets a long caption text for the left or
		-- right most icon
		local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
		local startPosition = getCaptionPosition(not enabled)
		local endPosition = getCaptionPosition(enabled)
		
		-- It's essential we reset the carets position to prevent the x sizing bounds
		-- of the caption from infinitely scaling up
		if enabled then
			local caretY = caret.Position.Y.Offset
			caret.Position = UDim2.fromOffset(0, caretY)
			caption.AutomaticSize = Enum.AutomaticSize.XY
			caption.Size = UDim2.fromOffset(32, 53)
		else
			local absolute = caption.AbsoluteSize
			caption.AutomaticSize = Enum.AutomaticSize.Y
			caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end
		
		-- We initially default to the opposite state
		local previousCaretX
		local function updateCaret()
			local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
			local caretY = caret.Position.Y.Offset
			local newCaretPosition = UDim2.fromOffset(caretX, caretY)
			if previousCaretX ~= caretX then
				-- Again, it's essential we reset the caret if
				-- a difference in X position is detected otherwise
				-- a slight quirk with AutomaticCanvas can cause
				-- the caption to infinitely scale
				previousCaretX = caretX
				caret.Position = UDim2.fromOffset(0, caretY)
				task.wait()
			end
			caret.Position = newCaretPosition
		end
		captionClone.Position = startPosition
		updateCaret()
		
		-- Now we tween into the new state
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
		local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
		tween:Play()
		tween.Completed:Once(function()
			updateCaretConnection:Disconnect()
		end)
		
	end
	captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updatePosition()
	end))
	updatePosition(false)
	
	captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
	for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
		updateHotkey(keyCodeEnum)
		break
	end
	captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
	local fakeToggleKey = icon.fakeToggleKey
	if fakeToggleKey then
		updateHotkey(fakeToggleKey)
	end

	local function setCaptionEnabled(enabled)
		if isCompletelyEnabled == enabled then
			return
		end
		local joinedFrame = icon.joinedFrame
		if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
			enabled = false
		end
		isCompletelyEnabled = enabled
		local newTransparency = (enabled and 0) or 1
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tweenTransparency = TweenService:Create(caption, tweenInfo, {
			GroupTransparency = newTransparency
		})
		tweenTransparency:Play()
		updatePosition()
		updateHotkey()
	end
	
	local WAIT_DURATION = 0.5
	local RECOVER_PERIOD = 0.3
	local Icon = require(icon.iconModule)
	captionJanitor:add(icon.stateChanged:Connect(function(stateName)
		if stateName == "Viewing" then
			local lastClock = Icon.captionLastClosedClock
			local clockDifference = (lastClock and os.clock() - lastClock) or 999
			local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
			task.delay(waitDuration, function()
				if icon.activeState == "Viewing" then
					setCaptionEnabled(true)
				end
			end)
		else
			Icon.captionLastClosedClock = os.clock()
			setCaptionEnabled(false)
		end
	end))
	
	return caption
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX1DF6D3BEBC034D4EB333E099C444F675">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Container</string>
												<string name="ScriptGuid">{C9E4BB7D-B02C-4FC3-AFA9-10A365E7D7EA}</string>
												<ProtectedString name="Source"><![CDATA[return function(Icon)
	
	local GuiService = game:GetService("GuiService")
	local isOldTopbar = Icon.isOldTopbar
	local container = {}
	local guiInset = GuiService:GetGuiInset()
	local isConsoleScreen = GuiService:IsTenFootInterface()
	local startInset = if isOldTopbar then 12 else guiInset.Y - (44 + 2)
	if isConsoleScreen then
		startInset = 10
	end
	local screenGui = Instance.new("ScreenGui")
	screenGui:SetAttribute("StartInset", startInset)
	screenGui.Name = "TopbarStandard"
	screenGui.Enabled = true
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true
	screenGui.ResetOnSpawn = false
	screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
	container[screenGui.Name] = screenGui
	screenGui.DisplayOrder = Icon.baseDisplayOrder
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGui.DisplayOrder = Icon.baseDisplayOrder
	end)

	local holders = Instance.new("Frame")
	local yDownOffset = if isOldTopbar then 2 else 0
	local ySizeOffset = -2
	if isConsoleScreen then
		yDownOffset += 13
		ySizeOffset = 50
	end
	holders.Name = "Holders"
	holders.BackgroundTransparency = 1
	holders.Position = UDim2.new(0, 0, 0, yDownOffset)
	holders.Size = UDim2.new(1, 0, 1, ySizeOffset)
	holders.Visible = true
	holders.ZIndex = 1
	holders.Parent = screenGui
	
	local screenGuiCenter = screenGui:Clone()
	local holdersCenter = screenGuiCenter.Holders
	local GuiService = game:GetService("GuiService")
	local function updateCenteredHoldersHeight()
		holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
	end
	screenGuiCenter.Name = "TopbarCentered"
	screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	end)
	container[screenGuiCenter.Name] = screenGuiCenter
	GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(updateCenteredHoldersHeight)
	updateCenteredHoldersHeight()
	
	local screenGuiClipped = screenGui:Clone()
	screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
	screenGuiClipped.DisplayOrder += 1
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiClipped.DisplayOrder = Icon.baseDisplayOrder + 1
	end)
	container[screenGuiClipped.Name] = screenGuiClipped
	
	local screenGuiCenterClipped = screenGuiCenter:Clone()
	screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
	screenGuiCenterClipped.DisplayOrder += 1
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenterClipped.DisplayOrder = Icon.baseDisplayOrder + 1
	end)
	container[screenGuiCenterClipped.Name] = screenGuiCenterClipped
	
	if isOldTopbar then
		task.defer(function()
			local function decideToHideTopbar()
				if GuiService.MenuIsOpen then
					Icon.setTopbarEnabled(false, true)
				else
					Icon.setTopbarEnabled()
				end
			end
			GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
			decideToHideTopbar()
		end)
	end
	
	local holderReduction = -24
	local left = Instance.new("ScrollingFrame")
	left:SetAttribute("IsAHolder", true)
	left.Name = "Left"
	left.Position = UDim2.fromOffset(startInset, 0)
	left.Size = UDim2.new(1, holderReduction, 1, 0)
	left.BackgroundTransparency = 1
	left.Visible = true
	left.ZIndex = 1
	left.Active = false
	left.ClipsDescendants = true
	left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
	left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	left.AutomaticCanvasSize = Enum.AutomaticSize.X
	left.ScrollingDirection = Enum.ScrollingDirection.X
	left.ScrollBarThickness = 0
	left.BorderSizePixel = 0
	left.Selectable = false
	left.ScrollingEnabled = false--true
	left.ElasticBehavior = Enum.ElasticBehavior.Never
	left.Parent = holders
	
	local UIListLayout = Instance.new("UIListLayout")
	UIListLayout.Padding = UDim.new(0, startInset)
	UIListLayout.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	UIListLayout.Parent = left
	
	local center = left:Clone()
	center.ScrollingEnabled = false
	center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	center.Name = "Center"
	center.Parent = holdersCenter
	
	local right = left:Clone()
	right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	right.Name = "Right"
	right.AnchorPoint = Vector2.new(1, 0)
	right.Position = UDim2.new(1, -12, 0, 0)
	right.Parent = holders

	return container
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX8535FF5FB7344C8CAA46F5B683F4A33F">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Dropdown</string>
												<string name="ScriptGuid">{C5A3128A-4B1A-4982-BF75-2BEE810006EA}</string>
												<ProtectedString name="Source"><![CDATA[return function(icon)
	
	local dropdown = Instance.new("Frame")
	dropdown.Name = "Dropdown"
	dropdown.AutomaticSize = Enum.AutomaticSize.XY
	dropdown.BackgroundTransparency = 1
	dropdown.BorderSizePixel = 0
	dropdown.AnchorPoint = Vector2.new(0.5, 0)
	dropdown.Position = UDim2.new(0.5, 0, 1, 10)
	dropdown.ZIndex = -2
	dropdown.ClipsDescendants = true
	dropdown.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "DropdownCorner"
	UICorner.CornerRadius = UDim.new(0, 10)
	UICorner.Parent = dropdown

	local dropdownScroller = Instance.new("ScrollingFrame")
	dropdownScroller.Name = "DropdownScroller"
	dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
	dropdownScroller.BackgroundTransparency = 1
	dropdownScroller.BorderSizePixel = 0
	dropdownScroller.AnchorPoint = Vector2.new(0, 0)
	dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
	dropdownScroller.ZIndex = -1
	dropdownScroller.ClipsDescendants = true
	dropdownScroller.Visible = true
	dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
	dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
	dropdownScroller.Active = false
	dropdownScroller.ScrollingEnabled = true
	dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
	dropdownScroller.ScrollBarThickness = 5
	dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	dropdownScroller.ScrollBarImageTransparency = 0.8
	dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	dropdownScroller.Selectable = false
	dropdownScroller.Active = true
	dropdownScroller.Parent = dropdown
	
	local dropdownPadding = Instance.new("UIPadding")
	dropdownPadding.Name = "DropdownPadding"
	dropdownPadding.PaddingTop = UDim.new(0, 8)
	dropdownPadding.PaddingBottom = UDim.new(0, 8)
	dropdownPadding.Parent = dropdownScroller

	local dropdownList = Instance.new("UIListLayout")
	dropdownList.Name = "DropdownList"
	dropdownList.FillDirection = Enum.FillDirection.Vertical
	dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
	dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
	dropdownList.Parent = dropdownScroller
	
	local dropdownJanitor = icon.dropdownJanitor
	local Icon = require(icon.iconModule)
	icon.dropdownChildAdded:Connect(function(childIcon)
		-- Modify appearance of child when joined
		local _, modificationUID = childIcon:modifyTheme({
			{"Widget", "BorderSize", 0},
			{"IconCorners", "CornerRadius", UDim.new(0, 4)},
			{"Widget", "MinimumWidth", 190},
			{"Widget", "MinimumHeight", 56},
			{"IconLabel", "TextSize", 19},
			{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
			{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
			{"Selection", "Size", UDim2.new(1, -8, 1, -8)},
			{"Selection", "Position", UDim2.new(0, 4, 0, 4)},
		})
		task.defer(function()
			childIcon.joinJanitor:add(function()
				childIcon:removeModification(modificationUID)
			end)
		end)
	end)
	icon.dropdownSet:Connect(function(arrayOfIcons)
		-- Destroy any previous icons
		for i, otherIconUID in pairs(icon.dropdownIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Add new icons
		local totalNewIcons = #arrayOfIcons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinDropdown(icon)
			end
		end
	end)

	-- Update visibiliy of dropdown
	local Utility = require(script.Parent.Parent.Utility)
	local function updateVisibility()
		--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
		Utility.setVisible(dropdown, icon.isSelected, "InternalDropdown")
	end
	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
	updateVisibility()
	--task.delay(0.2, updateVisibility)
	
	-- This updates the scrolling frame to only display a scroll
	-- length equal to the distance produced by its MaxIcons
	local updateCount = 0
	local isUpdating = false
	local function updateMaxIcons()
		
		-- This prevents more than 1 update occurring every frame
		updateCount += 1
		if isUpdating then
			return
		end
		local myUpdateCount = updateCount
		isUpdating = true
		task.defer(function()
			isUpdating = false
			if updateCount ~= myUpdateCount then
				updateMaxIcons()
			end
		end)
			
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then
			return
		end
		local orderedInstances = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") then
				table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
			end
		end
		table.sort(orderedInstances, function(groupA, groupB)
			return groupA[2] < groupB[2]
		end)
		local totalHeight = 0
		local hasSetNextSelection = false
		for i = 1, maxIcons do
			local group = orderedInstances[i]
			if not group then
				break
			end
			local child = group[1]
			local height = child.AbsoluteSize.Y
			totalHeight += height
			local iconUID = child:GetAttribute("WidgetUID")
			local childIcon = iconUID and Icon.getIconByUID(iconUID)
			if childIcon then
				local nextSelection = nil
				if not hasSetNextSelection then
					hasSetNextSelection = true
					nextSelection = icon:getInstance("ClickRegion")
				end
				childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
			end
		end
		totalHeight += dropdownPadding.PaddingTop.Offset
		totalHeight += dropdownPadding.PaddingBottom.Offset
		dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)
	end
	dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIcons))
	dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIcons))
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIcons))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIcons))
	dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIcons))
	updateMaxIcons()
	
	return dropdown
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX9E99A008B75E4AA9A4344739DE85550E">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Indicator</string>
												<string name="ScriptGuid">{16484D2A-383A-4BDE-9C9C-5318509224ED}</string>
												<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local widget = icon.widget
	local contents = icon:getInstance("Contents")
	local indicator = Instance.new("Frame")
	indicator.Name = "Indicator"
	indicator.LayoutOrder = 9999999
	indicator.ZIndex = 6
	indicator.Size = UDim2.new(0, 42, 0, 42)
	indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicator.BackgroundTransparency = 1
	indicator.Position = UDim2.new(1, 0, 0.5, 0)
	indicator.BorderSizePixel = 0
	indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicator.Parent = contents

	local indicatorButton = Instance.new("Frame")
	indicatorButton.Name = "IndicatorButton"
	indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
	indicatorButton.BorderSizePixel = 0
	indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.Parent = indicator
	
	local GuiService = game:GetService("GuiService")
	local GamepadService = game:GetService("GamepadService")
	local ourClickRegion = icon:getInstance("ClickRegion")
	local function selectionChanged()
		local selectedClickRegion = GuiService.SelectedObject
		if selectedClickRegion == ourClickRegion then
			indicatorButton.BackgroundTransparency = 1
			indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
		else
			indicatorButton.BackgroundTransparency = 0.75
			indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1, 1)
		end
	end
	icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
	selectionChanged()

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.LayoutOrder = 2
	imageLabel.ZIndex = 15
	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.Image = "rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png"
	imageLabel.Parent = indicatorButton

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = indicatorButton

	local UserInputService = game:GetService("UserInputService")
	local function setIndicatorVisible(visibility)
		if visibility == nil then
			visibility = indicator.Visible
		end
		if GamepadService.GamepadCursorEnabled then
			visibility = false
		end
		if visibility then
			icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
		elseif indicator.Visible then
			icon:removeModification("IndicatorPadding")
		end
		icon:modifyTheme({"Indicator", "Visible", visibility})
		icon.updateSize:Fire()
	end
	icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
	icon.indicatorSet:Connect(function(keyCode)
		local visibility = false
		if keyCode then
			imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
			visibility = true
		end
		setIndicatorVisible(visibility)
	end)

	local function updateSize()
		local ySize = widget.AbsoluteSize.Y*0.96
		indicator.Size = UDim2.new(0, ySize, 0, ySize)
	end
	widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
	updateSize()

	return indicator
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX94737B3F3FF9410DB9697EF49AB50738">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Menu</string>
												<string name="ScriptGuid">{AB92C211-8EAF-4815-BFBF-5396BF4778DB}</string>
												<ProtectedString name="Source"><![CDATA[return function(icon)

	local menu = Instance.new("ScrollingFrame")
	menu.Name = "Menu"
	menu.BackgroundTransparency = 1
	menu.Visible = true
	menu.ZIndex = 1
	menu.Size = UDim2.fromScale(1, 1)
	menu.ClipsDescendants = true
	menu.TopImage = ""
	menu.BottomImage = ""
	menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
	menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	menu.ScrollingEnabled = true
	menu.ScrollingDirection = Enum.ScrollingDirection.X
	menu.ZIndex = 20
	menu.ScrollBarThickness = 3
	menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	menu.ScrollBarImageTransparency = 0.8
	menu.BorderSizePixel = 0
	menu.Selectable = false
	
	local Icon = require(icon.iconModule)
	local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
	menuUIListLayout.Name = "MenuUIListLayout"
	menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	menuUIListLayout.Parent = menu

	local menuGap = Instance.new("Frame")
	menuGap.Name = "MenuGap"
	menuGap.BackgroundTransparency = 1
	menuGap.Visible = false
	menuGap.AnchorPoint = Vector2.new(0, 0.5)
	menuGap.ZIndex = 5
	menuGap.Parent = menu
	
	local hasStartedMenu = false
	local Themes = require(script.Parent.Parent.Features.Themes)
	local function totalChildrenChanged()
		
		local menuJanitor = icon.menuJanitor
		local totalIcons = #icon.menuIcons
		if hasStartedMenu then
			if totalIcons <= 0 then
				menuJanitor:clean()
				hasStartedMenu = false
			end
			return
		end
		hasStartedMenu = true
		
		-- Listen for changes
		menuJanitor:add(icon.toggled:Connect(function()
			if #icon.menuIcons > 0 then
				icon.updateSize:Fire()
			end
		end))
		
		-- Modify appearance of menu icon when joined
		local _, modificationUID = icon:modifyTheme({
			{"Menu", "Active", true},
		})
		task.defer(function()
			menuJanitor:add(function()
				icon:removeModification(modificationUID)
			end)
		end)
		
		-- For right-aligned icons, this ensures their menus
		-- close button appear instantly when selected (instead
		-- of partially hidden from view)
		local previousCanvasX = menu.AbsoluteCanvasSize.X
		local function rightAlignCanvas()
			if icon.alignment == "Right" then
				local newCanvasX = menu.AbsoluteCanvasSize.X
				local difference = previousCanvasX - newCanvasX
				previousCanvasX = newCanvasX
				menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
			end
		end
		menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
		menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))
		
		-- Apply a close selected image if the user hasn't applied thier own
		local stateGroup = icon:getStateGroup()
		local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
		local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
		if imageDeselected == imageSelected then
			local fontLink = "rbxasset://fonts/families/FredokaOne.json"
			local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
			icon:removeModificationWith("IconLabel", "Text", "Viewing")
			icon:removeModificationWith("IconLabel", "Image", "Viewing")
			icon:modifyTheme({
				{"IconLabel", "FontFace", fontFace, "Selected"},
				{"IconLabel", "Text", "X", "Selected"},
				{"IconLabel", "TextSize", 20, "Selected"},
				{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
				{"IconImage", "Image", "", "Selected"},
			})
		end

		-- Change order of spot when alignment changes
		local iconSpot = icon:getInstance("IconSpot")
		local menuGap = icon:getInstance("MenuGap")
		local function updateAlignent()
			local alignment = icon.alignment
			if alignment == "Right" then
				iconSpot.LayoutOrder = 99999
				menuGap.LayoutOrder = 99998
			else
				iconSpot.LayoutOrder = -99999
				menuGap.LayoutOrder = -99998
			end
		end
		menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
		updateAlignent()
		
		-- This updates the scrolling frame to only display a scroll
		-- length equal to the distance produced by its MaxIcons
		menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
			local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
			local canvasY = menu.CanvasSize.Y
			menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
		end)
		menuJanitor:add(icon.updateMenu:Connect(function()
			local maxIcons = menu:GetAttribute("MaxIcons")
			if not maxIcons then
				return
			end
			local orderedInstances = {}
			for _, child in pairs(menu:GetChildren()) do
				local widgetUID = child:GetAttribute("WidgetUID")
				if widgetUID and child.Visible then
					table.insert(orderedInstances, {child, child.AbsolutePosition.X})
				end
			end
			table.sort(orderedInstances, function(groupA, groupB)
				return groupA[2] < groupB[2]
			end)
			local totalWidth = 0
			for i = 1, maxIcons do
				local group = orderedInstances[i]
				if not group then
					break
				end
				local child = group[1]
				local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
				totalWidth += width
			end
			menu:SetAttribute("MenuWidth", totalWidth)
		end))
		local function startMenuUpdate()
			task.delay(0.1, function()
				icon.startMenuUpdate:Fire()
			end)
		end
		local iconButton = icon:getInstance("IconButton")
		local previousButtonWidth = iconButton.AbsoluteSize.X
		menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
		menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
		startMenuUpdate()
	end
	
	icon.menuChildAdded:Connect(totalChildrenChanged)
	icon.menuSet:Connect(function(arrayOfIcons)
		-- Reset any previous icons
		for i, otherIconUID in pairs(icon.menuIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Apply new icons
		local totalNewIcons = #arrayOfIcons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinMenu(icon)
			end
		end
	end)
	
	return menu
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXE7D381E951244E639182524803F0C0C4">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Selection</string>
												<string name="ScriptGuid">{D21B45B9-1E57-4605-9C95-B7A095EC1743}</string>
												<ProtectedString name="Source"><![CDATA[return function(Icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local selectionContainer = Instance.new("Frame")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Visible = false
	
	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	selection.BackgroundTransparency = 1
	selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
	selection.BorderSizePixel = 0
	selection.Parent = selectionContainer

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Name = "UIStroke"
	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	UIStroke.Color = Color3.fromRGB(255, 255, 255)
	UIStroke.Thickness = 3
	UIStroke.Parent = selection

	local selectionGradient = Instance.new("UIGradient")
	selectionGradient.Name = "SelectionGradient"
	selectionGradient.Parent = UIStroke

	local UICorner = Instance.new("UICorner")
	UICorner:SetAttribute("Collective", "IconCorners")
	UICorner.Name = "UICorner"
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = selection
	
	local RunService = game:GetService("RunService")
	local GuiService = game:GetService("GuiService")
	local rotationSpeed = 1
	selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
		rotationSpeed = selection:GetAttribute("RotationSpeed")
	end)
	RunService.Heartbeat:Connect(function()
		if not GuiService.SelectedObject then
			return
		end
		selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
	end)

	return selectionContainer
	
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX5537039CD0E24EFEB1C49B581D223F05">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Widget</string>
												<string name="ScriptGuid">{CA51CD9D-7735-48C1-B64D-E84F7872ED95}</string>
												<ProtectedString name="Source"><![CDATA[-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
-- the icon (aka Widget) instance.
-- This contains the core components of the icon such as the button, image, label and notice. It's
-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)

return function(icon, Icon)

	local widget = Instance.new("Frame")
	widget:SetAttribute("WidgetUID", icon.UID)
	widget.Name = "Widget"
	widget.BackgroundTransparency = 1
	widget.Visible = true
	widget.ZIndex = 20
	widget.Active = false
	widget.ClipsDescendants = true

	local button = Instance.new("Frame")
	button.Name = "IconButton"
	button.Visible = true
	button.ZIndex = 2
	button.BorderSizePixel = 0
	button.Parent = widget
	button.ClipsDescendants = true
	button.Active = false -- This is essential for mobile scrollers to work when dragging
	icon.deselected:Connect(function()
		button.ClipsDescendants = true
	end)
	icon.selected:Connect(function()
		task.defer(function()
			icon.resizingComplete:Once(function()
				if icon.isSelected then
					button.ClipsDescendants = false
				end
			end)
		end)
	end)

	local iconCorner = Instance.new("UICorner")
	iconCorner:SetAttribute("Collective", "IconCorners")
	iconCorner.Parent = button

	local menu = require(script.Parent.Menu)(icon)
	local menuUIListLayout = menu.MenuUIListLayout
	local menuGap = menu.MenuGap
	menu.Parent = button

	local iconSpot = Instance.new("Frame")
	iconSpot.Name = "IconSpot"
	iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
	iconSpot.BackgroundTransparency = 0.9
	iconSpot.Visible = true
	iconSpot.AnchorPoint = Vector2.new(0, 0.5)
	iconSpot.ZIndex = 5
	iconSpot.Parent = menu

	local iconSpotCorner = iconCorner:Clone()
	iconSpotCorner.Parent = iconSpot

	local overlay = iconSpot:Clone()
	overlay.Name = "IconOverlay"
	overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	overlay.ZIndex = iconSpot.ZIndex + 1
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.AnchorPoint = Vector2.new(0, 0)
	overlay.Visible = false
	overlay.Parent = iconSpot

	local clickRegion = Instance.new("TextButton")
	clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
	clickRegion.Name = "ClickRegion"
	clickRegion.BackgroundTransparency = 1
	clickRegion.Visible = true
	clickRegion.Text = ""
	clickRegion.ZIndex = 20
	clickRegion.Selectable = true
	clickRegion.SelectionGroup = true
	clickRegion.Parent = iconSpot
	
	local Gamepad = require(script.Parent.Parent.Features.Gamepad)
	Gamepad.registerButton(clickRegion)

	local clickRegionCorner = iconCorner:Clone()
	clickRegionCorner.Parent = clickRegion

	local contents = Instance.new("Frame")
	contents.Name = "Contents"
	contents.BackgroundTransparency = 1
	contents.Size = UDim2.fromScale(1, 1)
	contents.Parent = iconSpot

	local contentsList = Instance.new("UIListLayout")
	contentsList.Name = "ContentsList"
	contentsList.FillDirection = Enum.FillDirection.Horizontal
	contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
	contentsList.SortOrder = Enum.SortOrder.LayoutOrder
	contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
	contentsList.Padding = UDim.new(0, 3)
	contentsList.Parent = contents

	local paddingLeft = Instance.new("Frame")
	paddingLeft.Name = "PaddingLeft"
	paddingLeft.LayoutOrder = 1
	paddingLeft.ZIndex = 5
	paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingLeft.BackgroundTransparency = 1
	paddingLeft.BorderSizePixel = 0
	paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingLeft.Parent = contents

	local paddingCenter = Instance.new("Frame")
	paddingCenter.Name = "PaddingCenter"
	paddingCenter.LayoutOrder = 3
	paddingCenter.ZIndex = 5
	paddingCenter.Size = UDim2.new(0, 0, 1, 0)
	paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingCenter.BackgroundTransparency = 1
	paddingCenter.BorderSizePixel = 0
	paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingCenter.Parent = contents

	local paddingRight = Instance.new("Frame")
	paddingRight.Name = "PaddingRight"
	paddingRight.LayoutOrder = 5
	paddingRight.ZIndex = 5
	paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingRight.BackgroundTransparency = 1
	paddingRight.BorderSizePixel = 0
	paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingRight.Parent = contents

	local iconLabelContainer = Instance.new("Frame")
	iconLabelContainer.Name = "IconLabelContainer"
	iconLabelContainer.LayoutOrder = 4
	iconLabelContainer.ZIndex = 3
	iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
	iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
	iconLabelContainer.BackgroundTransparency = 1
	iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	iconLabelContainer.Parent = contents

	local iconLabel = Instance.new("TextLabel")
	local viewportX = workspace.CurrentCamera.ViewportSize.X+200
	iconLabel.Name = "IconLabel"
	iconLabel.LayoutOrder = 4
	iconLabel.ZIndex = 15
	iconLabel.AnchorPoint = Vector2.new(0, 0)
	iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
	iconLabel.ClipsDescendants = false
	iconLabel.BackgroundTransparency = 1
	iconLabel.Position = UDim2.fromScale(0, 0)
	iconLabel.RichText = true
	iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
	iconLabel.Text = ""
	iconLabel.TextWrapped = true
	iconLabel.TextWrap = true
	iconLabel.TextScaled = false
	iconLabel.Active = false
	iconLabel.AutoLocalize = true
	iconLabel.Parent = iconLabelContainer

	local iconImage = Instance.new("ImageLabel")
	iconImage.Name = "IconImage"
	iconImage.LayoutOrder = 2
	iconImage.ZIndex = 15
	iconImage.AnchorPoint = Vector2.new(0, 0.5)
	iconImage.Size = UDim2.new(0, 0, 0.5, 0)
	iconImage.BackgroundTransparency = 1
	iconImage.Position = UDim2.new(0, 11, 0.5, 0)
	iconImage.ScaleType = Enum.ScaleType.Stretch
	iconImage.Active = false
	iconImage.Parent = contents

	local iconImageCorner = iconCorner:Clone()
	iconImageCorner:SetAttribute("Collective", nil)
	iconImageCorner.CornerRadius = UDim.new(0, 0)
	iconImageCorner.Name = "IconImageCorner"
	iconImageCorner.Parent = iconImage

	local TweenService = game:GetService("TweenService")
	local resizingCount = 0
	local repeating = false
	local function handleLabelAndImageChangesUnstaggered(forceUpdateString)

		-- We defer changes by a frame to eliminate all but 1 requests which
		-- could otherwise stack up to 20+ requests in a single frame
		-- We then repeat again once to account for any final changes
		-- Deferring is also essential because properties are set immediately
		-- afterwards (therefore calculations will use the correct values)
		task.defer(function()
			local indicator = icon.indicator
			local usingIndicator = indicator and indicator.Visible
			local usingText = usingIndicator or iconLabel.Text ~= ""
			local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
			local alignment = Enum.HorizontalAlignment.Center
			local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
			local buttonSize = NORMAL_BUTTON_SIZE
			if usingImage and not usingText then
				iconLabelContainer.Visible = false
				iconImage.Visible = true
				paddingLeft.Visible = false
				paddingCenter.Visible = false
				paddingRight.Visible = false
			elseif not usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = false
				paddingLeft.Visible = true
				paddingCenter.Visible = false
				paddingRight.Visible = true
			elseif usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = true
				paddingLeft.Visible = true
				paddingCenter.Visible = not usingIndicator
				paddingRight.Visible = not usingIndicator
				alignment = Enum.HorizontalAlignment.Left
			end
			button.Size = buttonSize

			local function getItemWidth(item)
				local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
				return targetWidth
			end
			local contentsPadding = contentsList.Padding.Offset
			local initialWidgetWidth = contentsPadding --0
			local textWidth = iconLabel.TextBounds.X
			iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
			for _, child in pairs(contents:GetChildren()) do
				if child:IsA("GuiObject") and child.Visible == true then
					local itemWidth = getItemWidth(child)
					initialWidgetWidth += itemWidth + contentsPadding
				end
			end
			local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
			local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
			local widgetBorderSize = widget:GetAttribute("BorderSize")
			local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
			local menuIcons = icon.menuIcons
			local additionalWidth = 0
			local hasMenu = #menuIcons > 0
			local showMenu = hasMenu and icon.isSelected
			if showMenu then
				for _, frame in pairs(menu:GetChildren()) do
					if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
						additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
					end
				end
				if not iconSpot.Visible then
					widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
				end
				additionalWidth -= (widgetBorderSize*0.5)
				widgetWidth += additionalWidth - (widgetBorderSize*0.75)
			end
			menuGap.Visible = showMenu and iconSpot.Visible
			local desiredWidth = widget:GetAttribute("DesiredWidth")
			if desiredWidth and widgetWidth < desiredWidth then
				widgetWidth = desiredWidth
			end

			icon.updateMenu:Fire()
			local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
			local spotWidth = preWidth-(widgetBorderSize*2)
			local menuWidth = menu:GetAttribute("MenuWidth")
			local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
			if totalMenuWidth then
				local maxWidth = menu:GetAttribute("MaxWidth")
				if maxWidth then
					totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
				end
				menu:SetAttribute("MenuCanvasWidth", widgetWidth)
				if totalMenuWidth < widgetWidth then
					widgetWidth = totalMenuWidth
				end
			end

			local style = Enum.EasingStyle.Quint
			local direction = Enum.EasingDirection.Out
			local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
			local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
			local SPEED = 750
			local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
			local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
			TweenService:Create(iconSpot, spotTweenInfo, {
				Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
				Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
			}):Play()
			TweenService:Create(clickRegion, spotTweenInfo, {
				Size = UDim2.new(0, spotWidth, 1, 0),
			}):Play()
			local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
			local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
			if updateInstantly then
				widget.Size = newWidgetSize
			end
			widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
			local movingTween = TweenService:Create(widget, widgetTweenInfo, {
				Size = newWidgetSize,
			})
			movingTween:Play()
			resizingCount += 1
			for i = 1, widgetTweenInfo.Time * 100 do
				task.delay(i/100, function()
					Icon.iconChanged:Fire(icon)
				end)
			end
			task.delay(widgetTweenInfo.Time-0.2, function()
				resizingCount -= 1
				task.defer(function()
					if resizingCount == 0 then
						icon.resizingComplete:Fire()
					end
				end)
			end)
			icon:updateParent()
		end)
	end
	local Utility = require(script.Parent.Parent.Utility)
	local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
	local firstTimeSettingFontFace = true
	icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
	icon:setBehaviour("IconLabel", "FontFace", function(value)
		local previousFontFace = iconLabel.FontFace
		if previousFontFace == value then
			return
		end
		task.spawn(function()
			--[[
			local fontLink = value.Family
			if string.match(fontLink, "rbxassetid://") then
				local ContentProvider = game:GetService("ContentProvider")
				local assets = {fontLink}
				ContentProvider:PreloadAsync(assets)
				print("FONT LOADED!!!")
			end--]]

			-- Afaik there's no way to determine when a Font Family has
			-- loaded (even with ContentProvider), so we just have to try
			-- a few times and hope it loads within the refresh period
			handleLabelAndImageChanges()
			if firstTimeSettingFontFace then
				firstTimeSettingFontFace = false
				for i = 1, 10 do
					task.wait(1)
					handleLabelAndImageChanges()
				end
			end
		end)
	end)
	local function updateBorderSize()
		task.defer(function()
			local borderOffset = widget:GetAttribute("BorderSize")
			local alignment = icon.alignment
			local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
			menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
			menuGap.Size = UDim2.fromOffset(borderOffset, 0)
			menuUIListLayout.Padding = UDim.new(0, 0)
			handleLabelAndImageChanges()
		end)
	end
	icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
	icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
	icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
	icon.updateSize:Connect(handleLabelAndImageChanges)
	icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
	icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
	icon:setBehaviour("IconImage", "Image", function(value)
		local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
		if iconImage.Image ~= textureId then
			handleLabelAndImageChanges()
		end
		return textureId
	end)
	icon.alignmentChanged:Connect(function(newAlignment)
		if newAlignment == "Center" then
			newAlignment = "Left"
		end
		menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
		updateBorderSize()
	end)

	local iconImageScale = Instance.new("NumberValue")
	iconImageScale.Name = "IconImageScale"
	iconImageScale.Parent = iconImage
	iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
		iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
	end)

	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
	UIAspectRatioConstraint.Name = "IconImageRatio"
	UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
	UIAspectRatioConstraint.Parent = iconImage

	local iconGradient = Instance.new("UIGradient")
	iconGradient.Name = "IconGradient"
	iconGradient.Enabled = true
	iconGradient.Parent = button

	local iconSpotGradient = Instance.new("UIGradient")
	iconSpotGradient.Name = "IconSpotGradient"
	iconSpotGradient.Enabled = true
	iconSpotGradient.Parent = iconSpot

	return widget
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXEEE405A010B6421D992F63E119F1E719">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Notice</string>
												<string name="ScriptGuid">{02016B40-A7A0-4C1B-8708-54C78C48C611}</string>
												<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local notice = Instance.new("Frame")
	notice.Name = "Notice"
	notice.ZIndex = 25
	notice.AutomaticSize = Enum.AutomaticSize.X
	notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
	notice.BorderSizePixel = 0
	notice.BackgroundTransparency = 0.1
	notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	notice.Visible = false
	notice.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = notice

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Parent = notice

	local noticeLabel = Instance.new("TextLabel")
	noticeLabel.Name = "NoticeLabel"
	noticeLabel.ZIndex = 26
	noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	noticeLabel.AutomaticSize = Enum.AutomaticSize.X
	noticeLabel.Size = UDim2.new(1, 0, 1, 0)
	noticeLabel.BackgroundTransparency = 1
	noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
	noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.FontSize = Enum.FontSize.Size14
	noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.Text = "1"
	noticeLabel.TextWrapped = true
	noticeLabel.TextWrap = true
	noticeLabel.Font = Enum.Font.Arial
	noticeLabel.Parent = notice
	
	local iconModule = script.Parent.Parent
	local packages = iconModule.Packages
	local Janitor = require(packages.Janitor)
	local Signal = require(packages.GoodSignal)
	local Utility = require(iconModule.Utility)
	icon.noticeChanged:Connect(function(totalNotices)

		-- Notice amount
		if not totalNotices then
			return
		end
		local exceeded99 = totalNotices > 99
		local noticeDisplay = (exceeded99 and "99+") or totalNotices
		noticeLabel.Text = noticeDisplay
		if exceeded99 then
			noticeLabel.TextSize = 11
		end

		-- Should enable
		local enabled = true
		if totalNotices < 1 then
			enabled = false
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
		if icon.isSelected and dropdownOrMenuActive then
			enabled = false
		elseif parentIcon and not parentIcon.isSelected then
			enabled = false
		end
		Utility.setVisible(notice, enabled, "NoticeHandler")

	end)
	icon.noticeStarted:Connect(function(customClearSignal, noticeId)
	
		if not customClearSignal then
			customClearSignal = icon.deselected
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		if parentIcon then
			parentIcon:notify(customClearSignal)
		end
		
		local noticeJanitor = icon.janitor:add(Janitor.new())
		local noticeComplete = noticeJanitor:add(Signal.new())
		noticeJanitor:add(icon.endNotices:Connect(function()
			noticeComplete:Fire()
		end))
		noticeJanitor:add(customClearSignal:Connect(function()
			noticeComplete:Fire()
		end))
		noticeId = noticeId or Utility.generateUID()
		icon.notices[noticeId] = {
			completeSignal = noticeComplete,
			clearNoticeEvent = customClearSignal,
		}
		local noticeLabel = icon:getInstance("NoticeLabel")
		local function updateNotice()
			icon.noticeChanged:Fire(icon.totalNotices)
		end
		icon.notified:Fire(noticeId)
		icon.totalNotices += 1
		updateNotice()
		noticeComplete:Once(function()
			noticeJanitor:destroy()
			icon.totalNotices -= 1
			icon.notices[noticeId] = nil
			updateNotice()
		end)
	end)
	
	-- Establish the notice
	notice:SetAttribute("ClipToJoinedParent", true)
	icon:clipOutside(notice)
	
	return notice
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX52ABC851011343E0BBE2C00DDB8B7C6E">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Features</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX56E7AD300F304D1E84E529C8A3669B9D">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Gamepad</string>
												<string name="ScriptGuid">{FC5DDBD1-6D79-4F69-BC2C-9F4F1BCE4BEA}</string>
												<ProtectedString name="Source"><![CDATA[-- As the name suggests, this handles everything related to gamepads
-- (i.e. Xbox or Playstation controllers) and their navigation
-- I created a separate module for gamepads (and not touchpads or
-- keyboards) because gamepads are greatly more unqiue and require
-- additional tailored programming



-- SERVICES
local GamepadService = game:GetService("GamepadService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")



-- LOCAL
local Gamepad = {}
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Gamepad.start(incomingIcon)
	
	-- Public variables
	Icon = incomingIcon
	Icon.highlightKey = Enum.KeyCode.DPadUp -- What controller key to highlight the topbar (or set to false to disable)
	Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most
	
	-- We defer so the developer can make changes before the
	-- gamepad controls are initialized
	task.delay(1, function()
		-- Some local utility
		local iconsDict = Icon.iconsDictionary
		local function getIconFromSelectedObject()
			local clickRegion = GuiService.SelectedObject
			local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
			local icon = iconUID and iconsDict[iconUID]
			return icon
		end
		
		-- This enables users to instantly open up their last selected icon
		local previousHighlightedIcon
		local iconDisplayingHighlightKey
		local usedIndicatorOnce = false
		local usedBOnce = false
		local Utility = require(script.Parent.Parent.Utility)
		local Selection = require(script.Parent.Parent.Elements.Selection)
		local function updateSelectedObject()
			local icon = getIconFromSelectedObject()
			local gamepadEnabled = UserInputService.GamepadEnabled
			if icon then
				if gamepadEnabled then
					local clickRegion = icon:getInstance("ClickRegion")
					local selection = icon.selection
					if not selection then
						selection = icon.janitor:add(Selection(Icon))
						selection:SetAttribute("IgnoreVisibilityUpdater", true)
						selection.Parent = icon.widget
						icon.selection = selection
						icon:refreshAppearance(selection) --icon:clipOutside(selection)
					end
					clickRegion.SelectionImageObject = selection.Selection
				end
				if previousHighlightedIcon and previousHighlightedIcon ~= icon then
					previousHighlightedIcon:setIndicator()
				end
				local newIndicator = if gamepadEnabled and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
				previousHighlightedIcon = icon
				Icon.lastHighlightedIcon = icon
				icon:setIndicator(newIndicator)
			else
				local newIndicator = if gamepadEnabled and not usedIndicatorOnce then Icon.highlightKey else nil
				if not previousHighlightedIcon then
					previousHighlightedIcon = Gamepad.getIconToHighlight()
				end
				if newIndicator == Icon.highlightKey then
					-- We only display the highlightKey once to show
					-- the user how to highlight the topbar icon
					usedIndicatorOnce = true
				else
					--usedBOnce = true
				end
				if previousHighlightedIcon then
					previousHighlightedIcon:setIndicator(newIndicator)
				end
			end
		end
		GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)

		-- This listens for a gamepad being present/added/removed
		local function checkGamepadEnabled()
			local gamepadEnabled = UserInputService.GamepadEnabled
			if not gamepadEnabled then
				usedIndicatorOnce = false
				usedBOnce = false
			end
			updateSelectedObject()
		end
		UserInputService:GetPropertyChangedSignal("GamepadEnabled"):Connect(checkGamepadEnabled)
		checkGamepadEnabled()

		-- This allows for easy highlighting of the topbar when the
		-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
		-- If you'd like to disable, do ``Icon.highlightKey = false``
		UserInputService.InputBegan:Connect(function(input, touchingAnObject)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				-- Sometimes the Roblox gamepad glitches when combined with a cursor
				-- This fixes that by unhighlighting if the cursor is pressed down
				-- (i.e. a mouse click)
				local icon = getIconFromSelectedObject()
				if icon then
					GuiService.SelectedObject = nil
				end
				return
			end
			if input.KeyCode ~= Icon.highlightKey then
				return
			end
			local iconToHighlight = Gamepad.getIconToHighlight()
			if iconToHighlight then
				if GamepadService.GamepadCursorEnabled then
					task.wait(0.2)
					GamepadService:DisableGamepadCursor()
				end
				local clickRegion = iconToHighlight:getInstance("ClickRegion")
				GuiService.SelectedObject = clickRegion
			end
		end)
	end)
end

function Gamepad.getIconToHighlight()
	-- If an icon has already been selected, returns the last selected icon
	-- Else if more than 0 icons, it selects the left-most icon
	local iconsDict = Icon.iconsDictionary
	local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
	if not iconToHighlight then
		local currentX
		for _, icon in pairs(iconsDict) do
			if icon.parentIconUID then
				continue
			end
			local thisX = icon.widget.AbsolutePosition.X
			if not currentX or thisX < currentX then
				iconToHighlight = icon
				currentX = iconToHighlight.widget.AbsolutePosition.X
			end
		end
	end
	return iconToHighlight
end

-- This called when the icon's ClickRegion is created
function Gamepad.registerButton(buttonInstance)
	-- This provides a basic level of support for controllers by making
	-- the icons easy to highlight via the virtual cursor, then
	-- when selected, focuses in on the selected icon and hops
	-- between other nearby icons simply by toggling the joystick
	local inputBegan = false
	buttonInstance.InputBegan:Connect(function(input)
		-- Two wait frames required to ensure inputBegan is detected within
		-- UserInputService.InputBegan. We do this because object.InputBegan
		-- does not return the correct input objects (unlike the service)
		inputBegan = true
		task.wait()
		task.wait()
		inputBegan = false
	end)
	local connection = UserInputService.InputBegan:Connect(function(input)
		task.wait()
		if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
			-- We focus on an icon when selected via the virtual cursor
			task.wait(0.2)
			GamepadService:DisableGamepadCursor()
			GuiService.SelectedObject = buttonInstance
			return
		end
		local isSelected = GuiService.SelectedObject == buttonInstance
		local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
		local keyName = input.KeyCode.Name
		if table.find(unselectKeyCodes, keyName) and isSelected then
			-- We unfocus when back button is pressed, but ignore
			-- if the virtual cursor is disabled otherwise it will be
			-- impossible to select the topbar
			if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
				GuiService.SelectedObject = nil
			end
		end
	end)
	buttonInstance.Destroying:Once(function()
		connection:Disconnect()
	end)
end



return Gamepad]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX71EA82F9CF1C4C00B818B334BCD431E4">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Overflow</string>
												<string name="ScriptGuid">{D594FC91-E0DA-49EB-A28F-B259863300EA}</string>
												<ProtectedString name="Source"><![CDATA[-- When designing your game for many devices and screen sizes, icons may occasionally
-- particularly for smaller devices like phones, overlap with other icons or the bounds
-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring



-- LOCAL
local Overflow = {}
local holders = {}
local orderedAvailableIcons = {}
local iconsDict
local currentCamera = workspace.CurrentCamera
local overflowIcons = {}
local overflowIconUIDs = {}
local Utility = require(script.Parent.Parent.Utility)
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Overflow.start(incomingIcon)
	Icon = incomingIcon
	iconsDict = Icon.iconsDictionary
	local primaryScreenGui
	for _, screenGui in pairs(Icon.container) do
		if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
			primaryScreenGui = screenGui
		end
		for _, holder in pairs(screenGui.Holders:GetChildren()) do
			if holder:GetAttribute("IsAHolder") then
				holders[holder.Name] = holder
			end
		end
	end

	-- We listen for changes in icons (such as them being added, removed,
	-- the setting of a different alignment, the widget size changing, etc)
	local beginOverflow = false
	local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
		if not beginOverflow then
			return
		end
		if not ignoreAvailable then
			Overflow.updateAvailableIcons("Center")
		end
		Overflow.updateBoundary("Left")
		Overflow.updateBoundary("Right")
	end)
	task.delay(1, function()
		-- This is essential to prevent central icons begin added
		-- left or right due to incomplete UIListLayout calculations
		-- within the first few frames
		beginOverflow = true
		updateBoundaries()
	end)
	Icon.iconAdded:Connect(updateBoundaries)
	Icon.iconRemoved:Connect(updateBoundaries)
	Icon.iconChanged:Connect(updateBoundaries)
	currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
		updateBoundaries(true)
	end)
	primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updateBoundaries(true)
	end)
end

function Overflow.getWidth(icon, getMaxWidth)
	local widget = icon.widget
	return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
end

function Overflow.getAvailableIcons(alignment)
	local ourOrderedIcons = orderedAvailableIcons[alignment]
	if not ourOrderedIcons then
		ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	end
	return ourOrderedIcons
end

function Overflow.updateAvailableIcons(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon)
	local ourTotal = 0
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local ourOrderedIcons = {}
	for _, icon in pairs(iconsDict) do
		local parentUID = icon.parentIconUID
		local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
		local isOverflow = overflowIconUIDs[icon.UID]
		if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow then
			table.insert(ourOrderedIcons, icon)
			ourTotal += 1
		end
	end

	-- Ignore if no icons are available
	if ourTotal <= 0 then
		return {}
	end

	-- This sorts these icons by smallest order, or if equal, left-most position
	-- (even for the right alignment because all icons are sorted left-to-right)
	table.sort(ourOrderedIcons, function(iconA, iconB)
		local orderA = iconA.widget.LayoutOrder
		local orderB = iconB.widget.LayoutOrder
		local hasParentA = iconA.parentIconUID
		local hasParentB = iconB.parentIconUID
		if hasParentA == hasParentB then
			if orderA < orderB then
				return true
			end
			if orderA > orderB then
				return false
			end
			return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
		elseif hasParentB then
			return false
		elseif hasParentA then
			return true
		end
	end)

	-- Finish up
	orderedAvailableIcons[alignment] = ourOrderedIcons
	return ourOrderedIcons

end

function Overflow.getRealXPositions(alignment, orderedIcons)
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local isLeft = alignment == "Left"
	local holder = holders[alignment]
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local holderUIList = holder.UIListLayout
	local topbarInset = holderUIList.Padding.Offset
	local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
	local realXPositions = {}
	if isLeft then
		Utility.reverseTable(orderedIcons)
	end
	for i = #orderedIcons, 1, -1 do
		local icon = orderedIcons[i]
		local sizeX = Overflow.getWidth(icon)
		if not isLeft then
			absoluteX -= sizeX
		end
		realXPositions[icon.UID] = absoluteX
		if isLeft then
			absoluteX += sizeX
		end
		absoluteX += (isLeft and topbarInset) or -topbarInset
	end
	return realXPositions
end

function Overflow.updateBoundary(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local topbarInset = holderUIList.Padding.Offset
	local topbarPadding = holderUIList.Padding.Offset
	local BOUNDARY_GAP = topbarInset
	local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	local boundWidth = 0
	local ourTotal = 0
	for _, icon in pairs(ourOrderedIcons) do
		boundWidth += Overflow.getWidth(icon) + topbarPadding
		ourTotal += 1
	end
	if ourTotal <= 0 then
		return
	end
	
	-- These are the icons with menus which icons will be moved into
	-- when overflowing
	local isCentral = alignment == "Central"
	local isLeft = alignment == "Left"
	local isRight = not isLeft
	local overflowIcon = overflowIcons[alignment]
	if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
		local order = (isLeft and -9999999) or 9999999
		overflowIcon = Icon.new()--:setLabel(`{alignment}`)
		overflowIcon:setImage(6069276526, "Deselected")
		overflowIcon:setName("Overflow"..alignment)
		overflowIcon:setOrder(order)
		overflowIcon:setAlignment(alignment)
		overflowIcon:autoDeselect(false)
		overflowIcon.isAnOverflow = true
		--overflowIcon:freezeMenu()
		overflowIcon:select("OverflowStart", overflowIcon)
		overflowIcon:setEnabled(false)
		overflowIcons[alignment] = overflowIcon
		overflowIconUIDs[overflowIcon.UID] = true
	end

	-- The default boundary is the point where both the left-most-right-icon
	-- and left-most-right-icon meet OR the opposite side of the screen
	local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
	local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
	local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
	local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
	local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
	if nearestOppositeIcon then
		local oppositeEndWidget = nearestOppositeIcon.widget
		local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
		local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
		local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
		boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
	end
	
	-- We get the left-most icon (if left alignment) or right-most-icon (if
	-- right alignment) of the central icons group to see if we need to change
	-- the boundary (if the central icon boundary is smaller than the alignment
	-- boundary then we use the central)
	local centerOrderedIcons = Overflow.getAvailableIcons("Center")
	local centerPos = (isLeft and 1) or #centerOrderedIcons
	local nearestCenterIcon = centerOrderedIcons[centerPos]
	local usingNearestCenter = false
	if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
		local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
		local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
		local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
		local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
		local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
		local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
		if isLeft then
			if centerBoundary < removeBoundary then
				nearestCenterIcon:align("Left")
				nearestCenterIcon.hasRelocatedInOverflow = true
			end
		elseif isRight then
			if centerBoundary > removeBoundary then
				nearestCenterIcon:align("Right")
				nearestCenterIcon.hasRelocatedInOverflow = true
			end
		end
	end
	
	--[[
	This updates the maximum size of the overflow menus
	The menu determines its bounds from the smallest of either:
	 	1. The closest center-aligned icon (i.e. the boundary)
	 	2. The edge of the opposite overflow menu UNLESS...
	 	3. ... the edge exceeds more than half the screenGui
	--]]
	if overflowIcon then
		local menuBoundary = boundary
		local menu = overflowIcon:getInstance("Menu")
		local holderXEndPos = holderXPos + holderXSize
		local menuWidth = holderXSize
		if menu and oppositeOverflowIcon then
			local oppositeWidget = oppositeOverflowIcon.widget
			local oppositeXPos = oppositeWidget.AbsolutePosition.X
			local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
			local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
			local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
			local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
			if not usingNearestCenter then
				local halfwayXPos = holderXPos + holderXSize/2
				local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
				menuBoundary = halfwayBoundary
				if isDominant then
					menuBoundary = oppositeBoundary
				end
			end
			menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
		end
		local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
		menuWidth = Utility.round(menuWidth)
		if menu and currentMaxWidth ~= menuWidth then
			menu:SetAttribute("MaxWidth", menuWidth)
		end
	end

	-- Parent ALL icons of that alignment into the overflow if at least on
	-- sibling exceeds the bounds.
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local widgetX = Overflow.getWidth(icon)
		local xPos = realXPositions[icon.UID]
		if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
			joinOverflow = true
		end
	end
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local isOverflow = overflowIconUIDs[icon.UID]
		if not isOverflow then
			if joinOverflow and not icon.parentIconUID then
				icon:joinMenu(overflowIcon)
			elseif not joinOverflow and icon.parentIconUID then
				icon:leave()
			end
		end
	end
	
	-- Hide the overflows when not in use
	if overflowIcon.isEnabled ~= joinOverflow then
		overflowIcon:setEnabled(joinOverflow)
	end
	
	-- Have the menus auto selected
	if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
		overflowIcon.overflowAlreadyOpened = true
		overflowIcon:select()
	end

end



return Overflow]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX1D5A0081BC5A45438C29F4C87E60AC79">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Themes</string>
												<string name="ScriptGuid">{ABB1B5F3-4BA6-425B-91CA-FF36FB5C2809}</string>
												<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX3F2F87D4A03B41F9A9854CE0B2D84364">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">Classic</string>
													<string name="ScriptGuid">{5E1C8792-0A29-44DD-8241-314220886423}</string>
													<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX53C75E9BAF6E4DD78D19976C36F2DEAB">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<Content name="LinkedSource"><null></null></Content>
													<string name="Name">Default</string>
													<string name="ScriptGuid">{42ADE2B0-388D-4438-BF7D-02F7F07E62A9}</string>
													<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
	{"IconButton", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.3, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Medium, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.925, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
	{"Dropdown", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.3, "Deselected"},
	{"Dropdown", "MaxIcons", 4, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
									<Item class="Folder" referent="RBXC8332C541ADF4B87B195BA1ABE0E2442">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Packages</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX880147AEFB894A329DE85C122EE1787A">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">GoodSignal</string>
												<string name="ScriptGuid">{51EC698B-BB4E-454D-A3CB-0F5C011ED406}</string>
												<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end
Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end
Signal.Destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX85DE6611F1124D7D900D5D418BD0DAD1">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Janitor</string>
												<string name="ScriptGuid">{6ED602A8-04A1-4DC6-B67D-C7738A3C05CF}</string>
												<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------
This package was modified by ForeverHD.

PACKAGE MODIFICATIONS:
	1. Added pascalCase aliases for all methods
	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
	3. Slight change to how promises are tracked
	4. Added isAnInstanceBeingDestroyed check to line 228
	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
	6. Likely some additional changes which weren't record here
-------------------------------------
--]]



-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local function getPromiseReference()
	if RunService:IsRunning() then
		local main = require(game:GetService("ReplicatedStorage").Framework)
		return main.modules.Promise
	end
end

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	IGNORE_MEMORY_DEBUG = true,
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	["Promise"] = "cancel";
	RBXScriptConnection = "Disconnect";
}

--[[**
	Instantiates a new Janitor object.
	@returns [t:Janitor]
**--]]
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

--[[**
	Determines if the passed object is a Janitor.
	@param [t:any] Object The object you are checking.
	@returns [t:boolean] Whether or not the object is a Janitor.
**--]]
function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

--[[**
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.
	@param [t:any] Object The object you want to clean up.
	@param [t:string|true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param [t:any?] Index The index that can be used to clean up the object manually.
	@returns [t:any] The object that was passed.
**--]]
function Janitor.__index:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local objectType = typeof(Object)
	if objectType == "table" and string.match(tostring(Object), "Promise") then
		objectType = "Promise"
		--local status = Object:getStatus()
		--print("status =", status, status == "Rejected")
	end
	MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
	end

	local OriginalTraceback = debug.traceback("")
	self[Object] = {MethodName, OriginalTraceback}
	return Object
end
Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

--[[**
	Adds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.
	@param [t:Promise] PromiseObject The promise you want to add to the janitor.
	@returns [t:Promise]
**--]]
function Janitor.__index:AddPromise(PromiseObject)
	local Promise = getPromiseReference()
	if Promise then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
						PromiseObject:cancel()
					end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	local Promise = getPromiseReference()
	if Promise and Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

--[[**
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.
	@param [t:any] Index The index you want to remove.
	@returns [t:Janitor] The same janitor, for chaining reasons.
**--]]
function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]
	if This then
		local Object = This[Index]

		if Object then
			local ObjectDetail = self[Object]
			local MethodName = ObjectDetail and ObjectDetail[1]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

--[[**
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the job using `__index`.
	@param [t:any] Index The index that the object is stored under.
	@returns [t:any?] This will return the object if it is found, but it won't return anything if it doesn't exist.
**--]]
function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
end

--[[**
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).
	@returns [t:void]
**--]]
function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, ObjectDetail in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			local MethodName = ObjectDetail[1]
			local OriginalTraceback = ObjectDetail[2]
			local function warnUser(warning)
				local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
				local addedLine = OriginalTraceback
				warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
			end
			if MethodName == true then
				local success, warning = pcall(Object)
				if not success then
					warnUser(warning)
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					local success, warning = pcall(ObjectMethod, Object)
					local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
					if not success and not isAnInstanceBeingDestroyed then
						warnUser(warning)
					end
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

--[[**
	Calls `:Cleanup()` and renders the Janitor unusable.
	@returns [t:void]
**--]]
function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

--- Makes the Janitor clean up when the instance is destroyed
-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed
-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)
-- @author Corecii
local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

--[[**
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	@param [t:Instance] Object The instance you want to link the Janitor to.
	@param [t:boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.
	@returns [t:RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.
**--]]
function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

--[[**
	Links several instances to a janitor, which is then returned.
	@param [t:...Instance] ... All the instances you want linked.
	@returns [t:Janitor] A janitor that can be used to manually disconnect all LinkToInstances.
**--]]
function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Script" referent="RBX71F08F6CF07D4A078EE4072A1F306641">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">README AND DOCUMENTATION</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{1D3905EB-968F-4C56-B932-9B6CB810C80B}</string>
								<ProtectedString name="Source"><![CDATA[--[[
                                                                                                                                     
                                                                                                                                  
                                                                                                                                  
                                                                                                                                  
              ################                                                                                                    
             ###             ##                                                                                                   
             ###             ##                                                                                                   
             ##################                                                                                                   
     ##################################                                                                                           
    ###                             ####     ########## #####   #####  ######### #############  ##########   ######   ######   
    ####################################    ########### #####   ##### ##########  ###########  ############  ####### #######   
    ####################################   #####        #####   ##### ########       #####     ####    ####  ###############    
    ###                             ####   #####        #####   #####  ##########    #####     ####    ####  ###############    
    ####################################    #####       #####   #####       #####    #####     ####    ####  #### ##### ####    
    ####################################    ###########  ###########  ###########    #####     ############  ####  ###  ####   
    ####################################      #########   #########    #########     #####      #########    ####       ####      
    ####################################                                                                                          
    ####################################                                                                                          
    ####################################    #################################################################################     
    ####################################    #################################################################################     
    ####################################                                                                                          
    ####################################                     #######       ####         #####    ###     ####                     
    ####################################                    ###########   ######     ########### ####  ######                     
    ####################################                    ##### ###### #######    ######   ### ##########                       
    ####################################                    ##### ###############  #####         ########                         
    ###                             ####                    ########### #### ##### #####         ########                         
    ####################################                    #####      ###########  #####        #########                        
    ####################################                    #####     #############  ########### ####  #####                      
    ####                           #####                    #####     ####      ####   ########  ####    #####                    
    ####################################                                                                                          
    ####################################                                                                                          
     ##################################                                                                                           
                                                                                                                                  
                                                                                                                                                 
	Thank you for using CustomPack. Here's how to get started:

	It's pretty easy to set up, all you gotta do is to put the script into StarterPlayerScripts and customize it to your likings in the Attributes of the Main script.


	-- API DOCUMENTATION --
	
	To use the API, invoke the remote function named "CustomPackAPI".
	
	-+ MAIN +-
	
	SetBackpackEnabled()
		Arguments: enabled (boolean)
		Hides/shows the backpack and the hotbar. Does not affect the inventory.
		Example: CustomPackAPI:Invoke("SetBackpackEnabled", {true})
		
	SetInventoryOpen()
		Arguments: enabled (boolean)
		Opens/closes the inventory. Does not affect the hotbar or the backpack.
		Example: CustomPackAPI:Invoke("SetInventoryOpen", {true})
		
	ToggleInventoryOpen()
		Arguments: None
		Opens the inventory if it's closed, closes if it's open.
		Example: CustomPackAPI:Invoke("ToggleInventoryOpen")
		
	IsInventoryOpen()
		Arguments: None
		Checks if the inventory is open.
		Example: CustomPackAPI:Invoke("IsInventoryOpen")
		
	-+ TOOL GROUPS +-
	
	SetToolGroup()
		Arguments: tool (Tool), group (string)
		Sets the group of a tool.
		Example: CustomPackAPI:Invoke("SetToolGroup", {tool, "Group1"})
		
	GetToolsInGroup()
		Arguments: group (string)
		Gets all tools in a group.
		Example: CustomPackAPI:Invoke("SetToolGroupEnabled", {"Group1"})
	
	GetToolGroup()
		Arguments: tool (Tool)
		Gets the group of a tool.
		Example: CustomPackAPI:Invoke("GetToolGroup", {tool})
		
	GetGroupIcon()
		Arguments: group (string)
		Gets the icon of a tool group.
		Example: CustomPackAPI:Invoke("GetGroupIcon", {"Group1"})
		
	SetGroupIcon()
		Arguments: group (string), icon (string)
		Sets the icon of a tool group.
		Example: CustomPackAPI:Invoke("GetGroupIcon", {"Group1", "rbxassetid://1"})
	
	RemoveToolGroup()
		Arguments: tool (Tool)
		Removes the group of a tool.
		Example: CustomPackAPI:Invoke("RemoveToolGroup", {tool})
	
	GetAllGroups()
		Arguments: None
		Gets all tool groups.
		Example: CustomPackAPI:Invoke("GetAllGroups")
		
	-+ SLOTS +-
	
	GetSelectedSlotChangedEvent()
		Arguments: None
		Gets the event that is fired when the selected slot changes.
		Example: CustomPackAPI:Invoke("GetSelectedSlotChangedEvent")
	
	GetSlot()
		Arguments: index (number)
		Gets the slot at the given index. Returns nil if none is found.
		Example: CustomPackAPI:Invoke("GetSlot", {1})
		
	GetAllSlots()
		Arguments: None
		Gets all slots.
		Example: CustomPackAPI:Invoke("GetAllSlots")
		
	GetEquippedSlot()
		Arguments: None
		Gets the equipped slot. Returns nil if none is found.
		Example: CustomPackAPI:Invoke("GetEquippedSlot")
	
	--- OBJECTS ---
	
	Slot:
		Slot.Tool (Tool)
			The tool in the slot.
			Example: CustomPackAPI:Invoke("GetSlot", {1}).Tool
		
		Slot.Index (number)
			The index of the slot.
			Example: CustomPackAPI:Invoke("GetSlot", {1}).Index
		
		Slot.IsEquipped (boolean)
			If the slot is equipped.
			Example: CustomPackAPI:Invoke("GetSlot", {1}).IsEquipped
	
	
	-+ SOUNDS +-
	
	GetEquipSound()
		Arguments: None
		Gets the sound that is played when equipping a tool.
		Example: CustomPackAPI:Invoke("GetEquipSound")
		
	GetUnequipSound()
		Arguments: None
		Gets the sound that is played when unequipping a tool.
		Example: CustomPackAPI:Invoke("GetUnequipSound")
		
	-+ OTHER +-
	
	GetVersion()
		Arguments: None
		Gets the version of CustomPack.
		Example: CustomPackAPI:Invoke("GetVersion")
]]]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX092E7D60B27442E79FB0EBB64FC3AD4B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Text+</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB9D468C8506D468A9091480A8CDC6489">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Text</string>
							<string name="ScriptGuid">{3DFF20A2-71C4-4E2E-BFB3-88E4CC7EF9F8}</string>
							<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native

--[[

          TTTTTTTTTTTT                                                                              
TTTTTTTTTTTTTTTTTTTTTT                                                                              
TTTTTTTTTTTTTTTTTTTTTT                                                                              
 TT      TTTTT                                                      ttttt                           
         TTTTTT                                            xxx      tttttt                          
         TTTTTT            eeeeeeeeee      xxxxxxx     xxxxxx       tttttt             +++++        
         TTTTTT          eeeeeeeeeeeeee      xxxxxx    xxxxx     ttttttttttttt          +++++       
         TTTTTT         eeeeeee   eeeeee      xxxxxx  xxxxx      ttttttttttttt          +++++       
         TTTTTT        eeeeee       eeeee      xxxxxxxxxxx          tttttt              +++++++++++
         TTTTTT        eeeeeeeeeeeeeeeeee       xxxxxxxxxx          tttttt       +++++++++++++++++++
         TTTTTT       eeeeeeeeeeeeeeeeeee        xxxxxxxxx          tttttt       +++++++++++++++++++
          TTTTTT       eeeee           ee       xxxxxxxxxxx         tttttt        +++   +++++       
          TTTTTT       eeeeee                   xxxxx xxxxxx       tttttt                +++++      
          TTTTTT        eeeeee    eeeeeee      xxxxx   xxxxxxx     tttttt                +++++      
          TTTTTT         eeeeeeeeeeeeeee      xxxxxx     xxxxxx    ttttttttt             +++++      
                           eeeeeeeeee        xxxxxx                 ttttttttt                       
                                                                      ttttttt                       

v1.29.1

An efficient, robust, open-source text-rendering library for
Roblox, featuring custom fonts and advanced text control.


GitHub (repository):
https://github.com/AlexanderLindholt/TextPlus

GitBook (documentation):
https://alexxander.gitbook.io/TextPlus

DevForum (topic):
https://devforum.roblox.com/t/3521684


--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Alexander Lindholt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--------------------------------------------------------------------------------

]]--

-- Services.
local CollectionService = game:GetService("CollectionService")
local TextService = game:GetService("TextService")

-- Attempt to find the plugin object.
local plugin = script:FindFirstAncestorOfClass("Plugin")

-- Signal library.
local Signal
if plugin then
	for _, instance in plugin:GetDescendants() do
		if instance:HasTag("Signal") then
			Signal = require(instance)
			if type(Signal) == "table" and Signal.new then Signal = Signal.new end
			break
		end
	end
else
	Signal = CollectionService:GetTagged("Signal")[1]
	if Signal then
		Signal = require(Signal)
		if type(Signal) == "table" and Signal.new then Signal = Signal.new end
	end
end

-- Player viewport.
local camera = workspace.CurrentCamera

-- Character for when a character is missing in a custom font.
local missingCharacter = "rbxassetid://75989824347198"

-- Options list for validation.
local optionsList = require(script.Options)
-- Option defaults.
local defaults = require(script.Defaults)
-- Options corrector.
local correctOptions = require(script.CorrectOptions)

-- Instance recycling.
local textLabelsAmount, textLabels = 0, {}
local imageLabelsAmount, imageLabels = 0, {}
local uiStrokesAmount, uiStrokes = 0, {}
local foldersAmount, folders = 0, {}
local function getTextLabel()
	local instance = textLabels[textLabelsAmount]
	if not instance then
		textLabelsAmount += 1
		return Instance.new("TextLabel")
	end
	textLabels[textLabelsAmount] = nil
	textLabelsAmount -= 1
	return instance
end
local function getImageLabel()
	local instance = imageLabels[imageLabelsAmount]
	if not instance then
		imageLabelsAmount += 1
		return Instance.new("ImageLabel")
	end
	imageLabels[imageLabelsAmount] = nil
	imageLabelsAmount -= 1
	return instance
end
local function getUIStroke()
	local instance = uiStrokes[uiStrokesAmount]
	if not instance then
		uiStrokesAmount += 1
		return Instance.new("UIStroke")
	end
	uiStrokes[uiStrokesAmount] = nil
	uiStrokesAmount -= 1
	return instance
end
local function getFolder()
	local instance = folders[foldersAmount]
	if not instance then
		foldersAmount += 1
		return Instance.new("Folder")
	end
	folders[foldersAmount] = nil
	foldersAmount -= 1
	return instance
end

-- Types.
export type CustomFont = {
	Image: number,
	Size: number,
	Characters: {
		[string]: {}
	}
}
export type Options = {
	Font: Font | CustomFont?,
	
	Size: number?,
	
	ScaleSize:
		"RootX" | "RootY" | "RootXY" |
		"FrameX" | "FrameY" | "FrameXY"?,
	MinimumSize: number?,
	MaximumSize: number?,
	
	Color: Color3?,
	Transparency: number?,
	
	Pixelated: boolean?,
	
	Offset: Vector2?,
	Rotation: number?,
	
	StrokeSize: number?,
	StrokeColor: Color3?,
	StrokeTransparency: number?,
	
	ShadowOffset: Vector2?,
	ShadowColor: number?,
	ShadowTransparency: number?,
	
	LineHeight: number?,
	CharacterSpacing: number?,
	
	Truncate: boolean?,
	
	XAlignment: "Left" | "Center" | "Right" | "Justified"?,
	YAlignment: "Top" | "Center" | "Bottom" | "Justified"?,
	
	WordSorting: boolean?,
	LineSorting: boolean?,
	
	Dynamic: boolean?
}

type Connection = {
	Connected: boolean,
	Disconnect: typeof(
		-- Erases the connection.
		function(connection: Connection) end
	)
}
type Signal<Parameters...> = {
	Connect: typeof(
		-- Connects a function.
		function(signal: Signal<Parameters...>, callback: (Parameters...) -> ()): Connection end
	),
	Once: typeof(
		-- Connects a function, then auto-disconnects after the first call.
		function(signal: Signal<Parameters...>, callback: (Parameters...) -> ()): Connection end
	),
	Wait: typeof(
		-- Yields the calling thread until the next fire.
		function(signal: Signal<Parameters...>): Parameters... end
	),
	
	Fire: typeof(
		-- Runs all connected functions, and resumes all waiting threads.
		function(signal: Signal<Parameters...>, ...: Parameters...) end
	),
	
	DisconnectAll: typeof(
		-- Erases all connections.<br>
		-- <em>Much faster than calling <code>Disconnect</code> on each.</em>
		function(signal: Signal<Parameters...>) end
	),
	Destroy: typeof(
		-- Erases all connections and methods, making the signal unusable.<br>
		-- Remove references to the signal to delete it completely.
		function(signal: Signal<Parameters...>) end
	)
}

-- Frame data tables.
local frameText: {string} = {}
local frameOptions: {Options} = {}
local frameTextBounds: {Vector2} = {}
local frameSizeConnections: {RBXScriptSignal} = {}
local frameUpdateSignals: {Signal} = if Signal then {} else nil

-- Roblox built-in text rendering stuff.
local textBoundsParams = Instance.new("GetTextBoundsParams")
textBoundsParams.Size = 100 -- Size limit for Roblox's built-in text-rendering.

local characterWidthCache = {}

-- Custom fonts.
local userFonts = require(script.Fonts)

-- Module.
local module = {}

--[[
Returns the last rendered text string for a frame.
]]--
module.GetText = function(frame: GuiObject): Options
	-- Get, verify and return text.
	local text = frameText[frame]
	if not text then error("Invalid frame.", 2) end
	return text
end
--[[
Returns the current options for a frame.
]]--
module.GetOptions = function(frame: GuiObject): Options
	-- Get, verify and return options.
	local options = frameOptions[frame]
	if not options then error("Invalid frame.", 2) end
	return frameOptions[frame]
end
--[[
Returns the last rendered text's bounds for a frame.
]]--
module.GetBounds = function(frame: GuiObject): Vector2
	-- Get, verify and return text bounds.
	local textBounds = frameTextBounds[frame]
	if not textBounds then error("Invalid frame.", 2) end
	return textBounds
end

--[[
Returns the update signal for a frame.
]]--
module.GetUpdateSignal = function(frame: GuiObject): Signal
	-- Get, verify and return signal.
	local signal = frameUpdateSignals[frame]
	if not signal then error("Invalid frame.", 2) end
	return signal
end

--[[
Returns a function for iterating through all characters in a frame.

<em>Ignores sorting folders.
Works with any sorting.</em>
]]--
module.GetCharacters = function(frame: GuiObject): {TextLabel | ImageLabel}
	-- Get and verify options.
	local options = frameOptions[frame]
	if not options then error("Invalid frame.", 2) end
	
	-- Create and return iterator.
	return coroutine.wrap(function()
		-- Identify sorting.
		local lineSorting, wordSorting = options.LineSorting, options.WordSorting
		
		if lineSorting and wordSorting then -- Full sorting.
			-- Global character counter.
			local index = 0
			
			-- Loop through lines.
			for _, line in frame:GetChildren() do
				-- Verify instance.
				if line:IsA("Folder") then
					-- Loop through words.
					for _, word in line:GetChildren() do
						-- Loop through characters.
						for _, character in word:GetChildren() do
							-- Increment global character counter.
							index += 1
							-- Pass parameters to loop.
							coroutine.yield(index, character)
						end
					end
				end
			end
		elseif lineSorting or wordSorting then -- One sorting.
			-- Global character counter.
			local index = 0
			
			-- Loop through words/lines.
			for _, folder in frame:GetChildren() do
				-- Verify instance.
				if folder:IsA("Folder") then
					-- Loop through characters.
					for _, character in folder:GetChildren() do
						-- Increment global character counter.
						index += 1
						-- Pass parameters to loop.
						coroutine.yield(index, character)
					end
				end
			end
		else -- No sorting.
			-- Identify character instance class for verification.
			local characterClass = if type(options.Font) == "table" then "TextLabel" else "ImageLabel"
			
			-- Loop through characters.
			for index, character in frame:GetChildren() do
				-- Verify instance.
				if character:IsA(characterClass) then
					-- Pass parameters to loop.
					coroutine.yield(index, character)
				end
			end
		end
	end)
end

local function clear(frame)
	-- Get options.
	local options = frameOptions[frame]
	
	-- Identify character instance class and storage table.
	local characterTable, characterClass = nil
	if type(options.Font) == "table" then
		characterTable = imageLabels
		characterClass = "ImageLabel"
	else
		characterTable = textLabels
		characterClass = "TextLabel"
	end
	
	-- Setup character stashing.
	local function stashCharacter(character)
		-- Remove and store character instance.
		character.Parent = nil
		table.insert(characterTable, character)
		
		-- Remove and store character's stroke if existent.
		local stroke = character:FindFirstChildOfClass("UIStroke")
		if stroke then
			stroke.Parent = nil
			uiStrokes[uiStrokesAmount + 1] = stroke
		end
		
		-- Remove and store the main character if this is a shadow.
		local main = character:FindFirstChildOfClass(characterClass)
		if main then
			-- Remove and store the main character instance.
			main.Parent = nil
			table.insert(characterTable, main)
			
			-- Remove and store the main character's stroke if existent.
			local mainStroke = main:FindFirstChildOfClass("UIStroke")
			if mainStroke then
				mainStroke.Parent = nil
				uiStrokes[uiStrokesAmount + 1] = mainStroke
			end
		end
	end
	
	-- Identify sorting.
	local lineSorting, wordSorting = options.LineSorting, options.WordSorting
	
	if lineSorting and wordSorting then -- Full sorting.
		-- Loop through lines.
		for _, line in frame:GetChildren() do
			-- Verify instance.
			if not line:IsA("Folder") then continue end
			
			-- Remove and store line folder.
			line.Parent = nil
			folders[foldersAmount + 1] = line
			
			-- Loop through words.
			for _, word in line:GetChildren() do
				-- Remove and store word folder.
				word.Parent = nil
				folders[foldersAmount + 1] = word
				
				-- Loop through characters.
				for _, character in word:GetChildren() do
					stashCharacter(character)
				end
			end
		end
	elseif lineSorting or wordSorting then -- One sorting.
		-- Loop through words/lines.
		for _, folder in frame:GetChildren() do
			-- Verify instance.
			if not folder:IsA("Folder") then continue end
			
			-- Remove and store word/line folder.
			folder.Parent = nil
			folders[foldersAmount + 1] = folder
			
			-- Loop through characters.
			for _, character in folder:GetChildren() do
				stashCharacter(character)
			end
		end
	else -- No sorting.
		-- Loop through characters.
		for _, character in frame:GetChildren() do
			-- Verify instance.
			if not character:IsA(characterClass) then continue end
			
			stashCharacter(character)
		end
	end
end
local function render(frame, text, options)
	-- Cache frame size.
	local frameSize = frame.AbsoluteSize
	
	local frameWidth = frameSize.X
	local frameHeight = frameSize.Y
	
	-- Handle options.
	local font = options.Font
	
	local size = options.Size
	
	local color = options.Color
	local transparency = options.Transparency
	
	local offset = options.Offset; local offsetX, offsetY
	local rotation = options.Rotation
	
	local strokeSize = options.StrokeSize
	
	local shadowOffset = options.ShadowOffset; local shadowOffsetX, shadowOffsetY
	
	local lineHeight = options.LineHeight
	local characterSpacing = options.CharacterSpacing
	
	local truncationEnabled = options.Truncate
	
	local xAlignment = options.XAlignment
	local yAlignment = options.YAlignment
	
	local wordSorting = options.WordSorting
	local lineSorting = options.LineSorting
	
	local scaleSize = options.ScaleSize
	if scaleSize then
		-- Scale size.
		if scaleSize:sub(1, 1) == "R" then -- Relative to root.
			-- Find root size.
			local root = frame:FindFirstAncestorOfClass("GuiBase")
			local rootSize = if root then
				if root:IsA("ScreenGui") then
				camera.ViewportSize
				else
				root.AbsoluteSize
			else
				Vector2.zero
			
			-- Scale size.
			if scaleSize == "RootX" then
				size = size*0.01*rootSize.X
			elseif scaleSize == "RootY" then
				size = size*0.01*rootSize.Y
			else
				size = size*0.01*(rootSize.X + rootSize.Y)/2
			end
		else -- Relative to frame.
			if scaleSize == "FrameX" then
				size = size*0.01*frameWidth
			elseif scaleSize == "FrameY" then
				size = size*0.01*frameHeight
			else
				size = size*0.01*(frameWidth + frameHeight)/2
			end
		end
		
		-- Limit scaled size.
		if size < 1 then
			size = 1
		else
			-- Custom limits.
			local minimumSize = options.MinimumSize
			if minimumSize and options.Size < minimumSize then
				options.Size = minimumSize
			end
			local maximumSize = options.MaximumSize
			if maximumSize and options.Size > maximumSize then
				options.Size = maximumSize
			end
			
			-- Roblox font limit.
			if type(font) ~= "table" and size > 100 then
				size = 100
			end
		end
		
		-- Ensure integer size.
		size = math.round(size)
		
		-- Scale the related options.
		offsetX, offsetY = math.round(offset.X*0.01*size), math.round(offset.Y*0.01*size)
		if strokeSize then strokeSize = math.round(strokeSize*0.01*size) end
		if shadowOffset then shadowOffsetX, shadowOffsetY = math.round(shadowOffset.X*0.01*size), math.round(shadowOffset.Y*0.01*size) end
	else
		-- Ensure integer size.
		size = math.round(size)
		
		-- Save offsets in optimized format.
		offsetX, offsetY = offset.X, offset.Y
		if shadowOffset then shadowOffsetX, shadowOffsetY = shadowOffset.X, shadowOffset.Y end
	end
	
	lineHeight *= size
	
	-- Setup character functions.
	local getCharacterWidth, createCharacter
	if type(font) == "table" then
		-- Custom font.
		local image = "rbxassetid://"..tostring(font.Image)
		local scaleFactor = size/font.Size
		local characters = font.Characters
		local resampleMode = if options.Pixelated then Enum.ResamplerMode.Pixelated else Enum.ResamplerMode.Default
		
		--[[
		Character data (table):
			[1] = number - Size x
			[2] = number - Size y
			[3] = Vector2 - Image offset
			[4] = number - Offset x
			[5] = number - Offset y
			[6] = number - X advance
		]]--
		
		getCharacterWidth = function(character)
			local data = characters[character]
			return if data then
				data[6]*size*characterSpacing
				else -- Missing character.
				size*characterSpacing -- The 'missing' character is square, so height and width is the same.
		end
		if shadowOffset then
			-- Shadow.
			local shadowColor = options.ShadowColor
			local shadowTransparency = options.ShadowTransparency
			
			createCharacter = function(character, x, y)
				-- Calculate information.
				local data = characters[character]
				if data then
					-- Cache character data.
					local width = data[1]
					local height = data[2]
					local imageSize = Vector2.new(width, height)
					local imageOffset = data[3]
					
					-- Calculate position and size.
					local realX = x + data[4]*size
					local realY = y + data[5]*size
					local characterSize = UDim2.fromOffset(
						math.round(realX + width*scaleFactor) - math.round(realX),
						math.round(realY + height*scaleFactor) - math.round(realY)
					)
					
					-- Character shadow.
					local shadow = getImageLabel()
					do
						-- Stylize.
						shadow.BackgroundTransparency = 1
						shadow.Image = image
						shadow.ImageColor3 = shadowColor
						shadow.ImageTransparency = shadowTransparency
						shadow.ResampleMode = resampleMode
						-- Image cutout.
						shadow.ImageRectSize = imageSize
						shadow.ImageRectOffset = imageOffset
						-- Transformation.
						shadow.Size = characterSize
						shadow.Position = UDim2.fromOffset(
							math.round(realX) + offsetX + shadowOffsetX,
							math.round(realY) + offsetY + shadowOffsetY
						)
						shadow.Rotation = rotation
					end
					-- Main character.
					do
						-- Create and stylize.
						local main = getImageLabel()
						main.BackgroundTransparency = 1
						main.Image = image
						main.ImageColor3 = color
						main.ImageTransparency = transparency
						main.ResampleMode = resampleMode
						-- Image cutout.
						main.ImageRectSize = imageSize
						main.ImageRectOffset = imageOffset
						-- Transformation.
						main.Size = characterSize
						main.Position = UDim2.fromOffset(-shadowOffsetX, -shadowOffsetY) -- Counteract the shadow offset.
						-- Name and parent.
						main.Name = "Main"
						main.Parent = shadow
					end
					
					-- Return character instance.
					return shadow
				else -- Missing character.
					-- Create and stylize.
					local imageLabel = getImageLabel()
					imageLabel.BackgroundTransparency = 1
					imageLabel.Image = missingCharacter
					imageLabel.ImageColor3 = color
					imageLabel.ImageTransparency = transparency
					imageLabel.ResampleMode = resampleMode
					-- Transformation.
					imageLabel.Size = UDim2.fromOffset(size, size)
					imageLabel.Position = UDim2.fromOffset(
						math.round(x + size) + offsetX,
						math.round(y + size) + offsetY
					)
					imageLabel.Rotation = rotation
					
					-- Return character instance.
					return imageLabel
				end
			end
		else
			-- No shadow.
			createCharacter = function(character, x, y)
				local data = characters[character]
				if data then
					-- Create and stylize.
					local imageLabel = getImageLabel()
					imageLabel.BackgroundTransparency = 1
					imageLabel.Image = image
					imageLabel.ImageColor3 = color
					imageLabel.ImageTransparency = transparency
					imageLabel.ResampleMode = resampleMode
					-- Image cutout.
					local width = data[1]
					local height = data[2]
					imageLabel.ImageRectSize = Vector2.new(width, height)
					imageLabel.ImageRectOffset = data[3]
					-- Transformation.
					local realX = x + data[4]*size
					local realY = y + data[5]*size
					imageLabel.Size = UDim2.fromOffset(
						math.round(realX + width*scaleFactor) - math.round(realX),
						math.round(realY + height*scaleFactor) - math.round(realY)
					)
					imageLabel.Position = UDim2.fromOffset(
						math.round(realX) + offsetX,
						math.round(realY) + offsetY
					)
					imageLabel.Rotation = rotation
					
					-- Return character instance.
					return imageLabel
				else -- Missing character.
					-- Create and stylize.
					local imageLabel = getImageLabel()
					imageLabel.BackgroundTransparency = 1
					imageLabel.Image = missingCharacter
					imageLabel.ImageColor3 = color
					imageLabel.ImageTransparency = transparency
					-- Transformation.
					imageLabel.Size = UDim2.fromOffset(size, size)
					imageLabel.Position = UDim2.fromOffset(
						math.round(x + size) + offsetX,
						math.round(y + size) + offsetY
					)
					imageLabel.Rotation = rotation
					
					-- Return character instance.
					return imageLabel
				end
			end
		end
	else
		-- Roblox font.
		local strokeColor, strokeTransparency
		if strokeSize then
			if strokeSize < 1 then strokeSize = 1 end -- Limit again, in case it was scaled.
			strokeColor = options.StrokeColor
			strokeTransparency = options.StrokeTransparency
		end
		
		local invertedCharacterSpacing = 1/characterSpacing -- To avoid expensive division.
		local fontKey = font.Family..tostring(font.Weight.Value)..tostring(font.Style.Value)
		
		getCharacterWidth = function(character)
			local characterKey = character..fontKey
			local width = characterWidthCache[characterKey]
			if not width then
				textBoundsParams.Text = character
				width = TextService:GetTextBoundsAsync(textBoundsParams).X*0.01
				characterWidthCache[characterKey] = width
			end
			return width*size*characterSpacing
		end
		if shadowOffset then
			-- Shadow.
			local shadowColor = options.ShadowColor
			local shadowTransparency = options.ShadowTransparency
			
			createCharacter = function(character, x, y, width)
				-- Calculate size.
				local characterSize = UDim2.fromOffset(math.round(width*invertedCharacterSpacing), size)
				
				-- Character shadow.
				local shadow = getTextLabel()
				do
					-- Stylize.
					shadow.BackgroundTransparency = 1
					shadow.Text = character
					shadow.TextSize = size
					shadow.TextColor3 = shadowColor
					shadow.TextTransparency = shadowTransparency
					shadow.FontFace = font
					shadow.TextXAlignment = Enum.TextXAlignment.Left
					shadow.TextYAlignment = Enum.TextYAlignment.Top
					-- Transformation.
					shadow.Size = characterSize
					shadow.Rotation = rotation
					shadow.Position = UDim2.fromOffset(
						x + offsetX + shadowOffsetX,
						y + offsetY + shadowOffsetY
					)
				end
				-- Main character.
				local main = getTextLabel()
				do
					-- Stylize.
					main.BackgroundTransparency = 1
					main.Text = character
					main.TextSize = size
					main.TextColor3 = color
					main.TextTransparency = transparency
					main.FontFace = font
					main.TextXAlignment = Enum.TextXAlignment.Left
					main.TextYAlignment = Enum.TextYAlignment.Top
					-- Transform.
					main.Size = characterSize
					main.Position = UDim2.fromOffset(-shadowOffsetX, -shadowOffsetY) -- Counteract the shadow offset.
					-- Name and parent.
					main.Name = "Main"
					main.Parent = shadow
				end
				-- Apply stroke if options are given.
				if strokeSize then
					do
						local uiStroke = getUIStroke()
						uiStroke.Thickness = strokeSize
						uiStroke.Color = strokeColor
						uiStroke.Transparency = strokeTransparency
						uiStroke.Parent = main
					end
					do
						local uiStroke = getUIStroke()
						uiStroke.Thickness = strokeSize
						uiStroke.Color = strokeColor
						uiStroke.Transparency = strokeTransparency
						uiStroke.Parent = shadow
					end
				end
				
				-- Return character instance.
				return shadow
			end
		else
			-- No shadow.
			createCharacter = function(character, x, y, width)
				-- Create and stylize.
				local textLabel = getTextLabel()
				textLabel.BackgroundTransparency = 1
				textLabel.Text = character
				textLabel.TextSize = size
				textLabel.TextColor3 = color
				textLabel.TextTransparency = transparency
				textLabel.FontFace = font
				textLabel.TextXAlignment = Enum.TextXAlignment.Left
				textLabel.TextYAlignment = Enum.TextYAlignment.Top
				-- Transformation.
				textLabel.Size = UDim2.fromOffset(math.round(width*invertedCharacterSpacing), size)
				textLabel.Rotation = rotation
				textLabel.Position = UDim2.fromOffset(
					x + offsetX,
					y + offsetY
				)
				-- Apply stroke if options are given.
				if strokeSize then
					local uiStroke = getUIStroke()
					uiStroke.Thickness = strokeSize
					uiStroke.Color = strokeColor
					uiStroke.Transparency = strokeTransparency
					uiStroke.Parent = textLabel
				end
				-- Return character instance.
				return textLabel
			end
		end
	end
	
	-- Calculate base information.
	local textWidth = if xAlignment == "Justified" then frameWidth else 0
	
	local spaceWidth = getCharacterWidth(" ")
	
	local dotWidth = getCharacterWidth(".")
	local ellipsisWidth = dotWidth*3
	
	local lines = {}
	
	local truncated, truncate
	if truncationEnabled then
		truncate = function()
			-- Line count.
			local linesAmount = #lines
			
			-- Access last line.
			local line = lines[linesAmount]
			local lineWords = line[1]
			
			-- If the line is empty, we can simply put ellipsis here.
			if #lineWords == 0 then
				line[2] = ellipsisWidth
				
				local dot = {".", dotWidth}
				lineWords[1] = {dot, dot, dot}
				return
			end
			
			-- Calculate potential line width.
			local potentialLineWidth = ellipsisWidth
			for _, wordCharacters in lineWords do
				if wordCharacters then
					for _, characterData in wordCharacters do
						potentialLineWidth += characterData[2]
					end
				end
				potentialLineWidth += spaceWidth
			end
			
			-- Remove words one by one and check for space every time.
			for index = #lineWords, 1, -1 do
				local wordCharacters = lineWords[index]
				
				-- There may be empty words, caused by consecutive spaces. We skip those.
				if not wordCharacters then
					lineWords[index] = nil
					potentialLineWidth -= spaceWidth
					continue
				end
				
				-- Check for space at the end of the word.
				if potentialLineWidth < frameWidth then
					-- Update line width cache.
					line[2] = potentialLineWidth
					
					-- Add ellipsis and exit.
					local dot = {".", dotWidth}
					local charactersAmount = #wordCharacters
					wordCharacters[charactersAmount + 1] = dot
					wordCharacters[charactersAmount + 2] = dot
					wordCharacters[charactersAmount + 3] = dot
					return
				end
				
				-- Remove characters one by one and check for space every time.
				for index = #wordCharacters, 2, -1 do
					potentialLineWidth -= wordCharacters[index][2]
					wordCharacters[index] = nil
					
					if potentialLineWidth < frameWidth then
						-- Update line width cache.
						line[2] = potentialLineWidth
						
						-- Add ellipsis and exit.
						local dot = {".", dotWidth}
						local charactersAmount = #wordCharacters
						wordCharacters[charactersAmount + 1] = dot
						wordCharacters[charactersAmount + 2] = dot
						wordCharacters[charactersAmount + 3] = dot
						return
					end
				end
				
				-- Subtract remaining word width from potential, and remove word.
				potentialLineWidth -= spaceWidth + wordCharacters[1][2]
				lineWords[index] = nil
			end
			
			-- Stop or continue.
			if linesAmount == 1 then
				-- Last line, so we have no option but to put the ellipsis here.
				line[2] = ellipsisWidth
				
				local dot = {".", dotWidth}
				table.insert(lineWords, {dot, dot, dot})
			else
				-- Erase current line and repeat truncation on next line.
				lines[linesAmount] = nil
				truncate()
			end
		end
	end
	
	local lineWords = {}
	local lineWidth = -spaceWidth
	
	local lineIndex = 1
	
	for _, line in text:split("\n") do
		-- Process line.
		if line == "" then -- Means consecutive line-breaks.
			if #lineWords > 0 then
				-- Update text width.
				if lineWidth > textWidth then
					textWidth = lineWidth
				end
				-- Add current line.
				lines[lineIndex] = {lineWords, lineWidth}
				lineIndex += 1
			end
			-- Add empty line.
			lines[lineIndex] = {{}, 0}
			lineIndex += 1
			-- Reset line data.
			lineWidth = -spaceWidth
			lineWords = {}
		else
			-- Process words.
			local wordIndex = 1
			for _, word in line:split(" ") do
				if word == "" then -- Means consecutive spaces.
					lineWords[wordIndex] = false
					wordIndex += 1
					lineWidth += spaceWidth
				else
					local wordWidth = spaceWidth
					local wordCharacters = {}
					
					local characterIndex = 1
					for character in word:gmatch(utf8.charpattern) do
						local characterWidth = getCharacterWidth(character)
						wordWidth += characterWidth
						wordCharacters[characterIndex] = {character, characterWidth}
						characterIndex += 1
					end
					
					if lineWidth + wordWidth > frameWidth and wordIndex > 1 then
						-- Update text width.
						if lineWidth < frameWidth and lineWidth > textWidth then
							textWidth = lineWidth
						end
						
						-- Truncate if necessary.
						if truncationEnabled and lineIndex*lineHeight + size > frameHeight then
							-- Add word to line.
							lineWords[wordIndex] = wordCharacters
							wordIndex += 1
							-- Add current line.
							lines[lineIndex] = {lineWords, lineWidth}
							lineIndex += 1
							
							-- Truncate and exit.
							truncate()
							truncated = true
							break
						else
							-- Add current line.
							lines[lineIndex] = {lineWords, lineWidth}
							lineIndex += 1
							
							-- Initalize next line with the word that exceeded the boundary.
							lineWords = {wordCharacters}
							wordIndex = 2
							lineWidth = wordWidth
						end
					else
						-- Add word to line.
						lineWords[wordIndex] = wordCharacters
						wordIndex += 1
						lineWidth += wordWidth
					end
				end
			end
			
			-- Update text width.
			if lineWidth > textWidth then
				textWidth = lineWidth
			end
			
			-- Exit if truncated.
			if truncated then break end
			
			-- Add current line.
			lines[lineIndex] = {lineWords, lineWidth}
			lineIndex += 1
			-- Reset line data.
			lineWords = {}
			lineWidth = -spaceWidth
		end
	end
	
	-- Calculate final information and render.
	local textHeight, lineGap, y
	if yAlignment == "Top" then
		textHeight = (lineIndex - 2)*lineHeight + size
		lineGap = 0
		y = 0
	elseif yAlignment == "Center" then
		textHeight = (lineIndex - 2)*lineHeight + size
		lineGap = 0
		y = math.round((frameHeight - textHeight)/2)
	elseif yAlignment == "Bottom" then
		textHeight = (lineIndex - 2)*lineHeight + size
		lineGap = 0
		y = frameHeight - textHeight
	else
		-- Justified alignment.
		if #lines == 1 then
			textHeight = size
			lineGap = 0
			y = 0
		else
			textHeight = frameHeight
			local linesAmount = lineIndex - 2
			lineGap = (frameHeight - (linesAmount*lineHeight + size))/linesAmount
			y = 0
		end
	end
	
	local globalWordCount = 0 -- In case specifically only word sorting is enabled.
	local globalCharacterCount = 0 -- In case no sorting is enabled.
	
	for lineIndex, lineData in lines do
		-- Get the current line's words.
		local words = lineData[1]
		
		-- Horizontal alignment.
		local wordGap, x
		if xAlignment == "Left" then
			wordGap = 0
			x = 0
		elseif xAlignment == "Center" then
			wordGap = 0
			x = math.round((frameWidth - lineData[2])/2)
		elseif xAlignment == "Right" then
			wordGap = 0
			x = frameWidth - lineData[2]
		else
			-- Justified alignment.
			local wordsAmount = #words
			wordGap = if wordsAmount > 1 then
				(frameWidth - lineData[2])/(wordsAmount - 1)
				else
				0
			
			x = 0
		end
		
		-- Line sorting.
		local lineContainer = frame
		if lineSorting then
			lineContainer = getFolder()
			lineContainer.Name = tostring(lineIndex)
			lineContainer.Parent = frame
		end
		
		-- Create words.
		for wordIndex, word in words do
			if word then -- There may be empty words, caused by consecutive spaces. These we skip.
				local wordContainer
				if wordSorting then
					wordContainer = getFolder()
					-- Numerical naming.
					if lineSorting then
						wordContainer.Name = tostring(wordIndex)
					else
						globalWordCount += 1
						wordContainer.Name = tostring(globalWordCount)
					end
					-- Parent.
					wordContainer.Parent = lineContainer
				else
					wordContainer = lineContainer
				end
				
				-- Create characters.
				for characterIndex, characterData in word do
					local width = characterData[2]
					
					local instance = createCharacter(characterData[1], x, y, width)
					-- Numerical naming.
					if not lineSorting and not wordSorting then
						globalCharacterCount += 1
						instance.Name = tostring(globalCharacterCount)
					else
						instance.Name = tostring(characterIndex)
					end
					-- Parent.
					instance.Parent = wordContainer
					
					-- Add space before the next character.
					x += width
				end
			end
			
			-- Add space before the next word.
			x += spaceWidth + wordGap
		end
		
		-- Add space before the next line.
		y += lineHeight + lineGap
	end
	
	-- Save text bounds.
	frameTextBounds[frame] = Vector2.new(textWidth, textHeight)
	
	-- Fire update signal.
	if Signal then frameUpdateSignals[frame]:Fire() end
end

local function enableDynamic(frame, text)
	frameSizeConnections[frame] = frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		-- Clear current text.
		clear(frame)
		
		-- Render new text.
		local text = frameText[frame]
		if text == "" then
			frameTextBounds[frame] = Vector2.zero
			if Signal then frameUpdateSignals[frame]:Fire() end
		else
			render(frame, text, frameOptions[frame])
		end
	end)
end
local function create(frame, text, options)
	-- Cache information.
	frameText[frame] = text
	frameOptions[frame] = options
	
	-- Render new text.
	if text == "" then
		frameTextBounds[frame] = Vector2.zero
		if Signal then frameUpdateSignals[frame]:Fire() end
	else
		render(frame, text, options)
	end
end

--[[
Creates text in the specified frame.
If text is already present, it will overwrite text and merge options.

<strong>frame</strong>: The container and bounding box.
]]--
module.Create = function(frame: GuiObject, text: string, options: Options?)
	-- Find current options.
	local currentOptions = frameOptions[frame]
	
	-- Argument errors.
	if not currentOptions and (typeof(frame) ~= "Instance" or not frame:IsA("GuiObject")) then error("Invalid frame.", 2) end
	if type(text) ~= "string" then error("Invalid text.", 2) end
	
	-- Handle options.
	if currentOptions then -- Text has been created before in this frame.
		-- Clear current text.
		clear(frame)
		
		-- Handle options.
		if type(options) == "table" then
			-- Merge options.
			local newOptions = options
			options = currentOptions
			for key, value in newOptions do
				if optionsList[key] then
					if not value then
						options[key] = nil
					else
						options[key] = value
					end
				else
					warn("Invalid option '"..key.."'.")
				end
			end
			-- Correct new (merged) options.
			correctOptions(options)
		else
			options = currentOptions
		end
		
		-- Handle dynamic, calculate size, and render.
		if type(options.Dynamic) ~= "boolean" then
			options.Dynamic = defaults.Dynamic
		end
		if options.Dynamic == true then
			create(frame, text, options)
			enableDynamic(frame, text, options)
		else
			-- Dynamic disabling.
			if not options.Dynamic then
				local connection = frameSizeConnections[frame]
				if connection then connection:Disconnect() end
			end
			
			-- Get rid of the non-true value.
			options.Dynamic = nil
			
			-- Create.
			create(frame, text, options)
		end
	else -- First text creation for this frame.
		if Signal then frameUpdateSignals[frame] = Signal() end -- Create and save update signal.
		
		-- Correct options.
		if type(options) == "table" then
			for key in options do
				if not optionsList[key] then
					options[key] = nil
					warn("Invalid option '"..key.."'.")
				end
			end
		else
			options = {}
		end
		correctOptions(options)
		
		-- Handle dynamic, calculate size, and render.
		if type(options.Dynamic) ~= "boolean" then
			options.Dynamic = defaults.Dynamic
		end
		if options.Dynamic == true then
			create(frame, text, options)
			enableDynamic(frame, text, options)
		else
			-- Dynamic disabling.
			if not options.Dynamic then
				local connection = frameSizeConnections[frame]
				if connection then connection:Disconnect() end
			end
			
			-- Get rid of the non-true value.
			options.Dynamic = nil
			
			-- Create.
			create(frame, text, options)
		end
		
		-- Handle destroying.
		frame.Destroying:Once(function()
			-- Clear frame.
			clear(frame)
			-- Destroy signals.
			if Signal then
				frameUpdateSignals[frame]:Destroy()
				frameUpdateSignals[frame] = nil
			end
			-- Remove connections.
			frameSizeConnections[frame] = nil
			-- Clear data.
			frameText[frame] = nil
			frameOptions[frame] = nil
			frameTextBounds[frame] = nil
		end)
	end
end

return table.freeze(module)]]></ProtectedString>
							<int64 name="SourceAssetId">138658986432597</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX44E8BD77310F4A85936268CF787F9D86">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Defaults</string>
								<string name="ScriptGuid">{E910246C-7658-40F6-A147-2361DF2D40FA}</string>
								<ProtectedString name="Source"><![CDATA[--!optimize 2

-- Services.
local CollectionService = game:GetService("CollectionService")

-- Attempt to find the plugin object.
local plugin = script:FindFirstAncestorOfClass("Plugin")

-- Options list for validation.
local optionsList = require(script.Parent.Options)

-- Default defaults.
local defaults = {
	Font = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
	
	Size = 14,
	
	ScaleSize = nil,
	MinimumSize = nil,
	MaximumSize = nil,
	
	Color = Color3.fromRGB(0, 0, 0),
	Transparency = 0,
	
	Pixelated = false,
	
	Offset = Vector2.zero,
	Rotation = 0,
	
	StrokeSize = 5,
	StrokeColor = Color3.fromRGB(0, 0, 0),
	
	ShadowOffset = Vector2.new(0, 20),
	ShadowColor = Color3.fromRGB(50, 50, 50),
	
	LineHeight = 1,
	CharacterSpacing = 1,
	
	Truncate = false,
	
	XAlignment = "Left",
	YAlignment = "Top",
	
	WordSorting = false,
	LineSorting = false,
	
	Dynamic = false
}

-- Merge user defaults.
local userDefaults
if plugin then
	for _, instance in plugin:GetDescendants() do
		if instance:HasTag("TextDefaults") then
			userDefaults = require(instance)
			break
		end
	end
else
	userDefaults = CollectionService:GetTagged("TextDefaults")[1]
	if userDefaults then userDefaults = require(userDefaults) end
end
if userDefaults and type(userDefaults) == "table" then
	for key in userDefaults do
		if optionsList[key] then defaults[key] = userDefaults[key] end
	end
end

-- Remove false booleans.
for key, value in defaults do
	if value == false then defaults[key] = nil end
end

-- Return final defaults.
return defaults]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6A1A57177C524BD597ACB0202D5F0FF4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CorrectOptions</string>
								<string name="ScriptGuid">{2E72B42F-3B3B-4846-B4CB-DC18B795DED4}</string>
								<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native

-- Services.
local TextService = game:GetService("TextService")

-- Option defaults.
local defaults = require(script.Parent.Defaults)

-- User fonts.
local userFonts = require(script.Parent.Fonts)

-- Option lists for validity checks.
local scaleSizeTypes = {
	RootX = true,
	RootY = true,
	RootXY = true,
	
	FrameX = true,
	FrameY = true,
	FrameXY = true
}

local xAlignments = {
	Left = true,
	Center = true,
	Right = true,
	Justified = true
}
local yAlignments = {
	Top = true,
	Center = true,
	Bottom = true,
	Justified = true
}

-- Text params for verifying Roblox fonts.
local textBoundsParams = Instance.new("GetTextBoundsParams")
textBoundsParams.Text = ""

-- Options corrector.
return function(options)
	if not scaleSizeTypes[options.ScaleSize] then
		options.ScaleSize = defaults.ScaleSize
	end
	if not scaleSizeTypes[options.ScaleSize] then
		-- Scale-size disabled.
		options.ScaleSize = nil
		options.MinimumSize = nil
		options.MaximumSize = nil
		
		if type(options.Size) ~= "number" then
			options.Size = defaults.Size
		elseif options.Size < 1 then
			options.Size = 1
		end
	else
		-- Scale-size enabled.
		if type(options.MinimumSize) ~= "number" then
			options.MinimumSize = defaults.MinimumSize
		end
		if type(options.MinimumSize) ~= "number" then
			options.MinimumSize = nil
		elseif options.MinimumSize < 1 then
			options.MinimumSize = 1
		end
		
		if type(options.MaximumSize) ~= "number" then
			options.MaximumSize = defaults.MaximumSize
		end
		if type(options.MaximumSize) ~= "number" then
			options.MaximumSize = nil
		elseif options.MaximumSize < 1 then
			options.MaximumSize = 1
		end
		
		if type(options.Size) ~= "number" then
			options.Size = defaults.Size
		end
	end
	
	local font = options.Font
	if font == nil then
		options.Font = defaults.Font
		
		-- Roblox font size limit.
		if options.Size > 100 then
			options.Size = 100
		end
	elseif typeof(font) == "Font" then -- Roblox font.
		-- Verify font.
		textBoundsParams.Font = options.Font
		textBoundsParams.Text = ""
		local _, result = pcall(TextService.GetTextBoundsAsync, TextService, textBoundsParams)
		if type(result) == "string" then
			warn("Invalid font. Fallback to default.")
			options.Font = defaults.Font
		end
		
		-- Roblox font size limit.
		if options.Size > 100 then
			options.Size = 100
		end
	else
		if not userFonts[font] then
			-- Warn about invalid font.
			warn("Invalid font. Fallback to default.")
			
			-- Apply default font.
			options.Font = defaults.Font
			
			-- Roblox font size limit.
			if options.Size > 100 then
				options.Size = 100
			end
		end
	end
	
	local lineHeight = options.LineHeight
	if type(lineHeight) ~= "number" then
		options.LineHeight = defaults.LineHeight
	elseif lineHeight < 0 then
		options.LineHeight = 0
	end
	local characterSpacing = options.CharacterSpacing
	if type(characterSpacing) ~= "number" then
		options.CharacterSpacing = defaults.CharacterSpacing
	elseif characterSpacing < 0 then
		options.CharacterSpacing = 0
	end
	
	if typeof(options.Color) ~= "Color3" then
		options.Color = defaults.Color
	end
	if type(options.Transparency) ~= "number" then
		options.Transparency = defaults.Transparency
	end
	
	local pixelated = options.Pixelated
	if pixelated == false then
		options.Pixelated = nil
	elseif pixelated ~= true then
		options.Pixelated = defaults.Pixelated
	end
	
	if typeof(options.Offset) ~= "Vector2" then
		options.Offset = defaults.Offset
	end
	if type(options.Rotation) ~= "number" then
		options.Rotation = defaults.Rotation
	end
	
	local strokeSize = options.StrokeSize
	local strokeColor = options.StrokeColor
	local strokeTransparency = options.StrokeTransparency
	if type(strokeSize) ~= "number" then
		if typeof(strokeColor) == "Color3" then
			options.StrokeSize = defaults.StrokeSize
			if type(strokeTransparency) ~= "number" then
				options.StrokeTransparency = options.Transparency
			end
		elseif type(strokeTransparency) == "number" then
			options.StrokeSize = defaults.StrokeSize
			if type(strokeColor) ~= "number" then
				options.StrokeColor = defaults.StrokeColor
			end
		else
			options.StrokeSize = nil
			options.StrokeColor = nil
			options.StrokeTransparency = nil
		end
	else
		if strokeSize < 1 then
			options.StrokeSize = 1
		end
		if typeof(strokeColor) ~= "Color3" then
			options.StrokeColor = defaults.StrokeColor
		end
		if type(strokeTransparency) ~= "number" then
			options.StrokeTransparency = options.Transparency
		end
	end
	
	local shadowOffset = options.ShadowOffset
	local shadowColor = options.ShadowColor
	local shadowTransparency = options.ShadowTransparency
	if typeof(shadowOffset) ~= "Vector2" then
		if typeof(shadowColor) == "Color3" then
			options.ShadowOffset = defaults.ShadowOffset
			if type(shadowTransparency) ~= "number" then
				options.ShadowTransparency = options.Transparency
			end
		elseif type(shadowTransparency) == "number" then
			options.ShadowOffset = defaults.ShadowOffset
			if type(shadowColor) ~= "number" then
				options.ShadowColor = defaults.ShadowColor
			end
		else
			options.ShadowOffset = nil
			options.ShadowColor = nil
			options.ShadowTransparency = nil
		end
	else
		if typeof(shadowColor) ~= "Color3" then
			options.ShadowColor = defaults.ShadowColor
		end
		if type(shadowTransparency) ~= "number" then
			options.ShadowTransparency = options.Transparency
		end
	end
	
	local truncate = options.Truncate
	if truncate == false then
		options.Truncate = nil
	elseif truncate ~= true then
		options.Truncate = defaults.Truncate
	end
	
	if not xAlignments[options.XAlignment] then
		options.XAlignment = defaults.XAlignment
	end
	if not yAlignments[options.YAlignment] then
		options.YAlignment = defaults.YAlignment
	end
	
	local wordSorting = options.WordSorting
	if wordSorting == false then
		options.WordSorting = nil
	elseif wordSorting ~= true then
		options.WordSorting = defaults.WordSorting
	end
	
	local lineSorting = options.LineSorting
	if lineSorting == false then
		options.LineSorting = nil
	elseif lineSorting ~= true then
		options.LineSorting = defaults.LineSorting
	end
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3AA165458D6B473BACE1AE437B7BF3FE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Options</string>
								<string name="ScriptGuid">{175DD306-28C8-49AB-8FB3-DD24A67F8E9E}</string>
								<ProtectedString name="Source"><![CDATA[return {
	Font = true,
	
	Size = true,
	
	ScaleSize = true,
	MinimumSize = true,
	MaximumSize = true,
	
	Color = true,
	Transparency = true,
	
	Pixelated = true,
	
	Offset = true,
	Rotation = true,
	
	StrokeSize = true,
	StrokeColor = true,
	StrokeTransparency = true,
	
	ShadowOffset = true,
	ShadowColor = true,
	ShadowTransparency = true,
	
	LineHeight = true,
	CharacterSpacing = true,
	
	Truncate = true,
	
	XAlignment = true,
	YAlignment = true,
	
	WordSorting = true,
	LineSorting = true,
	
	Dynamic = true
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXAF5E25CC11F74371BF8EB72B517D23AB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Fonts</string>
								<string name="ScriptGuid">{AFEA0EA4-9804-4AE8-9EFB-551B627E219D}</string>
								<ProtectedString name="Source"><![CDATA[--!optimize 2

-- Services.
local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")

-- Load and store all custom fonts.
local userFonts = {}

for _, module in CollectionService:GetTagged("Fonts") do
	if module:IsA("ModuleScript") then
		local fullModuleName = module:GetFullName()
		
		local fonts = require(module)
		
		if type(fonts) ~= "table" then
			warn("'"..fullModuleName.."' font data is not a table.")
		else
			if not next(fonts) then
				warn("'"..fullModuleName.."' font data table is empty.")
			else
				local player = Players.LocalPlayer
				local load
				if player then -- If running on client.
					local screenGui = Instance.new("ScreenGui")
					screenGui.Parent = player.PlayerGui
					
					local loading = 0
					load = function(image) -- For preloading the font image assets.
						-- Increment counter for currently loading images.
						loading += 1
						
						-- Setup image label for loading the current font.
						local label = Instance.new("ImageLabel")
						label.Size = UDim2.fromOffset(1, 1) -- As small as possible.
						label.BackgroundTransparency = 1
						label.ImageTransparency = 0.999 -- Trick to make the image invisible and still have it be loaded.
						label.ResampleMode = Enum.ResamplerMode.Pixelated
						label.Image = "rbxassetid://"..tostring(image)
						label.Parent = screenGui -- It's crucial that we put it in a visible ScreenGui, otherwise it won't be loaded.
						
						-- Detect load.
						coroutine.resume(coroutine.create(function()
							while true do
								task.wait()
								if label.IsLoaded then
									if loading == 1 then
										screenGui:Destroy()
									else
										loading -= 1
									end
									return
								end
							end
						end))
					end
				end
				
				local function handleCharacters(characters, size)
					local invertedFontSize = 1/size -- To avoid expensive division.
					
					for key, value in characters do
						-- Verify format.
						if type(key) ~= "string" then return end
						if type(value) ~= "table" then return end
						if type(value[1]) ~= "number" then return end
						if type(value[2]) ~= "number" then return end
						if typeof(value[3]) ~= "Vector2" then return end
						if type(value[4]) ~= "number" then return end
						if type(value[5]) ~= "number" then return end
						if type(value[6]) ~= "number" then return end
						
						-- Precalculate normalized offset and x-advance.
						value[4] *= invertedFontSize
						value[5] *= invertedFontSize
						value[6] *= invertedFontSize
					end
					
					return true
				end
				
				local remove = {} -- Because immediate removal will throw off the loop.
				local freeze = {} -- Because freezing before removal will result in errors.
				
				local processFonts
				
				local function handleTable(key, value, currentPath)
					if value.Image or value.Size or value.Characters then
						-- Verify format.
						if type(value.Image) ~= "number" then
							warn("Missing an image ID in '"..currentPath.."'")
							table.insert(remove, key)
							return
						end
						if type(value.Size) ~= "number" then
							warn("Missing a size in '"..currentPath.."'")
							table.insert(remove, key)
							return
						end
						if type(value.Characters) ~= "table" then
							warn("Missing characters in '"..currentPath.."'")
							table.insert(remove, key)
							return
						end
						if not handleCharacters(value.Characters, value.Size) then -- If not valid characters then.
							warn("Invalid characters in '"..currentPath.."'")
							table.insert(remove, key)
							return
						end
						
						-- Insert for later freeze.
						table.insert(freeze, key)
						
						-- Insert the font into raw fonts table.
						userFonts[value] = true
						
						-- Preload images.
						if player then -- If running on client.
							load(value.Image)
						end
					else
						processFonts(value, currentPath)
						table.freeze(value)
					end
				end
				processFonts = function(parent, parentPath)
					for key, value in parent do
						if type(value) ~= "table" then
							table.insert(remove, key)
						else
							handleTable(key, value, parentPath.."."..key)
						end
					end
					
					for index, key in remove do
						parent[key] = nil
						remove[index] = nil
					end
					for index, key in freeze do
						table.freeze(parent[key])
						freeze[index] = nil
					end
				end
				
				handleTable("", fonts, fullModuleName)
				if #freeze > 0 then table.freeze(fonts) end
			end
		end
	end
end

-- Return the global user fonts table.
return userFonts]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX2DC2E5C47D6B4413B6FAD655D23E9959">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{4973D328-85AE-427D-8B50-4C358874FAB1}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "Text+",
	Thumbnail = "rbxassetid://129198310435042",
	AssetId = 138658986432597,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @AlexanderLindholt"},
		{Text = "Description: Get ready to experience text in Roblox like it shouldve been."},
		{Text = "Version: (latest)"},

		{Separator = "Features"},
		{Text = " Custom fonts: Use any font file, whether one of your own or one you found online."},
		{Text = " Advanced control: Easily transform and style any individual character, word or line with freedom."},
		{Text = " Advanced control: Utilize awesome text styling like justified alignments and spacing controls."},
		{Text = " Advanced control: Effortlessly setup text scaling, so that its the perfect size on all devices."},
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX7693DB5A69064FD982ACD9FC7E0E3F46">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">NumberSpinner</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX72528725347F44A79D9CA2A03A2BEA2F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{4DA5465B-EC85-42A5-8CCD-BF5100C8AE92}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "NumberSpinner",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 6523814884,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @boatbomber"},
		{Text = "Description: A easy way to create a number spinner animation"},
		{Text = "Version: (latest)"},

		{Separator = "Features"},
		{Text = " Uses proxies to automatically handle all your changes and values without you needing to ever call functions yourself"},
		{Text = " Supports all fonts, textsizes, and colors"},
		{Text = " Customizable spin speed"},
		{Text = " Customizable decimal places"},
		{Text = " Customizable prefix and suffix (default is $)"},
		{Text = " Support for comma placement"},
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB8533FFC97344216B07A17ADF9BAC539">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">NumberSpinner</string>
							<string name="ScriptGuid">{A22AAA5E-11A3-4F45-8644-2436721201E3}</string>
							<ProtectedString name="Source"><![CDATA[local Digit = require(script.Digit)

local NumberSpinner = {}

local READ_ONLY = {
	Frame = true,
	Digits = true,
	CommaLabels = true,
	Text = true,
}
local CUSTOM_PROPS = {
	Value = "number",
	Duration = "number",
	Decimals = "number",
	Prefix = "string",
	Suffix = "string",
	Commas = "boolean",
}
local TEXT_TO_LAYOUT = {
	[Enum.TextXAlignment.Center] = Enum.HorizontalAlignment.Center,
	[Enum.TextXAlignment.Left] = Enum.HorizontalAlignment.Left,
	[Enum.TextXAlignment.Right] = Enum.HorizontalAlignment.Right,
}

local DUMMY_FRAME = Instance.new("Frame")
local DUMMY_LABEL = Instance.new("TextLabel")
DUMMY_LABEL.TextSize = 25
DUMMY_LABEL.TextColor3 = Color3.fromRGB(250, 250, 255)
DUMMY_LABEL.FontFace = Font.new("SourceSans")

local function newSpinner()
	local Spinner = {
		-- Props
		Value = 0,
		Duration = 0.3,
		Decimals = 2,
		Prefix = "$",
		Suffix = "",
		Commas = false,

		-- Internal
		Digits = {
			Whole = table.create(3),
			Decimal = table.create(2),
		},
		CommaLabels = table.create(2),

		-- UIs (populated later)
		Frame = nil,
		Layout = nil,
		PrefixLabel = nil,
		SuffixLabel = nil,
		DecimalLabel = nil,
		NegativeLabel = nil,
	}

	local SpinnerProxy = setmetatable({}, {
		__index = function(_, key)
			local Direct = Spinner[key]
			if Direct then
				return Direct
			end

			local propExistsForFrame = pcall(function()
				local _ = DUMMY_FRAME[key]
			end)
			if propExistsForFrame then
				return Spinner.Frame[key]
			end

			local propExistsForLabel, labelProp = pcall(function()
				return DUMMY_LABEL[key]
			end)
			if propExistsForLabel then
				local digit = Spinner.Digits.Whole[1]
				if digit then
					return digit[key]
				else
					return labelProp
				end
			end

			--warn("Nothing found for",key)
			return nil
		end,
		__newindex = function(_, key, value)
			if READ_ONLY[key] then
				warn("Attempted to set read-only value Spinner." .. key)
				return
			end

			-- Handle setting of Frame properties
			local propExistsForFrame = pcall(function()
				local _ = DUMMY_FRAME[key]
			end)
			if propExistsForFrame then
				local t = typeof(DUMMY_FRAME[key])
				if (t ~= "nil") and (t ~= typeof(value)) then
					warn("Attempted to set Spinner." .. key .. " to invalid value (" .. tostring(value) .. ")")
					return
				end
				Spinner.Frame[key] = value
				return
			end

			-- Handle alignment since it's a special case
			if key == "TextXAlignment" then
				Spinner.Layout.HorizontalAlignment = TEXT_TO_LAYOUT[value]
				return
			end

			-- Handle setting of text related properties
			local propExistsForLabel = pcall(function()
				local _ = DUMMY_LABEL[key]
			end)
			if propExistsForLabel then
				local propType = typeof(DUMMY_LABEL[key])
				if (propType ~= "nil") and (propType ~= typeof(value)) then
					warn("Attempted to set Spinner." .. key .. " to invalid value (" .. tostring(value) .. ")")
					return
				end
				for _, digit in pairs(Spinner.Digits.Whole) do
					digit[key] = value
				end
				for _, digit in pairs(Spinner.Digits.Decimal) do
					digit[key] = value
				end
				for _, comma in pairs(Spinner.CommaLabels) do
					comma[key] = value
				end
				Spinner.PrefixLabel[key] = value
				Spinner.SuffixLabel[key] = value
				Spinner.DecimalLabel[key] = value
				Spinner.NegativeLabel[key] = value
				return
			end

			-- Handle setting of the custom spinner properties
			if CUSTOM_PROPS[key] then
				if typeof(value) ~= CUSTOM_PROPS[key] then
					warn("Attempted to set Spinner." .. key .. " to invalid value (" .. tostring(value) .. ")")
					return
				end
				Spinner[key] = value
				Spinner:Update(key, value)
				return
			end
		end,
	})

	function Spinner:Destroy()
		self.Frame:Destroy()
		table.clear(self)
	end

	function Spinner:Update(Type)
		if Type == "Prefix" then
			Spinner.PrefixLabel.Text = Spinner.Prefix
			return
		elseif Type == "Suffix" then
			Spinner.SuffixLabel.Text = Spinner.Suffix
			return
		end

		local AbsValue = math.abs(Spinner.Value)
		local isNegative = Spinner.Value < 0

		if Spinner.NegativeLabel then
			Spinner.NegativeLabel.Visible = isNegative
		end

		local TextValue = Spinner.Decimals > 0 and string.format("%." .. Spinner.Decimals .. "f", AbsValue)
			or string.format("%d", AbsValue)
		local split = string.split(TextValue, ".")
		local whole, decimal = split[1], split[2]
		if not whole then
			return
		end

		local numWhole = #whole
		for i = 1, numWhole do
			local digit = Spinner.Digits.Whole[i]

			if digit then
				digit.Duration = Spinner.Duration
				digit.Value = tonumber(string.sub(whole, i, i))
			else
				digit = Digit.new(SpinnerProxy, (i * 2) - 900, tonumber(string.sub(whole, i, i)))
				Spinner.Digits.Whole[i] = digit
			end
		end
		for i = numWhole + 1, #Spinner.Digits.Whole do
			local digit = Spinner.Digits.Whole[i]
			if digit then
				digit:Destroy()
				Spinner.Digits.Whole[i] = nil
			end
		end

		if Spinner.Commas then
			local endLayout = (numWhole * 2) - 900
			local str = string.format("%d", math.floor(math.abs(Spinner.Value)))
			local commaIndex = 0
			for i = 0, #str - 1, 3 do
				if i == 0 then
					continue
				end
				commaIndex += 1
				local CommaLabel = Spinner.CommaLabels[commaIndex]
				if not CommaLabel then
					CommaLabel = Instance.new("TextLabel")
					CommaLabel.Name = "Comma"
					CommaLabel.BackgroundTransparency = 1
					CommaLabel.Size = UDim2.new(0, 0, 1, 0)
					CommaLabel.FontFace = SpinnerProxy.FontFace
					CommaLabel.TextSize = SpinnerProxy.TextSize
					CommaLabel.TextColor3 = SpinnerProxy.TextColor3
					CommaLabel.Text = ","
					CommaLabel.AutomaticSize = Enum.AutomaticSize.X
					CommaLabel.Parent = Spinner.Frame

					Spinner.CommaLabels[commaIndex] = CommaLabel
				end

				CommaLabel.LayoutOrder = (endLayout - ((i - 1) * 2) - 1)
			end

			for i = commaIndex + 1, #Spinner.CommaLabels do
				Spinner.CommaLabels[i]:Destroy()
				Spinner.CommaLabels[i] = nil
			end
		end

		if not decimal then
			if Spinner.DecimalLabel then
				Spinner.DecimalLabel.Visible = false
			end
			for _, digit in ipairs(Spinner.Digits.Decimal) do
				digit:Destroy()
			end
			table.clear(Spinner.Digits.Decimal)
			return
		end

		if Spinner.DecimalLabel then
			Spinner.DecimalLabel.Visible = true
		end
		for i = 1, #decimal do
			local digit = Spinner.Digits.Decimal[i]

			if digit then
				digit.Duration = Spinner.Duration
				digit.Value = tonumber(string.sub(decimal, i, i))
			else
				digit = Digit.new(SpinnerProxy, i, tonumber(string.sub(decimal, i, i)))
				Spinner.Digits.Decimal[i] = digit
			end
		end
		for i = #decimal + 1, #Spinner.Digits.Decimal do
			local digit = Spinner.Digits.Decimal[i]
			if digit then
				digit:Destroy()
				Spinner.Digits.Decimal[i] = nil
			end
		end
	end

	return SpinnerProxy, Spinner
end

function NumberSpinner.new()
	local Spinner, RawSpinner = newSpinner()

	local Frame = Instance.new("Frame")
	Frame.BackgroundTransparency = 1
	Frame.ClipsDescendants = true
	Frame.Size = UDim2.new(0, 200, 0, 50)
	Frame.Position = UDim2.new(0, 0, 0, 0)

	local Layout = Instance.new("UIListLayout")
	Layout.SortOrder = Enum.SortOrder.LayoutOrder
	Layout.FillDirection = Enum.FillDirection.Horizontal
	Layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	Layout.VerticalAlignment = Enum.VerticalAlignment.Center
	Layout.Padding = UDim.new(0, 0)
	Layout.Parent = Frame

	local Prefix = Instance.new("TextLabel")
	Prefix.Name = "Prefix"
	Prefix.LayoutOrder = -1000
	Prefix.BackgroundTransparency = 1
	Prefix.Size = UDim2.new(0, 0, 1, 0)
	Prefix.FontFace = Spinner.FontFace
	Prefix.TextSize = Spinner.TextSize
	Prefix.TextColor3 = Spinner.TextColor3
	Prefix.Text = Spinner.Prefix
	Prefix.AutomaticSize = Enum.AutomaticSize.X
	Prefix.Parent = Frame

	local Suffix = Instance.new("TextLabel")
	Suffix.Name = "Suffix"
	Suffix.LayoutOrder = 1000
	Suffix.BackgroundTransparency = 1
	Suffix.Size = UDim2.new(0, 0, 1, 0)
	Suffix.FontFace = Spinner.FontFace
	Suffix.TextSize = Spinner.TextSize
	Suffix.TextColor3 = Spinner.TextColor3
	Suffix.Text = Spinner.Suffix
	Suffix.AutomaticSize = Enum.AutomaticSize.X
	Suffix.Parent = Frame

	local Decimal = Instance.new("TextLabel")
	Decimal.Name = "Decimal"
	Decimal.LayoutOrder = 0
	Decimal.BackgroundTransparency = 1
	Decimal.Size = UDim2.new(0, 0, 1, 0)
	Decimal.FontFace = Spinner.FontFace
	Decimal.TextSize = Spinner.TextSize
	Decimal.TextColor3 = Spinner.TextColor3
	Decimal.Text = "."
	Decimal.AutomaticSize = Enum.AutomaticSize.X
	Decimal.Parent = Frame

	local Negative = Instance.new("TextLabel")
	Negative.Name = "Negative"
	Negative.LayoutOrder = -999
	Negative.BackgroundTransparency = 1
	Negative.Size = UDim2.new(0, 0, 1, 0)
	Negative.FontFace = Spinner.FontFace
	Negative.TextSize = Spinner.TextSize
	Negative.TextColor3 = Spinner.TextColor3
	Negative.Text = "-"
	Negative.AutomaticSize = Enum.AutomaticSize.X
	Negative.Parent = Frame

	RawSpinner.Frame = Frame
	RawSpinner.Layout = Layout
	RawSpinner.PrefixLabel = Prefix
	RawSpinner.SuffixLabel = Suffix
	RawSpinner.DecimalLabel = Decimal
	RawSpinner.NegativeLabel = Negative

	Spinner:Update()

	return Spinner
end

function NumberSpinner.fromGuiObject(GuiObject)
	if typeof(GuiObject) ~= "Instance" then
		return
	end
	if not GuiObject:IsA("GuiObject") then
		return
	end

	local Spinner = NumberSpinner.new()

	Spinner.Name = "Spinner_" .. GuiObject.Name
	Spinner.SizeConstraint = GuiObject.SizeConstraint
	Spinner.Size = GuiObject.Size
	Spinner.Position = GuiObject.Position
	Spinner.AnchorPoint = GuiObject.AnchorPoint
	Spinner.Rotation = GuiObject.Rotation
	Spinner.LayoutOrder = GuiObject.LayoutOrder
	Spinner.ZIndex = GuiObject.ZIndex
	Spinner.Visible = GuiObject.Visible
	Spinner.BackgroundColor3 = GuiObject.BackgroundColor3
	Spinner.BorderColor3 = GuiObject.BorderColor3
	Spinner.BorderSizePixel = GuiObject.BorderSizePixel
	Spinner.BackgroundTransparency = GuiObject.BackgroundTransparency

	if GuiObject:IsA("TextLabel") or GuiObject:IsA("TextButton") or GuiObject:IsA("TextBox") then
		Spinner.FontFace = GuiObject.FontFace
		Spinner.TextSize = GuiObject.TextSize
		Spinner.TextColor3 = GuiObject.TextColor3
		Spinner.TextTransparency = GuiObject.TextTransparency
		Spinner.TextStrokeColor3 = GuiObject.TextStrokeColor3
		Spinner.TextStrokeTransparency = GuiObject.TextStrokeTransparency

		Spinner.Layout.HorizontalAlignment = TEXT_TO_LAYOUT[GuiObject.TextXAlignment]
	end

	Spinner.Parent = GuiObject.Parent

	GuiObject.Visible = false

	return Spinner
end

return NumberSpinner]]></ProtectedString>
							<int64 name="SourceAssetId">6523814884</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX54C98581DB28433AB85759624CE23D5A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Digit</string>
								<string name="ScriptGuid">{48E68D52-AA27-4588-9F30-7BF38227C38B}</string>
								<ProtectedString name="Source"><![CDATA[local TextService = game:GetService("TextService")
local TweenService = game:GetService("TweenService")

local sizeTweenInfo = TweenInfo.new(0.15)

local Digit = {}

function Digit.new(Spinner, LayoutOrder, Value)
	local digit = {
		Duration = Spinner.Duration,
		Value = Value,

		Labels = table.create(10),
		CanvasTweens = table.create(10),
	}
	local tweenInfo = TweenInfo.new(Spinner.Duration)

	local Frame = Instance.new("Frame")
	Frame.Name = "digit"
	Frame.LayoutOrder = LayoutOrder
	Frame.BackgroundTransparency = 1
	Frame.Size = UDim2.new(0, 0, 0, Spinner.TextSize + 6)
	Frame.ClipsDescendants = true

	local Canvas = Instance.new("Frame")
	Canvas.Name = "canvas"
	Canvas.Size = UDim2.new(1, 0, 10, 0)
	Canvas.BackgroundTransparency = 1
	Canvas.Parent = Frame

	Canvas.Position = UDim2.new(0, 0, -digit.Value, 0)

	for i = 0, 9 do
		local n = Instance.new("TextLabel")
		n.Name = "n_" .. i
		n.BackgroundTransparency = 1
		n.TextSize = Spinner.TextSize
		n.TextColor3 = Spinner.TextColor3
		n.FontFace = Spinner.FontFace
		n.Text = i
		n.Size = UDim2.new(1, 0, 0.1, 0)
		n.Position = UDim2.new(0, 0, i * 0.1, 0)
		n.Parent = Canvas
		digit.Labels[i] = n
		digit.CanvasTweens[i] = TweenService:Create(Canvas, tweenInfo, { Position = UDim2.new(0, 0, -i, 0) })
	end

	Frame.Parent = Spinner.Frame

	local TextBoundsParams = Instance.new("GetTextBoundsParams")

	local function updateSize(shouldDelete)
		task.spawn(function()
			TextBoundsParams.Text = "8"
			TextBoundsParams.Font = Spinner.FontFace
			TextBoundsParams.Size = Spinner.TextSize
			TextBoundsParams.Width = Spinner.TextSize

			-- Errors like "Temp read failed." can occur for some circumstances.
			local success, textBounds = pcall(TextService.GetTextBoundsAsync, TextService, TextBoundsParams)
			if success then
				local tween = TweenService:Create(
					Frame,
					sizeTweenInfo,
					{ Size = UDim2.new(0, if shouldDelete then 0 else textBounds.X + 1, 0, textBounds.Y + 10) }
				)
				tween.Completed:Connect(function()
					if shouldDelete then
						Frame:Destroy()
						table.clear(digit)
					end
					tween:Destroy()
				end)
				tween:Play()
			end
		end)
	end

	updateSize()

	local digitProxy = setmetatable({}, {
		__index = function(_, key)
			local Direct = digit[key]
			if Direct then
				return Direct
			end

			local propExistsForLabel = pcall(function()
				local _ = digit.Labels[1][key]
			end)
			if propExistsForLabel then
				return digit.Labels[1][key]
			end

			return nil
		end,
		__newindex = function(_, key, value)
			local Direct = digit[key]
			if Direct then
				digit[key] = value
				digit:Update(key, value)
				return
			end

			local propExistsForLabel = pcall(function()
				local _ = digit.Labels[1][key]
			end)
			if propExistsForLabel then
				for i = 0, 9 do
					digit.Labels[i][key] = value
				end
				digit:Update(key, value)
			end
		end,
	})

	function digit:Destroy()
		updateSize(true)
	end

	function digit:Update(Type, UpdateValue)
		if Type == "Duration" then
			tweenInfo = TweenInfo.new(UpdateValue)
			for i = 0, 9 do
				digit.CanvasTweens[i] = TweenService:Create(Canvas, tweenInfo, { Position = UDim2.new(0, 0, -i, 0) })
			end
		elseif Type == "Value" then
			digit.CanvasTweens[UpdateValue]:Play()
		elseif Type == "TextSize" or Type == "FontFace" then
			updateSize()
		end
	end

	return digitProxy
end

return Digit]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX5E10A72B9C164A09913CF61ABDDE3CD5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ClassPP</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX12B468C5E17A46FCAA15C32C883B83FF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{F9FB0B2B-3A38-41CB-A30A-EEE78DFDBA95}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "Class++",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @TenebrisNoctua"},
		{Text = "Description: Class++ is a module that aims to bring a class structure very similar to in languages such as C++ and Java to Luau. It brings access specifiers, function and operator overloading, inheritance, and many other features. It supports auto-completion with inheritance, and even has its own Type API!"},
		{Text = "Version: (latest)"},

		{Separator = "Features"},
		{Text = "Class++ offers a much simpler and easier experience while creating classes and objects, you no longer need to deal with the complexity of metatables to create a class system. And its features allow you to far surpass the things you were able to do with just metatables."},
	}
	
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX498CE7E789294E1DAB4865D520A5D93F">
						<Properties>
							<BinaryString name="AttributesSerialize">AQAAABQAAABzaWxlbmNlVXBkYXRlV2FybmluZwMA</BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClassPP</string>
							<string name="ScriptGuid">{430BC156-7C8C-4A7F-8AAC-A1733EC46863}</string>
							<ProtectedString name="Source"><![CDATA[--!native
--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		The main module of Class++.
	////
--]]

--////// Variables

local classpp = {}

local Util = require(script.Util)
local Error = require(script.Error)
local Type = require(script.Type)

local LogError = Error.logError
local LogErrorNonFatal = Error.logErrorNonFatal
local LogWarning = Error.logWarning

local operatorFuncNames: {string} = {"operator_add", "operator_sub", "operator_mul", "operator_div", "operator_idiv", "operator_mod", "operator_pow", "operator_unm", "operator_eq"}
local silenceUpdateWarning: boolean = script:GetAttribute("silenceUpdateWarning") or false

local Classes: {[string]: class} = {}

--////// Types

export type classData = Type.classData
export type class<AccessSpecifier = any?> = Type.class<AccessSpecifier>

type internalClassData = {
	Public: {[any]: any}?,
	Private: {[any]: any}?,
	Protected: {[any]: any}?,
	Friend: {any}?,
	Internal: {
		__type: string?,
		__locked: boolean?,
		constructor: (self: any, ...any) -> ()?,
		destructor: (self: any) -> ()?,
	}
}
type internalClass<AccessSpecifier = any?> = typeof(setmetatable({} :: {
	new: (...any) -> AccessSpecifier,
	extends: (className: string) -> (classData: classData) -> class<AccessSpecifier>,
	overload: (accessSpecifier: string, name: string, functionTable: {(...any) -> (any)}) -> (),
	static: (accessSpecifier: string, name: string, property: any) -> (),
	Name: string,
	Inherits: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end})),
	Friends: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end})),
	Statics: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end}))?
}, {
	__index = function(t, i) return end :: ({any}, any) -> (any),
	__newindex = function(t, i, v) end :: ({any}, any, any) -> (),
	__type = "",
	__classtype = "",
	__abstract = false,
	__final = false
}))

--////// Local Functions

--// A deep copy function for tables, with support for metatables.
local function deepCopy<T>(original: T & {[any]: any}): T & {[any]: any}
	local copy = table.clone(original) :: T & {[any]: any}

	for key, value in (original :: {[any]: any}) do
		if type(value) == "table" then
			local tmetatable = getmetatable(value);
			(copy :: {[any]: any})[key] = if not tmetatable then deepCopy(value) else setmetatable(deepCopy(value) :: {[any]: any}, tmetatable)
		end
	end

	return copy
end

--// Sorts the classData into an objectData that can be used inside objects.
local function sortAttributes(data: classData, className: string): internalClassData
	local classObjTbl: internalClassData = deepCopy(data)

	classObjTbl.Friend = nil
	classObjTbl.Internal = {
		__type = className,
		__locked = false
	}

	if classObjTbl["constructor"] then 
		classObjTbl.Internal.constructor = classObjTbl["constructor"] 
		classObjTbl["constructor"] = nil
	end

	if classObjTbl["destructor"] then
		classObjTbl.Internal.destructor = classObjTbl["destructor"]
		classObjTbl["destructor"] = nil
	end

	return classObjTbl
end

--// Recursively cleans the given table.
local function recursiveClean(tbl: {[any]: any})
	for key, value in tbl do
		if typeof(key) == "Instance" then key:Destroy() end
		if typeof(value) == "table" then
			for _, v in tbl do
				if v == value then return end
			end
			recursiveClean(value)
		elseif typeof(value) == "Instance" then
			value:Destroy()
		end

		tbl[key] = nil
	end
end

--// Cleans the objectData (except for the Internal data) and locks the object.
local function objectCleaner(objectTbl: {[string]: any}): {}
	for accessSpecifier, attributesData in objectTbl do
		if accessSpecifier == "Internal" then continue end
		recursiveClean(attributesData)
	end
	objectTbl.Internal.__locked = true
	return objectTbl
end

--// Merges classDatas of two related classes for inheritation.
local function mergeClassData(superClassData: classData, childClassData: classData): classData
	local newClassData: classData = {
		Public = {},
		Private = {},
		Protected = {}
	}

	for accessSpecifier, attributesData in superClassData do
		if accessSpecifier == "Private" then continue end
		if typeof(attributesData) == "function" then continue end

		for attributeName, attributeData in (attributesData :: any) do
			newClassData[accessSpecifier][attributeName] = attributeData
		end
	end

	for accessSpecifier, attributesData: any in childClassData do
		if typeof(accessSpecifier) ~= "string" then continue end

		local n: string? = if typeof(attributesData) == "function" then debug.info(attributesData, "n") else nil

		if n and n == "destructor" or n and n == "constructor" then
			newClassData[n] = attributesData
			continue
		end

		for attributeName, attributeData in attributesData do
			newClassData[accessSpecifier][attributeName] = attributeData
		end
	end

	return newClassData
end

--// Checks if the given string is a valid access specifier.
local function checkValidAccessSpecifier(specifierString: string): (boolean, string?)
	local accessSpecifiers: {string} = {"Public", "Private", "Protected", "Internal", "Friend"}

	for _, accessSpecifier in accessSpecifiers do
		if specifierString == accessSpecifier then
			return true, accessSpecifier
		end
	end

	return false
end

--// Returns the access specifier of an index.
local function returnAccessSpecifier(index: string, classData: any): string?
	for accessSpecifier, attributesData in classData do
		if typeof(attributesData) == "table" and attributesData[index] ~= nil then
			return accessSpecifier
		end
	end
	return
end

--// Finds the property that's been set to the given index. If given a string that contains an access specifier, it tries to find the property inside that access specifier.
local function findPropertyFromIndex(classData: internalClassData | classData, index: string, accessSpecifier: string?): any?
	local fAccessSpecifier = accessSpecifier or returnAccessSpecifier(index, classData)
	if not (classData :: any)[fAccessSpecifier] then return end
	if (classData :: any)[fAccessSpecifier][index] ~= nil then
		return (classData :: any)[fAccessSpecifier][index]
	end
	return
end

--// Calls an operator function from the given name.
local function callOperator(functionName, obj, obj2: any?, silenceError: boolean?): boolean | any
	if typeof(obj) == "userdata" then
		if obj[functionName] then
			return obj[functionName](obj, obj2)
		elseif not silenceError then
			LogError("classNoMatchingFunctionError", true, functionName)
		end
	elseif typeof(obj2) == "userdata" then
		if obj2[functionName] then
			return obj2[functionName](obj2, obj)
		elseif not silenceError then
			LogError("classNoMatchingFunctionError", true, functionName)
		end
	end

	return false
end

--// Checks if the given index has already been set inside an access specifier.
local function checkRedeclaration(classData: classData, index: string?): (boolean, any?)
	if not classData then return false end

	if index then
		local fnumber = 0
		for accessSpecifier, attributesData in classData do
			if typeof(attributesData) ~= "table" then continue end
			if (attributesData :: any)[index] then fnumber += 1 end
		end
		if fnumber >= 2 then return true, index end
	else
		for accessSpecifier, attributesData in classData do
			if typeof(attributesData) ~= "table" then continue end
			for attributeKey, _ in (attributesData :: any) do
				if checkRedeclaration(classData, attributeKey) then return true, attributeKey end
			end
		end
	end

	return false
end

--// Checks if there are any indexes inside the classData that aren't valid access specifiers or functions.
local function checkOutsideAccessSpecifierDecleration(classData: classData): boolean
	for index, value in classData do
		if typeof(index) ~= "string" then continue end
		if not checkValidAccessSpecifier(index) and index ~= "constructor" and index ~= "destructor" then
			return true
		end
	end

	return false
end

--// Sets the metamethods of an object.
local function setMetamethods(class: internalClass, classData: internalClassData, methods)
	methods.__metatable = 'The metatable is locked.'

	function methods:__index(index): any
		if classData.Internal.__locked == true then LogError("classObjectLocked", true) end

		local accessSpecifier = returnAccessSpecifier(index, classData)

		if accessSpecifier ~= "Public" then
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, index)
			elseif accessSpecifier == "Internal" and Util.getMethodContext(7) ~= Type.typeof then
				LogError("classPropertyIsInternal", true, index)
			elseif accessSpecifier == "Protected" and not Util.inClassScope(class, true, true, Classes) then
				LogError("classPropertyIsProtected", true, index)
			end
		end

		if index == "Destroy" then
			return function() 
				if classData.Internal.destructor then classData.Internal.destructor(self) end
				objectCleaner(classData)
			end
		end

		-- Checking if the index is calling an operator function, this part can be removed if you want to support operator functions still being callable even without operators.
		local sFound = string.find(index, "operator")
		if sFound then
			for _, opfuncname in operatorFuncNames do
				if index == opfuncname and Util.getMethodContext(5) ~= callOperator then
					LogError("nonNativeOperatorCall", true, index)
				end
			end
		end

		local rprop = findPropertyFromIndex(classData, index, accessSpecifier)
		if rprop ~= nil then return rprop elseif index ~= "constructor" and index ~= "destructor" and index ~= "__tostring" and not sFound then LogErrorNonFatal("classMemberNotFound", true, index) end

		return
	end

	function methods:__newindex(index, value)
		if classData.Internal.__locked == true then LogError("classObjectLocked", true) end
		if value == nil then LogError("classMemberCannotSetToNil", true) end

		local accessSpecifier = returnAccessSpecifier(index, classData)

		if accessSpecifier ~= "Public" then
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, index)
			elseif accessSpecifier == "Internal" then
				LogError("classPropertyIsInternal", true, index)
			elseif accessSpecifier == "Protected" and not Util.inClassScope(class, true, true, Classes) then				
				LogError("classPropertyIsProtected", true, index)
			end
		end

		for _, attributesData in classData do
			if typeof(attributesData) == "table" and (attributesData :: any)[index] ~= nil then
				if (attributesData :: any)[index] == value then return end
				(attributesData :: any)[index] = value
				return
			end
		end

		LogError("classMemberNotFound", true, index)
	end

	function methods:__tostring()
		if classData.Internal.__locked == true then LogError("classObjectLocked", true) end

		local result = callOperator("__tostring", self, nil, true)
		if result then
			return result
		else
			return class.Name
		end
	end

	for _, operatorFuncName in operatorFuncNames do
		if not (classData.Public :: {[any]: any})[operatorFuncName] then continue end

		methods[string.gsub(operatorFuncName, "operator", "_")] = function(obj, obj2)
			if classData.Internal.__locked == true then LogError("classObjectLocked", true) end
			return callOperator(operatorFuncName, obj, obj2)
		end
	end
end

--// Creates a new class object with the given classData, className and an additional internalFunctionsList table to allow access for functions inside it to write to Inherits and Friends tables.
local function createClassObject<AccessSpecifier>(nClassData: classData, className: string, internalFunctionsList: {(...any) -> (any)}?, superClassConstructor: (self: any, ...any) -> ()?): internalClass<AccessSpecifier>
	local class: internalClass = setmetatable({
		Inherits = setmetatable({}, { __tostring = function() return '{}' end, __newindex = function(t, i, v) local f = Util.getMethodContext(5) if f ~= createClassObject and internalFunctionsList and not table.find(internalFunctionsList, f) then LogError("attemptToModifyReadOnlyTable", false) end rawset(t :: any, i :: any, v :: any) end, __metatable = {} }),
		Friends = setmetatable({}, { __tostring = function() return '{}' end, __newindex = function(t, i, v) local f = Util.getMethodContext(5) if f ~= createClassObject and internalFunctionsList and not table.find(internalFunctionsList, f) then LogError("attemptToModifyReadOnlyTable", false) end rawset(t :: any, i :: any, v :: any) end, __metatable = {} }),
		Name = className
	} :: {
		new: (...any) -> AccessSpecifier,
		extends: (className: string) -> (classData: classData) -> class,
		overload: (accessSpecifier: string, name: string, functionTable: {(...any) -> (any)}) -> (),
		static: (accessSpecifier: string, name: string, property: any) -> (),
		Name: string,
		Inherits: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end})),
		Friends: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end})),
		Statics: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end}))?
	}, {
		__index = function(t, i) return rawget(t, i)  end,
		__newindex = function(t, i, v) rawset(t, i, v) end,
		__type = "",
		__classtype = "",
		__abstract = false,
		__final = false
	})

	class.Statics = setmetatable({}, {__tostring = function() return '{}' end, __newindex = function(t, i, v) local f = Util.getMethodContext(5) if f ~= class.static then LogError("attemptToModifyReadOnlyTable", false) end rawset(t :: any, i :: any, v :: any) end, __metatable = {}})

	if not nClassData.Public then nClassData.Public = {} end
	if not nClassData.Private then nClassData.Private = {} end
	if not nClassData.Protected then nClassData.Protected = {} end

	if nClassData.Friend then
		for _, friend in nClassData.Friend do
			table.insert(class.Friends :: any, friend)
		end
	end

	local overloadedFunctions = {}

	local methods = {
		__type = "Class",
		__classtype = className,
		__abstract = false,
		__final = false
	}

	methods.__index = function(t, i)
		if i == "__type" then return end
		if i == "__abstract" then 
			if classpp.abstract == Util.getMethodContext(5) or classpp.final == Util.getMethodContext(5) then
				return methods["__abstract"] 
			end
		end
		if i == "__final" then 
			if classpp.final == Util.getMethodContext(5) or classpp.abstract == Util.getMethodContext(5) then
				return methods["__final"] 
			end
		end
		if i == "__ovfunc" and Util.getMethodContext(5) == Util.inClassScope then
			return overloadedFunctions
		end

		local result = nClassData[i] or findPropertyFromIndex(nClassData, i)
		if not result then return (class.Statics :: any)[i] end

		local methodContext, name = Util.getMethodContext(5)
		if typeof(result) == "function" and methodContext ~= Util.inClassScope then LogError("cannotCallFunctionError") elseif typeof(result) == "table" and getmetatable(result) and getmetatable(result)["__call"] and methodContext ~= Util.inClassScope then LogError("cannotCallFunctionError") end

		return result
	end

	methods.__newindex = function(t, i, v)
		if i == "__type" then return end
		if i == "__abstract" then 
			if classpp.abstract == Util.getMethodContext(5) and v == true then
				methods.__abstract = true
				class.new = function()
					return LogError("attemptToCreateObjectFromAbstractClass", true)
				end
			end
			return
		end
		if i == "__final" then
			if classpp.final == Util.getMethodContext(5) and v == true then
				methods.__final = true
				class.extends = function()
					LogError("attemptToExtendAFinalClass", true)
					return function() 
						return setmetatable({}, {}) :: class
					end
				end
			end
			return
		end

		nClassData[i] = v

		return v
	end

	function class.new(...): any
		local newObjTbl: internalClassData = sortAttributes(nClassData, className)
		local newObj = newproxy(true)
		local methods = getmetatable(newObj)

		setMetamethods(class, newObjTbl, methods)

		if superClassConstructor then superClassConstructor(newObj, ...) end

		if newObjTbl.Internal.constructor then
			newObjTbl.Internal.constructor(newObj, ...)
		end

		return newObj
	end

	function class.extends(className: string): (extendedClassData: classData) -> class
		if typeof(className) ~= "string" then LogError("classNameNotString") end
		if Classes[className] then LogError("classAlreadyExists", false, className) end
		if not silenceUpdateWarning then LogWarning("compatibilityWarning", false) end

		return function(extendedClassData: classData): class
			local newClassData = mergeClassData(nClassData, extendedClassData)
			local newClass = createClassObject(newClassData, className, {debug.info(1, 'f')}, nClassData.constructor)
			Classes[className] = newClass

			table.insert(newClass.Inherits :: any, class)

			return newClass
		end
	end

	function class.overload(accessSpecifier: string, name: string, functionTable: {(...any) -> (any)})
		local accessSpecifierCheck, specifierName = checkValidAccessSpecifier(accessSpecifier)
		if not accessSpecifierCheck or specifierName and specifierName == "Internal" then LogError("invalidAccessSpecifierError", true) end
		if not name then LogError("overloadfunctionNameNotSet", true) end
		if typeof(functionTable) ~= "table" or #functionTable == 0 then LogError("overloadfunctionTableNotGiven", true) end

		for _, func in functionTable do
			if typeof(func) ~= "function" then LogError("expectedFunctionError", true, typeof(func)) end
			table.insert(overloadedFunctions, func)
		end

		local methods = {
			__index = function(tbl, i) return end,
			__newindex = function(tbl, i) return end
		}

		methods.__call = function(tbl, ...)
			if Util.getMethodContext(4) == deepCopy then return end

			local args = {...}
			local f = false
			for _, func in functionTable do
				local argCount, isVariadic = debug.info(func, 'a')
				if argCount == #args or isVariadic then
					f = true
					func(...)
					return -- Comment or remove this if you want to run multiple functions at the same time.
				end
			end

			if not f and #args > 0 then LogErrorNonFatal("overloadfunctionArgumentMismatch", false, #args, name) end
		end

		nClassData[specifierName][name] = setmetatable({}, methods)
	end

	function class.static(accessSpecifier: string, name: string, property: any)
		local accessSpecifierCheck, specifierName = checkValidAccessSpecifier(accessSpecifier)
		if not accessSpecifierCheck or specifierName and specifierName == "Internal" or specifierName and specifierName == "Protected" then LogError("invalidAccessSpecifierError", true) end
		if not name then LogError("staticMemberNameNotSet", true) end
		if not class.Statics then return end
		if not nClassData[specifierName] then nClassData[specifierName] = {} end

		if not silenceUpdateWarning then LogWarning("compatibilityWarning", false) end

		local newObj = newproxy(true)
		local methods = getmetatable(newObj)

		function methods:__index(index): any
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, name)
			end

			return property
		end

		function methods:__newindex(index, value)
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, name)
			end

			property = value
			return property
		end

		function methods:__call(...)
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, name)
			end

			if typeof(property) == "function" then 
				return property(...) 
			else
				return property
			end
		end

		function methods:__tostring()
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, name)
			end

			return tostring(property)
		end

		class.Statics[name] = newObj
	end

	return setmetatable(class :: any, methods)
end

--////// Module Functions

--[[
	Returns a new <code>class</code> with the given <code>className</code> and <code>classData</code>.
]]
function classpp.class(className: string): <T>(classData: {Public: T?} & classData) -> class<T>
	if typeof(className) ~= "string" then LogError("classNameNotString") end
	if Classes[className] then LogError("classAlreadyExists", false, className or "Unknown") end

	return function<T>(classData: classData & {Public: T?}): class<T>
		if typeof(classData) ~= "table" then LogError("classDataNotTable") end
		if getmetatable(classData :: any) or not select(1, pcall(setmetatable, classData, {})) then LogError("classDataContainsMetatable") end

		local isAPropertyRedeclared: boolean, redeclaredIndex: any? = checkRedeclaration(classData)
		if isAPropertyRedeclared then LogError("classPropertyRedeclaration", false, redeclaredIndex) end

		if findPropertyFromIndex(classData, "Destroy") then LogError("invalidDestructorDecleration", false) end
		if checkOutsideAccessSpecifierDecleration(classData) then LogError("invalidAccessSpecifierInClassDataError", false) end

		local nCObj: internalClass<T> = createClassObject(classData, className)
		Classes[className] = nCObj

		return nCObj
	end
end

--[[
	Marks the given <code>class</code> or <code>class</code>es as abstract. If given multiple, then the first class will be returned.
]]
function classpp.abstract(classTable: {class}): class
	if typeof(classTable) ~= "table" then LogError("invalidModifierArgument", true) end

	for _, class: class in classTable do
		if Type.typeof(class) ~= "Class" then LogError("typeofObjectIsNotClass") end
		if class["__final"] then LogError("illegalModifierCombination", true, `abstract and final`) end 

		class["__abstract"] = true
	end

	return classTable[1]
end

--[[
	Marks the given <code>class</code> or <code>class</code>es as final. If given multiple, then the first class will be returned.
]]
function classpp.final(classTable: {class}): class
	if typeof(classTable) ~= "table" then LogError("invalidModifierArgument", true) end

	for _, class: class in classTable do
		if Type.typeof(class) ~= "Class" then LogError("typeofObjectIsNotClass") end
		if class["__abstract"] then LogError("illegalModifierCombination", true, `final and abstract`) end 

		class["__final"] = true
	end

	return classTable[1]
end

--[[
	Returns the <code>class</code> with the given <code>className</code>, if it exists.
]]
function classpp.getClass(className: string): class
	if typeof(className) ~= "string" then LogError("classNameNotString") end
	if not Classes[className] then LogError("classNotFound") end

	return Classes[className]
end

classpp.Type = Type
classpp.Util = Util

return classpp]]></ProtectedString>
							<int64 name="SourceAssetId">18312821151</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX0F83CB8114954230821CC07CC8C62252">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Util</string>
								<string name="ScriptGuid">{1AC24A70-DF42-4A70-AFE5-DE98CEAFE423}</string>
								<ProtectedString name="Source"><![CDATA[--!native
--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		Utilities for Class++.
	////
--]]

local Util = {}
local Type = require(script.Parent.Type)

--////// Types

type class = Type.class

--////// Util Functions

function Util.getMethodContext(level: number): ((...any) -> (any), string)
	local _, f, n = pcall(function() 
		local f = debug.info(level, 'f')
		local n = debug.info(level, 'n')

		return f, n
	end)

	return f, n
end

function Util.checkInheritance(class: class, classOrMethod: any | () -> ()): boolean
	for _, inherited in class.Inherits do
		if typeof(classOrMethod) == "table" and inherited == classOrMethod or inherited[classOrMethod] then
			return true
		end
	end

	return false
end

function Util.checkFriendship(class: class, methodName: string, method: (any) -> (any), classes: {[string]: any}): boolean
	for _, friend in class.Friends do
		if Type.typeof(friend) == "Class" and friend[methodName] then
			return true
		elseif typeof(friend) == "string" then
			if classes[friend] and classes[friend][methodName] then
				return true
			end
		elseif typeof(friend) == "function" and friend == method then
			return true
		end
	end

	return false
end

function Util.inClassScope(class: class, includeInherited: boolean, includeFriend: boolean, classes: {[string]: any}?, defaultLevel: number?): boolean
	local level: number = defaultLevel or 6

	while true do
		local method, methodName = Util.getMethodContext(level)
		if not method then return false end

		if class[methodName] == method then return true end
		if #methodName == 0 and table.find(class["__ovfunc"], method) then return true end

		local result = if includeInherited then Util.checkInheritance(class, method) else false or if includeFriend and classes then Util.checkFriendship(class, methodName, method, classes) else false
		if result then return true end

		if method == Type.typeof then return true end

		level += 1
	end

	return false
end

return Util]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXCEDCE70BDA194D99BD7B8CD41FAEF6CF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Error</string>
								<string name="ScriptGuid">{0BCA86C1-B352-4DB3-9554-98EB211992A7}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		Handles logging Class++ specific errors.
	////
--]]

--////// Variables

local classError = {}
local LogMessages = require(script.Parent.LogMessages)

--////// Local Functions

local function logMessage(messageType: string, includeTraceback: boolean?, tracebackString: string?, logType: string, ...)
	local formatString: string
	local messageString: string

	if LogMessages[messageType] ~= nil then
		formatString = LogMessages[messageType]
	else
		formatString = LogMessages["unknownError"]
	end

	if ... and includeTraceback then
		formatString = string.format(formatString, ...)
		messageString = `\{Class++}: {formatString}\n--- Stack Trace ---\n{tracebackString or debug.traceback(nil, 4)}`
	elseif ... and not includeTraceback then
		formatString = string.format(formatString, ...)
		messageString = `\{Class++}: {formatString}`
	elseif not ... and includeTraceback then
		messageString = `\{Class++}: {formatString}\n--- Stack Trace ---\n{tracebackString or debug.traceback(nil, 4)}`
	else
		messageString = `\{Class++}: {formatString}`
	end
	
	if logType == "Error" then
		error(messageString, 0)
	elseif logType == "Warning" then
		warn(messageString)
	end
end

--////// Module Functions

function classError.logError(messageType: string, includeTraceback: boolean?, ...)
	return logMessage(messageType, includeTraceback, nil, "Error", ...)
end

function classError.logErrorNonFatal(messageType: string, includeTraceback: boolean?, ...)
	local tracebackString: string = debug.traceback(nil, 4)
	
	task.spawn(function(...)
		return logMessage(messageType, includeTraceback, tracebackString, "Error", ...)
	end, ...)
end

function classError.logWarning(messageType: string, includeTraceback: boolean?, ...)
	return logMessage(messageType, includeTraceback, nil, "Warning", ...)
end

return classError
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA73DFCCB06C846B3A4540C651913FFAA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LogMessages</string>
								<string name="ScriptGuid">{4EF9283B-AA2D-4173-BAED-AD143BE46C2A}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		Templates for Class++ log messages.
	////
--]]

return {
	attemptToModifyReadOnlyTable = "Cannot modify a read only table.",
	attemptToCreateObjectFromAbstractClass = "Cannot create an object from an abstracted class.",
	attemptToExtendAFinalClass = "Cannot create an inherited class from a final class.",
	cannotCallFunctionError = "Cannot call function directly.",
	classAlreadyExists = "Class \"%s\" already exists.",
	classDataNotTable = "Given ClassData value is not a table.",
	classDataContainsMetatable = "Given ClassData value contains a metatable.",
	classMemberCannotSetToNil = "Class members cannot be set to nil.",
	classMemberNotFound = "This class has no member named \"%s\".",
	classNameNotString = "Class name is not a string or is nil.",
	classNameNotSet = "A class name is not set for the created class.",
	classNotFound = "A class with the given name cannot be found.",
	classNoMatchingFunctionError = "No match for %s function in this class.",
	classObjectLocked = "This class object has been locked.",
	classPropertyIsPrivate = "Property \"%s\" is private in this class.",
	classPropertyIsProtected = "Property \"%s\" is protected in this class.",
	classPropertyIsInternal = "Property \"%s\" is internal in this class. You cannot access it.",
	classPropertyRedeclaration = "Cannot redeclare property \"%s\".",
	compatibilityWarning = "Compatibility Warning!\nIn the upcoming (2.0) update, Class++ will no longer support these methods:\nclass.extends\nFor more information, please go to this link:\nhttps://github.com/TenebrisNoctua/ClassPP/discussions/4\n(To silence this error, set the silenceUpdateWarning attribute in the main module instance to true.",
	expectedFunctionError = "Expected function, got: %s.",
	invalidAccessSpecifierError = "Given value is not a valid access specifier.",
	invalidAccessSpecifierInClassDataError = "Invalid access specifier or function found in classData table. Make sure the names are correct.",
	invalidDestructorDecleration = "Cannot create reserved function \"Destroy\".",
	invalidModifierArgument = "Given argument is not a class table.",
	illegalModifierCombination = "Cannot create an illegal combination of modifiers: %s",
	nonNativeOperatorCall = "Operator function %s cannot be called without its operator.",
	overloadfunctionArgumentMismatch = "A function to handle the given number of arguments (%d) have not been provided for the overloaded function: \"%s\"",
	overloadfunctionNameNotSet = "A function name has not been set for the overloaded function.",
	overloadfunctionTableNotGiven = "A function table has not been given for the overloaded function.",
	staticMemberNameNotSet = "A name has not been set for the static member.",
	typeofMetatableError = "A metatable for the given object cannot be found.",
	typeofObjectIsNotClass = "The given object is not a class type.",
	typeofObjectNotFound = "The given object's type cannot be found.",
	unknownError = "An unknown error has occured.",
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE0C64B18147B40EC8BCC27BFCE8FE0E5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Type</string>
								<string name="ScriptGuid">{A339C1D9-7A07-4E1B-AFB4-FC2A50EA6066}</string>
								<ProtectedString name="Source"><![CDATA[--!native
--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		Custom type system for Class++ classes and objects.
	////
--]]

--////// Variables

local Type = {}
local LogError = require(script.Parent.Error).logError

--////// Types

export type classData = {
	constructor: (self: any, ...any) -> ()?,
	destructor: (self: any) -> ()?,
	Public: {[any]: any}?,
	Private: {[any]: any}?,
	Protected: {[any]: any}?,
	Friend: {any}?
}

export type class<AccessSpecifier = any?> = typeof(setmetatable({} :: {
	new: (...any) -> AccessSpecifier,
	extends: (className: string) -> (classData: classData) -> class<AccessSpecifier>,
	overload: (accessSpecifier: string, name: string, functionTable: {(...any) -> (any)}) -> (),
	static: (accessSpecifier: string, name: string, property: any) -> (),
	Name: string
}, {
	__index = function(t, i) return end :: ({any}, any) -> (any),
	__newindex = function(t, i, v) end :: ({any}, any, any) -> (),
	__type = "",
	__classtype = "",
	__abstract = false,
	__final = false
}))

--////// Module Functions

function Type.typeof(object: any): string?
	local objType = typeof(object)
	if objType ~= "table" and objType ~= "userdata" then return objType end
	
	local metatable = getmetatable(object)
	if not metatable then LogError("typeofMetatableError") end
	if metatable["__type"] then return metatable["__type"] end
	
	if objType == "userdata" then 
		local _, rType = select(1, pcall(function() return object.__type end))
		if rType then return rType end
	end 
	
	return LogError("typeofObjectNotFound")
end

function Type.typeofClass(classObj: class): string?
	if Type.typeof(classObj) ~= "Class" then LogError("typeofObjectIsNotClass") end
	
	local metatable = getmetatable(classObj)
	if metatable["__classtype"] then return metatable["__classtype"] end
	
	return LogError("typeofObjectNotFound")
end

return Type
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXA901DB066F9E4BCC97F6A182115845BD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ColorMath</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX5CF32AAECC524BFF82C1ABB13B1B9095">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{E8BE7421-C0A5-462C-9A2D-0F995CD7DB7C}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "ColorMath",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 93416946935477,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @Crazyblox"},
		{Text = "Description: An easy-to-use math extension of the Color3 library. Color3 userdata doesnt support math, and stores its values as 0-1 sRGB floats. The sRGB color space splits dark and bright values between a linear scale [straight] and a gamma curve. sRGB originated in 1996, allocating human-noticeable color differences to an 8-bit integer. Due to this, sRGB needs converting to Linear RGB [AKA lRGB] so that we can do math."},
		{Text = "Version: (latest)"},

		{Separator = "API"},
		{Text = "API is minimal, accepting and returning 0-1 sRGB Color3. Color3s are converted from sRGB, calculated as lRGB, and converted back to sRGB. This can be costly in heavy loops, but this is designed for ease-of-use, not speed. Long-term compatibility is ensured by preventing below APIs being overwritten by Roblox. Colorspace conversions are included for more granular operation [eg. Color3:Lerp()]"},
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB4F2E9A17B7F4468B2F68E836BCD7244">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ColorMath</string>
							<string name="ScriptGuid">{26eb6bc4-fcde-4366-8145-7609f8cc5f62}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--!optimize 2
--!native
--|bruh

--[[ ColorMath : Crazyblox 2025

	ABOUT:
An easy-to-use math extension of RBX Color3.
Color3 doesn't support math, and stores its values as 0-1 sRGB floats.
The sRGB color space splits dark and bright values between a linear scale [straight] and a gamma curve.
sRGB originated in 1996, allocating human-noticeable color differences to an 8-bit integer.
Due to this, sRGB needs converting to Linear RGB [AKA lRGB] so that we can do math.

	SETUP:
As this module is Color3-only, replacing the Color3 global is optimal for readability.
The below line gives you auto-complete where you would need it most for these functions.
local Color3 = require(path.to.module)

	API:
API is minimal, accepting and returning standard Color3 userdata.
Color3's are converted from sRGB, calculated as lRGB, and converted back to sRGB.
This can be costly in heavy loops, but this is designed for ease-of-use, not speed.
Long-term compatibility is ensured by preventing below API's being overrided by Roblox.
Colorspace conversions are included for more granular operation [eg. Color3:Lerp()]

Math [sRGB input only]:
ColorMath.add( Color3, ...Color3 ): Color3
ColorMath.sub( Color3, ...Color3 ): Color3
ColorMath.mul( Color3, ...Color3 ): Color3
ColorMath.div( Color3, ...Color3 ): Color3
ColorMath.idiv( Color3, ...Color3 ): Color3

Color Space:
ColorMath.sRGB_To_lRGB( ...Color3 ): ...Color3
ColorMath.lRGB_To_sRGB( ...Color3 ): ...Color3
]]

local ColorMath = {
	--Adds given Color3's in order
	add = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do 
			C += vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	--Subtracts given Color3's in order
	sub = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do
			C -= vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	--Multiplies given Color3's in order
	mul = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do
			C *= vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	--Divides given Color3's in order
	div = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do
			C /= vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	--Floor-divides given Color3's in order
	idiv = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do
			C //= vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	sRGB_To_lRGB = function( ...: Color3 ): ...Color3
		local C: {Color3} = {}
		for _, Color: Color3 in {...} do
			table.insert( C, Color3.new(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			) )
		end
		return table.unpack( C )
	end,
	
	lRGB_To_sRGB = function( ...: Color3 ): ...Color3
		local C: {Color3} = {}
		for _, Color: Color3 in {...} do
			table.insert( C, Color3.new(
				Color.R <= 0.0031308 and Color.R * 12.92 or 1.055 * ( Color.R ^ 0.4166666666666667 ) - 0.055,
				Color.G <= 0.0031308 and Color.G * 12.92 or 1.055 * ( Color.G ^ 0.4166666666666667 ) - 0.055,
				Color.B <= 0.0031308 and Color.B * 12.92 or 1.055 * ( Color.B ^ 0.4166666666666667 ) - 0.055
				) )
		end
		return table.unpack( C )
	end
}
for name, method in Color3 do
	if not ColorMath[ name ] then
		ColorMath[ name ] = method
	end
end
return table.freeze( ColorMath )]]></ProtectedString>
							<int64 name="SourceAssetId">93416946935477</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX103704915D6B4635A0C07B610A4076B8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ByteNet</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXE6A9D2834E6F4AF4B8C2D8DE3790A543">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Config</string>
							<string name="ScriptGuid">{EF3BEA93-4C0E-48CA-AC88-FAED5655D703}</string>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "ByteNet",
	Thumbnail = "rbxassetid://76276498409431",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @ffrostfall"},
		{Text = "Description: ByteNet is an networking library which takes your Luau data, and serializes it into buffers. On the other end, ByteNet deserializes your data, and then feeds it back to your Luau code. You dont need to worry about type validation, optimization, packet structure, etc. ByteNet does all the hard parts for you! Strictly typed with an incredibly basic API that explains itself, ByteNet makes networking simple, easy, and quick. Theres very few concepts you need to grasp in order to use ByteNet; it has an incredibly minimalistic & simplistic, yet powerful API."},
		{Text = "Version: v0.4.3 (pre-release)"},

		{Separator = "Performance"},
		{Text = "ByteNet performs incredibly well compared to non-buffer based libraries like BridgeNet2. This is because ByteNet has a custom serializer that takes your Luau data and transforms it into a buffer, sending that and deserializing it on the other side."},
	}
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX312B6E2FDC6F47BF8D2558A96E6881CE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ByteNet</string>
							<string name="ScriptGuid">{01335CCD-029D-4B57-983B-D9906516B976}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local clientProcess = require(script.process.client)
local array = require(script.dataTypes.array)
local bool = require(script.dataTypes.bool)
local buff = require(script.dataTypes.buff)
local cframe = require(script.dataTypes.cframe)
local float32 = require(script.dataTypes.float32)
local float64 = require(script.dataTypes.float64)
local inst = require(script.dataTypes.inst)
local int16 = require(script.dataTypes.int16)
local int32 = require(script.dataTypes.int32)
local int8 = require(script.dataTypes.int8)
local map = require(script.dataTypes.map)
local nothing = require(script.dataTypes.nothing)
local optional = require(script.dataTypes.optional)
local string = require(script.dataTypes.string)
local struct = require(script.dataTypes.struct)
local uint16 = require(script.dataTypes.uint16)
local uint32 = require(script.dataTypes.uint32)
local uint8 = require(script.dataTypes.uint8)
local unknown = require(script.dataTypes.unknown)
local vec2 = require(script.dataTypes.vec2)
local vec3 = require(script.dataTypes.vec3)
local namespace = require(script.namespaces.namespace)
local definePacket = require(script.packets.definePacket)
local serverProcess = require(script.process.server)
local values = require(script.replicated.values)
local types = require(script.types)

values.start()

if RunService:IsServer() then
	serverProcess.start()
else
	clientProcess.start()
end

return (
	table.freeze({
		definePacket = definePacket,
		defineNamespace = namespace,

		array = array,
		bool = bool(),
		optional = optional,
		uint8 = uint8(),
		uint16 = uint16(),
		uint32 = uint32(),
		int8 = int8(),
		int16 = int16(),
		int32 = int32(),
		float32 = float32(),
		float64 = float64(),
		cframe = cframe(),
		string = string(),
		vec2 = vec2(),
		vec3 = vec3(),
		buff = buff(),
		struct = struct,
		map = map,
		inst = inst(),
		unknown = unknown(),
		nothing = nothing(),
	}) :: any
) :: types.ByteNet
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX51B2EF66104B46C8A8087307B4480269">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">types</string>
								<string name="ScriptGuid">{CCBECB27-70DC-472F-B41D-5AA3492B42FF}</string>
								<ProtectedString name="Source"><![CDATA[export type namespaceData = {
	packets: {
		[string]: any,
	},
	structs: {
		[number]: {
			[string]: any,
		},
	},
}

-- Externally used for defining packets
export type packetProps<T> = {
	value: T,
	reliabilityType: ("reliable" | "unreliable")?,
	callbackBehavior: {
		spawnThread: boolean,
		allowMultiple: boolean,
	}?,
}

-- Used internally for
export type channelData = {
	cursor: number,
	size: number,
	references: { unknown },
	buff: buffer,
}

-- Used internally for serializing and deserializing all data types
export type dataTypeInterface<T> = {
	write: (value: T) -> (),
	read: (b: buffer, cursor: number, references: { [number]: unknown }?) -> (T, number),
}

-- Somewhat public facing: used as return result in definePacket
type Packet<T> = {
	sendToAll: (data: T) -> (),
	sendTo: (data: T, target: Player) -> (),
	sendToList: (data: T, targets: { Player }) -> (),

	wait: () -> T,
	send: (data: T, target: Player?) -> (),
	listen: (callback: (data: T, player: Player?) -> ()) -> (),
}

-- Library type
export type ByteNet = {
	definePacket: <T>(props: packetProps<T>) -> Packet<T>,
	defineNamespace: <T>(name: string, namespace: () -> T) -> T,

	struct: <T>(format: T) -> T,
	bool: boolean,
	array: <T>(value: T) -> { [number]: T },
	optional: <T>(value: T) -> T?,
	inst: Instance,
	nothing: nil,
	unknown: unknown,
	uint8: number,
	uint16: number,
	uint32: number,
	int8: number,
	int16: number,
	int32: number,
	float32: number,
	float64: number,
	string: string,
	vec3: Vector3,
	vec2: Vector2,
	buff: buffer,
	cframe: CFrame,
	map: <K, V>(key: K, value: V) -> { [K]: V },
}

return nil
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX434FE02F990649A2877AA27C851ACEA9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">dataTypes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXD6DD67235C4C47ADB3B1BD94A1404717">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">array</string>
									<string name="ScriptGuid">{06860B59-2774-4CE8-A403-44E712AFD754}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16

--[[
	Create a new array with the given dataTypeInterface
]]
return function(valueType: types.dataTypeInterface<any>)
	local valueWrite = valueType.write
	local valueRead = valueType.read

	return {
		read = function(b: buffer, cursor: number)
			local arrayLength = buffer.readu16(b, cursor)
			local arrayCursor = cursor + 2
			local array = {}

			for _ = 1, arrayLength do
				local item, length = valueRead(b, arrayCursor)
				table.insert(array, item)

				arrayCursor += length
			end

			return array, arrayCursor - cursor
		end,
		write = function(value: any)
			local length = #value
			u16(length)

			-- numeric iteration is about 2x faster than generic iteration
			for i = 1, length do
				valueWrite(value[i])
			end
		end,
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3CC4201FEC144196BE45F7F1A67DFECD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">bool</string>
									<string name="ScriptGuid">{BCD344C1-D7E3-42E1-A024-AFBABC40E3BE}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local boolean = {
	--[[
		1 = true
		0 = false
		
		Write and read based off a uint8
	]]
	read = function(b: buffer, cursor: number)
		return buffer.readu8(b, cursor) == 1, 1
	end,

	write = bufferWriter.bool,
}

return function(): types.dataTypeInterface<boolean>
	return boolean
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC0DEB3F1C2C2418A82450CDA2A7FDFF7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">buff</string>
									<string name="ScriptGuid">{6FBDFD20-E265-4A0D-834E-888C71609CFD}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16
local copy = bufferWriter.copy
local dyn_alloc = bufferWriter.dyn_alloc

local buff = {
	read = function(b: buffer, cursor: number)
		local length = buffer.readu16(b, cursor)
		local freshBuffer = buffer.create(length)

		-- copy the data from the main buffer to the new buffer with an offset of 2 because of length
		buffer.copy(freshBuffer, 0, b, cursor + 2, length)

		return freshBuffer, length + 2
	end,
	write = function(data: buffer)
		local length = buffer.len(data)
		u16(length)

		dyn_alloc(length)

		-- write the length of the buffer, then the buffer itself
		copy(data)
	end,
}

return function(): types.dataTypeInterface<buffer>
	return buff
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB637B52F291D4B92B3C52BAC14547BBB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">cframe</string>
									<string name="ScriptGuid">{5326F4A8-399E-4732-89A0-3F281180C058}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f32NoAlloc = bufferWriter.f32NoAlloc
local alloc = bufferWriter.alloc

-- thanks jack :p
local cframe = {
	read = function(b: buffer, cursor: number)
		local x = buffer.readf32(b, cursor)
		local y = buffer.readf32(b, cursor + 4)
		local z = buffer.readf32(b, cursor + 8)
		local rx = buffer.readf32(b, cursor + 12)
		local ry = buffer.readf32(b, cursor + 16)
		local rz = buffer.readf32(b, cursor + 20)

		-- Re-construct the CFrame from the axis-angle representation
		local axis = Vector3.new(rx, ry, rz)
		local angle = axis.Magnitude

		return CFrame.fromAxisAngle(axis, angle) + Vector3.new(x, y, z), 24
	end,
	write = function(value: CFrame)
		-- Convert the CFrame to an axis-angle representation
		local x, y, z = value.X, value.Y, value.Z

		local axis, angle = value:ToAxisAngle()
		local rx, ry, rz = axis.X, axis.Y, axis.Z
		axis = axis * angle

		-- Math done, write it now
		alloc(24)
		f32NoAlloc(x)
		f32NoAlloc(y)
		f32NoAlloc(z)
		f32NoAlloc(rx)
		f32NoAlloc(ry)
		f32NoAlloc(rz)
	end,
}

return function(): types.dataTypeInterface<CFrame>
	return cframe
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA778BE9A1CB24FDE81967A00AB9A5E42">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">float32</string>
									<string name="ScriptGuid">{054B17FF-6958-4824-B695-690D009E9835}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f32 = bufferWriter.f32

local float32 = {
	write = f32,

	read = function(b: buffer, cursor: number)
		return buffer.readf32(b, cursor), 4
	end,
}

return function(): types.dataTypeInterface<number>
	return float32
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5CF60DA5630B475ABFE4FE72DF90C5DD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">float64</string>
									<string name="ScriptGuid">{2BA01641-0E2F-4891-99CF-1611DBEA7017}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f64 = bufferWriter.f64

local float64 = {
	write = f64,

	read = function(b: buffer, cursor: number)
		return buffer.readf64(b, cursor), 8
	end,
}

return function(): types.dataTypeInterface<number>
	return float64
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX71F42D3F017B4059B975BA45932CFA99">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">inst</string>
									<string name="ScriptGuid">{205C7EC2-C8C3-464D-A86D-0B0488C64005}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local readRefs = require(script.Parent.Parent.process.readRefs)
local types = require(script.Parent.Parent.types)

local reference = bufferWriter.reference
local alloc = bufferWriter.alloc

return function(): types.dataTypeInterface<Instance?>
	return {
		write = function(value)
			alloc(1)
			reference(value)
		end,

		read = function(b: buffer, cursor: number)
			local refs = readRefs.get()

			if not refs then
				return nil, 1
			end

			local ref = refs[buffer.readu8(b, cursor)]

			if typeof(ref) == "Instance" then
				return ref, 1
			else
				return nil, 1
			end
		end,
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX12B8C59E7A984596AAF50DE2287BEC4D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">int16</string>
									<string name="ScriptGuid">{5813BEBC-AA41-4A87-9D6A-45713178C96E}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local i16 = bufferWriter.i16

local int16 = {
	write = i16,

	read = function(b: buffer, cursor: number)
		return buffer.readi16(b, cursor), 2
	end,
}

return function(): types.dataTypeInterface<number>
	return int16
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXCA436D20C1644BDEA344452E4ECD29AA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">int32</string>
									<string name="ScriptGuid">{FB7A1884-D370-4D47-9313-8639F41C82DB}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local i32 = bufferWriter.i32

local int32 = {
	write = i32,

	read = function(b: buffer, cursor: number)
		return buffer.readi32(b, cursor), 4
	end,
}

return function(): types.dataTypeInterface<number>
	return int32
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1AFD1C91A8014C35A35C273227372E7C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">int8</string>
									<string name="ScriptGuid">{C634BA0F-4C56-4468-90C0-03703DACB7F8}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local i8 = bufferWriter.i8

local int8 = {
	write = i8,

	read = function(b: buffer, cursor: number)
		return buffer.readi8(b, cursor), 1
	end,
}

return function(): types.dataTypeInterface<number>
	return int8
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9D089FE099CB429A916F17D839642BDE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">map</string>
									<string name="ScriptGuid">{C87383CD-1936-43DB-B356-7D92573826CA}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16

-- thanks jack :p
return function(
	keyType: types.dataTypeInterface<any>,
	valueType: types.dataTypeInterface<any>
): types.dataTypeInterface<{ [any]: any }>
	-- Cache these functions to avoid the overhead of the index
	local keyWrite = keyType.write
	local valueWrite = valueType.write

	return {
		read = function(b: buffer, cursor: number)
			local map = {}
			local mapCursor = cursor

			-- Read map length
			local mapLength = buffer.readu16(b, mapCursor)
			mapCursor += 2

			for _ = 1, mapLength do
				-- read key/value pairs and add them to the map
				local key, keyLength = keyType.read(b, mapCursor)
				mapCursor += keyLength

				local value, valueLength = valueType.read(b, mapCursor)
				mapCursor += valueLength

				map[key] = value
			end

			-- Return the map, alongside length, because mapCursor - cursor = size
			return map, mapCursor - cursor
		end,
		write = function(map: any)
			local count = 0
			for _ in map do
				count += 1
			end

			-- Write length
			u16(count)

			for k, v in map do
				-- Write key/value pairs
				keyWrite(k)
				valueWrite(v)
			end
		end,
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5FACC33048B44CEDACBC265BCDD97D0D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">nothing</string>
									<string name="ScriptGuid">{3F61FD56-8656-40ED-81FE-E772B3BAFFDD}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)

local nothing = {
	write = function() end,

	read = function()
		return nil, 0
	end,
}

return function(): types.dataTypeInterface<nil>
	return nothing
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX61B5DE683317453992C536BDFC9B2927">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">optional</string>
									<string name="ScriptGuid">{BED9B6B8-F8F5-4EA0-8504-5378705F61E2}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local bool = bufferWriter.bool

return function(valueType: types.dataTypeInterface<any>)
	local valueRead = valueType.read
	local valueWrite = valueType.write

	return {
		--[[
			first byte is a boolean, if it's true, the next bytes are the value of valueType
			if it's false, its length of 1 cuz only 1 boolean
		]]

		read = function(b: buffer, cursor: number)
			if buffer.readu8(b, cursor) == 0 then
				-- doesn't exist
				return nil, 1
			else
				-- exists, read the value
				local item, length = valueRead(b, cursor + 1)
				return item, length + 1
			end
		end,

		write = function(value: any)
			local exists = value ~= nil

			bool(exists)

			if exists then
				valueWrite(value)
			end
		end,
	}
end :: <T>(valueType: types.dataTypeInterface<T>) -> types.dataTypeInterface<T?>
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX699A967CCC98407F816FD9EC9FC7EEC9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">string</string>
									<string name="ScriptGuid">{4933F234-893F-4FF9-9D21-69B6907C0B89}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16
local writestring = bufferWriter.writestring
local dyn_alloc = bufferWriter.dyn_alloc

local str = {
	-- 2 bytes for the length, then the string

	read = function(b: buffer, cursor: number)
		local length = buffer.readu16(b, cursor)

		return buffer.readstring(b, cursor + 2, length), length + 2
	end,
	write = function(data: string)
		local length = string.len(data)
		u16(length)

		dyn_alloc(length)
		writestring(data)
	end,
}

return function(): types.dataTypeInterface<string>
	return str
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA6C33FAD0E1A4928AE24719DED5AFD40">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">struct</string>
									<string name="ScriptGuid">{195DA38D-D472-42B1-95ED-00ADB8F801E6}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local namespacesDependencies = require(script.Parent.Parent.namespaces.namespacesDependencies)
local values = require(script.Parent.Parent.replicated.values)
local types = require(script.Parent.Parent.types)

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

type structData = {
	[string]: number,
}

return function(input: {
	[string]: types.dataTypeInterface<any>,
}): types.dataTypeInterface<any>
	-- This is used in the reading/writing parts, and isn't used in the initialization code
	-- It's used to store the index-value pairs and the index-key pairs
	-- Index being the position of the value in the array, and the key being the key in the struct dictionary
	local indexValueTypePairs: {
		[number]: types.dataTypeInterface<any>,
	} = {}
	local indexKeyPairs: { [number]: string } = {}

	--[[
		Array should look like {
			[index (1)] = value
			[index (2)] = value
		}

		Index value type is {
			[index (1)] = int32
		}

		Index key is {
			[index (1)] = "structField"
		}
	]]

	if runContext == "server" then
		local serializedStruct = {}

		-- Convert the struct to an array
		local count = 0
		for key in input do
			count += 1
			serializedStruct[key] = count

			-- Store the index-value pairs and the index-key pairs as a shortcut for serializing n all that
			indexValueTypePairs[count] = input[key]
			indexKeyPairs[count] = key
		end

		-- replicate
		namespacesDependencies.add(serializedStruct)
	elseif runContext == "client" then
		-- There's a layer of complexity added here because we have to access the namespace data
		namespacesDependencies.add(input)

		local name = namespacesDependencies.currentName()

		local namespaceReplicator = values.access(name)
		local namespaceData = namespaceReplicator:read() :: types.namespaceData

		-- struct id is just based on the order of creation in the namespace function
		local structData = namespaceData.structs[namespacesDependencies.currentLength()]

		-- Fetch the data from the server and store it in the index-value pairs and the index-key pairs
		for key, index in structData do
			indexValueTypePairs[index] = input[key]
			indexKeyPairs[index] = key
		end
	end

	return {
		read = function(b, cursor)
			local constructed = table.clone(input)
			local structCursor = cursor

			for index, valueType in indexValueTypePairs do
				local value, length = valueType.read(b, structCursor)

				constructed[indexKeyPairs[index]] = value

				structCursor += length
			end

			return constructed, structCursor - cursor
		end,

		write = function(structValue)
			for index, valueType in indexValueTypePairs do
				valueType.write(structValue[indexKeyPairs[index]])
			end
		end,
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF7589F4E55A04D4FB464B79844AFF39A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">uint16</string>
									<string name="ScriptGuid">{1981A3EA-60F5-4A72-A7E0-E27B1AEC34FB}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16

local uint16 = {
	write = u16,

	read = function(b: buffer, cursor: number)
		return buffer.readu16(b, cursor), 2
	end,
}

return function(): types.dataTypeInterface<number>
	return uint16
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDACD5B4AEC4E4510A3F78B6B8FEFAA05">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">uint32</string>
									<string name="ScriptGuid">{E44FA52F-7863-49DE-B2F3-F27D7D55E2A7}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u32 = bufferWriter.u32

local uint32 = {
	write = u32,

	read = function(b: buffer, cursor: number)
		return buffer.readu32(b, cursor), 4
	end,
}

return function(): types.dataTypeInterface<number>
	return uint32
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9DDFE2A698654BF6AF7C25D42CD5D83B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">uint8</string>
									<string name="ScriptGuid">{9130F908-8C5A-4752-A25D-DEE2169115AA}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local bufferWriter = require(script.Parent.Parent.process.bufferWriter)

local u8 = bufferWriter.u8

local uint8 = {
	write = u8,

	read = function(b: buffer, cursor: number)
		return buffer.readu8(b, cursor), 1
	end,
}

return function(): types.dataTypeInterface<number>
	return uint8
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFD637ED99453431F95A508AC2D914EA5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">unknown</string>
									<string name="ScriptGuid">{5ABB060C-D381-4FBD-AA78-7C150D9D5951}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local readRefs = require(script.Parent.Parent.process.readRefs)
local types = require(script.Parent.Parent.types)

local reference = bufferWriter.reference
local alloc = bufferWriter.alloc

return function(): types.dataTypeInterface<unknown>
	return {
		write = function(value: unknown)
			alloc(1)
			reference(value)
		end,

		read = function(b: buffer, cursor: number)
			local refs = readRefs.get()

			if not refs then
				return nil, 1
			end

			return refs[buffer.readu8(b, cursor)], 1
		end,
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1FAC633C2F2843CEBD681454DA5F682E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">vec2</string>
									<string name="ScriptGuid">{D1CB1B2A-6A7A-4F1E-9EC7-89156F5A6FBA}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f32NoAlloc = bufferWriter.f32NoAlloc
local alloc = bufferWriter.alloc

local vec2 = {
	--[[
		2 float32s, one for X, one for Y
	]]

	read = function(b: buffer, cursor: number)
		return Vector2.new(buffer.readf32(b, cursor), buffer.readf32(b, cursor + 4)), 8
	end,

	write = function(value: Vector2)
		alloc(8)
		f32NoAlloc(value.X)
		f32NoAlloc(value.Y)
	end,
}

return function(): types.dataTypeInterface<Vector2>
	return vec2
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6B3C9DA0411849BD82D8D45E6A56AF01">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">vec3</string>
									<string name="ScriptGuid">{A19E7F2A-A7D9-4CE5-9BC8-6756667710C2}</string>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f32NoAlloc = bufferWriter.f32NoAlloc
local alloc = bufferWriter.alloc

local vec3 = {
	--[[
		3 floats, 12 bytes
	]]
	read = function(b: buffer, cursor: number)
		return Vector3.new(buffer.readf32(b, cursor), buffer.readf32(b, cursor + 4), buffer.readf32(b, cursor + 8)), 12
	end,

	write = function(value: Vector3)
		alloc(12)
		f32NoAlloc(value.X)
		f32NoAlloc(value.Y)
		f32NoAlloc(value.Z)
	end,
}

return function(): types.dataTypeInterface<Vector3>
	return vec3
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXCF98D9C273A046D682AC5263525B9A06">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">namespaces</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXC417168850B2468DB923B9FD3AA242EF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">namespace</string>
									<string name="ScriptGuid">{1848E0D0-61D8-4891-BFEE-933EDDBC900D}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	The file that contains the function for handling and creating namespaces.
	Namespaces aren't really anything special, they are just an encapsulation to make it easier to manage packets and structs.
	
	Dependency management is fun!
]]

local RunService = game:GetService("RunService")

local values = require(script.Parent.Parent.replicated.values)
local types = require(script.Parent.Parent.types)
local namespacesDependencies = require(script.Parent.namespacesDependencies)
local packetIDs = require(script.Parent.packetIDs)

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

local count = 0

return function(
	name: string,
	input: () -> {
		[string]: any,
	}
)
	local namespaceReplicator = values.access(name)

	namespacesDependencies.start(name)
	local packets: {
		[string]: (id: number) -> any,
	} = input()
	local structs = namespacesDependencies.empty()

	local result = {}

	if runContext == "server" then
		local constructedNamespace = {
			structs = {},
			packets = {},
		}

		for key in packets do
			count += 1
			constructedNamespace.packets[key] = count
			result[key] = packets[key](count)

			packetIDs.set(count, result[key])
		end

		for index, value in structs do
			constructedNamespace.structs[index] = value
		end

		namespaceReplicator:write(constructedNamespace)
	elseif runContext == "client" then
		-- yes, this means that packets technically don't need to be defined on the client
		-- we do it anyway for typechecking and perf shortcuts
		local namespaceData = namespaceReplicator:read() :: types.namespaceData

		for key, packet in packets do
			result[key] = packet(namespaceData.packets[key])

			packetIDs.set(namespaceData.packets[key], result[key])
		end
	end

	return result
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX58A582DF575646CC9D90E8F806D8CB7E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">namespacesDependencies</string>
									<string name="ScriptGuid">{95546D2B-5D7E-48A3-AE7D-6D5399413E09}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Basic dependency graph for structs created within a namespace
]]

local current: { [number]: any }?
local currentName: string

local namespacesDependencies = {}

function namespacesDependencies.start(name: string)
	current = {} :: { [number]: any }
	currentName = name
end

function namespacesDependencies.add(data)
	if not current then
		return
	end

	table.insert(current, data)
end

function namespacesDependencies.currentLength()
	return if current then #current else 0
end

function namespacesDependencies.currentName()
	return currentName
end

function namespacesDependencies.empty(): { [number]: any }
	if current == nil then
		return {}
	end

	local result = current
	current = nil

	return result
end

return namespacesDependencies
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC911C36ADE82498E80591CA7369A8AEE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">packetIDs</string>
									<string name="ScriptGuid">{AA701365-64C7-4704-97C5-5DD9A98CD121}</string>
									<ProtectedString name="Source"><![CDATA[--!native

--[[
	Exists solely to get a packet instance from an ID in the reader file.
	Might be able to be done in a better way?
]]
local dict = {}

local packetIDs = {}

function packetIDs.set(id: number, packet: any)
	dict[id] = packet
end

-- Use this instead of a get function for performance.
function packetIDs.ref()
	return dict
end

return packetIDs
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX688D8245B4794B96AD0C32933B24DEE3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">packets</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX9A11ADCB340A4450996D93E161152F69">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">definePacket</string>
									<string name="ScriptGuid">{0A40DD04-F25B-406B-B209-80FA2CE2655F}</string>
									<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2

--[[
	Exists so that the namespace can set the ID of the packet

	Packet shouldnt need to care about making its own ID
]]
local types = require(script.Parent.Parent.types)
local packet = require(script.Parent.packet)

return function(props: types.packetProps<any>)
	return function(id: number)
		return packet(props, id)
	end
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE89AEDA7D7674A928E6AB45A253DE356">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">packet</string>
									<string name="ScriptGuid">{31F18280-ADF0-443D-B884-F19E43907C81}</string>
									<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local types = require(script.Parent.Parent.types)
local client = require(script.Parent.Parent.process.client)
local server = require(script.Parent.Parent.process.server)

local moduleRunContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

--[[
	We use closures here instead of metatables for performance
	It's just faster to use closures than metatables
]]
return function(props: types.packetProps<types.dataTypeInterface<any>>, id: number)
	-- Basic properties: reliability type, "unique" which is used to get the packet ID, and set up listeners
	local reliabilityType = props.reliabilityType or "reliable"
	local listeners = {}

	local serverSendFunction: (player: Player, id: number, writer: (value: any) -> (), data: any) -> () = if reliabilityType
			== "reliable"
		then server.sendPlayerReliable
		else server.sendPlayerUnreliable

	local serverSendAllFunction: (id: number, writer: (value: any) -> (), data: any) -> () = if reliabilityType
			== "reliable"
		then server.sendAllReliable
		else server.sendAllUnreliable

	local clientSendFunction: (id: number, writer: (value: any) -> (), data: any) -> () = if reliabilityType
			== "reliable"
		then client.sendReliable
		else client.sendUnreliable

	-- shorcut to avoid indexxing
	local writer = props.value.write

	local exported = {}

	-- RunContext error checking that doesn't have performance drawbacks
	setmetatable(exported, {
		__index = function(index)
			if
				(index == "sendTo" or index == "sendToAllExcept" or index == "sendToAll")
				and moduleRunContext == "client"
			then
				error("You cannot use sendTo, sendToAllExcept, or sendToAll on the client")
			elseif index == "send" and moduleRunContext == "server" then
				error("You cannot use send on the server")
			end
		end,
	})

	-- exposed for the reader file
	exported.reader = props.value.read

	if moduleRunContext == "server" then
		function exported.sendToList(data, players: { Player })
			for _, player in players do
				serverSendFunction(player, id, writer, data)
			end
		end

		function exported.sendTo(data, player: Player)
			serverSendFunction(player, id, writer, data)
		end

		function exported.sendToAllExcept(data, except: Player)
			for _, player: Player in Players:GetPlayers() do
				if player ~= except then
					serverSendFunction(player, id, writer, data)
				end
			end
		end

		function exported.sendToAll(data)
			serverSendAllFunction(id, writer, data)
		end
	elseif moduleRunContext == "client" then
		function exported.send(data)
			clientSendFunction(id, writer, data)
		end
	end

	function exported.wait()
		-- define it up here so we can use it to disconnect
		local index: number

		local runningThread = coroutine.running()
		table.insert(listeners, function(data, player)
			task.spawn(runningThread, data, player)

			-- Disconnects the listener
			table.remove(listeners, index)
		end)

		-- we connected, time to set the index for when we need to disconnect.
		index = #listeners

		-- the listener will resume the thread
		return coroutine.yield()
	end

	function exported.listen(callback)
		table.insert(listeners, callback)
	end

	function exported.getListeners()
		return listeners
	end

	return exported
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX6ADB5C067716474E8E0F2C6EBE1AECFD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">process</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX4D9435D0879040AC8E4A1BDEBDDE0D35">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">bufferWriter</string>
									<string name="ScriptGuid">{6B32B726-AF36-4ED1-AD0F-DCD003B2A976}</string>
									<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2

--[[
	Collects all write operations into a queue.
	When the buffer is written, it will be written in the order of the queue.
	
	All operations take in 2 parameters: the cursor and the value.
	Knowing this we can easily attach everything in a nice table, where
	{
		[1] = writer,
		[2] = cursor,
		[3] = value
	}
	
	A lot of these functions just exist as shorthand optimizations.
]]
local types = require(script.Parent.Parent.types)

local current: types.channelData

local size: number
local cursor: number
local buff: buffer
local references: { [number]: unknown }

local function alloc(bytes: number)
	if not (cursor + bytes >= size) then
		return
	end

	size = math.floor(size * 1.5)

	local newBuffer = buffer.create(size)
	buffer.copy(newBuffer, 0, buff)

	buff = newBuffer
end

local function dyn_alloc(bytes: number)
	while cursor + bytes >= size do
		size = math.floor(size * 1.5)
	end

	local newBuffer = buffer.create(size)
	buffer.copy(newBuffer, 0, buff)

	buff = newBuffer
end

local bufferWriter = {}

bufferWriter.alloc = alloc
bufferWriter.dyn_alloc = dyn_alloc

function bufferWriter.u8(value: number)
	alloc(1)
	buffer.writeu8(buff, cursor, value)
	cursor += 1
end

function bufferWriter.i8(value: number)
	alloc(1)
	buffer.writei8(buff, cursor, value)
	cursor += 1
end

-- this exists solely for the unknown and instance data type. Will likely be obselete soon enough
function bufferWriter.reference(value: any)
	table.insert(references, value)
	local index = #references

	buffer.writeu8(buff, cursor, index)
	cursor += 1
	print(references)
end

function bufferWriter.u16(value: number)
	alloc(2)
	buffer.writeu16(buff, cursor, value)
	cursor += 2
end

function bufferWriter.i16(value: number)
	alloc(2)
	buffer.writeu16(buff, cursor, value)
	cursor += 2
end

function bufferWriter.u32(value: number)
	alloc(4)
	buffer.writeu32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.writestring(value: string)
	buffer.writestring(buff, cursor, value)
	cursor += string.len(value)
end

function bufferWriter.i32(value: number)
	alloc(4)
	buffer.writei32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.f32NoAlloc(value: number)
	buffer.writef32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.f64NoAlloc(value: number)
	buffer.writef64(buff, cursor, value)
	cursor += 4
end

function bufferWriter.f32(value: number)
	alloc(4)
	buffer.writef32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.f64(value: number)
	alloc(8)
	buffer.writef64(buff, cursor, value)
	cursor += 8
end

function bufferWriter.copy(value)
	buffer.copy(buff, cursor, value)
	cursor += buffer.len(value)
end

function bufferWriter.bool(val: boolean)
	alloc(1)
	buffer.writeu8(buff, cursor, if val then 1 else 0)
	cursor += 1
end

function bufferWriter.load(channel: types.channelData)
	current = channel
	size = channel.size
	cursor = channel.cursor
	references = channel.references
	buff = channel.buff
end

function bufferWriter.export()
	current.size = size
	current.cursor = cursor
	current.references = references
	current.buff = buff

	return current
end

return bufferWriter
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFA9F7D34F6FC4C8897DA8CF6FC36A838">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">client</string>
									<string name="ScriptGuid">{85236C1B-5066-4AFA-B05A-03DB4B1F5D6B}</string>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local types = require(script.Parent.Parent.types)
local read = require(script.Parent.read)
local bufferWriter = require(script.Parent.bufferWriter)

local alloc = bufferWriter.alloc
local u8 = bufferWriter.u8
local load = bufferWriter.load

local function onClientEvent(receivedBuffer, ref)
	read(receivedBuffer, ref)
end

-- Shared with: src/process/server.luau (Infeasible to split this into another file)
local function create()
	return {
		cursor = 0,
		size = 256,
		references = {},
		buff = buffer.create(256),
	}
end

local function dump(channel: types.channelData): (buffer, { unknown }?)
	local cursor = channel.cursor
	local dumpBuffer = buffer.create(cursor)

	buffer.copy(dumpBuffer, 0, channel.buff, 0, cursor)

	return dumpBuffer, if #channel.references > 0 then channel.references else nil
end
-- No longer shared

local reliable: types.channelData = create()
local unreliable: types.channelData = create()

local clientProcess = {}

function clientProcess.sendReliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	reliable = load(reliable)

	alloc(1)
	u8(id)
	writer(data)

	reliable = bufferWriter.export()
end

function clientProcess.sendUnreliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	unreliable = load(unreliable)

	alloc(1)
	u8(id)
	writer(data)

	unreliable = bufferWriter.export()
end

function clientProcess.start()
	local reliableRemote = ReplicatedStorage:WaitForChild("ByteNetReliable")
	reliableRemote.OnClientEvent:Connect(onClientEvent)

	local unreliableRemote = ReplicatedStorage:WaitForChild("ByteNetUnreliable")
	unreliableRemote.OnClientEvent:Connect(onClientEvent)

	RunService.Heartbeat:Connect(function()
		-- Again, checking if there's anything in the channel before we send it.
		if reliable.cursor > 0 then
			local b, r = dump(reliable)
			reliableRemote:FireServer(b, r)

			-- effectively clears the channel
			reliable.cursor = 0
			table.clear(reliable.references)
		end

		if unreliable.cursor > 0 then
			local b, r = dump(unreliable)
			unreliableRemote:FireServer(b, r)

			unreliable.cursor = 0
			table.clear(unreliable.references)
		end
	end)
end

return clientProcess
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE50EA228E38642C2A760FFD0707EF71E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">read</string>
									<string name="ScriptGuid">{BC3129BA-DB01-441D-9116-8AD2B431D65E}</string>
									<ProtectedString name="Source"><![CDATA[--!native
local packetIDs = require(script.Parent.Parent.namespaces.packetIDs)
local readRefs = require(script.Parent.readRefs)

local ref = packetIDs.ref()
local freeThread: thread?

local function functionPasser(fn, ...)
	local aquiredThread = freeThread
	freeThread = nil
	fn(...)
	freeThread = aquiredThread
end

local function yielder()
	while true do
		functionPasser(coroutine.yield())
	end
end

local function runListener(fn, ...)
	if freeThread == nil then
		freeThread = coroutine.create(yielder)
		coroutine.resume(freeThread :: thread)
	end

	task.spawn(freeThread :: thread, fn, ...)
end

return function(incomingBuffer: buffer, references: { [number]: unknown }?, player: Player?)
	local length = buffer.len(incomingBuffer)
	local readCursor = 0

	readRefs.set(references)

	while readCursor < length do
		local packet = ref[buffer.readu8(incomingBuffer, readCursor)]
		readCursor += 1

		local value, valueLength = packet.reader(incomingBuffer, readCursor)

		readCursor += valueLength

		for _, listener in packet.getListeners() do
			runListener(listener, value, player)
		end
	end
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4097EE799E1C451BB5B08D89C3878840">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">readRefs</string>
									<string name="ScriptGuid">{90DD0D59-688F-4B72-8067-CB7BFB7B6295}</string>
									<ProtectedString name="Source"><![CDATA[--!native
local current

local readRefs = {}

function readRefs.set(refTable)
	current = refTable
end

function readRefs.get()
	return current
end

return readRefs
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX00A54C4BFC924254B90C2D36CFA2BAC3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">server</string>
									<string name="ScriptGuid">{C9DEF7EE-7090-48CF-AA38-F9040E57FA6E}</string>
									<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local types = require(script.Parent.Parent.types)
local read = require(script.Parent.read)
local bufferWriter = require(script.Parent.bufferWriter)

local alloc = bufferWriter.alloc
local u8 = bufferWriter.u8
local load = bufferWriter.load

-- All channelData is set to nil upon being sent which is why these are all optionals
local perPlayerReliable: { [Player]: types.channelData } = {}
local perPlayerUnreliable: { [Player]: types.channelData } = {}

-- Shared with: src/process/client.luau (Infeasible to split this into another file)
local function create()
	return {
		cursor = 0,
		size = 256,
		references = {},
		buff = buffer.create(256),
	}
end

local function dump(channel: types.channelData): (buffer, { unknown }?)
	local cursor = channel.cursor
	local dumpBuffer = buffer.create(cursor)

	buffer.copy(dumpBuffer, 0, channel.buff, 0, cursor)

	return dumpBuffer, if #channel.references > 0 then channel.references else nil
end
-- No longer shared

local globalReliable: types.channelData = create()
local globalUnreliable: types.channelData = create()

-- TODO handle invalid data better
local function onServerEvent(player: Player, data, references)
	-- Only accept buffer data
	if not (typeof(data) == "buffer") then
		return
	end

	read(data, references, player)
end

local function playerAdded(player)
	if not perPlayerReliable[player] then
		perPlayerReliable[player] = create()
	end

	if not perPlayerUnreliable[player] then
		perPlayerUnreliable[player] = create()
	end
end

local serverProcess = {}

function serverProcess.sendAllReliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	load(globalReliable)

	alloc(1)
	u8(id)
	writer(data)

	globalReliable = bufferWriter.export()
end

function serverProcess.sendAllUnreliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	load(globalUnreliable or create())

	alloc(1)
	u8(id)
	writer(data)

	globalUnreliable = bufferWriter.export()
end

function serverProcess.sendPlayerReliable(
	player: Player,
	id: number,
	writer: (value: any) -> (),
	data: { [string]: any }
)
	load(perPlayerReliable[player] or create())

	alloc(1)
	u8(id)
	writer(data)

	perPlayerReliable[player] = bufferWriter.export()
end

function serverProcess.sendPlayerUnreliable(
	player: Player,
	id: number,
	writer: (value: any) -> (),
	data: { [string]: any }
)
	load(perPlayerUnreliable[player])

	alloc(1)
	u8(id)
	writer(data)

	perPlayerUnreliable[player] = bufferWriter.export()
end

function serverProcess.start()
	local reliableRemote = Instance.new("RemoteEvent")
	reliableRemote.Name = "ByteNetReliable"
	reliableRemote.OnServerEvent:Connect(onServerEvent)
	reliableRemote.Parent = ReplicatedStorage

	local unreliableRemote = Instance.new("UnreliableRemoteEvent")
	unreliableRemote.Name = "ByteNetUnreliable"
	unreliableRemote.OnServerEvent:Connect(onServerEvent)
	unreliableRemote.Parent = ReplicatedStorage

	for _, player in Players:GetPlayers() do
		playerAdded(player)
	end

	Players.PlayerAdded:Connect(playerAdded)

	RunService.Heartbeat:Connect(function()
		-- Check if the channel has anything before trying to send it
		if globalReliable.cursor > 0 then
			local b, r = dump(globalReliable)
			reliableRemote:FireAllClients(b, r)

			globalReliable.cursor = 0
			table.clear(globalReliable.references)
		end

		if globalUnreliable.cursor > 0 then
			local b, r = dump(globalUnreliable)
			unreliableRemote:FireAllClients(b, r)

			globalUnreliable.cursor = 0
			table.clear(globalUnreliable.references)
		end

		for _, player in Players:GetPlayers() do
			if perPlayerReliable[player].cursor > 0 then
				local b, r = dump(perPlayerReliable[player])
				reliableRemote:FireClient(player, b, r)

				perPlayerReliable[player].cursor = 0
				table.clear(perPlayerReliable[player].references)
			end

			if perPlayerUnreliable[player].cursor > 0 then
				local b, r = dump(perPlayerUnreliable[player])
				unreliableRemote:FireClient(player, b, r)

				perPlayerUnreliable[player].cursor = 0
				table.clear(perPlayerUnreliable[player].references)
			end
		end
	end)
end

return serverProcess
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX85D7D1F7DD4E40D1BD4E965DD5E3E635">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">replicated</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX918315C106CD4E02B8467F8B606D4C7B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">replicatedValue</string>
									<string name="ScriptGuid">{F6875F30-F87B-476C-9EB6-6FA9AC060AD7}</string>
									<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

local replicatedValuePrototype = {}
local replicatedValueMetatable = { __index = replicatedValuePrototype }
export type replicatedValueType = typeof(setmetatable(
	{} :: {
		_luauData: {},
		_value: StringValue,
	},
	replicatedValueMetatable
))

function replicatedValuePrototype.write(self: replicatedValueType, value: {})
	assert(runContext == "server", "cannot write to replicatdvalue on client")

	self._luauData = value

	-- self._value.Value :(
	self._value.Value = HttpService:JSONEncode(value)
end

function replicatedValuePrototype.read(self: replicatedValueType)
	return self._luauData
end

return function(valueObject: StringValue): replicatedValueType
	local self = setmetatable({}, replicatedValueMetatable)

	self._luauData = {}
	self._value = valueObject

	-- important note: We freeze the table on the client to ensure that it never is modified
	-- We initialize _luauData as an empty table because on the server, we don't need to freeze it.
	if runContext == "client" then
		self._luauData = table.freeze(HttpService:JSONDecode(valueObject.Value))

		valueObject.Changed:Connect(function(value: string)
			if not value then
				return
			end

			self._luauData = table.freeze(HttpService:JSONDecode(value))
		end)
	end

	return self
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5B482878887D4424A55EC9031BA720C0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">values</string>
									<string name="ScriptGuid">{85A2C33A-7AFE-4226-AE36-87F543B7B622}</string>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local replicatedValue = require(script.Parent.replicatedValue)

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"
local valueFolder: Folder
local valueDictionary: {
	[string]: replicatedValue.replicatedValueType,
} = {}

local values = {}

function values.start()
	if runContext == "server" then
		local storage = Instance.new("Folder")
		storage.Name = "BytenetStorage"
		storage.Parent = ReplicatedStorage

		valueFolder = storage
	elseif runContext == "client" then
		valueFolder = ReplicatedStorage:WaitForChild("BytenetStorage")
	end
end

function values.access(name: string): replicatedValue.replicatedValueType
	-- caching
	if valueDictionary[name] then
		return valueDictionary[name]
	end

	if runContext == "client" then
		local potentialValueInstance = valueFolder:FindFirstChild(name)
		if potentialValueInstance and potentialValueInstance:IsA("StringValue") then
			-- set up the value and return it
			local value = replicatedValue(potentialValueInstance)

			valueDictionary[name] = value

			return value
		end
	elseif runContext == "server" then
		-- create the value and return it
		local newValueInstance = Instance.new("StringValue")
		newValueInstance.Name = name
		newValueInstance.Parent = valueFolder

		local value = replicatedValue(newValueInstance)

		valueDictionary[name] = value

		return value
	end

	return valueDictionary[name]
end

return values
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX322A35ECEA9340E6889CBFAA81D036E8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Templates</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Frame" referent="RBX18E77C0F933F4D01B03F6519DC5F4E2B">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">999999</int>
						<string name="Name">library_prompt_frame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9999</int>
					</Properties>
					<Item class="UIPadding" referent="RBXD69EF05C1A074343A922AB402FC975CD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">padding</string>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>50</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXCBF967246226414197FBEAE449D39BFB">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
								<Weight>500</Weight>
								<Style>Normal</Style>
							</Font>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">message</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<string name="OpenTypeFeatures"></string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>-0.052516412</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">false</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.463894963</YS>
								<YO>60</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">Warn</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">30</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0.100000001</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9999</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX213A1C910C0040E39DB1B8535F3BD3B3">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">buttons_container</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.687363863</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.506762147</XS>
								<XO>0</XO>
								<YS>0.305719912</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">10000</int>
						</Properties>
						<Item class="UIListLayout" referent="RBX1B9C906DAF0C4D58916411807ED6D508">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<token name="FillDirection">1</token>
								<token name="HorizontalAlignment">0</token>
								<token name="HorizontalFlex">0</token>
								<token name="ItemLineAlignment">0</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>10</O>
								</UDim>
								<token name="SortOrder">2</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<token name="VerticalAlignment">0</token>
								<token name="VerticalFlex">0</token>
								<bool name="Wraps">false</bool>
							</Properties>
						</Item>
						<Item class="ImageButton" referent="RBX49DF0AF2C8FA49D2BEC6F89D602275DD">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">false</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">5</int>
								<bool name="Modal">false</bool>
								<string name="Name">no_button</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.826652765</XS>
									<XO>0</XO>
									<YS>0.447885096</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="PressHapticEffect">null</Ref>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.853305578</XS>
									<XO>0</XO>
									<YS>0.227991059</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">10001</int>
							</Properties>
							<Item class="TextLabel" referent="RBX62EB9DC418854339B2D5D968FF89E7FC">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">label</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Decline</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">18</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">10001</int>
								</Properties>
							</Item>
							<Item class="ImageLabel" referent="RBX73EF202B7A3C4E27BB40D39AFEFDF6A7">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>1</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxassetid://11419709766</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0.5</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">icon</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>20</XO>
										<YS>0</YS>
										<YO>20</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">10001</int>
								</Properties>
							</Item>
							<Item class="UIPadding" referent="RBX20D3B6F1F8D449E2A62AD86D63924177">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBXC31AC3EBB7074249B7D52587BB9E299A">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<token name="StrokeSizingMode">0</token>
									<BinaryString name="Tags"></BinaryString>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="ImageButton" referent="RBXB4E8A19B43CB4D9A8699EF6C9E59DDCB">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">false</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">2</int>
								<bool name="Modal">false</bool>
								<string name="Name">yes_button</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="PressHapticEffect">null</Ref>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">0</token>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.852999985</XS>
									<XO>0</XO>
									<YS>0.228</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">10001</int>
							</Properties>
							<Item class="UIPadding" referent="RBXFB9206915DA14991A51DA9E6FA602146">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBX5016A2B30F2F4154A439C8061E04E3F2">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<token name="StrokeSizingMode">0</token>
									<BinaryString name="Tags"></BinaryString>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX1B221F4BA3D14ED2A37F4F7AB03D880B">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">label</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<string name="OpenTypeFeatures"></string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Accept</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">18</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">10001</int>
								</Properties>
							</Item>
							<Item class="ImageLabel" referent="RBX7000056F17014A3EA35860A568FAA4AA">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>1</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxassetid://11419719540</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0.5</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">icon</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>20</XO>
										<YS>0</YS>
										<YO>20</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">10001</int>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX70FA957BD3E64A8D8B94BF61A10CF150">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">2</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
							<Weight>500</Weight>
							<Style>Normal</Style>
						</Font>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="Name">text</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<string name="OpenTypeFeatures"></string>
						<UDim2 name="Position">
							<XS>0.0276422761</XS>
							<XO>0</XO>
							<YS>0.0690335333</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text"></string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">30</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0.100000001</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">0</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX5AE7A42AF24040DEA2800D428AC9D249">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">InstertFrame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.0421638824</XS>
							<XO>0</XO>
							<YS>0.0848126262</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.260143191</XS>
							<XO>0</XO>
							<YS>0.644970417</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextLabel" referent="RBX20DFC927F70B49D780BCFDF204F5A262">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">title</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<string name="OpenTypeFeatures"></string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.25</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text"><![CDATA[Insert
<b> Icon Module </b>]]></string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIPadding" referent="RBXD0AD76B2646942BEB0FC0543140D7377">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIPadding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>10</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>10</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>10</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>10</O>
								</UDim>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBX7A5B586BA7764C53BAFEF9E502927699">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">false</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.899999976</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<Ref name="HoverHapticEffect">null</Ref>
							<Content name="HoverImage"><null></null></Content>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">2</int>
							<bool name="Modal">false</bool>
							<string name="Name">button</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.498957217</XS>
								<XO>0</XO>
								<YS>0.726727366</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="PressHapticEffect">null</Ref>
							<Content name="PressedImage"><null></null></Content>
							<token name="ResampleMode">0</token>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<token name="ScaleType">0</token>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.822606266</XS>
								<XO>0</XO>
								<YS>0.376152754</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIPadding" referent="RBX70C5130E17BC4DCE863F5B8BA405D50E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">padding</string>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>10</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>20</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>20</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>10</O>
								</UDim>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIStroke" referent="RBX35BB392F34A548BDBA3076A3BE96E822">
							<Properties>
								<token name="ApplyStrokeMode">0</token>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UDim name="BorderOffset">
									<S>0</S>
									<O>0</O>
								</UDim>
								<token name="BorderStrokePosition">0</token>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<Color3 name="Color">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Enabled">true</bool>
								<token name="LineJoinMode">2</token>
								<string name="Name">stroke</string>
								<int64 name="SourceAssetId">-1</int64>
								<token name="StrokeSizingMode">0</token>
								<BinaryString name="Tags"></BinaryString>
								<float name="Thickness">0</float>
								<float name="Transparency">0.800000012</float>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBXBBB796AFDEFE4145A7C60DD8023695BA">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">label</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1.00319493</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Open</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">62</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX1489AB4FA48B4F278988B7DD9915BE58">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipsDescendants">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Draggable">false</bool>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
							<Weight>500</Weight>
							<Style>Normal</Style>
						</Font>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="Name">separator</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<string name="OpenTypeFeatures"></string>
						<UDim2 name="Position">
							<XS>0.500813007</XS>
							<XO>0</XO>
							<YS>0.0276134126</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">Inserts Window</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">30</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0.100000001</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="ObjectValue" referent="RBX680DF6B8F98C47639ED29E231611ECE2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Path</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<Ref name="Value">RBX48B8AA28F0C84C1CBDEFAF9526BA80E0</Ref>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXA62D7D5ED03649D0BFFD4F5AD5DF13DD">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Util</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX97F447039B4E4D7F8A776E54DABE3ED9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ConnectionUtil</string>
						<string name="ScriptGuid">{49014FAB-F053-4815-B493-F8FBA3034BB7}</string>
						<ProtectedString name="Source"><![CDATA[--!strict
-- Utility module for handling RBXScriptConnections. This module is used to track connections and disconnect them when needed.

type ConnectionUtilClass = {
	__index: ConnectionUtilClass,
	new: () -> ConnectionUtil,
	-- Connect with an RBXScripConnection
	trackConnection: (self: ConnectionUtil, string, RBXScriptConnection) -> (),
	-- Adds a manual disconnect function
	trackBoundFunction: (self: ConnectionUtil, string, () -> ()) -> (),
	-- Disconnects the key
	disconnect: (self: ConnectionUtil, string) -> (),
	-- Disconnects all connections on this util
	disconnectAll: (self: ConnectionUtil) -> (),
}

export type ConnectionUtil = typeof(setmetatable({} :: {
	-- Mapping from a unique key to a disconnect function
	_connections: {[string]: () -> ()},
}, {} :: ConnectionUtilClass))

local ConnectionUtil: ConnectionUtilClass = {} :: ConnectionUtilClass;
ConnectionUtil.__index = ConnectionUtil

function ConnectionUtil.new()
	local self = setmetatable({}, ConnectionUtil)

	self._connections = {}

	return self
end

function ConnectionUtil:trackConnection(key, connection)
	if self._connections[key] then
		self._connections[key]() -- Disconnect existing connection
	end
	-- store the disconnect function
	self._connections[key] = function() connection:Disconnect() end
end

function ConnectionUtil:trackBoundFunction(key, disconnectionFunc)
	if self._connections[key] then
		self._connections[key]()
	end
	self._connections[key] = disconnectionFunc
end

function ConnectionUtil:disconnect(key)
	if self._connections[key] then
		self._connections[key]()
		self._connections[key] = nil
	end
end

function ConnectionUtil:disconnectAll()
	for _, disconnectFunc in pairs(self._connections) do
		disconnectFunc()
	end
	self._connections = {} -- Clear all connections
end

return ConnectionUtil]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCBFAA495550F409785BA1AFB83725289">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InstancesManager</string>
						<string name="ScriptGuid">{DE53A6C0-5E46-4E57-9021-C7EC4AA89F47}</string>
						<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local InsertService = game:GetService("InsertService")

local InstancesManager = {}
InstancesManager.__index = InstancesManager

local COMMON_LIBRARIES = {
	"Maid", "Janitor", "Spring", "Icon", "Signal", "Promise", 
	"Trove", "Fusion", "Roact", "Rodux", "ProfileService"
}

function InstancesManager.new(gui, templates, inserts, resources, conn, settingsManager)
	local self = setmetatable({}, InstancesManager)
	self.gui = gui
	self.templates = templates
	self.inserts = inserts
	self.resources = resources
	self.conn = conn
	self.settingsManager = settingsManager
	self.animInfo = TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
	self.pendingLibraryChanges = {}
	return self
end

function InstancesManager:print(...)
	if self.settingsManager:getSetting("EnablePrints") then
		print(...)
	end
end

function InstancesManager:disableScripts(instance)
	for _, descendant in instance:GetDescendants() do
		if (descendant:IsA("Script") or descendant:IsA("LocalScript")) and descendant.Enabled then
			descendant.Enabled = false
		end
	end
	if (instance:IsA("Script") or instance:IsA("LocalScript")) and instance.Enabled then
		instance.Enabled = false
	end
end

function InstancesManager:getInsertConfig(insertFolder)
	local configModule = insertFolder:FindFirstChild("Config")
	if configModule then
		local success, config = pcall(function()
			return require(configModule)
		end)
		if success then
			return config
		end
	end
	return {
		Name = insertFolder.Name,
		Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
		Description = "No description available",
		Format = {},
		AssetId = nil
	}
end

function InstancesManager:getInsertObject(insertFolder)
	for _, child in insertFolder:GetChildren() do
		if child.Name == insertFolder.Name then
			return child
		end
	end
	return nil
end

function InstancesManager:getTargetPath()
	local pathValue = self.resources:FindFirstChild("Path")
	if pathValue and pathValue:IsA("ObjectValue") then
		if pathValue.Value and pathValue.Value:IsDescendantOf(game) then
			return pathValue.Value
		else
			warn("Path ObjectValue exists but has no value set. Use 'Change Path' to set a target location.")
		end
	else
		warn("Path ObjectValue not found in Resources")
	end
	return game.ServerStorage
end

function InstancesManager:isCommonLibrary(name)
	for _, libName in ipairs(COMMON_LIBRARIES) do
		if name:lower():match(libName:lower()) then
			return libName
		end
	end
	return nil
end

function InstancesManager:findExistingLibrary(libraryName, targetParent)
	local searchLocations = {
		game.ReplicatedStorage,
		game.ServerStorage,
		game.ServerScriptService,
		targetParent
	}

	for _, location in ipairs(searchLocations) do
		local found = location:FindFirstChild(libraryName, true)
		if found and found:IsA("ModuleScript") then
			return found
		end
	end
	return nil
end

function InstancesManager:findModulesRequiringLibrary(libraryName)
	local modules = {}
	local searchLocations = {
		game.ReplicatedStorage,
		game.ServerStorage,
		game.ServerScriptService,
		game.StarterPlayer,
		game.StarterPack,
		game.StarterGui,
		workspace
	}

	for _, location in ipairs(searchLocations) do
		for _, descendant in ipairs(location:GetDescendants()) do
			if descendant:IsA("ModuleScript") or descendant:IsA("Script") or descendant:IsA("LocalScript") then
				local success, source = pcall(function()
					return descendant.Source
				end)

				if success and source then
					-- More robust pattern matching for require statements
					local patterns = {
						"require%(%s*[^)]*" .. libraryName .. "[^)]*%)",
						"require%s*%(.-" .. libraryName .. ".-%)",
						"require%(\"[^\"]*" .. libraryName .. "[^\"]*\"%)",
						"require%('[^']*" .. libraryName .. "[^']*'%)"
					}

					for _, pattern in ipairs(patterns) do
						if source:match(pattern) then
							table.insert(modules, descendant)
							break
						end
					end
				end
			end
		end
	end

	return modules
end

function InstancesManager:updateRequirePaths(modules, oldPath, newPath, libraryName)
	local updatedCount = 0
	local oldFullName = oldPath:GetFullName()
	local newFullName = newPath:GetFullName()

	-- Escape special characters for pattern matching
	local oldPathPattern = oldFullName:gsub("([%(%)%.%[%]%*%+%-%?%^%$%%])", "%%%1")

	self:print("Updating require paths from: " .. oldFullName .. " to: " .. newFullName)
	self:print("Found " .. #modules .. " modules that may need updating for library: " .. libraryName)

	for _, module in ipairs(modules) do
		local success, err = pcall(function()
			local source = module.Source
			local originalSource = source

			-- Pattern to match various require formats
			local patterns = {
				-- require(game.ServerStorage.ModuleName)
				["require%s*%(%s*" .. oldPathPattern .. "%s*%)"] = "require(" .. newFullName .. ")",
				-- require "game.ServerStorage.ModuleName"
				["require%s*%\"%s*" .. oldPathPattern .. "%s*%\""] = "require(\"" .. newFullName .. "\")",
				-- require 'game.ServerStorage.ModuleName'
				["require%s*%'%s*" .. oldPathPattern .. "%s*%'"] = "require('" .. newFullName .. "')",
			}

			local wasUpdated = false
			for pattern, replacement in pairs(patterns) do
				local newSource, count = source:gsub(pattern, replacement)
				if count > 0 then
					source = newSource
					updatedCount = updatedCount + count
					wasUpdated = true
					self:print("   Updated " .. module:GetFullName() .. " (pattern: " .. pattern:sub(1, 30) .. "...)")
				end
			end

			if wasUpdated then
				module.Source = source
				self:print("   Successfully updated require path in: " .. module:GetFullName())
			else
				self:print("   No matching require pattern found in: " .. module:GetFullName())
				self:print("    Module requires " .. libraryName .. " but couldn't auto-update path")
			end
		end)

		if not success then
			warn("Failed to update require path in " .. module:GetFullName() .. ": " .. tostring(err))
		end
	end

	self:print(" Updated " .. updatedCount .. " require paths across " .. #modules .. " modules for library: " .. libraryName)
	return updatedCount
end

function InstancesManager:showLibraryPrompt(libraryName, existingLib, newLib, targetParent, callback)
	local clonepromptFrame = self.templates:FindFirstChild("library_prompt_frame")
	if not clonepromptFrame then
		warn("library_prompt_frame not found in GUI")
		if callback then callback(false) end
		return
	end
	local promptFrame = clonepromptFrame:Clone()
	promptFrame.Parent = self.gui

	local messageLabel = promptFrame:FindFirstChild("message")
	if messageLabel then
		messageLabel.Text = string.format(
			"Found existing '%s' module at:\n%s\n\nWould you like to move it to the new insert path and update all references?\n\nThis will update require() paths in all scripts that reference this library.",
			libraryName,
			existingLib:GetFullName()
		)
	end

	self:animateFrameIn(promptFrame)

	local function cleanup()
		self.conn:disconnect("LibraryPromptYes")
		self.conn:disconnect("LibraryPromptNo")
		if promptFrame and promptFrame.Parent then
			self:animateFrameOut(promptFrame, function()
				promptFrame:Destroy()
			end)
		end
	end

	self.conn:trackConnection("LibraryPromptYes",
		promptFrame.buttons_container.yes_button.MouseButton1Down:Connect(function()
			cleanup()
			if callback then callback(true) end
		end)
	)

	self.conn:trackConnection("LibraryPromptNo",
		promptFrame.buttons_container.no_button.MouseButton1Down:Connect(function()
			cleanup()
			if callback then callback(false) end
		end)
	)
end

function InstancesManager:loadFromAssetId(assetId, callback)
	local success, result = pcall(function()
		return InsertService:LoadAsset(assetId)
	end)

	if success and result then
		self:print("Successfully loaded asset: " .. assetId)
		local model = result:GetChildren()[1]
		if model then
			model.Parent = workspace.Terrain
			result:Destroy()
			if callback then callback(model) end
			task.delay(1, function()
				model:Destroy()
			end)
			return model
		else
			warn("Asset loaded but contains no children")
			result:Destroy()
		end
	else
		warn("Failed to load asset " .. assetId .. ": " .. tostring(result))
	end

	if callback then callback(nil) end
	return nil
end

function InstancesManager:populateInstanceContainer(container, format)
	for _, child in container:GetChildren() do
		if not child:IsA("UIListLayout") and not child:IsA("UIPadding") then
			child:Destroy()
		end
	end

	if not container:FindFirstChild("UIListLayout") then
		local listLayout = Instance.new("UIListLayout")
		listLayout.SortOrder = Enum.SortOrder.LayoutOrder
		listLayout.Padding = UDim.new(0, 5)
		listLayout.Parent = container
	end

	local layoutOrder = 0
	for _, item in ipairs(format) do
		layoutOrder += 1

		if item.Separator then
			local separator = self.templates:FindFirstChild("separator")
			if separator then
				local newSeparator = separator:Clone()
				local titleLabel = newSeparator:FindFirstChildWhichIsA("TextLabel", true)
				if titleLabel then
					titleLabel.Text = item.Separator
				elseif newSeparator:IsA("TextLabel") then
					newSeparator.Text = item.Separator
				end
				newSeparator.LayoutOrder = layoutOrder
				newSeparator.Parent = container
			end
		elseif item.Text then
			local textTemplate = self.templates:FindFirstChild("text")
			if textTemplate then
				local newText = textTemplate:Clone()
				local textLabel = newText:FindFirstChildWhichIsA("TextLabel", true)
				if textLabel then
					textLabel.Text = item.Text
				elseif newText:IsA("TextLabel") then
					newText.Text = item.Text
				end
				newText.LayoutOrder = layoutOrder
				newText.Parent = container
			end
		end
	end
end

function InstancesManager:animateFrameIn(frame)
	frame.Position = UDim2.new(0.5, 0, 1.5, 0)
	frame.Visible = true
	TweenService:Create(frame, self.animInfo, {
		Position = UDim2.new(0.5, 0, 0.5, 0)
	}):Play()
end

function InstancesManager:animateFrameOut(frame, callback)
	local tween = TweenService:Create(frame, self.animInfo, {
		Position = UDim2.new(0.5, 0, -0.5, 0)
	})
	tween.Completed:Connect(function()
		frame.Visible = false
		frame.Position = UDim2.new(0.5, 0, 0.5, 0)
		if callback then callback() end
	end)
	tween:Play()
end

function InstancesManager:findLibrariesInObject(object)
	local libraries = {}

	if object:IsA("ModuleScript") then
		local libraryType = self:isCommonLibrary(object.Name)
		if libraryType then
			table.insert(libraries, {module = object, libraryType = libraryType})
		end
	end

	for _, descendant in ipairs(object:GetDescendants()) do
		if descendant:IsA("ModuleScript") then
			local libraryType = self:isCommonLibrary(descendant.Name)
			if libraryType then
				table.insert(libraries, {module = descendant, libraryType = libraryType})
			end
		end
	end

	return libraries
end

function InstancesManager:handleLibraryConflict(libraryInfo, existingLib, targetParent, onComplete)
	self:showLibraryPrompt(libraryInfo.libraryType, existingLib, libraryInfo.module, targetParent, function(userAccepted)
		if userAccepted then
			local success, err = pcall(function()
				local oldLocation = existingLib:GetFullName()
				existingLib.Parent = targetParent
				local newLocation = existingLib:GetFullName()

				self:print("Moved existing " .. libraryInfo.libraryType .. " from " .. oldLocation .. " to " .. newLocation)

				local dependentModules = self:findModulesRequiringLibrary(libraryInfo.libraryType)
				if #dependentModules > 0 then
					self:print("Found " .. #dependentModules .. " modules that require " .. libraryInfo.libraryType)
					self:print("Updating require paths...")

					local updatedCount = self:updateRequirePaths(dependentModules, existingLib, existingLib, libraryInfo.libraryType)

					if updatedCount > 0 then
						self:print(" Successfully updated " .. updatedCount .. " require paths for " .. libraryInfo.libraryType)
					else
						self:print(" No require paths needed updating for " .. libraryInfo.libraryType)
					end
				else
					self:print("No modules found that require " .. libraryInfo.libraryType)
				end
			end)

			if not success then
				warn("Failed to move library: " .. tostring(err))
			end

			libraryInfo.module:Destroy()
		else
			local success, err = pcall(function()
				libraryInfo.module.Name = libraryInfo.module.Name .. "_New"
				self:print("Renamed new library to: " .. libraryInfo.module.Name)
			end)

			if not success then
				warn("Failed to rename new library: " .. tostring(err))
			end
		end

		if onComplete then onComplete() end
	end)
end

function InstancesManager:insertInstance(insertObject, config, targetParent)
	local insertClone = insertObject:Clone()
	self:disableScripts(insertClone)
	insertClone.Name = insertObject.Name

	local librariesFound = self:findLibrariesInObject(insertClone)

	if #librariesFound > 0 then
		self:print("Found " .. #librariesFound .. " common libraries in insert")

		local conflictsToResolve = {}
		for _, libInfo in ipairs(librariesFound) do
			local existingLib = self:findExistingLibrary(libInfo.libraryType, targetParent)
			if existingLib then
				table.insert(conflictsToResolve, {libInfo = libInfo, existing = existingLib})
				self:print("Conflict detected: " .. libInfo.libraryType .. " already exists at " .. existingLib:GetFullName())
			end
		end

		if #conflictsToResolve > 0 then
			local currentIndex = 1
			local function resolveNext()
				if currentIndex <= #conflictsToResolve then
					local conflict = conflictsToResolve[currentIndex]
					currentIndex = currentIndex + 1
					self:handleLibraryConflict(conflict.libInfo, conflict.existing, targetParent, resolveNext)
				else
					local success, errorMsg = pcall(function()
						insertClone.Parent = targetParent
						self:print("Successfully inserted: " .. insertObject.Name .. " into " .. targetParent:GetFullName())
					end)

					if not success then
						warn("Failed to insert object: " .. tostring(errorMsg))
					end
				end
			end

			resolveNext()
			return
		end
	end

	local success, errorMsg = pcall(function()
		insertClone.Parent = targetParent
		self:print("Successfully inserted: " .. insertObject.Name .. " into " .. targetParent:GetFullName())
	end)

	if not success then
		warn("Failed to insert object: " .. tostring(errorMsg))
	end
end

function InstancesManager:showInstanceFrame(insertFolder)
	self:animateFrameOut(self.gui.insets_frame, function()
		local config = self:getInsertConfig(insertFolder)
		local insertObject = self:getInsertObject(insertFolder)

		self.gui.instance_frame.header.Text = config.Name or insertFolder.Name
		self.gui.instance_frame.instance_thumbnail.Image = config.Thumbnail

		local container = self.gui.instance_frame:FindFirstChild("info_container")
		if container then
			self:populateInstanceContainer(container, config.Format or {})
		end

		self:animateFrameIn(self.gui.instance_frame)

		self.conn:trackConnection("InstanceFrameGoBack",
			self.gui.instance_frame.buttons_container.go_back.MouseButton1Down:Connect(function()
				self:animateFrameOut(self.gui.instance_frame, function()
					self:animateFrameIn(self.gui.insets_frame)
				end)
				self.conn:disconnect("InstanceFrameGoBack")
				self.conn:disconnect("InstanceFrameInsert")
			end)
		)

		self.conn:trackConnection("InstanceFrameInsert",
			self.gui.instance_frame.buttons_container.insert_button.MouseButton1Down:Connect(function()
				local targetParent = self:getTargetPath()

				if config.AssetId and tonumber(config.AssetId) then
					self:print("Loading asset from AssetId: " .. config.AssetId)
					self:loadFromAssetId(config.AssetId, function(loadedAsset)
						if loadedAsset then
							self:disableScripts(loadedAsset)
							self:insertInstance(loadedAsset, config, targetParent)
						else
							warn("Failed to load asset, trying local object...")
							if insertObject then
								self:insertInstance(insertObject, config, targetParent)
							end
						end
					end)
				elseif insertObject then
					self:insertInstance(insertObject, config, targetParent)
				else
					warn("Insert object is nil and no AssetId provided")
				end
			end)
		)
	end)
end

function InstancesManager:refreshInsertsList()
	for _, child in self.gui.insets_frame.inserts_container:GetChildren() do
		if child:IsA("Frame") or child:IsA("GuiObject") then
			child:Destroy()
		end
	end

	for _, insertFolder in self.inserts:GetChildren() do
		if insertFolder:IsA("Folder") then
			local template = self.templates.InstertFrame:Clone()
			template.title.Text = insertFolder.Name
			template.Parent = self.gui.insets_frame.inserts_container

			self.conn:trackConnection("insertModulesButton_" .. insertFolder.Name,
				template.button.MouseButton1Click:Connect(function()
					self:showInstanceFrame(insertFolder)
				end)	
			)
		end
	end
end

return InstancesManager]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD2FEB3424AFA4684963DE4C9AC67FD73">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PathChangerManager</string>
						<string name="ScriptGuid">{2B4ED9B8-BF36-42E6-8E3F-8C43F72E1319}</string>
						<ProtectedString name="Source"><![CDATA[local PathChangerManager = {}
PathChangerManager.__index = PathChangerManager

function PathChangerManager.new(gui, resources, conn, plugin)
	local self = setmetatable({}, PathChangerManager)
	self.gui = gui
	self.resources = resources
	self.conn = conn
	self.plugin = plugin
	self.settingKey = "EncryUtilsPathValue"
	self:loadSettings()
	self:updatePathDisplay()
	return self
end

function PathChangerManager:instanceToPath(instance)
	if not instance then return nil end
	local path = instance:GetFullName()
	path = path:gsub("^game%.", "")
	return path
end

function PathChangerManager:pathToInstance(pathString)
	if not pathString or pathString == "" then return nil end
	local parts = string.split(pathString, ".")
	local service = game:GetService(parts[1])
	if #parts == 1 then
		return service
	end
	local objectSoFar = service
	for index, value in pairs(parts) do
		if index ~= 1 then
			local object = objectSoFar:FindFirstChild(value)
			if object then
				objectSoFar = object
			else
				return nil
			end
		end
	end
	return objectSoFar
end

function PathChangerManager:loadSettings()
	if not self.plugin then
		warn("PathChangerManager: Plugin not provided, cannot load settings")
		return
	end
	local savedPath = self.plugin:GetSetting(self.settingKey)
	if savedPath and type(savedPath) == "string" then
		local instance = self:pathToInstance(savedPath)
		if instance then
			pcall(function()
				self.resources.Path.Value = instance
			end)
		end
	end
end

function PathChangerManager:saveSettings(instance)
	local path = self:instanceToPath(instance)
	if path then
		self.plugin:SetSetting(self.settingKey, path)
	end
end

function PathChangerManager:updatePathDisplay()
	local pathValue = self.resources:FindFirstChild("Path")
	if pathValue and pathValue.Value then
		local displayText = pathValue.Value.Name

		local changeButton = self.gui.path_changer_frame:FindFirstChild("change_path")
		if changeButton then
			local valueLabel = changeButton:FindFirstChild("value")
			if valueLabel then
				valueLabel.Text = displayText
			end
		end

		local openableButton = self.gui.button_container.scroll:FindFirstChild("change_path")
		if openableButton then
			local valueLabel = openableButton:FindFirstChild("value")
			if valueLabel then
				valueLabel.Text = displayText
			end
		end
	end
end

function PathChangerManager:showGoBackButton(visible)
	if self.gui.path_changer_frame.go_back then
		self.gui.path_changer_frame.go_back.Visible = visible
	end
end

function PathChangerManager:cancelSelection()
	self.conn:disconnect("pathSelectionWatcher")
	self:showGoBackButton(true)

	local changeButton = self.gui.path_changer_frame:FindFirstChild("change_path")
	if changeButton then
		local label = changeButton:FindFirstChild("label")
		if label then
			label.Text = "Change Insert Path"
		end
	end

	game:GetService("Selection"):Set({})
end

function PathChangerManager:initialize()
	self:updatePathDisplay()

	self.conn:trackConnection("pathConn",
		self.gui.path_changer_frame.change_path.MouseButton1Down:Connect(function()
			local changeButton = self.gui.path_changer_frame.change_path
			local label = changeButton:FindFirstChild("label")
			if label then
				label.Text = "Select your desired location!"
			end

			self:showGoBackButton(false)
			local selection = game:GetService("Selection")
			selection:Set({})

			self.conn:trackConnection("pathSelectionWatcher", 
				selection.SelectionChanged:Connect(function()
					local selected = selection:Get()
					if #selected == 1 then
						local instance = selected[1]
						if instance then
							local success, result = pcall(function()
								self.resources.Path.Value = instance
								self:saveSettings(instance)
								self:updatePathDisplay()

								if label then
									label.Text = "Change Insert Path"
								end

								self:showGoBackButton(true)
								selection:Set({})
								self.conn:disconnect("pathSelectionWatcher")
							end)
							if not success then
								if label then
									label.Text = "Failed to set path!"
								end
								warn("Path Change Failed: " .. tostring(result))
								task.wait(2)
								if label then
									label.Text = "Change Insert Path"
								end
								self:showGoBackButton(true)
							end
						end
					end
				end)	
			)
		end)
	)
end

return PathChangerManager]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX50D215A2F68646AE8B89B3D52C04C4A2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MagicSelectManager</string>
						<string name="ScriptGuid">{58737B9C-4A61-47F3-BB7C-D7A4DDD6F311}</string>
						<ProtectedString name="Source"><![CDATA[local MagicSelectManager = {}
MagicSelectManager.__index = MagicSelectManager

function MagicSelectManager.new(gui, conn, plugin)
	local self = setmetatable({}, MagicSelectManager)
	self.gui = gui
	self.conn = conn
	self.plugin = plugin
	self.settingKey = "EncryUtilsMagicSelectSettings"
	self.maxSelectionLimit = 100
	self.magicSelectSettings = {
		ByName = true,
		ByClass = true,
		ByParent = true,
		ByColor = true
	}
	self.isSelecting = false
	self:loadSettings()
	return self
end

function MagicSelectManager:loadSettings()
	if not self.plugin then
		warn("MagicSelectManager: Plugin not provided, cannot load settings")
		return
	end
	local savedSettings = self.plugin:GetSetting(self.settingKey)
	if savedSettings and type(savedSettings) == "table" then
		for key, value in pairs(savedSettings) do
			if self.magicSelectSettings[key] ~= nil then
				self.magicSelectSettings[key] = value
			end
		end
	end
end

function MagicSelectManager:saveSettings()
	self.plugin:SetSetting(self.settingKey, self.magicSelectSettings)
end

function MagicSelectManager:updateMagicSelectButtons()
	local settingsContainer = self.gui.magic_select_frame:FindFirstChild("settings_container")
	if not settingsContainer then return end

	for name, value in pairs(self.magicSelectSettings) do
		local button = settingsContainer:FindFirstChild("by_" .. name:lower():sub(3))
		if button and button:IsA("ImageButton") then
			local valueLabel = button:FindFirstChild("value")
			if valueLabel and valueLabel:IsA("TextLabel") then
				valueLabel.Text = tostring(value)
			end
		end
	end
end

function MagicSelectManager:setSettingsVisibility(visible)
	local settingsContainer = self.gui.magic_select_frame:FindFirstChild("settings_container")
	if not settingsContainer then return end

	for _, child in pairs(settingsContainer:GetChildren()) do
		if child:IsA("ImageButton") then
			child.Visible = visible
		end
	end
end

function MagicSelectManager:cancelSelection()
	self.conn:disconnect("MagicSelectionWatcher")

	local goBackButton = self.gui.magic_select_frame:FindFirstChild("go_back")
	if goBackButton then
		local label = goBackButton:FindFirstChild("label")
		if label then
			label.Text = "Go Back"
		end
	end

	self:setSettingsVisibility(true)
	self.isSelecting = false
	game:GetService("Selection"):Set({})
end

function MagicSelectManager:findSimilarInstances(baseInstance)
	local allInstances = {}

	local function shouldSelect(instance)
		local shouldSelect = true

		if self.magicSelectSettings.ByName and instance.Name ~= baseInstance.Name then
			shouldSelect = false
		end

		if self.magicSelectSettings.ByClass and instance.ClassName ~= baseInstance.ClassName then
			shouldSelect = false
		end

		if self.magicSelectSettings.ByParent and instance.Parent ~= baseInstance.Parent then
			shouldSelect = false
		end

		if self.magicSelectSettings.ByColor then
			if baseInstance:IsA("BasePart") and instance:IsA("BasePart") then
				if instance.BrickColor ~= baseInstance.BrickColor then
					shouldSelect = false
				end
			elseif baseInstance:IsA("BasePart") ~= instance:IsA("BasePart") then
				shouldSelect = false
			end
		end

		return shouldSelect
	end

	local function searchInContainer(container)
		for _, instance in container:GetChildren() do
			if shouldSelect(instance) then
				table.insert(allInstances, instance)
				if #allInstances >= self.maxSelectionLimit then
					return true
				end
			end
			if searchInContainer(instance) then
				return true
			end
		end
		return false
	end

	searchInContainer(game)
	return allInstances
end

function MagicSelectManager:initialize()
	self:updateMagicSelectButtons()

	local settingsContainer = self.gui.magic_select_frame:FindFirstChild("settings_container")
	if settingsContainer then
		for name, _ in pairs(self.magicSelectSettings) do
			local buttonName = "by_" .. name:lower():sub(3)
			local button = settingsContainer:FindFirstChild(buttonName)
			if button and button:IsA("ImageButton") then
				self.conn:trackConnection("MagicSelect" .. name,
					button.MouseButton1Down:Connect(function()
						self.magicSelectSettings[name] = not self.magicSelectSettings[name]
						self:saveSettings()
						self:updateMagicSelectButtons()
					end)
				)
			end
		end
	end

	local selectButton = self.gui.magic_select_frame.buttons_container:FindFirstChild("select")
	if selectButton then
		self.conn:trackConnection("MagicSelectSelect",
			selectButton.MouseButton1Down:Connect(function()
				if self.isSelecting then return end

				self.isSelecting = true

				local goBackButton = self.gui.magic_select_frame:FindFirstChild("go_back")
				if goBackButton then
					local label = goBackButton:FindFirstChild("label")
					if label then
						label.Text = "Cancel"
					end
				end

				self:setSettingsVisibility(false)

				local selection = game:GetService("Selection")
				selection:Set({})

				self.conn:trackConnection("MagicSelectionWatcher",
					selection.SelectionChanged:Connect(function()
						if not self.isSelecting then return end

						local selected = selection:Get()
						if #selected == 1 then
							local instance = selected[1]
							if instance then
								self.conn:disconnect("MagicSelectionWatcher")

								local allInstances = self:findSimilarInstances(instance)

								if #allInstances >= self.maxSelectionLimit then
									warn(string.format("Magic Select: Found %d instances, limiting to %d", 
										#allInstances, self.maxSelectionLimit))
								end

								task.wait()
								selection:Set(allInstances)

								if goBackButton then
									local label = goBackButton:FindFirstChild("label")
									if label then
										label.Text = "Go Back"
									end
								end

								self:setSettingsVisibility(true)
								self.isSelecting = false
							end
						end
					end)
				)
			end)
		)
	end
end

return MagicSelectManager]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0A876E5E589A46C18D63D53F9813BB20">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VersionChecker</string>
						<string name="ScriptGuid">{41754111-EC63-4EBF-BA46-F29D0040A5A2}</string>
						<ProtectedString name="Source"><![CDATA[local VersionChecker = {}
VersionChecker.__index = VersionChecker

function VersionChecker.new(plugin)
	local self = setmetatable({}, VersionChecker)
	self.plugin = plugin
	self.settingKey = "EncryUtilsVersion"
	return self
end

function VersionChecker:getResources()
	local pluginScript = script.Parent.Parent.Parent.init
	return pluginScript.Parent:FindFirstChild("Resources")
end

function VersionChecker:getCurrentVersion(resources)
	local versionValue = resources and resources:FindFirstChild("Version")
	return versionValue and versionValue.Value
end

function VersionChecker:getStoredVersion()
	return self.plugin:GetSetting(self.settingKey)
end

function VersionChecker:updateStoredVersion(version)
	self.plugin:SetSetting(self.settingKey, version)
end

function VersionChecker:checkRestartRequired()
	local resources = self:getResources()
	if not resources then
		return true, "Resources folder not found"
	end

	local currentVersion = self:getCurrentVersion(resources)
	if not currentVersion then
		return true, "Version value not found in Resources"
	end

	local storedVersion = self:getStoredVersion()
	if not storedVersion then
		self:updateStoredVersion(currentVersion)
		return false, ""
	end

	if currentVersion > storedVersion then
		self:updateStoredVersion(currentVersion)
		return true, string.format(
			"Plugin updated (v%s -> v%s). Please restart Studio.",
			tostring(storedVersion),
			tostring(currentVersion)
		)
	end

	return false, ""
end

return VersionChecker]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX70D21F5CA2B34F93B94CA88EF63CA1CD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SettingsManager</string>
						<string name="ScriptGuid">{254DA81D-7C90-419D-8E0E-65D8825BBF43}</string>
						<ProtectedString name="Source"><![CDATA[local SettingsManager = {}
SettingsManager.__index = SettingsManager

function SettingsManager.new(plugin)
	local self = setmetatable({}, SettingsManager)
	self.plugin = plugin
	self.settingKey = "EncryUtilsSettings"
	self.defaultSettings = {
		EnablePrints = true
	}
	self.settings = self:loadSettings()
	return self
end

function SettingsManager:loadSettings()
	local savedSettings = self.plugin:GetSetting(self.settingKey)
	if savedSettings and type(savedSettings) == "table" then
		local mergedSettings = table.clone(self.defaultSettings)
		for key, value in pairs(savedSettings) do
			if mergedSettings[key] ~= nil then
				mergedSettings[key] = value
			end
		end
		return mergedSettings
	end
	return table.clone(self.defaultSettings)
end

function SettingsManager:saveSettings()
	self.plugin:SetSetting(self.settingKey, self.settings)
end

function SettingsManager:getSetting(settingName)
	return self.settings[settingName]
end

function SettingsManager:setSetting(settingName, value)
	self.settings[settingName] = value
	self:saveSettings()
	self:updateSettingsButtons()
end

function SettingsManager:updateSettingsButtons()
	if not self.gui or not self.gui:FindFirstChild("settings_frame") then
		warn("SettingsManager: GUI not initialized or settings_frame not found")
		return
	end

	local settingsContainer = self.gui.settings_frame:FindFirstChild("settings_container")
	if not settingsContainer then
		warn("SettingsManager: settings_container not found")
		return
	end

	for settingName, value in pairs(self.settings) do
		local buttonNames = {
			settingName:lower(),
			"enable_" .. settingName:lower(),
			settingName
		}

		local button = nil
		for _, buttonName in ipairs(buttonNames) do
			button = settingsContainer:FindFirstChild(buttonName)
			if button then break end
		end

		if button and button:IsA("ImageButton") then
			local valueLabel = button:FindFirstChild("value")
			if valueLabel and valueLabel:IsA("TextLabel") then
				valueLabel.Text = tostring(value)
				--print("SettingsManager: Updated " .. settingName .. " button to: " .. tostring(value))
			else
				warn("SettingsManager: Value label not found in button " .. button.Name)
			end
		else
			warn("SettingsManager: Button not found for setting: " .. settingName)
		end
	end
end

function SettingsManager:initialize(gui, conn)
	self.gui = gui
	self.conn = conn

	local settingsContainer = self.gui.settings_frame:FindFirstChild("settings_container")
	if not settingsContainer then
		warn("SettingsManager: settings_container not found in settings_frame")
		return
	end

	for settingName, _ in pairs(self.settings) do
		-- Try to find button by different naming patterns
		local buttonNames = {
			settingName:lower(),
			"enable_" .. settingName:lower(),
			settingName
		}

		local button = nil
		for _, buttonName in ipairs(buttonNames) do
			button = settingsContainer:FindFirstChild(buttonName)
			if button then break end
		end

		if button and button:IsA("ImageButton") then
			self.conn:trackConnection("Settings" .. settingName,
				button.MouseButton1Down:Connect(function()
					--print("SettingsManager: Toggling " .. settingName)
					local newValue = not self:getSetting(settingName)
					self:setSetting(settingName, newValue)
				end)
			)
			--print("SettingsManager: Connected button for " .. settingName)
		else
			warn("SettingsManager: Could not find button for setting: " .. settingName)
		end
	end

	self:updateSettingsButtons()
end

return SettingsManager]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="NumberValue" referent="RBX99749EB17FAD42F6B8EFC761B3957A63">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Version</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<double name="Value">1.5300000000000000266</double>
				</Properties>
			</Item>
		</Item>
	</Item>
	<SharedStrings>
		<SharedString md5="aaQQwlzZOlor7w4mpBFaRg==">Q1NHUEhTBwAAAALWGYVAtL0atRTKtSMNQse0FA/UP5P+diJsCyY2wsbTP/heGaRLD9Q/EAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxYOAAAEAAAAAAAAAPtMgD2x
fn8/Nv3/vftMgD2ycX0/AAAAAPtMgL2xfn8/Nv3/PftMgD2ycX0/2v77PYPZPz5QcXk/AAAA
AIPZPz6BcXs/2v77vYPZPz5QcXk/CP59vvtMgD0gcXc/Nv3/vftMgL2ycX0/rf95voPZPz5a
inM/Nv3/PftMgL2ycX0/2v77vYPZP75QcXk/AAAAAIPZP76BcXs/2v77PYPZP75QcXk/CP59
PvtMgD0gcXc/rf95PoPZPz5ainM/IwL0PbQrnj4qinE/AAAAALQrnj6+cHM/IwL0vbQrnj4q
inE/HBm8vvtMgD3IiW0/CP59vvtMgL0gcXc/rf95voPZP75ainM/Vxq5voPZPz5tyWk/9QJy
vrQrnj6eyWs/rf95PoPZP75ainM/CP59PvtMgL0gcXc/IwL0vbQrnr4qinE/AAAAALQrnr6+
cHM/IwL0PbQrnr4qinE/HBm8PvtMgD3IiW0/Vxq5PoPZPz5tyWk/9QJyPrQrnj6eyWs//zpm
Pibp2T5UVWA/DwfoPSbp2T4MyWU/AAAAACbp2T4Elmc/DwfovSbp2T4MyWU//zpmvibp2T5U
VWA/4Br2vvtMgD0W4l8/HBm8vvtMgL3IiW0/Vxq5voPZP75tyWk/9QJyvrQrnr6eyWs/Ezby
voPZPz7yVFw/XDazvrQrnj6EVWI/CIbqvrQrnj5IVFU/9QJyPrQrnr6eyWs/Vxq5PoPZP75t
yWk/HBm8PvtMgL3IiW0//zpmvibp2b5UVWA/DwfovSbp2b4MyWU/AAAAACbp2b4Elmc/Dwfo
PSbp2b4MyWU//zpmPibp2b5UVWA/4Br2PvtMgD0W4l8/EzbyPoPZPz7yVFw/CIbqPrQrnj5I
VFU/XDazPrQrnj6EVWI/u4aqPibp2T55VFc/6tpWPucrCT/nU1E/3HPYPecrCT/8bVY/AAAA
AOcrCT9ZIVg/3HPYvecrCT/8bVY/u4aqvibp2T55VFc/6tpWvucrCT/nU1E/sygWv/tMgD1A
rU4/4Br2vvtMgL0W4l8/EzbyvoPZP77yVFw/CIbqvrQrnr5IVFU/XDazvrQrnr6EVWI/ScMT
v4PZPz4iYEs/AxIPv7Qrnj5S7EQ/TyTfvibp2T6y+Uo/qiEIvybp2T6dXjs/XDazPrQrnr6E
VWI/CIbqPrQrnr5IVFU/EzbyPoPZP77yVFw/4Br2PvtMgL0W4l8/u4aqvibp2b55VFc/6tpW
vucrCb/nU1E/3HPYvecrCb/8bVY/AAAAAOcrCb9ZIVg/3HPYPecrCb/8bVY/6tpWPucrCb/n
U1E/u4aqPibp2b55VFc/sygWP/tMgD1ArU4/ScMTP4PZPz4iYEs/AxIPP7Qrnj5S7EQ/qiEI
Pybp2T6dXjs/TyTfPibp2T6y+Uo/cwufPucrCT+07Eg/wCqRPuEhIz88Xjc/1BVEPuEhIz9c
BT8/xa7FPeEhIz80rEM/AAAAAOEhIz8mOUU/xa7FveEhIz80rEM/1BVEvuEhIz9cBT8/cwuf
vucrCT+07Eg/wCqRvuEhIz88Xjc/jN4uv/tMgD0bODo/sygWv/tMgL1ArU4/rB8sv4PZPz6g
RDc/ScMTv4PZP74iYEs/AxIPv7Qrnr5S7EQ/qiEIvybp2b6dXjs/TyTfvibp2b6y+Uo/7qEm
v7Qrnj5GdzE/dyrQvucrCT/OXj0/mBf+vucrCT9t3S4/p4sevybp2T4N0Cg/Z/YTv+crCT/7
jh0/TyTfPibp2b6y+Uo/qiEIPybp2b6dXjs/AxIPP7Qrnr5S7EQ/ScMTP4PZP74iYEs/sygW
P/tMgL1ArU4/cwufvucrCb+07Eg/wCqRvuEhI788Xjc/1BVEvuEhI79cBT8/xa7FveEhI780
rEM/AAAAAOEhI78mOUU/xa7FPeEhI780rEM/1BVEPuEhI79cBT8/wCqRPuEhI788Xjc/cwuf
PucrCb+07Eg/jN4uP/tMgD0bODo/rB8sP4PZPz6gRDc/7qEmP7Qrnj5GdzE/p4sePybp2T4N
0Cg/Z/YTP+crCT/7jh0/mBf+PucrCT9t3S4/dyrQPucrCT/OXj0/u/69PuEhIz9u0Cw/OtSo
PlqWOj+Zjhk/Mv6APlqWOj9I3CI/+VEuPlqWOj+Jtik/j1GvPVqWOj+G0C0/AAAAAFqWOj8P
Ny8/j1GvvVqWOj+G0C0/+VEuvlqWOj+Jtik/u/69vuEhIz9u0Cw/Mv6AvlqWOj9I3CI/OtSo
vlqWOj+Zjhk/hdVEv/tMgD16zyI/jN4uv/tMgL0bODo/Mb1Bv4PZPz5wQiA/rB8sv4PZP76g
RDc/7qEmv7Qrnr5GdzE/p4sevybp2b4N0Cg/Z/YTv+crCb/7jh0/mBf+vucrCb9t3S4/dyrQ
vucrCb/OXj0/iYw7v7Qrnj5aKBs/q3Yyvybp2T7VmhM/8dPnvuEhIz8rjx8/X4gmv+crCT9M
wAk/vPsGv+EhIz/ewA8/w/QXv+EhIz+zZPs+dyrQPucrCb/OXj0/mBf+PucrCb9t3S4/Z/YT
P+crCb/7jh0/p4sePybp2b4N0Cg/7qEmP7Qrnr5GdzE/rB8sP4PZP76gRDc/jN4uP/tMgL0b
ODo/u/69vuEhI79u0Cw/OtSovlqWOr+Zjhk/Mv6AvlqWOr9I3CI/+VEuvlqWOr+Jtik/j1Gv
vVqWOr+G0C0/AAAAAFqWOr8PNy8/j1GvPVqWOr+G0C0/+VEuPlqWOr+Jtik/Mv6APlqWOr9I
3CI/OtSoPlqWOr+Zjhk/u/69PuEhI79u0Cw/hdVEP/tMgD16zyI/Mb1BP4PZPz5wQiA/iYw7
P7Qrnj5aKBs/q3YyPybp2T7VmhM/X4gmP+crCT9MwAk/w/QXP+EhIz+zZPs+vPsGP+EhIz/e
wA8/8dPnPuEhIz8rjx8/KvjNPlqWOj+twA0/oveQPtoVTz9W2QM/z3FdPtoVTz8Y2gs/WI8V
PtoVTz9ypxE/746WPdoVTz9kQRU/AAAAANoVTz+0dBY/746WvdoVTz9kQRU/WI8VvtoVTz9y
pxE/z3FdvtoVTz8Y2gs/KvjNvlqWOj+twA0/oveQvtoVTz9W2QM/KrRXv/tMgD3P2Qg/hdVE
v/tMgL16zyI/Mb1Bv4PZP75wQiA/KU9Uv4PZPz41swY/J4VNv7Qrnj7NcgI/iYw7v7Qrnr5a
KBs/q3Yyvybp2b7VmhM/X4gmv+crCb9MwAk/w/QXv+EhI7+zZPs+vPsGv+EhI7/ewA8/8dPn
vuEhI78rjx8/QYlDvybp2T4yMfg+OOrvvlqWOj+xfv8+B3U2v+crCT8Eluc+X4gmv+EhIz/l
YNM+vPsGv1qWOj8JYt8+Z/YTv1qWOj8Nxbs+8dPnPuEhI78rjx8/vPsGP+EhI7/ewA8/w/QX
P+EhI7+zZPs+X4gmP+crCb9MwAk/q3YyPybp2b7VmhM/iYw7P7Qrnr5aKBs/Mb1BP4PZP75w
QiA/hdVEP/tMgL16zyI/KvjNvlqWOr+twA0/oveQvtoVT79W2QM/z3FdvtoVT78Y2gs/WI8V
vtoVT79ypxE/746WvdoVT79kQRU/AAAAANoVT7+0dBY/746WPdoVT79kQRU/WI8VPtoVT79y
pxE/z3FdPtoVT78Y2gs/oveQPtoVT79W2QM/KvjNPlqWOr+twA0/KrRXP/tMgD0BzQg/KU9U
P4PZPz41swY/J4VNP7Qrnj7NcgI/QYlDPybp2T4yMfg+B3U2P+crCT8Eluc+X4gmP+EhIz/l
YNM+Z/YTP1qWOj8Nxbs+vPsGP1qWOj8JYt8+OOrvPlqWOj8VZf8+KvjNPtoVTz8MSNs+8tCw
PtoVTz/wY/M+oveQPmVTYD9decc+XJ5tPmVTYD+LFNg+OII1PmVTYD//SOU+2DT1PWVTYD+D
4+4+yc12PWVTYD/dsPQ+AAAAAGVTYD9xl/Y+yc12vWVTYD/dsPQ+2DT1vWVTYD+D4+4+OII1
vmVTYD//SOU+8tCwvtoVTz/wY/M+XJ5tvmVTYD+LFNg+oveQvmVTYD9decc+ByFnv/tMgD0T
e9k+KrRXv/tMgL3P2Qg/KU9Uv4PZP741swY/J4VNv7Qrnr7NcgI/IHxjv4PZPz5aFNY+4Utc
v7Qrnj7oRs8+QYlDvybp2b4yMfg+B3U2v+crCb8Eluc+X4gmv+EhI7/lYNM+Z/YTv1qWOr8N
xbs+vPsGv1qWOr8JYt8+OOrvvlqWOr+xfv8+SpBRvybp2T5YLMU+KvjNvtoVTz8MSNs+8dPn
vtoVTz/Sq78+QYlDv+crCT/k97c+q3Yyv+EhIz9e9qc+mBf+vtoVTz/sKKE+p4sev1qWOj/I
J5U+qiEIv9oVTz8sDIA+OOrvPlqWOr8VZf8+vPsGP1qWOr8JYt8+Z/YTP1qWOr8Nxbs+X4gm
P+EhI7/lYNM+B3U2P+crCb8Eluc+QYlDPybp2b4yMfg+J4VNP7Qrnr7NcgI/KU9UP4PZP741
swY/KrRXP/tMgL0BzQg/8tCwvtoVT7/wY/M+oveQvmVTYL9decc+XJ5tvmVTYL+LFNg+OII1
vmVTYL//SOU+2DT1vWVTYL+D4+4+yc12vWVTYL/dsPQ+AAAAAGVTYL9xl/Y+yc12PWVTYL/d
sPQ+2DT1PWVTYL+D4+4+OII1PmVTYL//SOU+XJ5tPmVTYL+LFNg+oveQPmVTYL9decc+8tCw
PtoVT7/wY/M+KvjNPtoVT78MSNs+ByFnP/tMgD0Te9k+IHxjP4PZPz5aFNY+4UtcP7Qrnj7o
Rs8+SpBRPybp2T5YLMU+QYlDP+crCT/k97c+q3YyP+EhIz9e9qc+p4seP1qWOj/IJ5U+qiEI
P9oVTz8sDIA+mBf+PtoVTz/sKKE+8dPnPtoVTz/Sq78+OtSoPmVTYD9KxLM+z3FdPgECbj/l
dJg+OII1PgECbj9NKaU+3JMKPgECbj9BKq8+o0y7PQECbj+/d7Y+WH88PQECbj8t+Lo+AAAA
AAECbj9ReLw+WH88vQECbj8t+Lo+o0y7vQECbj+/d7Y+3JMKvgECbj9BKq8+OII1vgECbj9N
KaU+OtSovmVTYD9KxLM+z3FdvgECbj/ldJg+xPVyv/tMgD3P250+ByFnv/tMgL0Te9k+IHxj
v4PZP75aFNY+4Utcv7Qrnr7oRs8+vx1vv4PZPz6SW5s+Q4dnv7Qrnj60dJY+4Utcvybp2T42
J48+SpBRvybp2b5YLMU+QYlDv+crCb/k97c+q3Yyv+EhI79e9qc+p4sev1qWOr/IJ5U+qiEI
v9oVT78sDIA+mBf+vtoVT7/sKKE+8dPnvtoVT7/Sq78+KvjNvtoVT78MSNs+u/69vmVTYD/u
Dp0+J4VNv+crCT+yjIU+iYw7v+EhIz/EsHM+7qEmv1qWOj/7elg+dyrQvmVTYD8qJoQ+TyTf
vmVTYD/B4FE+AxIPv9oVTz943jk+8dPnPtoVT7/Sq78+mBf+PtoVT7/sKKE+qiEIP9oVT78s
DIA+p4seP1qWOr/IJ5U+q3YyP+EhI79e9qc+QYlDP+crCb/k97c+SpBRPybp2b5YLMU+4Utc
P7Qrnr7oRs8+IHxjP4PZP75aFNY+ByFnP/tMgL0Te9k+OtSovmVTYL9KxLM+z3FdvgECbr/l
dJg+OII1vgECbr9NKaU+3JMKvgECbr9BKq8+o0y7vQECbr+/d7Y+WH88vQECbr8t+Lo+AAAA
AAECbr9ReLw+WH88PQECbr8t+Lo+o0y7PQECbr+/d7Y+3JMKPgECbr9BKq8+OII1PgECbr9N
KaU+z3FdPgECbr/ldJg+OtSoPmVTYL9KxLM+xPVyP/tMgD3P250+vx1vP4PZPz6SW5s+Q4dn
P7Qrnj60dJY+4UtcPybp2T42J48+J4VNP+crCT+yjIU+iYw7P+EhIz/EsHM+7qEmP1qWOj/7
elg+AxIPP9oVTz943jk+TyTfPmVTYD/B4FE+dyrQPmVTYD8qJoQ+u/69PmVTYD/uDp0+wCqR
PgECbj/TFnA+Mv6APgECbj/cWYk++VEuPlzudz8IeDk+WI8VPlzudz9f4E0+2DT1PVzudz81
FV8+o0y7PVzudz8asGw+kDF9PVzudz/VfXY+CP79PFzudz9ofnw+AAAAAFzudz+Yfn4+CP79
vFzudz9ofnw+kDF9vVzudz/VfXY+o0y7vVzudz8asGw+2DT1vVzudz81FV8+Mv6AvgECbj/c
WYk+wCqRvgECbj/TFnA+WI8Vvlzudz9f4E0++VEuvlzudz8IeDk+fPJ6v/tMgD2aeD8+xPVy
v/tMgL3P250+6AB3v4PZPz5ReDw+vx1vv4PZP76SW5s+Q4dnv7Qrnr60dJY+4Utcvybp2b42
J48+vx1vv7Qrnj6/dzY+IHxjvybp2T7kdi0+KU9Uv+crCT8w3CE+J4VNv+crCb+yjIU+iYw7
v+EhI7/EsHM+7qEmv1qWOr/7elg+AxIPv9oVT7943jk+TyTfvmVTYL/B4FE+dyrQvmVTYL8q
JoQ+u/69vmVTYL/uDp0+Mb1Bv+EhIz+jpxM+rB8sv1qWOj91DAM+cwufvgECbj/+30k+u4aq
vgECbj+odSA+CIbqvmVTYD+tQRg+ScMTv9oVTz+eSOE9EzbyvmVTYD9g3rg9u/69PmVTYL/u
Dp0+dyrQPmVTYL8qJoQ+TyTfPmVTYL/B4FE+AxIPP9oVT7943jk+7qEmP1qWOr/7elg+iYw7
P+EhI7/EsHM+J4VNP+crCb+yjIU+4UtcPybp2b42J48+Q4dnP7Qrnr60dJY+vx1vP4PZP76S
W5s+xPVyP/tMgL3P250+wCqRvgECbr/TFnA+Mv6AvgECbr/cWYk++VEuvlzud78IeDk+WI8V
vlzud79f4E0+2DT1vVzud781FV8+o0y7vVzud78asGw+kDF9vVzud7/VfXY+CP79vFzud79o
fnw+AAAAAFzud7+Yfn4+CP79PFzud79ofnw+kDF9PVzud7/VfXY+o0y7PVzud78asGw+2DT1
PVzud781FV8+WI8VPlzud79f4E0++VEuPlzud78IeDk+Mv6APgECbr/cWYk+wCqRPgECbr/T
FnA+fPJ6P/tMgD2aeD8+6AB3P4PZPz5ReDw+vx1vP7Qrnj6/dzY+IHxjPybp2T7kdi0+KU9U
P+crCT8w3CE+Mb1BP+EhIz+jpxM+rB8sP1qWOj91DAM+ScMTP9oVTz+eSOE9EzbyPmVTYD9g
3rg9CIbqPmVTYD+tQRg+u4aqPgECbj+odSA+cwufPgECbj/+30k+6tpWPlzudz9fcwg+1BVE
Plzudz+gQiI+xa7FPfjxfT+5QqM9j1GvPfjxfT+R3ro9746WPfjxfT/oRs89yc12PfjxfT8u
4uA9WH88PfjxfT8Tfe49CP79PPjxfT8Gfvg9+pZ/PPjxfT+Yfv49AAAAAPjxfT8sDAA++pZ/
vPjxfT+Yfv49CP79vPjxfT8Gfvg9WH88vfjxfT8Tfe49yc12vfjxfT8u4uA91BVEvlzudz+g
QiI+6tpWvlzudz9fcwg+746WvfjxfT/oRs89j1GvvfjxfT+R3ro9xa7FvfjxfT+5QqM9n/1+
v/tMgD0sDIA9fPJ6v/tMgL2aeD8+6AB3v4PZP75ReDw+xPVyv7Qrnj41F3Q9fPJ6v4PZPz73
F3w9vx1vv7Qrnr6/dzY+IHxjvybp2b7kdi0+KU9Uv+crCb8w3CE+ByFnvybp2T4QFmg9KrRX
v+crCT9r4Vg9Mb1Bv+EhI7+jpxM+rB8sv1qWOr91DAM+ScMTv9oVT7+eSOE9EzbyvmVTYL9g
3rg9CIbqvmVTYL+tQRg+u4aqvgECbr+odSA+cwufvgECbr/+30k+hdVEv+EhIz9lrEU9jN4u
v1qWOj/dQy89sygWv9oVTz+0dBY9XDazvgECbj/x4ug9/zpmvlzudz/7etg99QJyvlzudz+2
25w9Vxq5vgECbj+hQI094Br2vmVTYD/VffY8HBm8vgECbj8BRbs8cwufPgECbr/+30k+u4aq
PgECbr+odSA+CIbqPmVTYL+tQRg+EzbyPmVTYL9g3rg9ScMTP9oVT7+eSOE9rB8sP1qWOr91
DAM+Mb1BP+EhI7+jpxM+KU9UP+crCb8w3CE+IHxjPybp2b7kdi0+vx1vP7Qrnr6/dzY+6AB3
P4PZP75ReDw+fPJ6P/tMgL2aeD8+6tpWvlzud79fcwg+1BVEvlzud7+gQiI+xa7Fvfjxfb+5
QqM9j1Gvvfjxfb+R3ro9746Wvfjxfb/oRs89yc12vfjxfb8u4uA9WH88vfjxfb8Tfe49CP79
vPjxfb8Gfvg9+pZ/vPjxfb+Yfv49AAAAAPjxfb8sDAA++pZ/PPjxfb+Yfv49CP79PPjxfb8G
fvg9WH88Pfjxfb8Tfe49yc12Pfjxfb8u4uA9746WPfjxfb/oRs89j1GvPfjxfb+R3ro9xa7F
Pfjxfb+5QqM91BVEPlzud7+gQiI+6tpWPlzud79fcwg+n/1+P/tMgD0sDIA9fPJ6P4PZPz73
F3w9xPVyP7Qrnj41F3Q9ByFnPybp2T4QFmg9KrRXP+crCT9r4Vg9hdVEP+EhIz9lrEU9jN4u
P1qWOj/dQy89sygWP9oVTz+0dBY94Br2PmVTYD/VffY8HBm8PgECbj8BRbs8Vxq5PgECbj+h
QI09XDazPgECbj/x4ug99QJyPlzudz+225w9/zpmPlzudz/7etg9DwfoPfjxfT8se1o93HPY
PfjxfT9AQIk9AAAAAAAAgD8AAAAA3HPYvfjxfT9AQIk9DwfovfjxfT8se1o9n/1+v/tMgD0s
DIC9n/1+v/tMgL0sDIA9fPJ6v4PZP773F3w9xPVyv7Qrnr41F3Q9xPVyv7Qrnj41F3S9fPJ6
v4PZPz73F3y9ByFnvybp2b4QFmg9KrRXv+crCb9r4Vg9ByFnvybp2T4QFmi9KrRXv+crCT9r
4Vi9hdVEv+EhI79lrEU9jN4uv1qWOr/dQy89sygWv9oVT7+0dBY94Br2vmVTYL/VffY8HBm8
vgECbr8BRbs8Vxq5vgECbr+hQI09XDazvgECbr/x4ug99QJyvlzud7+225w9/zpmvlzud7/7
etg9hdVEv+EhIz9lrEW9jN4uv1qWOj/dQy+9sygWv9oVTz+0dBa9rf95vlzudz+CeD49IwL0
vfjxfT93dR494Br2vmVTYD/Vffa8CP59vlzudz/Y5Hw8HBm8vgECbj8BRbu8/zpmPlzud7/7
etg99QJyPlzud7+225w9XDazPgECbr/x4ug9Vxq5PgECbr+hQI09HBm8PgECbr8BRbs84Br2
PmVTYL/VffY8sygWP9oVT7+0dBY9jN4uP1qWOr/dQy89hdVEP+EhI79lrEU9KrRXP+crCb9r
4Vg9ByFnPybp2b4QFmg9xPVyP7Qrnr41F3Q9fPJ6P4PZP773F3w9n/1+P/tMgL0sDIA9Dwfo
vfjxfb8se1o93HPYvfjxfb9AQIk9AAAAAAAAgL8AAAAA3HPYPfjxfb9AQIk9DwfoPfjxfb8s
e1o9n/1+P/tMgD0sDIC9fPJ6P4PZPz73F3y9xPVyP7Qrnj41F3S9ByFnPybp2T4QFmi9KrRX
P+crCT9r4Vi9hdVEP+EhIz9lrEW9jN4uP1qWOj/dQy+9sygWP9oVTz+0dBa94Br2PmVTYD/V
ffa8HBm8PgECbj8BRbu8CP59Plzudz/Y5Hw8rf95Plzudz+CeD49IwL0PfjxfT93dR492v77
PfjxfT9DEsA8Nv3/PfjxfT8sDAA8Nv3/PfjxfT8sDAC82v77PfjxfT9DEsC8IwL0PfjxfT93
dR69DwfoPfjxfT8se1q93HPYPfjxfT9AQIm9xa7FPfjxfT+5QqO9j1GvPfjxfT+R3rq9746W
PfjxfT/oRs+9yc12PfjxfT8u4uC9WH88PfjxfT8Tfe69CP79PPjxfT8Gfvi9+pZ/PPjxfT+Y
fv69AAAAAPjxfT8sDAC++pZ/vPjxfT+Yfv69CP79vPjxfT8Gfvi9WH88vfjxfT8Tfe69yc12
vfjxfT8u4uC9746WvfjxfT/oRs+9j1GvvfjxfT+R3rq9xa7FvfjxfT+5QqO93HPYvfjxfT9A
QIm9DwfovfjxfT8se1q9IwL0vfjxfT93dR692v77vfjxfT9DEsC8Nv3/vfjxfT8sDAC8Nv3/
vfjxfT8sDAA82v77vfjxfT9DEsA8fPJ6v/tMgD2aeD++n/1+v/tMgL0sDIC96AB3v4PZPz5R
eDy+fPJ6v4PZP773F3y9xPVyv7Qrnr41F3S9vx1vv7Qrnj6/dza+IHxjvybp2T7kdi2+ByFn
vybp2b4QFmi9KrRXv+crCb9r4Vi9KU9Uv+crCT8w3CG+Mb1Bv+EhIz+jpxO+hdVEv+EhI79l
rEW9jN4uv1qWOr/dQy+9sygWv9oVT7+0dBa94Br2vmVTYL/Vffa8HBm8vgECbr8BRbu8CP59
vlzud7/Y5Hw8rf95vlzud7+CeD49IwL0vfjxfb93dR49rB8sv1qWOj91DAO+EzbyvmVTYD9g
3ri9ScMTv9oVTz+eSOG9CP59vlzudz/Y5Hy8Vxq5vgECbj+hQI29rf95vlzudz+CeD69IwL0
Pfjxfb93dR49rf95Plzud7+CeD49CP59Plzud7/Y5Hw8HBm8PgECbr8BRbu84Br2PmVTYL/V
ffa8sygWP9oVT7+0dBa9jN4uP1qWOr/dQy+9hdVEP+EhI79lrEW9KrRXP+crCb9r4Vi9ByFn
Pybp2b4QFmi9xPVyP7Qrnr41F3S9fPJ6P4PZP773F3y9n/1+P/tMgL0sDIC9AAAAAPjxfb8s
DAC++pZ/PPjxfb+Yfv69CP79PPjxfb8Gfvi9WH88Pfjxfb8Tfe69yc12Pfjxfb8u4uC9746W
Pfjxfb/oRs+9j1GvPfjxfb+R3rq9xa7FPfjxfb+5QqO93HPYPfjxfb9AQIm9DwfoPfjxfb8s
e1q9IwL0Pfjxfb93dR692v77Pfjxfb9DEsC8Nv3/Pfjxfb8sDAC8Nv3/Pfjxfb8sDAA82v77
Pfjxfb9DEsA82v77vfjxfb9DEsA8Nv3/vfjxfb8sDAA8Nv3/vfjxfb8sDAC82v77vfjxfb9D
EsC8IwL0vfjxfb93dR69Dwfovfjxfb8se1q93HPYvfjxfb9AQIm9xa7Fvfjxfb+5QqO9j1Gv
vfjxfb+R3rq9746Wvfjxfb/oRs+9yc12vfjxfb8u4uC9WH88vfjxfb8Tfe69CP79vPjxfb8G
fvi9+pZ/vPjxfb+Yfv69fPJ6P/tMgD2aeD++6AB3P4PZPz5ReDy+vx1vP7Qrnj6/dza+IHxj
Pybp2T7kdi2+KU9UP+crCT8w3CG+Mb1BP+EhIz+jpxO+rB8sP1qWOj91DAO+ScMTP9oVTz+e
SOG9EzbyPmVTYD9g3ri9Vxq5PgECbj+hQI29rf95Plzudz+CeD69CP59Plzudz/Y5Hy89QJy
Plzudz+225y9/zpmPlzudz/7eti96tpWPlzudz9fcwi+1BVEPlzudz+gQiK++VEuPlzudz8I
eDm+WI8VPlzudz9f4E2+2DT1PVzudz81FV++o0y7PVzudz8asGy+kDF9PVzudz/VfXa+CP79
PFzudz9ofny+AAAAAFzudz+Yfn6+CP79vFzudz9ofny+kDF9vVzudz/VfXa+o0y7vVzudz8a
sGy+2DT1vVzudz81FV++WI8Vvlzudz9f4E2++VEuvlzudz8IeDm+1BVEvlzudz+gQiK+6tpW
vlzudz9fcwi+/zpmvlzudz/7eti99QJyvlzudz+225y9xPVyv/tMgD3P252+fPJ6v/tMgL2a
eD++6AB3v4PZP75ReDy+Q4dnv7Qrnj60dJa+vx1vv4PZPz6SW5u+vx1vv7Qrnr6/dza+IHxj
vybp2b7kdi2+4Utcvybp2T42J4++KU9Uv+crCb8w3CG+Mb1Bv+EhI7+jpxO+iYw7v+EhIz/E
sHO+J4VNv+crCT+yjIW+7qEmv1qWOj/7eli+rB8sv1qWOr91DAO+ScMTv9oVT7+eSOG9Ezby
vmVTYL9g3ri9Vxq5vgECbr+hQI29rf95vlzud7+CeD69CP59vlzud7/Y5Hy8AxIPv9oVTz94
3jm+CIbqvmVTYD+tQRi+XDazvgECbj/x4ui9CP59Plzud7/Y5Hy8Vxq5PgECbr+hQI29Ezby
PmVTYL9g3ri9rf95Plzud7+CeD69ScMTP9oVT7+eSOG9rB8sP1qWOr91DAO+Mb1BP+EhI7+j
pxO+KU9UP+crCb8w3CG+IHxjPybp2b7kdi2+vx1vP7Qrnr6/dza+6AB3P4PZP75ReDy+fPJ6
P/tMgL2aeD++AAAAAFzud7+Yfn6+CP79PFzud79ofny+kDF9PVzud7/VfXa+o0y7PVzud78a
sGy+2DT1PVzud781FV++WI8VPlzud79f4E2++VEuPlzud78IeDm+1BVEPlzud7+gQiK+6tpW
Plzud79fcwi+/zpmPlzud7/7eti99QJyPlzud7+225y99QJyvlzud7+225y9/zpmvlzud7/7
eti96tpWvlzud79fcwi+1BVEvlzud7+gQiK++VEuvlzud78IeDm+WI8Vvlzud79f4E2+2DT1
vVzud781FV++o0y7vVzud78asGy+kDF9vVzud7/VfXa+CP79vFzud79ofny+xPVyP/tMgD3P
252+vx1vP4PZPz6SW5u+Q4dnP7Qrnj60dJa+4UtcPybp2T42J4++J4VNP+crCT+yjIW+iYw7
P+EhIz/EsHO+7qEmP1qWOj/7eli+AxIPP9oVTz943jm+CIbqPmVTYD+tQRi+XDazPgECbj/x
4ui9u4aqPgECbj+odSC+cwufPgECbj/+30m+wCqRPgECbj/TFnC+Mv6APgECbj/cWYm+z3Fd
PgECbj/ldJi+OII1PgECbj9NKaW+3JMKPgECbj9BKq++o0y7PQECbj+/d7a+WH88PQECbj8t
+Lq+AAAAAAECbj9ReLy+WH88vQECbj8t+Lq+o0y7vQECbj+/d7a+3JMKvgECbj9BKq++OII1
vgECbj9NKaW+z3FdvgECbj/ldJi+Mv6AvgECbj/cWYm+wCqRvgECbj/TFnC+cwufvgECbj/+
30m+u4aqvgECbj+odSC+IHxjv4PZPz5aFNa+ByFnv/tMgD0Te9m+xPVyv/tMgL3P252+vx1v
v4PZP76SW5u+Q4dnv7Qrnr60dJa+4Utcv7Qrnj7oRs++4Utcvybp2b42J4++SpBRvybp2T5Y
LMW+QYlDv+crCT/k97e+J4VNv+crCb+yjIW+iYw7v+EhI7/EsHO+7qEmv1qWOr/7eli+q3Yy
v+EhIz9e9qe+p4sev1qWOj/IJ5W+qiEIv9oVTz8sDIC+AxIPv9oVT7943jm+CIbqvmVTYL+t
QRi+XDazvgECbr/x4ui9TyTfvmVTYD/B4FG+XDazPgECbr/x4ui9CIbqPmVTYL+tQRi+AxIP
P9oVT7943jm+7qEmP1qWOr/7eli+iYw7P+EhI7/EsHO+J4VNP+crCb+yjIW+4UtcPybp2b42
J4++Q4dnP7Qrnr60dJa+vx1vP4PZP76SW5u+xPVyP/tMgL3P252+AAAAAAECbr9ReLy+WH88
PQECbr8t+Lq+o0y7PQECbr+/d7a+3JMKPgECbr9BKq++OII1PgECbr9NKaW+z3FdPgECbr/l
dJi+Mv6APgECbr/cWYm+wCqRPgECbr/TFnC+cwufPgECbr/+30m+u4aqPgECbr+odSC+u4aq
vgECbr+odSC+cwufvgECbr/+30m+wCqRvgECbr/TFnC+Mv6AvgECbr/cWYm+z3FdvgECbr/l
dJi+OII1vgECbr9NKaW+3JMKvgECbr9BKq++o0y7vQECbr+/d7a+WH88vQECbr8t+Lq+ByFn
P/tMgD0Te9m+IHxjP4PZPz5aFNa+4UtcP7Qrnj7oRs++SpBRPybp2T5YLMW+QYlDP+crCT/k
97e+q3YyP+EhIz9e9qe+p4seP1qWOj/IJ5W+qiEIP9oVTz8sDIC+TyTfPmVTYD/B4FG+dyrQ
PmVTYD8qJoS+u/69PmVTYD/uDp2+OtSoPmVTYD9KxLO+oveQPmVTYD9dece+XJ5tPmVTYD+L
FNi+OII1PmVTYD//SOW+2DT1PWVTYD+D4+6+yc12PWVTYD/dsPS+AAAAAGVTYD9xl/a+yc12
vWVTYD/dsPS+2DT1vWVTYD+D4+6+OII1vmVTYD//SOW+XJ5tvmVTYD+LFNi+oveQvmVTYD9d
ece+OtSovmVTYD9KxLO+u/69vmVTYD/uDp2+dyrQvmVTYD8qJoS+KU9Uv4PZPz41swa/KrRX
v/tMgD3P2Qi/ByFnv/tMgL0Te9m+IHxjv4PZP75aFNa+4Utcv7Qrnr7oRs++J4VNv7Qrnj7N
cgK/QYlDvybp2T4yMfi+SpBRvybp2b5YLMW+QYlDv+crCb/k97e+B3U2v+crCT8Elue+q3Yy
v+EhI79e9qe+p4sev1qWOr/IJ5W+qiEIv9oVT78sDIC+X4gmv+EhIz/lYNO+Z/YTv1qWOj8N
xbu+mBf+vtoVTz/sKKG+TyTfvmVTYL/B4FG+TyTfPmVTYL/B4FG+qiEIP9oVT78sDIC+p4se
P1qWOr/IJ5W+q3YyP+EhI79e9qe+QYlDP+crCb/k97e+SpBRPybp2b5YLMW+4UtcP7Qrnr7o
Rs++IHxjP4PZP75aFNa+ByFnP/tMgL0Te9m+yc12vWVTYL/dsPS+AAAAAGVTYL9xl/a+yc12
PWVTYL/dsPS+2DT1PWVTYL+D4+6+OII1PmVTYL//SOW+XJ5tPmVTYL+LFNi+oveQPmVTYL9d
ece+OtSoPmVTYL9KxLO+u/69PmVTYL/uDp2+dyrQPmVTYL8qJoS+dyrQvmVTYL8qJoS+u/69
vmVTYL/uDp2+OtSovmVTYL9KxLO+oveQvmVTYL9dece+XJ5tvmVTYL+LFNi+OII1vmVTYL//
SOW+2DT1vWVTYL+D4+6+KrRXP/tMgD3P2Qi/KU9UP4PZPz41swa/J4VNP7Qrnj7NcgK/QYlD
Pybp2T4yMfi+B3U2P+crCT8Elue+X4gmP+EhIz/lYNO+Z/YTP1qWOj8Nxbu+mBf+PtoVTz/s
KKG+8dPnPtoVTz/Sq7++KvjNPtoVTz8MSNu+8tCwPtoVTz/wY/O+oveQPtoVTz9W2QO/z3Fd
PtoVTz8Y2gu/WI8VPtoVTz9ypxG/746WPdoVTz9kQRW/AAAAANoVTz+0dBa/746WvdoVTz9k
QRW/WI8VvtoVTz9ypxG/z3FdvtoVTz8Y2gu/oveQvtoVTz9W2QO/8tCwvtoVTz/wY/O+KvjN
vtoVTz8MSNu+8dPnvtoVTz/Sq7++Mb1Bv4PZPz5wQiC/hdVEv/tMgD16zyK/KrRXv/tMgL3P
2Qi/KU9Uv4PZP741swa/J4VNv7Qrnr7NcgK/QYlDvybp2b4yMfi+iYw7v7Qrnj5aKBu/q3Yy
vybp2T7VmhO/X4gmv+crCT9MwAm/B3U2v+crCb8Elue+X4gmv+EhI7/lYNO+Z/YTv1qWOr8N
xbu+mBf+vtoVT7/sKKG+w/QXv+EhIz+zZPu+vPsGv1qWOj8JYt++mBf+PtoVT7/sKKG+Z/YT
P1qWOr8Nxbu+X4gmP+EhI7/lYNO+B3U2P+crCb8Elue+QYlDPybp2b4yMfi+J4VNP7Qrnr7N
cgK/KU9UP4PZP741swa/KrRXP/tMgL3P2Qi/746WvdoVT79kQRW/AAAAANoVT7+0dBa/746W
PdoVT79kQRW/WI8VPtoVT79ypxG/z3FdPtoVT78Y2gu/oveQPtoVT79W2QO/8tCwPtoVT7/w
Y/O+KvjNPtoVT78MSNu+8dPnPtoVT7/Sq7++8dPnvtoVT7/Sq7++KvjNvtoVT78MSNu+8tCw
vtoVT7/wY/O+oveQvtoVT79W2QO/z3FdvtoVT78Y2gu/WI8VvtoVT79ypxG/hdVEP/tMgD16
zyK/Mb1BP4PZPz5wQiC/iYw7P7Qrnj5aKBu/q3YyPybp2T7VmhO/X4gmP+crCT9MwAm/w/QX
P+EhIz+zZPu+vPsGP1qWOj8JYt++OOrvPlqWOj+xfv++KvjNPlqWOj+twA2/OtSoPlqWOj+Z
jhm/Mv6APlqWOj9I3CK/+VEuPlqWOj+Jtim/j1GvPVqWOj+G0C2/AAAAAFqWOj8PNy+/j1Gv
vVqWOj+G0C2/+VEuvlqWOj+Jtim/Mv6AvlqWOj9I3CK/OtSovlqWOj+Zjhm/KvjNvlqWOj+t
wA2/OOrvvlqWOj8VZf++7qEmv7Qrnj5GdzG/rB8sv4PZPz6gRDe/jN4uv/tMgD0bODq/hdVE
v/tMgL16zyK/Mb1Bv4PZP75wQiC/iYw7v7Qrnr5aKBu/q3Yyvybp2b7VmhO/X4gmv+crCb9M
wAm/p4sevybp2T4N0Ci/Z/YTv+crCT/7jh2/w/QXv+EhI7+zZPu+vPsGv1qWOr8JYt++vPsG
v+EhIz/ewA+/vPsGP1qWOr8JYt++w/QXP+EhI7+zZPu+X4gmP+crCb9MwAm/q3YyPybp2b7V
mhO/iYw7P7Qrnr5aKBu/Mb1BP4PZP75wQiC/hdVEP/tMgL16zyK/+VEuvlqWOr+Jtim/j1Gv
vVqWOr+G0C2/AAAAAFqWOr8PNy+/j1GvPVqWOr+G0C2/+VEuPlqWOr+Jtim/Mv6APlqWOr9I
3CK/OtSoPlqWOr+Zjhm/KvjNPlqWOr+twA2/OOrvPlqWOr+xfv++OOrvvlqWOr8VZf++KvjN
vlqWOr+twA2/OtSovlqWOr+Zjhm/Mv6AvlqWOr9I3CK/jN4uP/tMgD0bODq/rB8sP4PZPz6g
RDe/7qEmP7Qrnj5GdzG/p4sePybp2T4N0Ci/Z/YTP+crCT/7jh2/vPsGP+EhIz/ewA+/8dPn
PuEhIz8rjx+/u/69PuEhIz9u0Cy/wCqRPuEhIz88Xje/1BVEPuEhIz9cBT+/xa7FPeEhIz80
rEO/AAAAAOEhIz8mOUW/xa7FveEhIz80rEO/1BVEvuEhIz9cBT+/wCqRvuEhIz88Xje/u/69
vuEhIz9u0Cy/8dPnvuEhIz8rjx+/AxIPv7Qrnj5S7ES/qiEIvybp2T6dXju/ScMTv4PZPz4i
YEu/sygWv/tMgD1ArU6/jN4uv/tMgL0bODq/rB8sv4PZP76gRDe/7qEmv7Qrnr5GdzG/p4se
vybp2b4N0Ci/Z/YTv+crCb/7jh2/mBf+vucrCT9t3S6/vPsGv+EhI7/ewA+/vPsGP+EhI7/e
wA+/Z/YTP+crCb/7jh2/p4sePybp2b4N0Ci/7qEmP7Qrnr5GdzG/rB8sP4PZP76gRDe/jN4u
P/tMgL0bODq/wCqRvuEhI788Xje/1BVEvuEhI79cBT+/xa7FveEhI780rEO/AAAAAOEhI78m
OUW/xa7FPeEhI780rEO/1BVEPuEhI79cBT+/wCqRPuEhI788Xje/u/69PuEhI79u0Cy/8dPn
PuEhI78rjx+/8dPnvuEhI78rjx+/u/69vuEhI79u0Cy/sygWP/tMgD1ArU6/ScMTP4PZPz4i
YEu/AxIPP7Qrnj5S7ES/qiEIPybp2T6dXju/mBf+PucrCT9t3S6/dyrQPucrCT/OXj2/cwuf
PucrCT+07Ei/6tpWPucrCT/nU1G/3HPYPecrCT/8bVa/AAAAAOcrCT9ZIVi/3HPYvecrCT/8
bVa/6tpWvucrCT/nU1G/cwufvucrCT+07Ei/dyrQvucrCT/OXj2/CIbqvrQrnj5IVFW/Ezby
voPZPz7yVFy/TyTfvibp2T6y+Uq/4Br2vvtMgD0W4l+/sygWv/tMgL1ArU6/ScMTv4PZP74i
YEu/AxIPv7Qrnr5S7ES/qiEIvybp2b6dXju/mBf+vucrCb9t3S6/mBf+PucrCb9t3S6/qiEI
Pybp2b6dXju/AxIPP7Qrnr5S7ES/ScMTP4PZP74iYEu/sygWP/tMgL1ArU6/dyrQvucrCb/O
Xj2/cwufvucrCb+07Ei/6tpWvucrCb/nU1G/3HPYvecrCb/8bVa/AAAAAOcrCb9ZIVi/3HPY
PecrCb/8bVa/6tpWPucrCb/nU1G/cwufPucrCb+07Ei/dyrQPucrCb/OXj2/4Br2PvtMgD0W
4l+/EzbyPoPZPz7yVFy/CIbqPrQrnj5IVFW/TyTfPibp2T6y+Uq/u4aqPibp2T55VFe//zpm
Pibp2T5UVWC/DwfoPSbp2T4MyWW/AAAAACbp2T4Elme/DwfovSbp2T4MyWW//zpmvibp2T5U
VWC/u4aqvibp2T55VFe/XDazvrQrnj6EVWK/Vxq5voPZPz5tyWm/HBm8vvtMgD3IiW2/4Br2
vvtMgL0W4l+/EzbyvoPZP77yVFy/CIbqvrQrnr5IVFW/TyTfvibp2b6y+Uq/TyTfPibp2b6y
+Uq/CIbqPrQrnr5IVFW/EzbyPoPZP77yVFy/4Br2PvtMgL0W4l+/u4aqvibp2b55VFe//zpm
vibp2b5UVWC/DwfovSbp2b4MyWW/AAAAACbp2b4Elme/DwfoPSbp2b4MyWW//zpmPibp2b5U
VWC/u4aqPibp2b55VFe/HBm8PvtMgD3IiW2/Vxq5PoPZPz5tyWm/XDazPrQrnj6EVWK/9QJy
PrQrnj6eyWu/IwL0PbQrnj4qinG/AAAAALQrnj6+cHO/IwL0vbQrnj4qinG/9QJyvrQrnj6e
yWu/rf95voPZPz5ainO/CP59vvtMgD0gcXe/HBm8vvtMgL3IiW2/Vxq5voPZP75tyWm/XDaz
vrQrnr6EVWK/XDazPrQrnr6EVWK/Vxq5PoPZP75tyWm/HBm8PvtMgL3IiW2/9QJyvrQrnr6e
yWu/IwL0vbQrnr4qinG/AAAAALQrnr6+cHO/IwL0PbQrnr4qinG/9QJyPrQrnr6eyWu/CP59
PvtMgD0gcXe/rf95PoPZPz5ainO/2v77PYPZPz5QcXm/AAAAAIPZPz6BcXu/2v77vYPZPz5Q
cXm/Nv3/vftMgD2ycX2/CP59vvtMgL0gcXe/rf95voPZP75ainO/rf95PoPZP75ainO/CP59
PvtMgL0gcXe/2v77vYPZP75QcXm/AAAAAIPZP76BcXu/2v77PYPZP75QcXm/Nv3/PftMgD2y
cX2/AAAAAPtMgD2xfn+/Nv3/vftMgL2ycX2/Nv3/PftMgL2ycX2/AAAAAPtMgL2xfn+/IBwA
AAAAAAABAAAACAAAAAAAAAAIAAAAAgAAAAAAAAACAAAACgAAAAAAAAAKAAAAAwAAAAAAAAAD
AAAABAAAAAAAAAAEAAAABQAAAAAAAAAFAAAABgAAAAAAAAAGAAAAAQAAAAEAAAAHAAAAFAAA
AAEAAAAUAAAACAAAAAEAAAAGAAAACQAAAAEAAAAJAAAABwAAAAIAAAAIAAAACwAAAAIAAAAL
AAAADAAAAAIAAAAMAAAADQAAAAIAAAANAAAACgAAAAMAAAAKAAAAGQAAAAMAAAAZAAAADgAA
AAMAAAAOAAAADwAAAAMAAAAPAAAABAAAAAQAAAAPAAAAEAAAAAQAAAAQAAAABQAAAAUAAAAQ
AAAAEQAAAAUAAAARAAAAEgAAAAUAAAASAAAABgAAAAYAAAASAAAACQAAAAcAAAATAAAAJgAA
AAcAAAAmAAAAFAAAAAcAAAAJAAAAEwAAAAgAAAAUAAAAFQAAAAgAAAAVAAAACwAAAAkAAAAW
AAAAEwAAAAkAAAASAAAAFwAAAAkAAAAXAAAAFgAAAAoAAAANAAAAGAAAAAoAAAAYAAAAGQAA
AAsAAAAVAAAAGgAAAAsAAAAaAAAADAAAAAwAAAAaAAAAGwAAAAwAAAAbAAAAHAAAAAwAAAAc
AAAADQAAAA0AAAAcAAAAGAAAAA4AAAAZAAAALgAAAA4AAAAuAAAAHQAAAA4AAAAdAAAADwAA
AA8AAAAdAAAAHgAAAA8AAAAeAAAAHwAAAA8AAAAfAAAAEAAAABAAAAAfAAAAIAAAABAAAAAg
AAAAIQAAABAAAAAhAAAAEQAAABEAAAAhAAAAIgAAABEAAAAiAAAAIwAAABEAAAAjAAAAEgAA
ABIAAAAjAAAAJAAAABIAAAAkAAAAFwAAABMAAAAlAAAAQAAAABMAAABAAAAAJgAAABMAAAAW
AAAAJQAAABQAAAAmAAAAFQAAABUAAAAnAAAAKAAAABUAAAAoAAAAGgAAABUAAAAmAAAAJwAA
ABYAAAApAAAAJQAAABYAAAAXAAAAKgAAABYAAAAqAAAAKwAAABYAAAArAAAAKQAAABcAAAAk
AAAAKgAAABgAAAAcAAAALAAAABgAAAAsAAAALQAAABgAAAAtAAAALgAAABgAAAAuAAAAGQAA
ABoAAAAoAAAALwAAABoAAAAvAAAAMAAAABoAAAAwAAAAGwAAABsAAAAwAAAAMQAAABsAAAAx
AAAAMgAAABsAAAAyAAAAHAAAABwAAAAyAAAAMwAAABwAAAAzAAAALAAAAB0AAAAuAAAASwAA
AB0AAABLAAAANAAAAB0AAAA0AAAAHgAAAB4AAAA0AAAANQAAAB4AAAA1AAAANgAAAB4AAAA2
AAAANwAAAB4AAAA3AAAAHwAAAB8AAAA3AAAAIAAAACAAAAA3AAAAOAAAACAAAAA4AAAAOQAA
ACAAAAA5AAAAOgAAACAAAAA6AAAAIQAAACEAAAA6AAAAOwAAACEAAAA7AAAAIgAAACIAAAA7
AAAAIwAAACMAAAA7AAAAPAAAACMAAAA8AAAAJAAAACQAAAA9AAAAKgAAACQAAAA8AAAAPgAA
ACQAAAA+AAAAPQAAACUAAAA/AAAAYgAAACUAAABiAAAAQAAAACUAAAApAAAAPwAAACYAAABA
AAAAJwAAACcAAABBAAAAQgAAACcAAABCAAAAQwAAACcAAABDAAAAKAAAACcAAABAAAAAQQAA
ACgAAABDAAAALwAAACkAAABEAAAAPwAAACkAAAArAAAARQAAACkAAABFAAAARAAAACoAAAA9
AAAARgAAACoAAABGAAAAKwAAACsAAABGAAAARwAAACsAAABHAAAARQAAACwAAAAzAAAASAAA
ACwAAABIAAAALQAAAC0AAABIAAAASQAAAC0AAABJAAAASgAAAC0AAABKAAAASwAAAC0AAABL
AAAALgAAAC8AAABMAAAATQAAAC8AAABNAAAATgAAAC8AAABOAAAAMAAAAC8AAABDAAAATAAA
ADAAAABOAAAATwAAADAAAABPAAAAMQAAADEAAABPAAAAMgAAADIAAABPAAAAUAAAADIAAABQ
AAAAMwAAADMAAABQAAAAUQAAADMAAABRAAAAUgAAADMAAABSAAAASAAAADQAAABLAAAAcQAA
ADQAAABxAAAAUwAAADQAAABTAAAANQAAADUAAABTAAAAVAAAADUAAABUAAAAVQAAADUAAABV
AAAANgAAADYAAABVAAAAVgAAADYAAABWAAAAVwAAADYAAABXAAAANwAAADcAAABXAAAAOAAA
ADgAAABXAAAAWAAAADgAAABYAAAAOQAAADkAAABYAAAAWQAAADkAAABZAAAAWgAAADkAAABa
AAAAOgAAADoAAABaAAAAWwAAADoAAABbAAAAOwAAADsAAABbAAAAXAAAADsAAABcAAAAXQAA
ADsAAABdAAAAPAAAADwAAABdAAAAXgAAADwAAABeAAAAPgAAAD0AAAA+AAAAXwAAAD0AAABf
AAAARgAAAD4AAABeAAAAYAAAAD4AAABgAAAAXwAAAD8AAABhAAAAjgAAAD8AAACOAAAAYgAA
AD8AAABEAAAAYwAAAD8AAABjAAAAYQAAAEAAAABiAAAAQQAAAEEAAABkAAAAZQAAAEEAAABl
AAAAQgAAAEEAAABiAAAAZAAAAEIAAABlAAAAZgAAAEIAAABmAAAAZwAAAEIAAABnAAAAQwAA
AEMAAABnAAAATAAAAEQAAABFAAAAYwAAAEUAAABoAAAAYwAAAEUAAABHAAAAaAAAAEYAAABf
AAAAaQAAAEYAAABpAAAAagAAAEYAAABqAAAARwAAAEcAAABrAAAAaAAAAEcAAABqAAAAbAAA
AEcAAABsAAAAawAAAEgAAABSAAAAbQAAAEgAAABtAAAASQAAAEkAAABtAAAAbgAAAEkAAABu
AAAAbwAAAEkAAABvAAAASgAAAEoAAABvAAAAcAAAAEoAAABwAAAAcQAAAEoAAABxAAAASwAA
AEwAAABnAAAAcgAAAEwAAAByAAAATQAAAE0AAAByAAAAcwAAAE0AAABzAAAAdAAAAE0AAAB0
AAAATgAAAE4AAAB0AAAAdQAAAE4AAAB1AAAATwAAAE8AAAB1AAAAdgAAAE8AAAB2AAAAdwAA
AE8AAAB3AAAAUAAAAFAAAAB3AAAAeAAAAFAAAAB4AAAAUQAAAFEAAAB4AAAAeQAAAFEAAAB5
AAAAegAAAFEAAAB6AAAAUgAAAFIAAAB6AAAAbQAAAFMAAABxAAAAogAAAFMAAACiAAAAewAA
AFMAAAB7AAAAfAAAAFMAAAB8AAAAVAAAAFQAAAB8AAAAVQAAAFUAAAB8AAAAfQAAAFUAAAB9
AAAAVgAAAFYAAAB9AAAAfgAAAFYAAAB+AAAAfwAAAFYAAAB/AAAAgAAAAFYAAACAAAAAVwAA
AFcAAACAAAAAgQAAAFcAAACBAAAAWAAAAFgAAACBAAAAWQAAAFkAAACBAAAAggAAAFkAAACC
AAAAgwAAAFkAAACDAAAAhAAAAFkAAACEAAAAhQAAAFkAAACFAAAAWgAAAFoAAACFAAAAWwAA
AFsAAACFAAAAhgAAAFsAAACGAAAAhwAAAFsAAACHAAAAXAAAAFwAAACHAAAAXQAAAF0AAACH
AAAAiAAAAF0AAACIAAAAiQAAAF0AAACJAAAAXgAAAF4AAACJAAAAYAAAAF8AAABgAAAAaQAA
AGAAAACKAAAAaQAAAGAAAACJAAAAiwAAAGAAAACLAAAAjAAAAGAAAACMAAAAigAAAGEAAACN
AAAAwgAAAGEAAADCAAAAjgAAAGEAAABjAAAAjwAAAGEAAACPAAAAjQAAAGIAAACOAAAAkAAA
AGIAAACQAAAAZAAAAGMAAABoAAAAjwAAAGQAAACQAAAAZQAAAGUAAACRAAAAZgAAAGUAAACQ
AAAAkQAAAGYAAACSAAAAkwAAAGYAAACTAAAAlAAAAGYAAACUAAAAZwAAAGYAAACRAAAAkgAA
AGcAAACUAAAAlQAAAGcAAACVAAAAcgAAAGgAAACWAAAAjwAAAGgAAABrAAAAlwAAAGgAAACX
AAAAlgAAAGkAAACKAAAAagAAAGoAAACKAAAAmAAAAGoAAACYAAAAbAAAAGsAAABsAAAAlwAA
AGwAAACZAAAAlwAAAGwAAACYAAAAmgAAAGwAAACaAAAAmwAAAGwAAACbAAAAmQAAAG0AAAB6
AAAAnAAAAG0AAACcAAAAnQAAAG0AAACdAAAAbgAAAG4AAACdAAAAngAAAG4AAACeAAAAnwAA
AG4AAACfAAAAoAAAAG4AAACgAAAAbwAAAG8AAACgAAAAoQAAAG8AAAChAAAAcAAAAHAAAACh
AAAAcQAAAHEAAAChAAAAogAAAHIAAACVAAAAcwAAAHMAAACjAAAApAAAAHMAAACkAAAApQAA
AHMAAAClAAAApgAAAHMAAACmAAAAdAAAAHMAAACVAAAAowAAAHQAAACmAAAAdQAAAHUAAACm
AAAApwAAAHUAAACnAAAAqAAAAHUAAACoAAAAdgAAAHYAAACoAAAAdwAAAHcAAACoAAAAqQAA
AHcAAACpAAAAqgAAAHcAAACqAAAAeAAAAHgAAACqAAAAeQAAAHkAAACqAAAAqwAAAHkAAACr
AAAArAAAAHkAAACsAAAArQAAAHkAAACtAAAAnAAAAHkAAACcAAAAegAAAHsAAACiAAAA2QAA
AHsAAADZAAAArgAAAHsAAACuAAAArwAAAHsAAACvAAAAfAAAAHwAAACvAAAAfQAAAH0AAACv
AAAAsAAAAH0AAACwAAAAsQAAAH0AAACxAAAAfgAAAH4AAACxAAAAfwAAAH8AAACxAAAAsgAA
AH8AAACyAAAAswAAAH8AAACzAAAAtAAAAH8AAAC0AAAAtQAAAH8AAAC1AAAAgAAAAIAAAAC1
AAAAggAAAIAAAACCAAAAgQAAAIIAAAC1AAAAgwAAAIMAAAC1AAAAtgAAAIMAAAC2AAAAtwAA
AIMAAAC3AAAAuAAAAIMAAAC4AAAAhAAAAIQAAAC4AAAAhQAAAIUAAAC4AAAAuQAAAIUAAAC5
AAAAugAAAIUAAAC6AAAAhgAAAIYAAAC6AAAAhwAAAIcAAAC6AAAAuwAAAIcAAAC7AAAAvAAA
AIcAAAC8AAAAiAAAAIgAAAC8AAAAiQAAAIkAAAC8AAAAvQAAAIkAAAC9AAAAvgAAAIkAAAC+
AAAAiwAAAIoAAACMAAAAmAAAAIsAAAC+AAAAjAAAAIwAAAC/AAAAmAAAAIwAAAC+AAAAwAAA
AIwAAADAAAAAvwAAAI0AAADBAAAA/QAAAI0AAAD9AAAAwgAAAI0AAACPAAAAwQAAAI4AAADC
AAAAwwAAAI4AAADDAAAAkAAAAI8AAADEAAAAwQAAAI8AAACWAAAAxQAAAI8AAADFAAAAxAAA
AJAAAADDAAAAkQAAAJEAAADGAAAAxwAAAJEAAADHAAAAkgAAAJEAAADDAAAAxgAAAJIAAADH
AAAAkwAAAJMAAADIAAAAyQAAAJMAAADJAAAAygAAAJMAAADKAAAAywAAAJMAAADLAAAAlAAA
AJMAAADHAAAAyAAAAJQAAADLAAAAowAAAJQAAACjAAAAlQAAAJYAAACXAAAAxQAAAJcAAADM
AAAAxQAAAJcAAACZAAAAzAAAAJgAAAC/AAAAzQAAAJgAAADNAAAAmgAAAJkAAADOAAAAzAAA
AJkAAACbAAAAzwAAAJkAAADPAAAAzgAAAJoAAADNAAAAmwAAAJsAAADNAAAA0AAAAJsAAADQ
AAAA0QAAAJsAAADRAAAAzwAAAJwAAACtAAAAnQAAAJ0AAACtAAAA0gAAAJ0AAADSAAAAngAA
AJ4AAADSAAAA0wAAAJ4AAADTAAAA1AAAAJ4AAADUAAAA1QAAAJ4AAADVAAAA1gAAAJ4AAADW
AAAAnwAAAJ8AAADWAAAAoAAAAKAAAADWAAAA1wAAAKAAAADXAAAA2AAAAKAAAADYAAAAoQAA
AKEAAADYAAAAogAAAKIAAADYAAAA2QAAAKMAAADLAAAApAAAAKQAAADLAAAA2gAAAKQAAADa
AAAA2wAAAKQAAADbAAAA3AAAAKQAAADcAAAApQAAAKUAAADcAAAApgAAAKYAAADcAAAA3QAA
AKYAAADdAAAA3gAAAKYAAADeAAAApwAAAKcAAADeAAAAqAAAAKgAAADeAAAA3wAAAKgAAADf
AAAA4AAAAKgAAADgAAAAqQAAAKkAAADgAAAAqgAAAKoAAADgAAAA4QAAAKoAAADhAAAA4gAA
AKoAAADiAAAAqwAAAKsAAADiAAAArAAAAKwAAADiAAAA4wAAAKwAAADjAAAA5AAAAKwAAADk
AAAA0gAAAKwAAADSAAAArQAAAK4AAADZAAAAGAEAAK4AAAAYAQAA5QAAAK4AAADlAAAA5gAA
AK4AAADmAAAArwAAAK8AAADmAAAA5wAAAK8AAADnAAAAsAAAALAAAADnAAAAsQAAALEAAADn
AAAA6AAAALEAAADoAAAAsgAAALIAAADoAAAA6QAAALIAAADpAAAA6gAAALIAAADqAAAAswAA
ALMAAADqAAAA6wAAALMAAADrAAAA7AAAALMAAADsAAAA7QAAALMAAADtAAAAtAAAALQAAADt
AAAAtQAAALUAAADtAAAAtgAAALYAAADtAAAA7gAAALYAAADuAAAA7wAAALYAAADvAAAAtwAA
ALcAAADvAAAA8AAAALcAAADwAAAA8QAAALcAAADxAAAA8gAAALcAAADyAAAAuAAAALgAAADy
AAAA8wAAALgAAADzAAAAuQAAALkAAADzAAAAugAAALoAAADzAAAA9AAAALoAAAD0AAAAuwAA
ALsAAAD0AAAA9QAAALsAAAD1AAAA9gAAALsAAAD2AAAAvAAAALwAAAD2AAAA9wAAALwAAAD3
AAAAvQAAAL0AAAD3AAAAvgAAAL4AAAD3AAAA+AAAAL4AAAD4AAAAwAAAAL8AAADAAAAA+QAA
AL8AAAD5AAAAzQAAAMAAAAD4AAAA+gAAAMAAAAD6AAAA+wAAAMAAAAD7AAAA+QAAAMEAAAD8
AAAAPwEAAMEAAAA/AQAA/QAAAMEAAADEAAAA/AAAAMIAAAD9AAAAwwAAAMMAAAD+AAAA/wAA
AMMAAAD/AAAAxgAAAMMAAAD9AAAA/gAAAMQAAAAAAQAA/AAAAMQAAADFAAAAAQEAAMQAAAAB
AQAAAAEAAMUAAADMAAAAAQEAAMYAAAD/AAAAxwAAAMcAAAACAQAAyAAAAMcAAAD/AAAAAgEA
AMgAAAADAQAABAEAAMgAAAAEAQAAyQAAAMgAAAACAQAAAwEAAMkAAAAEAQAABQEAAMkAAAAF
AQAABgEAAMkAAAAGAQAABwEAAMkAAAAHAQAAygAAAMoAAAAHAQAAywAAAMsAAAAHAQAA2gAA
AMwAAAAIAQAAAQEAAMwAAADOAAAACAEAAM0AAAD5AAAACQEAAM0AAAAJAQAACgEAAM0AAAAK
AQAA0AAAAM4AAAALAQAACAEAAM4AAADPAAAADAEAAM4AAAAMAQAACwEAAM8AAADRAAAADAEA
ANAAAAAKAQAADQEAANAAAAANAQAA0QAAANEAAAAOAQAADAEAANEAAAANAQAADwEAANEAAAAP
AQAADgEAANIAAADkAAAAEAEAANIAAAAQAQAA0wAAANMAAAAQAQAA1AAAANQAAAAQAQAAEQEA
ANQAAAARAQAAEgEAANQAAAASAQAAEwEAANQAAAATAQAA1QAAANUAAAATAQAAFAEAANUAAAAU
AQAAFQEAANUAAAAVAQAA1gAAANYAAAAVAQAAFgEAANYAAAAWAQAA1wAAANcAAAAWAQAA2AAA
ANgAAAAWAQAAFwEAANgAAAAXAQAA2QAAANkAAAAXAQAAGAEAANoAAAAHAQAAGQEAANoAAAAZ
AQAA2wAAANsAAAAZAQAAGgEAANsAAAAaAQAAGwEAANsAAAAbAQAAHAEAANsAAAAcAQAA3AAA
ANwAAAAcAQAAHQEAANwAAAAdAQAA3QAAAN0AAAAdAQAA3gAAAN4AAAAdAQAAHgEAAN4AAAAe
AQAA3wAAAN8AAAAeAQAAHwEAAN8AAAAfAQAAIAEAAN8AAAAgAQAA4AAAAOAAAAAgAQAAIQEA
AOAAAAAhAQAA4QAAAOEAAAAhAQAA4gAAAOIAAAAhAQAAIgEAAOIAAAAiAQAA4wAAAOMAAAAi
AQAAIwEAAOMAAAAjAQAAJAEAAOMAAAAkAQAAJQEAAOMAAAAlAQAA5AAAAOQAAAAlAQAAJgEA
AOQAAAAmAQAAEAEAAOUAAAAYAQAAXQEAAOUAAABdAQAAJwEAAOUAAAAnAQAA5gAAAOYAAAAn
AQAAKAEAAOYAAAAoAQAAKQEAAOYAAAApAQAA5wAAAOcAAAApAQAA6AAAAOgAAAApAQAAKgEA
AOgAAAAqAQAA6QAAAOkAAAAqAQAAKwEAAOkAAAArAQAALAEAAOkAAAAsAQAA6gAAAOoAAAAs
AQAA6wAAAOsAAAAsAQAALQEAAOsAAAAtAQAALgEAAOsAAAAuAQAALwEAAOsAAAAvAQAA7AAA
AOwAAAAvAQAAMAEAAOwAAAAwAQAA7gAAAOwAAADuAAAA7QAAAO4AAAAwAQAAMQEAAO4AAAAx
AQAA7wAAAO8AAAAxAQAA8AAAAPAAAAAxAQAAMgEAAPAAAAAyAQAAMwEAAPAAAAAzAQAA8QAA
APEAAAAzAQAA8gAAAPIAAAAzAQAANAEAAPIAAAA0AQAA8wAAAPMAAAA0AQAANQEAAPMAAAA1
AQAANgEAAPMAAAA2AQAA9AAAAPQAAAA2AQAANwEAAPQAAAA3AQAA9QAAAPUAAAA3AQAA9gAA
APYAAAA3AQAAOAEAAPYAAAA4AQAA9wAAAPcAAAA4AQAAOQEAAPcAAAA5AQAAOgEAAPcAAAA6
AQAA+AAAAPgAAAA6AQAAOwEAAPgAAAA7AQAA+gAAAPkAAAD7AAAAPAEAAPkAAAA8AQAACQEA
APoAAAA7AQAA+wAAAPsAAAA7AQAAPQEAAPsAAAA9AQAAPAEAAPwAAAA+AQAAiAEAAPwAAACI
AQAAPwEAAPwAAAAAAQAAPgEAAP0AAAA/AQAA/gAAAP4AAABAAQAAQQEAAP4AAABBAQAA/wAA
AP4AAAA/AQAAQAEAAP8AAABBAQAAAgEAAAABAABCAQAAPgEAAAABAAABAQAAQgEAAAEBAABD
AQAAQgEAAAEBAAAIAQAARAEAAAEBAABEAQAAQwEAAAIBAABBAQAARQEAAAIBAABFAQAAAwEA
AAMBAABGAQAARwEAAAMBAABHAQAABAEAAAMBAABFAQAARgEAAAQBAABHAQAABQEAAAUBAABH
AQAASAEAAAUBAABIAQAASQEAAAUBAABJAQAASgEAAAUBAABKAQAABgEAAAYBAABKAQAASwEA
AAYBAABLAQAABwEAAAcBAABLAQAATAEAAAcBAABMAQAAGQEAAAgBAAALAQAARAEAAAkBAAA8
AQAACgEAAAoBAAA8AQAATQEAAAoBAABNAQAADQEAAAsBAABOAQAARAEAAAsBAAAMAQAATgEA
AAwBAABPAQAATgEAAAwBAAAOAQAAUAEAAAwBAABQAQAATwEAAA0BAABNAQAAUQEAAA0BAABR
AQAAUgEAAA0BAABSAQAADwEAAA4BAAAPAQAAUAEAAA8BAABTAQAAUAEAAA8BAABSAQAAUwEA
ABABAAAmAQAAEQEAABEBAAAmAQAAVAEAABEBAABUAQAAVQEAABEBAABVAQAAEgEAABIBAABV
AQAAVgEAABIBAABWAQAAVwEAABIBAABXAQAAWAEAABIBAABYAQAAEwEAABMBAABYAQAAFAEA
ABQBAABYAQAAWQEAABQBAABZAQAAWgEAABQBAABaAQAAFQEAABUBAABaAQAAWwEAABUBAABb
AQAAFgEAABYBAABbAQAAFwEAABcBAABbAQAAXAEAABcBAABcAQAAXQEAABcBAABdAQAAGAEA
ABkBAABMAQAAXgEAABkBAABeAQAAGgEAABoBAABeAQAAXwEAABoBAABfAQAAYAEAABoBAABg
AQAAGwEAABsBAABgAQAAHAEAABwBAABgAQAAYQEAABwBAABhAQAAHQEAAB0BAABhAQAAYgEA
AB0BAABiAQAAYwEAAB0BAABjAQAAHgEAAB4BAABjAQAAZAEAAB4BAABkAQAAHwEAAB8BAABk
AQAAIAEAACABAABkAQAAZQEAACABAABlAQAAIQEAACEBAABlAQAAZgEAACEBAABmAQAAZwEA
ACEBAABnAQAAIgEAACIBAABnAQAAaAEAACIBAABoAQAAIwEAACMBAABoAQAAJAEAACQBAABo
AQAAaQEAACQBAABpAQAAagEAACQBAABqAQAAJQEAACUBAABqAQAAJgEAACYBAABqAQAAVAEA
ACcBAABdAQAAqAEAACcBAACoAQAAawEAACcBAABrAQAAKAEAACgBAABrAQAAbAEAACgBAABs
AQAAKQEAACkBAABsAQAAbQEAACkBAABtAQAAbgEAACkBAABuAQAAKgEAACoBAABuAQAAKwEA
ACsBAABuAQAAbwEAACsBAABvAQAALAEAACwBAABvAQAAcAEAACwBAABwAQAAcQEAACwBAABx
AQAALQEAAC0BAABxAQAALgEAAC4BAABxAQAAcgEAAC4BAAByAQAAcwEAAC4BAABzAQAALwEA
AC8BAABzAQAAdAEAAC8BAAB0AQAAdQEAAC8BAAB1AQAAMAEAADABAAB1AQAAMQEAADEBAAB1
AQAAdgEAADEBAAB2AQAAdwEAADEBAAB3AQAAMgEAADIBAAB3AQAAeAEAADIBAAB4AQAAeQEA
ADIBAAB5AQAAegEAADIBAAB6AQAAMwEAADMBAAB6AQAAewEAADMBAAB7AQAANAEAADQBAAB7
AQAANQEAADUBAAB7AQAAfAEAADUBAAB8AQAANgEAADYBAAB8AQAAfQEAADYBAAB9AQAANwEA
ADcBAAB9AQAAfgEAADcBAAB+AQAAfwEAADcBAAB/AQAAOAEAADgBAAB/AQAAgAEAADgBAACA
AQAAOQEAADkBAACAAQAAgQEAADkBAACBAQAAOgEAADoBAACBAQAAOwEAADsBAACBAQAAggEA
ADsBAACCAQAAPQEAADwBAAA9AQAAgwEAADwBAACDAQAAhAEAADwBAACEAQAATQEAAD0BAACC
AQAAhQEAAD0BAACFAQAAhgEAAD0BAACGAQAAgwEAAD4BAACHAQAA2gEAAD4BAADaAQAAiAEA
AD4BAABCAQAAiQEAAD4BAACJAQAAhwEAAD8BAACIAQAAQAEAAEABAACKAQAAQQEAAEABAACI
AQAAigEAAEEBAACLAQAAjAEAAEEBAACMAQAARQEAAEEBAACKAQAAiwEAAEIBAABDAQAAiQEA
AEMBAACNAQAAiQEAAEMBAABEAQAAjQEAAEQBAACOAQAAjQEAAEQBAABOAQAAjwEAAEQBAACP
AQAAjgEAAEUBAACMAQAARgEAAEYBAACQAQAARwEAAEYBAACMAQAAkAEAAEcBAACRAQAAkgEA
AEcBAACSAQAASAEAAEcBAACQAQAAkQEAAEgBAACSAQAASQEAAEkBAACTAQAAlAEAAEkBAACU
AQAASgEAAEkBAACSAQAAkwEAAEoBAACUAQAAlQEAAEoBAACVAQAAlgEAAEoBAACWAQAASwEA
AEsBAACWAQAAXgEAAEsBAABeAQAATAEAAE0BAACEAQAAUQEAAE4BAABPAQAAjwEAAE8BAACX
AQAAjwEAAE8BAABQAQAAlwEAAFABAACYAQAAlwEAAFABAABTAQAAmAEAAFEBAACEAQAAmQEA
AFEBAACZAQAAmgEAAFEBAACaAQAAUgEAAFIBAACbAQAAUwEAAFIBAACaAQAAmwEAAFMBAACc
AQAAmAEAAFMBAACbAQAAnQEAAFMBAACdAQAAnAEAAFQBAABqAQAAngEAAFQBAACeAQAAVQEA
AFUBAACeAQAAnwEAAFUBAACfAQAAoAEAAFUBAACgAQAAVgEAAFYBAACgAQAAoQEAAFYBAACh
AQAAogEAAFYBAACiAQAAVwEAAFcBAACiAQAAWAEAAFgBAACiAQAAowEAAFgBAACjAQAApAEA
AFgBAACkAQAAWQEAAFkBAACkAQAApQEAAFkBAAClAQAAWgEAAFoBAAClAQAAWwEAAFsBAACl
AQAApgEAAFsBAACmAQAApwEAAFsBAACnAQAAXAEAAFwBAACnAQAAqAEAAFwBAACoAQAAXQEA
AF4BAACWAQAAqQEAAF4BAACpAQAAqgEAAF4BAACqAQAAXwEAAF8BAACqAQAAqwEAAF8BAACr
AQAArAEAAF8BAACsAQAArQEAAF8BAACtAQAAYAEAAGABAACtAQAArgEAAGABAACuAQAAYQEA
AGEBAACuAQAAYgEAAGIBAACuAQAArwEAAGIBAACvAQAAYwEAAGMBAACvAQAAsAEAAGMBAACw
AQAAZAEAAGQBAACwAQAAsQEAAGQBAACxAQAAsgEAAGQBAACyAQAAZQEAAGUBAACyAQAAswEA
AGUBAACzAQAAZgEAAGYBAACzAQAAtAEAAGYBAAC0AQAAZwEAAGcBAAC0AQAAaAEAAGgBAAC0
AQAAtQEAAGgBAAC1AQAAaQEAAGkBAAC1AQAAtgEAAGkBAAC2AQAAtwEAAGkBAAC3AQAAuAEA
AGkBAAC4AQAAagEAAGoBAAC4AQAAuQEAAGoBAAC5AQAAngEAAGsBAACoAQAA/gEAAGsBAAD+
AQAAugEAAGsBAAC6AQAAuwEAAGsBAAC7AQAAbAEAAGwBAAC7AQAAbQEAAG0BAAC7AQAAvAEA
AG0BAAC8AQAAbgEAAG4BAAC8AQAAvQEAAG4BAAC9AQAAvgEAAG4BAAC+AQAAbwEAAG8BAAC+
AQAAcAEAAHABAAC+AQAAvwEAAHABAAC/AQAAcQEAAHEBAAC/AQAAwAEAAHEBAADAAQAAcgEA
AHIBAADAAQAAwQEAAHIBAADBAQAAwgEAAHIBAADCAQAAwwEAAHIBAADDAQAAcwEAAHMBAADD
AQAAxAEAAHMBAADEAQAAdAEAAHQBAADEAQAAxQEAAHQBAADFAQAAdgEAAHQBAAB2AQAAdQEA
AHYBAADFAQAAxgEAAHYBAADGAQAAxwEAAHYBAADHAQAAdwEAAHcBAADHAQAAeAEAAHgBAADH
AQAAyAEAAHgBAADIAQAAyQEAAHgBAADJAQAAygEAAHgBAADKAQAAeQEAAHkBAADKAQAAywEA
AHkBAADLAQAAegEAAHoBAADLAQAAewEAAHsBAADLAQAAzAEAAHsBAADMAQAAzQEAAHsBAADN
AQAAfAEAAHwBAADNAQAAzgEAAHwBAADOAQAAfQEAAH0BAADOAQAAfgEAAH4BAADOAQAAzwEA
AH4BAADPAQAA0AEAAH4BAADQAQAAfwEAAH8BAADQAQAA0QEAAH8BAADRAQAAgAEAAIABAADR
AQAAgQEAAIEBAADRAQAA0gEAAIEBAADSAQAA0wEAAIEBAADTAQAAggEAAIIBAADTAQAAhQEA
AIMBAACGAQAA1AEAAIMBAADUAQAAhAEAAIQBAADUAQAA1QEAAIQBAADVAQAAmQEAAIUBAADT
AQAA1gEAAIUBAADWAQAA1wEAAIUBAADXAQAAhgEAAIYBAADXAQAA2AEAAIYBAADYAQAA1AEA
AIcBAADZAQAAJgIAAIcBAAAmAgAA2gEAAIcBAACJAQAA2QEAAIgBAADaAQAA2wEAAIgBAADb
AQAAigEAAIkBAACNAQAA3AEAAIkBAADcAQAA3QEAAIkBAADdAQAA2QEAAIoBAADbAQAAiwEA
AIsBAADeAQAAjAEAAIsBAADbAQAA3gEAAIwBAADeAQAA3wEAAIwBAADfAQAA4AEAAIwBAADg
AQAAkAEAAI0BAACOAQAA3AEAAI4BAADhAQAA3AEAAI4BAACPAQAA4QEAAI8BAACXAQAA4gEA
AI8BAADiAQAA4QEAAJABAADgAQAAkQEAAJEBAADjAQAAkgEAAJEBAADgAQAA4wEAAJIBAADj
AQAA5AEAAJIBAADkAQAAkwEAAJMBAADlAQAA5gEAAJMBAADmAQAA5wEAAJMBAADnAQAAlAEA
AJMBAADkAQAA5QEAAJQBAADnAQAA6AEAAJQBAADoAQAAlQEAAJUBAADoAQAA6QEAAJUBAADp
AQAAqQEAAJUBAACpAQAAlgEAAJcBAADqAQAA4gEAAJcBAACYAQAA6gEAAJgBAADrAQAA6gEA
AJgBAACcAQAA7AEAAJgBAADsAQAA6wEAAJkBAADVAQAAmgEAAJoBAADtAQAAmwEAAJoBAADV
AQAA7gEAAJoBAADuAQAA7wEAAJoBAADvAQAA7QEAAJsBAADtAQAA8AEAAJsBAADwAQAAnQEA
AJwBAACdAQAA7AEAAJ0BAADxAQAA7AEAAJ0BAADwAQAA8gEAAJ0BAADyAQAA8QEAAJ4BAAC5
AQAAnwEAAJ8BAAC5AQAA8wEAAJ8BAADzAQAA9AEAAJ8BAAD0AQAAoAEAAKABAAD0AQAA9QEA
AKABAAD1AQAAoQEAAKEBAAD1AQAA9gEAAKEBAAD2AQAA9wEAAKEBAAD3AQAA+AEAAKEBAAD4
AQAAogEAAKIBAAD4AQAA+QEAAKIBAAD5AQAAowEAAKMBAAD5AQAA+gEAAKMBAAD6AQAApAEA
AKQBAAD6AQAApQEAAKUBAAD6AQAA+wEAAKUBAAD7AQAA/AEAAKUBAAD8AQAApgEAAKYBAAD8
AQAA/QEAAKYBAAD9AQAApwEAAKcBAAD9AQAAqAEAAKgBAAD9AQAA/gEAAKkBAADpAQAA/wEA
AKkBAAD/AQAAAAIAAKkBAAAAAgAAqgEAAKoBAAAAAgAAqwEAAKsBAAAAAgAAAQIAAKsBAAAB
AgAAAgIAAKsBAAACAgAAAwIAAKsBAAADAgAArAEAAKwBAAADAgAABAIAAKwBAAAEAgAArQEA
AK0BAAAEAgAArgEAAK4BAAAEAgAABQIAAK4BAAAFAgAABgIAAK4BAAAGAgAArwEAAK8BAAAG
AgAABwIAAK8BAAAHAgAAsAEAALABAAAHAgAAsQEAALEBAAAHAgAACAIAALEBAAAIAgAACQIA
ALEBAAAJAgAAsgEAALIBAAAJAgAACgIAALIBAAAKAgAAswEAALMBAAAKAgAAtAEAALQBAAAK
AgAACwIAALQBAAALAgAADAIAALQBAAAMAgAAtQEAALUBAAAMAgAAtgEAALYBAAAMAgAADQIA
ALYBAAANAgAADgIAALYBAAAOAgAAtwEAALcBAAAOAgAADwIAALcBAAAPAgAAEAIAALcBAAAQ
AgAAuAEAALgBAAAQAgAAuQEAALkBAAAQAgAAEQIAALkBAAARAgAA8wEAALoBAAD+AQAATQIA
ALoBAABNAgAAEgIAALoBAAASAgAAuwEAALsBAAASAgAAEwIAALsBAAATAgAAFAIAALsBAAAU
AgAAvAEAALwBAAAUAgAAvQEAAL0BAAAUAgAAFQIAAL0BAAAVAgAAvgEAAL4BAAAVAgAAFgIA
AL4BAAAWAgAAvwEAAL8BAAAWAgAAFwIAAL8BAAAXAgAAwAEAAMABAAAXAgAAGAIAAMABAAAY
AgAAGQIAAMABAAAZAgAAwQEAAMEBAAAZAgAAwgEAAMIBAAAZAgAAGgIAAMIBAAAaAgAAGwIA
AMIBAAAbAgAAHAIAAMIBAAAcAgAAwwEAAMMBAAAcAgAAHQIAAMMBAAAdAgAAxAEAAMQBAAAd
AgAAHgIAAMQBAAAeAgAAHwIAAMQBAAAfAgAAxgEAAMQBAADGAQAAxQEAAMYBAAAfAgAAIAIA
AMYBAAAgAgAAIQIAAMYBAAAhAgAAyAEAAMYBAADIAQAAxwEAAMgBAAAhAgAAIgIAAMgBAAAi
AgAAyQEAAMkBAAAiAgAAygEAAMoBAAAiAgAAywEAAMsBAAAiAgAAzAEAAMwBAAAiAgAAzQEA
AM0BAAAiAgAAzgEAAM4BAAAiAgAAzwEAAM8BAAAiAgAA0AEAANABAAAiAgAA0QEAANEBAAAi
AgAA0gEAANIBAAAiAgAA0wEAANMBAAAiAgAA1gEAANQBAADYAQAA1QEAANUBAADYAQAAIwIA
ANUBAAAjAgAAJAIAANUBAAAkAgAA7gEAANYBAAAiAgAA1wEAANcBAAAiAgAA2AEAANgBAAAi
AgAAIwIAANkBAADdAQAAKgIAANkBAAAqAgAAJQIAANkBAAAlAgAAfgIAANkBAAB+AgAAJgIA
ANoBAAAmAgAA2wEAANsBAAAnAgAAKAIAANsBAAAoAgAA3gEAANsBAAAmAgAAJwIAANwBAAAp
AgAAKgIAANwBAAAqAgAA3QEAANwBAADhAQAALQIAANwBAAAtAgAAKQIAAN4BAAAoAgAA3wEA
AN8BAAArAgAA4AEAAN8BAAAoAgAAKwIAAOABAAAsAgAA4wEAAOABAAArAgAALAIAAOEBAADi
AQAALgIAAOEBAAAuAgAALQIAAOIBAADqAQAAOAIAAOIBAAA4AgAALgIAAOMBAAAvAgAA5AEA
AOMBAAAsAgAALwIAAOQBAAAwAgAAMQIAAOQBAAAxAgAA5QEAAOQBAAAvAgAAMAIAAOUBAAAx
AgAA5gEAAOYBAAAyAgAAMwIAAOYBAAAzAgAANAIAAOYBAAA0AgAA5wEAAOYBAAAxAgAAMgIA
AOcBAAA0AgAANQIAAOcBAAA1AgAA6AEAAOgBAAA1AgAANgIAAOgBAAA2AgAANwIAAOgBAAA3
AgAA/wEAAOgBAAD/AQAA6QEAAOoBAADrAQAAOQIAAOoBAAA5AgAAOAIAAOsBAADsAQAAOgIA
AOsBAAA6AgAAOQIAAOwBAADxAQAAPQIAAOwBAAA9AgAAOgIAAO0BAADvAQAAOwIAAO0BAAA7
AgAA8AEAAO4BAAAkAgAAPAIAAO4BAAA8AgAA7wEAAO8BAAA8AgAAOwIAAPABAAA7AgAA8gEA
APEBAADyAQAAPwIAAPEBAAA/AgAAPQIAAPIBAAA7AgAAPgIAAPIBAAA+AgAAkwIAAPIBAACT
AgAAPwIAAPMBAAARAgAA9AEAAPQBAAARAgAAQAIAAPQBAABAAgAAQQIAAPQBAABBAgAAQgIA
APQBAABCAgAA9QEAAPUBAABCAgAAQwIAAPUBAABDAgAA9gEAAPYBAABDAgAARAIAAPYBAABE
AgAARQIAAPYBAABFAgAARgIAAPYBAABGAgAA9wEAAPcBAABGAgAA+AEAAPgBAABGAgAARwIA
APgBAABHAgAASAIAAPgBAABIAgAA+QEAAPkBAABIAgAASQIAAPkBAABJAgAA+gEAAPoBAABJ
AgAASgIAAPoBAABKAgAA+wEAAPsBAABKAgAASwIAAPsBAABLAgAA/AEAAPwBAABLAgAA/QEA
AP0BAABLAgAATAIAAP0BAABMAgAATQIAAP0BAABNAgAA/gEAAP8BAAA3AgAATgIAAP8BAABO
AgAATwIAAP8BAABPAgAAAQIAAP8BAAABAgAAAAIAAAECAABPAgAAUAIAAAECAABQAgAAAgIA
AAICAABQAgAAAwIAAAMCAABQAgAABAIAAAQCAABQAgAABQIAAAUCAABQAgAABgIAAAYCAABQ
AgAABwIAAAcCAABQAgAACAIAAAgCAABQAgAACQIAAAkCAABQAgAACgIAAAoCAABQAgAACwIA
AAsCAABQAgAADAIAAAwCAABQAgAADQIAAA0CAABQAgAADgIAAA4CAABQAgAADwIAAA8CAABQ
AgAAUQIAAA8CAABRAgAAEQIAAA8CAAARAgAAEAIAABECAABRAgAAUgIAABECAABSAgAAQAIA
ABICAABNAgAAogIAABICAACiAgAAUwIAABICAABTAgAAVAIAABICAABUAgAAEwIAABMCAABU
AgAAVQIAABMCAABVAgAAFAIAABQCAABVAgAAVgIAABQCAABWAgAAFQIAABUCAABWAgAAVwIA
ABUCAABXAgAAFgIAABYCAABXAgAAWAIAABYCAABYAgAAFwIAABcCAABYAgAAWQIAABcCAABZ
AgAAGAIAABgCAABZAgAAWgIAABgCAABaAgAAGQIAABkCAABaAgAAWwIAABkCAABbAgAAGgIA
ABoCAABbAgAAXAIAABoCAABcAgAAGwIAABsCAABcAgAAywIAABsCAADLAgAAXQIAABsCAABd
AgAAXgIAABsCAABeAgAAHAIAABwCAABeAgAAHQIAAB0CAABeAgAAHgIAAB4CAABeAgAAXwIA
AB4CAABfAgAAHwIAAB8CAABfAgAAIAIAACACAABfAgAAIgIAACACAAAiAgAAIQIAACICAABf
AgAAYAIAACICAABgAgAAYQIAACICAABhAgAAYgIAACICAABiAgAAYwIAACICAABjAgAAZAIA
ACICAABkAgAAZQIAACICAABlAgAAZgIAACICAABmAgAAZwIAACICAABnAgAAaAIAACICAABo
AgAAaQIAACICAABpAgAAagIAACICAABqAgAAawIAACICAABrAgAAbAIAACICAABsAgAAbQIA
ACICAABtAgAAbgIAACICAABuAgAAbwIAACICAABvAgAAcAIAACICAABwAgAAcQIAACICAABx
AgAAcgIAACICAAByAgAAcwIAACICAABzAgAAdAIAACICAAB0AgAAdQIAACICAAB1AgAAdgIA
ACICAAB2AgAAdwIAACICAAB3AgAAeAIAACICAAB4AgAAeQIAACICAAB5AgAAegIAACICAAB6
AgAAewIAACICAAB7AgAAfAIAACICAAB8AgAAPAIAACICAAA8AgAAJAIAACICAAAkAgAAIwIA
ACUCAAB9AgAA4gIAACUCAADiAgAAfgIAACUCAAAqAgAAfwIAACUCAAB/AgAAfQIAACYCAAB+
AgAAgAIAACYCAACAAgAAJwIAACcCAACAAgAAgQIAACcCAACBAgAAKAIAACgCAACBAgAAhAIA
ACgCAACEAgAAKwIAACkCAACCAgAAfwIAACkCAAB/AgAAKgIAACkCAAAtAgAAgwIAACkCAACD
AgAAggIAACsCAACEAgAAhQIAACsCAACFAgAALAIAACwCAACFAgAAiAIAACwCAACIAgAALwIA
AC0CAAAuAgAAhgIAAC0CAACGAgAAgwIAAC4CAAA4AgAAhwIAAC4CAACHAgAAhgIAAC8CAACI
AgAAiQIAAC8CAACJAgAAMAIAADACAACJAgAAigIAADACAACKAgAAMQIAADECAACKAgAAiwIA
ADECAACLAgAAMgIAADICAACLAgAAjAIAADICAACMAgAAMwIAADMCAACMAgAA8wIAADMCAADz
AgAAjQIAADMCAACNAgAAjgIAADMCAACOAgAANAIAADQCAACOAgAANQIAADUCAACOAgAANgIA
ADYCAACOAgAAjwIAADYCAACPAgAANwIAADcCAACPAgAATgIAADgCAAA5AgAAkAIAADgCAACQ
AgAAhwIAADkCAAA6AgAAkAIAADoCAAA9AgAAkQIAADoCAACRAgAAkgIAADoCAACSAgAAkAIA
ADsCAAA8AgAAfAIAADsCAAB8AgAAPgIAAD0CAAA/AgAAkQIAAD4CAAB8AgAAewIAAD4CAAB7
AgAAegIAAD4CAAB6AgAAkwIAAD8CAACUAgAAkQIAAD8CAACTAgAAlQIAAD8CAACVAgAAlAIA
AEACAABSAgAAlgIAAEACAACWAgAAQQIAAEECAACWAgAAlwIAAEECAACXAgAAQgIAAEICAACX
AgAAQwIAAEMCAACXAgAARAIAAEQCAACXAgAAmAIAAEQCAACYAgAA9wIAAEQCAAD3AgAAmQIA
AEQCAACZAgAAmgIAAEQCAACaAgAARQIAAEUCAACaAgAAmwIAAEUCAACbAgAARgIAAEYCAACb
AgAAnAIAAEYCAACcAgAARwIAAEcCAACcAgAAnQIAAEcCAACdAgAASAIAAEgCAACdAgAAngIA
AEgCAACeAgAASQIAAEkCAACeAgAAnwIAAEkCAACfAgAASgIAAEoCAACfAgAAoAIAAEoCAACg
AgAASwIAAEsCAACgAgAAoQIAAEsCAAChAgAATAIAAEwCAAChAgAAogIAAEwCAACiAgAATQIA
AE4CAACPAgAAUAIAAE4CAABQAgAATwIAAFACAACjAgAApAIAAFACAACkAgAApQIAAFACAACl
AgAApgIAAFACAACmAgAApwIAAFACAACnAgAAqAIAAFACAACoAgAAqQIAAFACAACpAgAAqgIA
AFACAACqAgAAqwIAAFACAACrAgAArAIAAFACAACsAgAArQIAAFACAACtAgAArgIAAFACAACu
AgAArwIAAFACAACvAgAAsAIAAFACAACwAgAAsQIAAFACAACxAgAAlgIAAFACAACWAgAAUgIA
AFACAABSAgAAUQIAAFACAACPAgAAsgIAAFACAACyAgAAswIAAFACAACzAgAAtAIAAFACAAC0
AgAAtQIAAFACAAC1AgAAtgIAAFACAAC2AgAAtwIAAFACAAC3AgAAuAIAAFACAAC4AgAAuQIA
AFACAAC5AgAAugIAAFACAAC6AgAAuwIAAFACAAC7AgAAvAIAAFACAAC8AgAAvQIAAFACAAC9
AgAAvgIAAFACAAC+AgAAvwIAAFACAAC/AgAAowIAAFMCAACiAgAAAgMAAFMCAAACAwAAwAIA
AFMCAADAAgAAwQIAAFMCAADBAgAAVAIAAFQCAADBAgAAVQIAAFUCAADBAgAAwgIAAFUCAADC
AgAAwwIAAFUCAADDAgAAVgIAAFYCAADDAgAAxAIAAFYCAADEAgAAVwIAAFcCAADEAgAAxQIA
AFcCAADFAgAAWAIAAFgCAADFAgAAxgIAAFgCAADGAgAAWQIAAFkCAADGAgAAWgIAAFoCAADG
AgAAxwIAAFoCAADHAgAAyAIAAFoCAADIAgAAWwIAAFsCAADIAgAAXAIAAFwCAADIAgAAyQIA
AFwCAADJAgAAygIAAFwCAADKAgAAywIAAF0CAABhAgAAYAIAAF0CAABgAgAAXgIAAF0CAADL
AgAAYgIAAF0CAABiAgAAYQIAAF4CAABgAgAAXwIAAGICAADLAgAAYwIAAGMCAADLAgAAygIA
AGMCAADKAgAAZAIAAGQCAADKAgAAzAIAAGQCAADMAgAAzQIAAGQCAADNAgAAZQIAAGUCAADN
AgAAzgIAAGUCAADOAgAAZgIAAGYCAADOAgAAZwIAAGcCAADOAgAAzwIAAGcCAADPAgAA0AIA
AGcCAADQAgAAaAIAAGgCAADQAgAA0QIAAGgCAADRAgAAaQIAAGkCAADRAgAAagIAAGoCAADR
AgAA0gIAAGoCAADSAgAA0wIAAGoCAADTAgAAawIAAGsCAADTAgAAbAIAAGwCAADTAgAA1AIA
AGwCAADUAgAA1QIAAGwCAADVAgAAbQIAAG0CAADVAgAA1gIAAG0CAADWAgAAbgIAAG4CAADW
AgAAbwIAAG8CAADWAgAA1wIAAG8CAADXAgAA2AIAAG8CAADYAgAAcAIAAHACAADYAgAA2QIA
AHACAADZAgAAcQIAAHECAADZAgAAcgIAAHICAADZAgAA2gIAAHICAADaAgAA2wIAAHICAADb
AgAAcwIAAHMCAADbAgAA3AIAAHMCAADcAgAAdAIAAHQCAADcAgAAdQIAAHUCAADcAgAA3QIA
AHUCAADdAgAA3gIAAHUCAADeAgAAdgIAAHYCAADeAgAAdwIAAHcCAADeAgAA3wIAAHcCAADf
AgAAeAIAAHgCAADfAgAA4AIAAHgCAADgAgAAlQIAAHgCAACVAgAAeQIAAHkCAACVAgAAkwIA
AHkCAACTAgAAegIAAH0CAADhAgAANwMAAH0CAAA3AwAA4gIAAH0CAAB/AgAA4QIAAH4CAADi
AgAA4wIAAH4CAADjAgAAgAIAAH8CAACCAgAA5AIAAH8CAADkAgAA5QIAAH8CAADlAgAA4QIA
AIACAADjAgAAgQIAAIECAADmAgAA5wIAAIECAADnAgAAhAIAAIECAADjAgAA5gIAAIICAACD
AgAA6AIAAIICAADoAgAA5AIAAIMCAACGAgAA6AIAAIQCAADnAgAA6QIAAIQCAADpAgAAhQIA
AIUCAADpAgAA6gIAAIUCAADqAgAAiAIAAIYCAACHAgAA6wIAAIYCAADrAgAA7AIAAIYCAADs
AgAA6AIAAIcCAACQAgAA7QIAAIcCAADtAgAA6wIAAIgCAADqAgAA7gIAAIgCAADuAgAAiQIA
AIkCAADuAgAAigIAAIoCAADvAgAA8AIAAIoCAADwAgAAiwIAAIoCAADuAgAA7wIAAIsCAADw
AgAAjAIAAIwCAADwAgAA8QIAAIwCAADxAgAA8gIAAIwCAADyAgAA8wIAAI0CAADzAgAAtAIA
AI0CAAC0AgAAswIAAI0CAACzAgAAsgIAAI0CAACyAgAAjgIAAI4CAACyAgAAjwIAAJACAACS
AgAA9AIAAJACAAD0AgAA7QIAAJECAAD1AgAA9AIAAJECAAD0AgAAkgIAAJECAACUAgAA9QIA
AJQCAACVAgAA9gIAAJQCAAD2AgAA9QIAAJUCAADgAgAA9gIAAJYCAACxAgAAlwIAAJcCAACx
AgAAmAIAAJgCAACxAgAAsAIAAJgCAACwAgAArwIAAJgCAACvAgAA9wIAAJkCAAD4AgAA+QIA
AJkCAAD5AgAAmgIAAJkCAAD3AgAA+gIAAJkCAAD6AgAA+AIAAJoCAAD5AgAAmwIAAJsCAAD5
AgAA+wIAAJsCAAD7AgAA/AIAAJsCAAD8AgAAnAIAAJwCAAD8AgAAnQIAAJ0CAAD8AgAA/QIA
AJ0CAAD9AgAAngIAAJ4CAAD9AgAA/gIAAJ4CAAD+AgAAnwIAAJ8CAAD/AgAAoAIAAJ8CAAD+
AgAA/wIAAKACAAD/AgAAAAMAAKACAAAAAwAAAQMAAKACAAABAwAAoQIAAKECAAABAwAAogIA
AKICAAABAwAAAgMAAKMCAAC/AgAAAwMAAKMCAAADAwAApAIAAKQCAAADAwAABAMAAKQCAAAE
AwAABQMAAKQCAAAFAwAApQIAAKUCAAAFAwAABgMAAKUCAAAGAwAApgIAAKYCAAAGAwAApwIA
AKcCAAAGAwAABwMAAKcCAAAHAwAACAMAAKcCAAAIAwAAqAIAAKgCAAAIAwAACQMAAKgCAAAJ
AwAAqQIAAKkCAAAJAwAAqgIAAKoCAAAJAwAACgMAAKoCAAAKAwAACwMAAKoCAAALAwAAqwIA
AKsCAAALAwAArAIAAKwCAAALAwAADAMAAKwCAAAMAwAArQIAAK0CAAAMAwAADQMAAK0CAAAN
AwAA+gIAAK0CAAD6AgAArgIAAK4CAAD6AgAA9wIAAK4CAAD3AgAArwIAALQCAADzAgAAtQIA
ALUCAADzAgAA8gIAALUCAADyAgAAtgIAALYCAADyAgAADgMAALYCAAAOAwAADwMAALYCAAAP
AwAAtwIAALcCAAAPAwAAEAMAALcCAAAQAwAAuAIAALgCAAAQAwAAuQIAALkCAAAQAwAAEQMA
ALkCAAARAwAAEgMAALkCAAASAwAAugIAALoCAAASAwAAEwMAALoCAAATAwAAuwIAALsCAAAT
AwAAvAIAALwCAAATAwAAFAMAALwCAAAUAwAAFQMAALwCAAAVAwAAvQIAAL0CAAAVAwAAvgIA
AL4CAAAVAwAAFgMAAL4CAAAWAwAAFwMAAL4CAAAXAwAAvwIAAL8CAAAXAwAAAwMAAMACAAAC
AwAAUQMAAMACAABRAwAAGAMAAMACAAAYAwAAwQIAAMECAAAZAwAAGgMAAMECAAAaAwAAwgIA
AMECAAAYAwAAGQMAAMICAAAaAwAAGwMAAMICAAAbAwAAwwIAAMMCAAAbAwAAxAIAAMQCAAAc
AwAAHQMAAMQCAAAdAwAAxQIAAMQCAAAbAwAAHAMAAMUCAAAdAwAAHgMAAMUCAAAeAwAAxgIA
AMYCAAAeAwAAHwMAAMYCAAAfAwAAxwIAAMcCAAAfAwAAyAIAAMgCAAAfAwAAIAMAAMgCAAAg
AwAAyQIAAMkCAAAgAwAAIQMAAMkCAAAhAwAAygIAAMoCAAAhAwAAzAIAAMwCAAAhAwAAIgMA
AMwCAAAiAwAAzQIAAM0CAAAiAwAAzgIAAM4CAAAiAwAAIwMAAM4CAAAjAwAAJAMAAM4CAAAk
AwAAzwIAAM8CAAAkAwAAJQMAAM8CAAAlAwAA0AIAANACAAAlAwAAJgMAANACAAAmAwAA0QIA
ANECAAAmAwAA0gIAANICAAAmAwAAJwMAANICAAAnAwAA0wIAANMCAAAnAwAAKAMAANMCAAAo
AwAAKQMAANMCAAApAwAA1AIAANQCAAApAwAAKgMAANQCAAAqAwAA1QIAANUCAAAqAwAAKwMA
ANUCAAArAwAA1gIAANYCAAArAwAA1wIAANcCAAArAwAALAMAANcCAAAsAwAA2AIAANgCAAAs
AwAALQMAANgCAAAtAwAA2QIAANkCAAAtAwAALgMAANkCAAAuAwAALwMAANkCAAAvAwAA2gIA
ANoCAAAvAwAAMAMAANoCAAAwAwAA2wIAANsCAAAwAwAA3AIAANwCAAAwAwAAMQMAANwCAAAx
AwAA3QIAAN0CAAAxAwAAMgMAAN0CAAAyAwAA3gIAAN4CAAAyAwAAMwMAAN4CAAAzAwAANAMA
AN4CAAA0AwAA3wIAAN8CAAA0AwAA4AIAAOACAAA0AwAA9gIAAOECAADlAgAANQMAAOECAAA1
AwAANgMAAOECAAA2AwAAgQMAAOECAACBAwAANwMAAOICAAA3AwAA4wIAAOMCAAA3AwAAOAMA
AOMCAAA4AwAAOQMAAOMCAAA5AwAA5gIAAOQCAAA6AwAA5QIAAOQCAADoAgAAOgMAAOUCAAA6
AwAANQMAAOYCAAA5AwAAOwMAAOYCAAA7AwAA5wIAAOcCAAA7AwAA6QIAAOgCAAA8AwAAOgMA
AOgCAADsAgAAPQMAAOgCAAA9AwAAPAMAAOkCAAA7AwAAPgMAAOkCAAA+AwAAPwMAAOkCAAA/
AwAA6gIAAOoCAAA/AwAAQAMAAOoCAABAAwAA7gIAAOsCAABBAwAA7AIAAOsCAADtAgAAQQMA
AOwCAABBAwAAPQMAAO0CAABCAwAAQQMAAO0CAAD0AgAAQwMAAO0CAABDAwAAQgMAAO4CAABA
AwAARAMAAO4CAABEAwAA7wIAAO8CAABEAwAA8AIAAPACAABFAwAA8QIAAPACAABEAwAARQMA
APECAABFAwAARgMAAPECAABGAwAA8gIAAPICAABGAwAADgMAAPQCAAD1AgAARwMAAPQCAABH
AwAAQwMAAPUCAAD2AgAANAMAAPUCAAA0AwAARwMAAPgCAABIAwAASQMAAPgCAABJAwAA+QIA
APgCAAD6AgAASAMAAPkCAABJAwAASgMAAPkCAABKAwAA+wIAAPoCAAANAwAASAMAAPsCAABK
AwAA/AIAAPwCAABLAwAA/QIAAPwCAABKAwAASwMAAP0CAABLAwAATAMAAP0CAABMAwAA/gIA
AP4CAABNAwAATgMAAP4CAABOAwAA/wIAAP4CAABMAwAATQMAAP8CAABOAwAAAAMAAAADAABO
AwAATwMAAAADAABPAwAAAQMAAAEDAABQAwAAUQMAAAEDAABRAwAAAgMAAAEDAABPAwAAUAMA
AAMDAAAXAwAAUgMAAAMDAABSAwAABAMAAAQDAABSAwAAUwMAAAQDAABTAwAABQMAAAUDAABT
AwAAVAMAAAUDAABUAwAABgMAAAYDAABUAwAAVQMAAAYDAABVAwAAVgMAAAYDAABWAwAABwMA
AAcDAABWAwAAVwMAAAcDAABXAwAACAMAAAgDAABXAwAACQMAAAkDAABXAwAAWAMAAAkDAABY
AwAACgMAAAoDAABYAwAAWQMAAAoDAABZAwAACwMAAAsDAABZAwAAWgMAAAsDAABaAwAAWwMA
AAsDAABbAwAADAMAAAwDAABbAwAADQMAAA0DAABbAwAASAMAAA4DAABGAwAAXAMAAA4DAABc
AwAADwMAAA8DAABcAwAAEAMAABADAABcAwAAXQMAABADAABdAwAAXgMAABADAABeAwAAEQMA
ABEDAABeAwAAXwMAABEDAABfAwAAEgMAABIDAABfAwAAYAMAABIDAABgAwAAEwMAABMDAABg
AwAAFAMAABQDAABgAwAAYQMAABQDAABhAwAAFQMAABUDAABhAwAAYgMAABUDAABiAwAAYwMA
ABUDAABjAwAAFgMAABYDAABjAwAAZAMAABYDAABkAwAAFwMAABcDAABkAwAAUgMAABgDAABR
AwAAmAMAABgDAACYAwAAZQMAABgDAABlAwAAZgMAABgDAABmAwAAGQMAABkDAABmAwAAZwMA
ABkDAABnAwAAGgMAABoDAABnAwAAGwMAABsDAABnAwAAaAMAABsDAABoAwAAaQMAABsDAABp
AwAAHAMAABwDAABpAwAAagMAABwDAABqAwAAHQMAAB0DAABqAwAAHgMAAB4DAABqAwAAawMA
AB4DAABrAwAAbAMAAB4DAABsAwAAHwMAAB8DAABsAwAAbQMAAB8DAABtAwAAIAMAACADAABt
AwAAIgMAACADAAAiAwAAIQMAACIDAABtAwAAbgMAACIDAABuAwAAIwMAACMDAABuAwAAJAMA
ACQDAABuAwAAbwMAACQDAABvAwAAcAMAACQDAABwAwAAJQMAACUDAABwAwAAJgMAACYDAABw
AwAAcQMAACYDAABxAwAAJwMAACcDAABxAwAAcgMAACcDAAByAwAAcwMAACcDAABzAwAAKAMA
ACgDAABzAwAAdAMAACgDAAB0AwAAKQMAACkDAAB0AwAAKgMAACoDAAB0AwAAdQMAACoDAAB1
AwAAKwMAACsDAAB1AwAAdgMAACsDAAB2AwAAdwMAACsDAAB3AwAALAMAACwDAAB3AwAAeAMA
ACwDAAB4AwAALQMAAC0DAAB4AwAALgMAAC4DAAB4AwAAeQMAAC4DAAB5AwAALwMAAC8DAAB5
AwAAegMAAC8DAAB6AwAAewMAAC8DAAB7AwAAMAMAADADAAB7AwAAfAMAADADAAB8AwAAMQMA
ADEDAAB8AwAAMgMAADIDAAB8AwAAfQMAADIDAAB9AwAAfgMAADIDAAB+AwAAMwMAADMDAAB+
AwAANAMAADQDAAB+AwAARwMAADUDAAA6AwAAfwMAADUDAAB/AwAANgMAADYDAACAAwAAwwMA
ADYDAADDAwAAgQMAADYDAAB/AwAAgAMAADcDAACBAwAAggMAADcDAACCAwAAOAMAADgDAACC
AwAAgwMAADgDAACDAwAAOQMAADkDAACDAwAAOwMAADoDAACEAwAAfwMAADoDAAA8AwAAhQMA
ADoDAACFAwAAhAMAADsDAACDAwAAhgMAADsDAACGAwAAhwMAADsDAACHAwAAPgMAADwDAAA9
AwAAiAMAADwDAACIAwAAhQMAAD0DAABBAwAAiAMAAD4DAACHAwAAiQMAAD4DAACJAwAAPwMA
AD8DAACJAwAAQAMAAEADAACJAwAAigMAAEADAACKAwAAiwMAAEADAACLAwAARAMAAEEDAACM
AwAAiAMAAEEDAABCAwAAjQMAAEEDAACNAwAAjAMAAEIDAABDAwAAjQMAAEMDAABHAwAAjgMA
AEMDAACOAwAAjQMAAEQDAACLAwAAjwMAAEQDAACPAwAARQMAAEUDAACPAwAAXAMAAEUDAABc
AwAARgMAAEcDAAB+AwAAjgMAAEgDAABbAwAASQMAAEkDAABbAwAAkAMAAEkDAACQAwAASgMA
AEoDAACRAwAASwMAAEoDAACQAwAAkQMAAEsDAACSAwAAkwMAAEsDAACTAwAATAMAAEsDAACR
AwAAkgMAAEwDAACTAwAATQMAAE0DAACUAwAATgMAAE0DAACTAwAAlAMAAE4DAACVAwAAlgMA
AE4DAACWAwAATwMAAE4DAACUAwAAlQMAAE8DAACWAwAAUAMAAFADAACXAwAAUQMAAFADAACW
AwAAlwMAAFEDAACXAwAAmAMAAFIDAABkAwAAmQMAAFIDAACZAwAAmgMAAFIDAACaAwAAmwMA
AFIDAACbAwAAUwMAAFMDAACbAwAAnAMAAFMDAACcAwAAVAMAAFQDAACcAwAAVQMAAFUDAACc
AwAAnQMAAFUDAACdAwAAVgMAAFYDAACdAwAAngMAAFYDAACeAwAAnwMAAFYDAACfAwAAVwMA
AFcDAACfAwAAoAMAAFcDAACgAwAAWAMAAFgDAACgAwAAWQMAAFkDAACgAwAAoQMAAFkDAACh
AwAAogMAAFkDAACiAwAAWgMAAFoDAACiAwAAWwMAAFsDAACiAwAAkAMAAFwDAACPAwAAowMA
AFwDAACjAwAAXQMAAF0DAACjAwAAXgMAAF4DAACjAwAApAMAAF4DAACkAwAApQMAAF4DAACl
AwAAXwMAAF8DAAClAwAAYAMAAGADAAClAwAApgMAAGADAACmAwAAYQMAAGEDAACmAwAApwMA
AGEDAACnAwAAqAMAAGEDAACoAwAAYgMAAGIDAACoAwAAqQMAAGIDAACpAwAAYwMAAGMDAACp
AwAAZAMAAGQDAACpAwAAmQMAAGUDAACYAwAA1wMAAGUDAADXAwAAqgMAAGUDAACqAwAAqwMA
AGUDAACrAwAAZgMAAGYDAACrAwAAZwMAAGcDAACrAwAArAMAAGcDAACsAwAArQMAAGcDAACt
AwAAaAMAAGgDAACtAwAArgMAAGgDAACuAwAAaQMAAGkDAACuAwAAagMAAGoDAACuAwAArwMA
AGoDAACvAwAAsAMAAGoDAACwAwAAawMAAGsDAACwAwAAbAMAAGwDAACxAwAAbQMAAGwDAACw
AwAAsQMAAG0DAACxAwAAbgMAAG4DAACxAwAAbwMAAG8DAACxAwAAsgMAAG8DAACyAwAAcAMA
AHADAACyAwAAswMAAHADAACzAwAAtAMAAHADAAC0AwAAcQMAAHEDAAC0AwAAtQMAAHEDAAC1
AwAAcgMAAHIDAAC1AwAAcwMAAHMDAAC1AwAAtgMAAHMDAAC2AwAAdAMAAHQDAAC2AwAAtwMA
AHQDAAC3AwAAuAMAAHQDAAC4AwAAdQMAAHUDAAC4AwAAuQMAAHUDAAC5AwAAdgMAAHYDAAC5
AwAAdwMAAHcDAAC5AwAAugMAAHcDAAC6AwAAeAMAAHgDAAC6AwAAuwMAAHgDAAC7AwAAvAMA
AHgDAAC8AwAAeQMAAHkDAAC8AwAAvQMAAHkDAAC9AwAAegMAAHoDAAC9AwAAewMAAHsDAAC9
AwAAvgMAAHsDAAC+AwAAfAMAAHwDAAC+AwAAvwMAAHwDAAC/AwAAwAMAAHwDAADAAwAAfQMA
AH0DAADAAwAAjgMAAH0DAACOAwAAfgMAAH8DAACEAwAAwQMAAH8DAADBAwAAgAMAAIADAADB
AwAAwgMAAIADAADCAwAA/gMAAIADAAD+AwAAwwMAAIEDAADDAwAAxAMAAIEDAADEAwAAggMA
AIIDAADEAwAAgwMAAIMDAADFAwAAxgMAAIMDAADGAwAAhgMAAIMDAADEAwAAxQMAAIQDAADH
AwAAwQMAAIQDAACFAwAAyAMAAIQDAADIAwAAxwMAAIUDAACIAwAAyQMAAIUDAADJAwAAyAMA
AIYDAADGAwAAygMAAIYDAADKAwAAhwMAAIcDAADKAwAAiQMAAIgDAACMAwAAyQMAAIkDAADL
AwAAzAMAAIkDAADMAwAAigMAAIkDAADKAwAAywMAAIoDAADMAwAAiwMAAIsDAADMAwAAzQMA
AIsDAADNAwAAjwMAAIwDAADOAwAAyQMAAIwDAACNAwAAzgMAAI0DAADPAwAAzgMAAI0DAACO
AwAAzwMAAI4DAADAAwAAzwMAAI8DAADNAwAAowMAAJADAACiAwAA0AMAAJADAADQAwAAkQMA
AJEDAADQAwAA0QMAAJEDAADRAwAAkgMAAJIDAADRAwAAkwMAAJMDAADRAwAA0gMAAJMDAADS
AwAA0wMAAJMDAADTAwAAlAMAAJQDAADTAwAAlQMAAJUDAADUAwAAlgMAAJUDAADTAwAA1AMA
AJYDAADUAwAA1QMAAJYDAADVAwAA1gMAAJYDAADWAwAAlwMAAJcDAADWAwAAmAMAAJgDAADW
AwAA1wMAAJkDAACpAwAA2AMAAJkDAADYAwAA2QMAAJkDAADZAwAAmgMAAJoDAADZAwAAmwMA
AJsDAADZAwAA2gMAAJsDAADaAwAAnAMAAJwDAADaAwAA2wMAAJwDAADbAwAA3AMAAJwDAADc
AwAAnQMAAJ0DAADcAwAA3QMAAJ0DAADdAwAAngMAAJ4DAADdAwAAnwMAAJ8DAADdAwAA3gMA
AJ8DAADeAwAAoAMAAKADAADeAwAA3wMAAKADAADfAwAA4AMAAKADAADgAwAAoQMAAKEDAADg
AwAA0AMAAKEDAADQAwAAogMAAKMDAADNAwAApAMAAKQDAADNAwAA4QMAAKQDAADhAwAApQMA
AKUDAADhAwAA4gMAAKUDAADiAwAA4wMAAKUDAADjAwAApgMAAKYDAADjAwAA5AMAAKYDAADk
AwAApwMAAKcDAADkAwAAqAMAAKgDAADkAwAA5QMAAKgDAADlAwAAqQMAAKkDAADlAwAA5gMA
AKkDAADmAwAA2AMAAKoDAADXAwAADgQAAKoDAAAOBAAA5wMAAKoDAADnAwAA6AMAAKoDAADo
AwAAqwMAAKsDAADoAwAArAMAAKwDAADoAwAA6QMAAKwDAADpAwAA6gMAAKwDAADqAwAArQMA
AK0DAADqAwAA6wMAAK0DAADrAwAArgMAAK4DAADrAwAArwMAAK8DAADrAwAA7AMAAK8DAADs
AwAAsAMAALADAADsAwAA7QMAALADAADtAwAAsQMAALEDAADtAwAAsgMAALIDAADtAwAA7gMA
ALIDAADuAwAAswMAALMDAADuAwAAtAMAALQDAADuAwAA7wMAALQDAADvAwAAtQMAALUDAADv
AwAA8AMAALUDAADwAwAAtgMAALYDAADwAwAA8QMAALYDAADxAwAA8gMAALYDAADyAwAAtwMA
ALcDAADyAwAAuAMAALgDAADyAwAA8wMAALgDAADzAwAA9AMAALgDAAD0AwAAuQMAALkDAAD0
AwAAugMAALoDAAD0AwAA9QMAALoDAAD1AwAA9gMAALoDAAD2AwAAuwMAALsDAAD2AwAAvAMA
ALwDAAD2AwAA9wMAALwDAAD3AwAA+AMAALwDAAD4AwAAvQMAAL0DAAD4AwAA+QMAAL0DAAD5
AwAAvgMAAL4DAAD5AwAAvwMAAL8DAAD5AwAA+gMAAL8DAAD6AwAAzwMAAL8DAADPAwAAwAMA
AMEDAADHAwAA+wMAAMEDAAD7AwAA/AMAAMEDAAD8AwAA/QMAAMEDAAD9AwAAwgMAAMIDAAD9
AwAAMQQAAMIDAAAxBAAA/gMAAMMDAAD+AwAA/wMAAMMDAAD/AwAAxAMAAMQDAAD/AwAAxQMA
AMUDAAD/AwAAAAQAAMUDAAAABAAAAQQAAMUDAAABBAAAxgMAAMYDAAABBAAAAgQAAMYDAAAC
BAAAygMAAMcDAADIAwAA+wMAAMgDAAADBAAA+wMAAMgDAADJAwAABAQAAMgDAAAEBAAAAwQA
AMkDAADOAwAABAQAAMoDAAACBAAAywMAAMsDAAACBAAABQQAAMsDAAAFBAAAzAMAAMwDAAAF
BAAABgQAAMwDAAAGBAAAzQMAAM0DAAAGBAAA4QMAAM4DAAAHBAAABAQAAM4DAADPAwAA+gMA
AM4DAAD6AwAABwQAANADAADgAwAACAQAANADAAAIBAAA0QMAANEDAAAIBAAACQQAANEDAAAJ
BAAA0gMAANIDAAAJBAAACgQAANIDAAAKBAAA0wMAANMDAAAKBAAA1AMAANQDAAALBAAA1QMA
ANQDAAAKBAAACwQAANUDAAALBAAADAQAANUDAAAMBAAADQQAANUDAAANBAAA1gMAANYDAAAN
BAAA1wMAANcDAAANBAAADgQAANgDAADmAwAADwQAANgDAAAPBAAAEAQAANgDAAAQBAAAEQQA
ANgDAAARBAAA2QMAANkDAAARBAAA2gMAANoDAAARBAAAEgQAANoDAAASBAAAEwQAANoDAAAT
BAAA2wMAANsDAAATBAAA3AMAANwDAAATBAAAFAQAANwDAAAUBAAAFQQAANwDAAAVBAAA3QMA
AN0DAAAVBAAAFgQAAN0DAAAWBAAA3gMAAN4DAAAWBAAAFwQAAN4DAAAXBAAA3wMAAN8DAAAX
BAAA4AMAAOADAAAXBAAACAQAAOEDAAAGBAAA4gMAAOIDAAAGBAAAGAQAAOIDAAAYBAAAGQQA
AOIDAAAZBAAA4wMAAOMDAAAZBAAA5AMAAOQDAAAZBAAAGgQAAOQDAAAaBAAA5QMAAOUDAAAa
BAAAGwQAAOUDAAAbBAAADwQAAOUDAAAPBAAA5gMAAOcDAAAOBAAAPQQAAOcDAAA9BAAAHAQA
AOcDAAAcBAAA6AMAAOgDAAAdBAAAHgQAAOgDAAAeBAAA6QMAAOgDAAAcBAAAHQQAAOkDAAAe
BAAA6gMAAOoDAAAeBAAAHwQAAOoDAAAfBAAAIAQAAOoDAAAgBAAA6wMAAOsDAAAgBAAA7AMA
AOwDAAAgBAAAIQQAAOwDAAAhBAAA7gMAAOwDAADuAwAA7QMAAO4DAAAhBAAAIgQAAO4DAAAi
BAAA7wMAAO8DAAAiBAAA8AMAAPADAAAiBAAAIwQAAPADAAAjBAAAJAQAAPADAAAkBAAA8QMA
APEDAAAkBAAA8gMAAPIDAAAkBAAAJQQAAPIDAAAlBAAAJgQAAPIDAAAmBAAA8wMAAPMDAAAm
BAAA9AMAAPQDAAAmBAAAJwQAAPQDAAAnBAAAKAQAAPQDAAAoBAAA9QMAAPUDAAAoBAAA9gMA
APYDAAAoBAAAKQQAAPYDAAApBAAAKgQAAPYDAAAqBAAA9wMAAPcDAAAqBAAA+AMAAPgDAAAq
BAAAKwQAAPgDAAArBAAALAQAAPgDAAAsBAAA+QMAAPkDAAAsBAAA+gMAAPoDAAAsBAAABwQA
APsDAAAtBAAA/AMAAPsDAAADBAAALgQAAPsDAAAuBAAALQQAAPwDAAAtBAAALwQAAPwDAAAv
BAAAMAQAAPwDAAAwBAAA/QMAAP0DAAAwBAAAWwQAAP0DAABbBAAAMQQAAP4DAAAxBAAA/wMA
AP8DAAAxBAAAMgQAAP8DAAAyBAAAMwQAAP8DAAAzBAAAAAQAAAAEAAAzBAAAAQQAAAEEAAAz
BAAANAQAAAEEAAA0BAAANQQAAAEEAAA1BAAAAgQAAAIEAAA1BAAABQQAAAMEAAAEBAAALgQA
AAQEAAAHBAAALAQAAAQEAAAsBAAANgQAAAQEAAA2BAAALgQAAAUEAAA3BAAAGAQAAAUEAAAY
BAAABgQAAAUEAAA1BAAANwQAAAgEAAAXBAAACQQAAAkEAAAXBAAAOAQAAAkEAAA4BAAAOQQA
AAkEAAA5BAAACgQAAAoEAAA5BAAACwQAAAsEAAA6BAAAOwQAAAsEAAA7BAAADAQAAAsEAAA5
BAAAOgQAAAwEAAA7BAAADQQAAA0EAAA8BAAAPQQAAA0EAAA9BAAADgQAAA0EAAA7BAAAPAQA
AA8EAAAbBAAAPgQAAA8EAAA+BAAAPwQAAA8EAAA/BAAAQAQAAA8EAABABAAAEAQAABAEAABA
BAAAEQQAABEEAABABAAAQQQAABEEAABBBAAAQgQAABEEAABCBAAAEgQAABIEAABCBAAAEwQA
ABMEAABCBAAAQwQAABMEAABDBAAARAQAABMEAABEBAAAFAQAABQEAABEBAAAFQQAABUEAABE
BAAARQQAABUEAABFBAAARgQAABUEAABGBAAAFgQAABYEAABGBAAAFwQAABcEAABGBAAAOAQA
ABgEAAA3BAAARwQAABgEAABHBAAAGQQAABkEAABHBAAAGgQAABoEAABHBAAASAQAABoEAABI
BAAAPgQAABoEAAA+BAAAGwQAABwEAAA9BAAAZAQAABwEAABkBAAASQQAABwEAABJBAAAHQQA
AB0EAABKBAAASwQAAB0EAABLBAAAHgQAAB0EAABJBAAASgQAAB4EAABLBAAATAQAAB4EAABM
BAAAHwQAAB8EAABMBAAAIAQAACAEAABNBAAAIgQAACAEAAAiBAAAIQQAACAEAABMBAAATQQA
ACIEAABNBAAAIwQAACMEAABNBAAATgQAACMEAABOBAAAJAQAACQEAABOBAAATwQAACQEAABP
BAAAUAQAACQEAABQBAAAJQQAACUEAABQBAAAUQQAACUEAABRBAAAJgQAACYEAABRBAAAUgQA
ACYEAABSBAAAJwQAACcEAABSBAAAKAQAACgEAABSBAAAUwQAACgEAABTBAAAKQQAACkEAABT
BAAAVAQAACkEAABUBAAAKgQAACoEAABUBAAAVQQAACoEAABVBAAAVgQAACoEAABWBAAAKwQA
ACsEAABWBAAANgQAACsEAAA2BAAALAQAAC0EAABXBAAAWAQAAC0EAABYBAAALwQAAC0EAAAu
BAAAVwQAAC4EAABZBAAAVwQAAC4EAAA2BAAAWQQAAC8EAABYBAAAMAQAADAEAABaBAAAfAQA
ADAEAAB8BAAAWwQAADAEAABYBAAAWgQAADEEAABbBAAAMgQAADIEAABbBAAAXAQAADIEAABc
BAAAXQQAADIEAABdBAAAMwQAADMEAABdBAAAXgQAADMEAABeBAAANAQAADQEAABeBAAANQQA
ADUEAABeBAAAXwQAADUEAABfBAAARwQAADUEAABHBAAANwQAADYEAABWBAAAWQQAADgEAABG
BAAAOQQAADkEAABgBAAAYQQAADkEAABhBAAAOgQAADkEAABGBAAAYAQAADoEAABhBAAAOwQA
ADsEAABhBAAAYgQAADsEAABiBAAAPAQAADwEAABjBAAAZAQAADwEAABkBAAAPQQAADwEAABi
BAAAYwQAAD4EAABIBAAAZQQAAD4EAABlBAAAZgQAAD4EAABmBAAAZwQAAD4EAABnBAAAPwQA
AD8EAABnBAAAaAQAAD8EAABoBAAAQAQAAEAEAABoBAAAaQQAAEAEAABpBAAAQQQAAEEEAABp
BAAAQgQAAEIEAABpBAAAagQAAEIEAABqBAAAQwQAAEMEAABqBAAAawQAAEMEAABrBAAARAQA
AEQEAABrBAAAbAQAAEQEAABsBAAAbQQAAEQEAABtBAAARQQAAEUEAABtBAAAYAQAAEUEAABg
BAAARgQAAEcEAABfBAAASAQAAEgEAABfBAAAZQQAAEkEAABkBAAAgwQAAEkEAACDBAAAbgQA
AEkEAABuBAAAbwQAAEkEAABvBAAASgQAAEoEAABvBAAASwQAAEsEAABvBAAAcAQAAEsEAABw
BAAATAQAAEwEAABwBAAAcQQAAEwEAABxBAAATQQAAE0EAABxBAAATgQAAE4EAABxBAAATwQA
AE8EAABxBAAAcgQAAE8EAAByBAAAUAQAAFAEAAByBAAAcwQAAFAEAABzBAAAUQQAAFEEAABz
BAAAdAQAAFEEAAB0BAAAUgQAAFIEAAB0BAAAdQQAAFIEAAB1BAAAdgQAAFIEAAB2BAAAUwQA
AFMEAAB2BAAAdwQAAFMEAAB3BAAAVAQAAFQEAAB3BAAAeAQAAFQEAAB4BAAAVQQAAFUEAAB4
BAAAWQQAAFUEAABZBAAAVgQAAFcEAAB5BAAAegQAAFcEAAB6BAAAWAQAAFcEAABZBAAAeQQA
AFgEAAB6BAAAWgQAAFkEAAB4BAAAeQQAAFoEAAB7BAAAlQQAAFoEAACVBAAAfAQAAFoEAAB6
BAAAewQAAFsEAAB8BAAAfQQAAFsEAAB9BAAAXAQAAFwEAAB9BAAAXQQAAF0EAAB+BAAAXgQA
AF0EAAB9BAAAfgQAAF4EAAB+BAAAfwQAAF4EAAB/BAAAXwQAAF8EAAB/BAAAZQQAAGAEAABt
BAAAgAQAAGAEAACABAAAYQQAAGEEAACABAAAgQQAAGEEAACBBAAAYgQAAGIEAACBBAAAggQA
AGIEAACCBAAAYwQAAGMEAACCBAAAZAQAAGQEAACCBAAAgwQAAGUEAAB/BAAAZgQAAGYEAAB/
BAAAhAQAAGYEAACEBAAAZwQAAGcEAACEBAAAhQQAAGcEAACFBAAAaAQAAGgEAACFBAAAhgQA
AGgEAACGBAAAaQQAAGkEAACGBAAAhwQAAGkEAACHBAAAiAQAAGkEAACIBAAAagQAAGoEAACI
BAAAiQQAAGoEAACJBAAAawQAAGsEAACJBAAAigQAAGsEAACKBAAAbAQAAGwEAACKBAAAgAQA
AGwEAACABAAAbQQAAG4EAACDBAAAmgQAAG4EAACaBAAAiwQAAG4EAACLBAAAjAQAAG4EAACM
BAAAbwQAAG8EAACMBAAAcAQAAHAEAACMBAAAjQQAAHAEAACNBAAAcQQAAHEEAACNBAAAcgQA
AHIEAACNBAAAcwQAAHMEAACNBAAAjgQAAHMEAACOBAAAjwQAAHMEAACPBAAAdAQAAHQEAACP
BAAAkAQAAHQEAACQBAAAdQQAAHUEAACQBAAAdgQAAHYEAACQBAAAkQQAAHYEAACRBAAAdwQA
AHcEAACRBAAAkgQAAHcEAACSBAAAeQQAAHcEAAB5BAAAeAQAAHkEAACSBAAAegQAAHoEAACS
BAAAkwQAAHoEAACTBAAAewQAAHsEAACTBAAAlAQAAHsEAACUBAAApgQAAHsEAACmBAAAlQQA
AHwEAACVBAAAlgQAAHwEAACWBAAAfQQAAH0EAACWBAAAfgQAAH4EAACXBAAAfwQAAH4EAACW
BAAAlwQAAH8EAACXBAAAhAQAAIAEAACKBAAAmAQAAIAEAACYBAAAgQQAAIEEAACYBAAAmQQA
AIEEAACZBAAAggQAAIIEAACZBAAAgwQAAIMEAACZBAAAmgQAAIQEAACXBAAAhQQAAIUEAACX
BAAAmwQAAIUEAACbBAAAnAQAAIUEAACcBAAAhgQAAIYEAACcBAAAnQQAAIYEAACdBAAAhwQA
AIcEAACdBAAAiAQAAIgEAACdBAAAngQAAIgEAACeBAAAiQQAAIkEAACeBAAAnwQAAIkEAACf
BAAAmAQAAIkEAACYBAAAigQAAIsEAACaBAAAqQQAAIsEAACpBAAAoAQAAIsEAACgBAAAoQQA
AIsEAAChBAAAjAQAAIwEAAChBAAAjgQAAIwEAACOBAAAjQQAAI4EAAChBAAAjwQAAI8EAACh
BAAAogQAAI8EAACiBAAAowQAAI8EAACjBAAAkAQAAJAEAACjBAAAkQQAAJEEAACjBAAApAQA
AJEEAACkBAAAkwQAAJEEAACTBAAAkgQAAJMEAACkBAAApQQAAJMEAAClBAAAlAQAAJQEAACl
BAAArwQAAJQEAACvBAAApgQAAJUEAACmBAAApwQAAJUEAACnBAAAlgQAAJYEAACnBAAAmwQA
AJYEAACbBAAAlwQAAJgEAACfBAAAmQQAAJkEAACoBAAAmgQAAJkEAACfBAAAqAQAAJoEAACo
BAAAqQQAAJsEAACnBAAAnAQAAJwEAACnBAAAqgQAAJwEAACqBAAAqwQAAJwEAACrBAAAnQQA
AJ0EAACrBAAAngQAAJ4EAACrBAAArAQAAJ4EAACsBAAAqAQAAJ4EAACoBAAAnwQAAKAEAACp
BAAAsAQAAKAEAACwBAAArQQAAKAEAACtBAAAoQQAAKEEAACtBAAAogQAAKIEAACtBAAArgQA
AKIEAACuBAAAowQAAKMEAACuBAAApAQAAKQEAACuBAAApQQAAKUEAACuBAAAsQQAAKUEAACx
BAAArwQAAKYEAACvBAAApwQAAKcEAACvBAAAqgQAAKgEAACsBAAAsAQAAKgEAACwBAAAqQQA
AKoEAACvBAAAsQQAAKoEAACxBAAAqwQAAKsEAACxBAAArAQAAKwEAACxBAAAsAQAAK0EAACw
BAAAsQQAAK0EAACxBAAArgQAAA==</SharedString>
		<SharedString md5="hFbDjtH6cycB1zhM9yA98w==">Q1NHUEhTBwAAAAIAACBBAAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAIA/EAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPwwAAAAEAAAAAADIwvOqiDcA
AMjCAADIwvOqiLcAAMhCAADIQvOqiDcAAMjCAADIQvOqiLcAAMhCDAAAAAAAAAABAAAAAwAA
AAAAAAADAAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAAAQAAAA==</SharedString>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>