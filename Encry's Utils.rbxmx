<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX72791B54709043AEB1C6D32348935C9D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">Encry&apos;s Utils</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBXCAC23F87C0D1427D895DC8E97D65F2CA">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local toolbar = plugin:CreateToolbar("Encry's Utils")
local StudioService = game:GetService("StudioService")
local TweenService = game:GetService("TweenService")

local Resources = script.Parent:FindFirstChild("Resources")
if not Resources then
	local RestartButton = toolbar:CreateButton(
		"Util (Needs restart)",
		"Resources folder not found",
		"rbxassetid://138336801576694"
	)
	return
end

local success, loadedModules = pcall(function()
	local ConnectionUtil = require(Resources.Util.ConnectionUtil)
	local GUI = Resources.GUI
	local Templates = Resources.Templates
	local Inserts = Resources.Inserts

	local SettingsManager = require(Resources.Util.SettingsManager)
	local InstancesManager = require(Resources.Util.InstancesManager)
	local PathChangerManager = require(Resources.Util.PathChangerManager)
	local MagicSelectManager = require(Resources.Util.MagicSelectManager)
	local BulkExportManager = require(Resources.Util.BulkExportManager)

	return {
		Resources = Resources,
		ConnectionUtil = ConnectionUtil,
		GUI = GUI,
		Templates = Templates,
		Inserts = Inserts,
		SettingsManager = SettingsManager,
		InstancesManager = InstancesManager,
		PathChangerManager = PathChangerManager,
		MagicSelectManager = MagicSelectManager,
		BulkExportManager = BulkExportManager
	}
end)

if not success then
	local finalReason = "Module loading failed: " .. tostring(loadedModules)
	local RestartButton = toolbar:CreateButton(
		"Util (Needs restart)",
		finalReason,
		"rbxassetid://93200537889042"
	)
	return
end

local ConnectionUtil = loadedModules.ConnectionUtil
local GUI = loadedModules.GUI
local Templates = loadedModules.Templates
local Inserts = loadedModules.Inserts
local SettingsManager = loadedModules.SettingsManager
local InstancesManager = loadedModules.InstancesManager
local PathChangerManager = loadedModules.PathChangerManager
local MagicSelectManager = loadedModules.MagicSelectManager
local BulkExportManager = loadedModules.BulkExportManager

local conn = ConnectionUtil.new()

local PluginButton = toolbar:CreateButton(
	"Util",
	"Open Encry's Utils",
	"rbxassetid://138336801576694"
)

PluginButton.ClickableWhenViewportHidden = true

local function createInsertsDockInfo()
	return DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Float,
		false,
		false,
		900,
		400,
		900,
		400
	)
end

local PluginWidget = plugin:CreateDockWidgetPluginGui("Inserts", createInsertsDockInfo())
PluginWidget.Title = "Utils"
PluginWidget.Name = "Encry's Utils"

local newGUI = GUI.main_frame:Clone()
newGUI.Parent = PluginWidget

local settingsManager = SettingsManager.new(plugin)
local instancesManager = InstancesManager.new(newGUI, Templates, Inserts, Resources, conn, settingsManager)
local pathChangerManager = PathChangerManager.new(newGUI, Resources, conn, plugin)
local magicSelectManager = MagicSelectManager.new(newGUI, conn, plugin)
local bulkExportManager = BulkExportManager.new(newGUI, conn, plugin, settingsManager)

local animInfo = TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
local buttonAnimInfo = TweenInfo.new(0.2, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)

local function setupButtonAnimations()
	local setupButtons = {}

	local function setupButton(button)
		if not (button:IsA("ImageButton") or button:IsA("TextButton")) then return end
		if setupButtons[button] then return end

		setupButtons[button] = true

		local stroke = button:FindFirstChild("stroke") or button:FindFirstChildWhichIsA("UIStroke")

		local originalTransparency = button.BackgroundTransparency
		local originalStrokeThickness = stroke and stroke.Thickness or 0

		button.MouseEnter:Connect(function()
			TweenService:Create(button, buttonAnimInfo, {
				BackgroundTransparency = math.max(originalTransparency - 0.1, 0)
			}):Play()

			if stroke then
				TweenService:Create(stroke, buttonAnimInfo, {Thickness = originalStrokeThickness + 2}):Play()
			end
		end)

		button.MouseButton1Down:Connect(function()
			TweenService:Create(button, buttonAnimInfo, {
				BackgroundTransparency = math.max(originalTransparency - 0.2, 0)
			}):Play()

			if stroke then
				TweenService:Create(stroke, buttonAnimInfo, {Thickness = originalStrokeThickness + 3}):Play()
			end
		end)

		button.MouseButton1Up:Connect(function()
			TweenService:Create(button, buttonAnimInfo, {
				BackgroundTransparency = math.max(originalTransparency - 0.1, 0)
			}):Play()

			if stroke then
				TweenService:Create(stroke, buttonAnimInfo, {Thickness = originalStrokeThickness + 2}):Play()
			end
		end)

		button.MouseLeave:Connect(function()
			TweenService:Create(button, buttonAnimInfo, {
				BackgroundTransparency = originalTransparency
			}):Play()

			if stroke then
				TweenService:Create(stroke, buttonAnimInfo, {Thickness = originalStrokeThickness}):Play()
			end
		end)
	end

	local function scanForButtons(container)
		for _, descendant in pairs(container:GetDescendants()) do
			if descendant:IsA("ImageButton") or descendant:IsA("TextButton") then
				setupButton(descendant)
			end
		end
	end

	scanForButtons(newGUI)

	newGUI.DescendantAdded:Connect(function(descendant)
		if descendant:IsA("ImageButton") or descendant:IsA("TextButton") then
			task.wait(0.1)
			setupButton(descendant)
		end
	end)

	newGUI.DescendantRemoving:Connect(function(descendant)
		if setupButtons[descendant] then
			setupButtons[descendant] = nil
		end
	end)
end

local function animateFrameIn(frame)
	frame.Position = UDim2.new(0.5, 0, 1.5, 0)
	frame.Visible = true
	TweenService:Create(frame, animInfo, {
		Position = UDim2.new(0.5, 0, 0.5, 0)
	}):Play()
end

local function animateFrameOut(frame, callback)
	local tween = TweenService:Create(frame, animInfo, {
		Position = UDim2.new(0.5, 0, -0.5, 0)
	})
	tween.Completed:Connect(function()
		frame.Visible = false
		frame.Position = UDim2.new(0.5, 0, 0.5, 0)
		if callback then callback() end
	end)
	tween:Play()
end

local function resetGUI()
	if newGUI:FindFirstChild("button_container") then
		newGUI.button_container.Visible = true
		newGUI.button_container.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("insets_frame") then
		newGUI.insets_frame.Visible = false
		newGUI.insets_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("instance_frame") then
		newGUI.instance_frame.Visible = false
		newGUI.instance_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("path_changer_frame") then
		newGUI.path_changer_frame.Visible = false
		newGUI.path_changer_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("magic_select_frame") then
		newGUI.magic_select_frame.Visible = false
		newGUI.magic_select_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("settings_frame") then
		newGUI.settings_frame.Visible = false
		newGUI.settings_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end

	if newGUI:FindFirstChild("bulk_export_frame") then
		newGUI.bulk_export_frame.Visible = false
		newGUI.bulk_export_frame.Position = UDim2.new(0.5, 0, 0.5, 0)
	end
end

if newGUI.button_container and newGUI.button_container:FindFirstChild("scroll") then
	local scroll = newGUI.button_container.scroll

	if scroll:FindFirstChild("open_inserts") then
		conn:trackConnection("ChangeOpenInsertsGUI",
			scroll.open_inserts.MouseButton1Down:Connect(function()
				animateFrameOut(newGUI.button_container, function()
					animateFrameIn(newGUI.insets_frame)
					instancesManager:refreshInsertsList()
				end)

				conn:trackConnection("InsertsGoBack",
					newGUI.insets_frame.go_back.MouseButton1Down:Connect(function()
						animateFrameOut(newGUI.insets_frame, function()
							animateFrameIn(newGUI.button_container)
						end)
					end)
				)
			end)    
		)
	end

	if scroll:FindFirstChild("change_path") then
		conn:trackConnection("ChangePathGUI",
			scroll.change_path.MouseButton1Down:Connect(function()
				animateFrameOut(newGUI.button_container, function()
					animateFrameIn(newGUI.path_changer_frame)
					pathChangerManager:initialize()
				end)

				conn:trackConnection("PathGoBack",
					newGUI.path_changer_frame.go_back.MouseButton1Down:Connect(function()
						animateFrameOut(newGUI.path_changer_frame, function()
							pathChangerManager:cancelSelection()
							animateFrameIn(newGUI.button_container)
						end)
					end)
				)
			end)    
		)
	end

	if scroll:FindFirstChild("open_magic_select") then
		conn:trackConnection("OpenMagicSelectGUI",
			scroll.open_magic_select.MouseButton1Down:Connect(function()
				animateFrameOut(newGUI.button_container, function()
					animateFrameIn(newGUI.magic_select_frame)
					magicSelectManager:initialize()
				end)

				conn:trackConnection("MagicSelectGoBack",
					newGUI.magic_select_frame.buttons_container.go_back.MouseButton1Down:Connect(function()
						animateFrameOut(newGUI.magic_select_frame, function()
							magicSelectManager:cancelSelection()
							animateFrameIn(newGUI.button_container)
						end)
					end)
				)
			end)    
		)
	end

	if scroll:FindFirstChild("open_bulk_export") then
		conn:trackConnection("OpenBulkExportGUI",
			scroll.open_bulk_export.MouseButton1Down:Connect(function()
				animateFrameOut(newGUI.button_container, function()
					animateFrameIn(newGUI.bulk_export_frame)
					bulkExportManager:initialize()
				end)

				conn:trackConnection("BulkExportGoBack",
					newGUI.bulk_export_frame.buttons_container.go_back.MouseButton1Down:Connect(function()
						animateFrameOut(newGUI.bulk_export_frame, function()
							animateFrameIn(newGUI.button_container)
						end)
					end)
				)
			end)    
		)
	end

	if scroll:FindFirstChild("open_settings") then
		conn:trackConnection("OpenSettingsGUI",
			scroll.open_settings.MouseButton1Down:Connect(function()
				animateFrameOut(newGUI.button_container, function()
					animateFrameIn(newGUI.settings_frame)
					settingsManager:initialize(newGUI, conn)
				end)

				conn:trackConnection("SettingsGoBack",
					newGUI.settings_frame.buttons_container.go_back.MouseButton1Down:Connect(function()
						animateFrameOut(newGUI.settings_frame, function()
							animateFrameIn(newGUI.button_container)
						end)
					end)
				)
			end)    
		)
	end
end

conn:trackConnection("pluginWidget", 
	PluginButton.Click:Connect(function()
		PluginWidget.Enabled = not PluginWidget.Enabled
		if PluginWidget.Enabled then
			resetGUI()
			instancesManager:refreshInsertsList()
		end
	end)    
)

conn:trackConnection("PluginWidgetClosed",
	PluginWidget:GetPropertyChangedSignal("Enabled"):Connect(function()
		if not PluginWidget.Enabled then
			resetGUI()
			pathChangerManager:cancelSelection()
			magicSelectManager:cancelSelection()
		end
	end)
)

conn:trackConnection("UnloadPlugin",
	plugin.Unloading:Connect(function()
		resetGUI()
		pathChangerManager:cancelSelection()
		magicSelectManager:cancelSelection()
		conn:disconnectAll()
	end)    
)

setupButtonAnimations()
resetGUI()]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">3</token>
				<string name="ScriptGuid">{6F9AD9B9-B2D0-479B-80E8-E2295E3429E6}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">init</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX9AD7FB91043B4A4C8B4ACC69D9B9631D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Resources</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX9F6E1866E7234FCD9AEB4F248E9E6A89">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">GUI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Frame" referent="RBXA2583330CA6E4A0CA8A62375CC6C2EA7">
					<Properties>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">main_frame</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Frame" referent="RBX63C0631F8BD34D4DBCAADC586C60EF25">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">path_changer_frame</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ImageButton" referent="RBX2DB1C7AA5AE84ADE891A5FA51529BE06">
							<Properties>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<token name="ScaleType">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="AutoButtonColor">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<bool name="Modal">false</bool>
								<Ref name="PressHapticEffect">null</Ref>
								<bool name="Selected">false</bool>
								<token name="Style">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">1</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.499808043</XS>
									<XO>0</XO>
									<YS>0.498027623</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.834260106</XS>
									<XO>0</XO>
									<YS>0.381447732</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">change_path</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIPadding" referent="RBX1EC5DD3995D048D19356A0D8153E61CE">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBX7395D19D09C8417C998C339AE317589A">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<token name="StrokeSizingMode">0</token>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX3C28629528914E3A839859A03249C63D">
								<Properties>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="OpenTypeFeatures"></string>
									<bool name="RichText">false</bool>
									<string name="Text">Change Insert Path</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">45</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">label</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX7BBFD6E53135447E85E6B54D9A3A4C78">
								<Properties>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="OpenTypeFeatures"></string>
									<bool name="RichText">false</bool>
									<string name="Text">ServerStorage</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">46</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.5</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">1</token>
									<token name="TextYAlignment">1</token>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>1</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">value</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBX7468041381A74366BBE179FCE0CD3FC2">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Change Path Window</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.120315582</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">header</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ImageButton" referent="RBX272EFE2173614493A9E82806A16950AC">
							<Properties>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<token name="ScaleType">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="AutoButtonColor">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<bool name="Modal">false</bool>
								<Ref name="PressHapticEffect">null</Ref>
								<bool name="Selected">false</bool>
								<token name="Style">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">2</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.497149825</XS>
									<XO>0</XO>
									<YS>0.877712011</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.365140051</XS>
									<XO>0</XO>
									<YS>0.1368718</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">go_back</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIPadding" referent="RBX3375AA8AC86E4AADB8C31BD98A547CC3">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBX2965A5400A7C4DC6869A40B82287C3AE">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<token name="StrokeSizingMode">0</token>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX4738DED9E3A8432589C05EF99B488237">
								<Properties>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="OpenTypeFeatures"></string>
									<bool name="RichText">false</bool>
									<string name="Text">Go Back</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">39</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1.00319493</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">label</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX8270F8DD927F4F3B918F11BB40D8FC10">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">button_container</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UIPadding" referent="RBX0BAE6C7242A042DE8C8ED54549482F50">
							<Properties>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>0</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>50</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">padding</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX3BEEA935CECD4731AE1EB4E41C30EF75">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Selection Window</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">header</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ScrollingFrame" referent="RBX4DBE9CC12FD74CCAA12E265A4F090743">
							<Properties>
								<token name="AutomaticCanvasSize">2</token>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0.5</float>
								<int name="ScrollBarThickness">2</int>
								<token name="ScrollingDirection">2</token>
								<bool name="ScrollingEnabled">true</bool>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">true</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>100</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-20</XO>
									<YS>1</YS>
									<YO>-110</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">scroll</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ImageButton" referent="RBX993472474EB44FB7A7999755E3DB4D69">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">open_inserts</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIStroke" referent="RBX26D8F58891E14AA090C6C04EBA9E0147">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX7288DFFC6E064932B16C0B84E8913CCE">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Inserts</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBX56A2C8509CEC4140B1D38D2EDF5A2354">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBX7004508EE59F435EB41C1CB861BE4689">
									<Properties>
										<Content name="Image"><url>rbxassetid://12967375842</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0.5</float>
										<token name="ResampleMode">0</token>
										<token name="ScaleType">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>20</XO>
											<YS>0</YS>
											<YO>20</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">icon</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="UIListLayout" referent="RBX3019E0F6F1394583A1FF4819BF93F362">
								<Properties>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<UDim name="Padding">
										<S>0</S>
										<O>10</O>
									</UDim>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">1</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">list</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIPadding" referent="RBX076BDE082D2B4510AF79358B601515CC">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX8515DDF948A64EA896E411CBC9F62341">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">change_path</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX6607428949824C0C86D2CFF5D55C496C">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX5275105168C742BA8908EE2BAD8257D1">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX3416ED5191BE4368AF149C4FF370A49C">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Change Insert Path</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXCDD259809EE0407ABA91CBD99C88DEF3">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">ServerStorage</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBXDE06C3B13D874E4D8BB67BC18E9CB72B">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">open_magic_select</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBXBA816E79954A4D6AA64CB4CA2824CB53">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX03B4F2C48CCB428293D248425616B2AA">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX2E9E119CFFD448A8B3A56E55356017A2">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Magic Select Tool</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBXA2410744ECA34198B4DDDCE6695C0530">
									<Properties>
										<Content name="Image"><url>rbxassetid://11432864143</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0.5</float>
										<token name="ResampleMode">0</token>
										<token name="ScaleType">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>20</XO>
											<YS>0</YS>
											<YO>20</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">icon</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="TextLabel" referent="RBXB0F4083A02F040E099A41168D5C708D5">
								<Properties>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="OpenTypeFeatures"></string>
									<bool name="RichText">false</bool>
									<string name="Text">DISCLAIMER: !!! I AM NOT THE COPYRIGHT OWNER OF MOST OF THESE ASSETS !!!</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>0</G>
										<B>0.0156862754</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">999999999</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.134166673</XS>
										<XO>0</XO>
										<YS>0.530973434</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.731666684</XS>
										<XO>0</XO>
										<YS>0.0532386787</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">WARNING</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBXD2887E2A52354643AA288D1035E28539">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">5</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">open_settings</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIStroke" referent="RBX7D32273D11BC4DF79AFBF37B55B5C4FB">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX6FCB7223E1734165AFF0AFCB170859DA">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Settings</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBXF74B142ECC204A98A3A8A3B5CD5295E5">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBX6D4273BD0912463181C6A94AD0AFD243">
									<Properties>
										<Content name="Image"><url>rbxassetid://11293977610</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0.5</float>
										<token name="ResampleMode">0</token>
										<token name="ScaleType">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>20</XO>
											<YS>0</YS>
											<YO>20</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">icon</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBXA7419C1917444BF09FF1FC9D05459712">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">5</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">open_bulk_export</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIStroke" referent="RBX9AECA35CC728407CBB05CBBD93613C94">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXB099ED7B393F462FB73CE6908451FDDA">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Bulk Export To Roblox</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBX6E0DCD7D583B43D6BA5858C00F852DB4">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBXFC169D228F384E599CE1D7047A341787">
									<Properties>
										<Content name="Image"><url>rbxassetid://11295287500</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0.5</float>
										<token name="ResampleMode">0</token>
										<token name="ScaleType">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>20</XO>
											<YS>0</YS>
											<YO>20</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">icon</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX6E89792123CC43ABBB7C4F6A6E6CF4D3">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">magic_select_frame</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="TextLabel" referent="RBX2B7BE5DC48E64184B1BE5B058D83550A">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Magic Select</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.0946745574</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">header</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ScrollingFrame" referent="RBXAE2B254C7E0B424D92A141898E827246">
							<Properties>
								<token name="AutomaticCanvasSize">2</token>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0.5</float>
								<int name="ScrollBarThickness">2</int>
								<token name="ScrollingDirection">2</token>
								<bool name="ScrollingEnabled">true</bool>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">true</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.142011806</YS>
									<YO>100</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-20</XO>
									<YS>0.563928306</YS>
									<YO>-110</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">settings_container</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIPadding" referent="RBXC513CF17BA0A422CB6849F5A745A814D">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBXDFCD3857B0774F729D98A0663CBD55A5">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">5</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">by_color</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIStroke" referent="RBX76B408C6D9CF4DDCBE3F3D3FA61B3A43">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX20179347C84D434C93B1305750E6C5C9">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Filter By Object Color (BaseParts only)</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIPadding" referent="RBX4F503CC24EA546D392C09A7E62829619">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX9D7D539C39F148D59A177B96F860E98A">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBXE0AC6E4F269742FFA4798C839AE57794">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">by_class</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX685A1DD2473D45A8A239567260C979C1">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX19DD8FF9208540EAB147C796664D6342">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXFA7FC94C442B47AF997C86F37BE65899">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Filter By Object Class</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX2CB308A969B34ACEA8DF53FF320B8823">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX6974AED1B37743319B2D972AEA1CF571">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">by_name</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBXEBD801681E254F0BA7C76051696E65B2">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX1887AC8A6F2547D5A7CE746717CCC52B">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX71C5DF98567B44B9B040B0036F48A254">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Filter By Object Name</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX8AA8DA877AD445D5AA166A6C9ED3FAC9">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX65A24CBBE3A14B13984BF39FC5C51F4C">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">by_parent</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX3BD3852C95084DC9BA70761AF72D25BE">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX5D0F322A675C4FD5AFAB4CE8218D3E8F">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXC2660E2FE839495E86D401642311B63A">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Filter By Object Parent</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX9D97B5F977ED410582170D76C7891755">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="UIGridLayout" referent="RBXFDDB1F4F7F214140B4883A37FE54EB6A">
								<Properties>
									<UDim2 name="CellPadding">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<UDim2 name="CellSize">
										<XS>0.49000001</XS>
										<XO>0</XO>
										<YS>0.25</YS>
										<YO>0</YO>
									</UDim2>
									<int name="FillDirectionMaxCells">0</int>
									<token name="StartCorner">0</token>
									<token name="FillDirection">0</token>
									<token name="HorizontalAlignment">1</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">1</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIGridLayout</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBXA3BDC0F444C4426F877D28173EBA34A6">
							<Properties>
								<token name="Style">0</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.858974338</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>832</XO>
									<YS>0</YS>
									<YO>120</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">buttons_container</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIListLayout" referent="RBX83E90A724CF948F9A2B1FD8FC18598C0">
								<Properties>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<UDim name="Padding">
										<S>0</S>
										<O>10</O>
									</UDim>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIListLayout</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBXB56F6B91C8734A16A22F317EBCD670B6">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.915187359</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">go_back</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX442BB312A99945BD9A2CB9D720F6B242">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX1C509A8340A349D1B03A59560BD4102C">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX1B826BD81ED04FAE8027DB5E1C71EB0F">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Go Back</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBXC698D7F73D9144B2BD536D0A1216E8EF">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.786982238</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">select</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX762FC9F890A845F09A349B82595ED414">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX9AFAEA177D724E889B7188ABAE4222DA">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX8437D25E9E3B4010AA9595CBC7777B90">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Start Selecting</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBXD3FF033352534C04A1A8F63DB4F54BA3">
						<Properties>
							<Content name="HoverImage"><null></null></Content>
							<Content name="Image"><url>rbxassetid://14407899530</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0.730000019</float>
							<Content name="PressedImage"><null></null></Content>
							<token name="ResampleMode">0</token>
							<token name="ScaleType">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="AutoButtonColor">false</bool>
							<Ref name="HoverHapticEffect">null</Ref>
							<bool name="Modal">false</bool>
							<Ref name="PressHapticEffect">null</Ref>
							<bool name="Selected">false</bool>
							<token name="Style">0</token>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">0</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">background</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX85C62F7D034648AFB13C92DFF4D3E428">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">settings_frame</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="TextLabel" referent="RBX38A75AAB73F64854962D00F3835A23EF">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Settings Window</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.0946745574</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">header</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ScrollingFrame" referent="RBXC83A6F43D30849A4B9D41DD3E2A55EF7">
							<Properties>
								<token name="AutomaticCanvasSize">2</token>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0.5</float>
								<int name="ScrollBarThickness">2</int>
								<token name="ScrollingDirection">2</token>
								<bool name="ScrollingEnabled">true</bool>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">true</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.0374752842</YS>
									<YO>100</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-20</XO>
									<YS>0.733553588</YS>
									<YO>-110</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">settings_container</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIPadding" referent="RBX46F8B1EEDEB043F6A59FA5D233FC44C9">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX620D0403E65B4B5B8887D7EDDC2DFF5B">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">EnablePrints</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX5B22B2BA99024B7D9F6664AC6276AE9A">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBXF8E98CAB82BB4CA29AE555C8FBC1DB71">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXC9D2A0D094BD48D98AD8208C57113D5B">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Enable Print Comments</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX6F0058B833E84267A9A16042352E542F">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="UIGridLayout" referent="RBX93D330F2EDE24E4B8C8227C6459EAFAC">
								<Properties>
									<UDim2 name="CellPadding">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<UDim2 name="CellSize">
										<XS>0.49000001</XS>
										<XO>0</XO>
										<YS>0.25</YS>
										<YO>0</YO>
									</UDim2>
									<int name="FillDirectionMaxCells">0</int>
									<token name="StartCorner">0</token>
									<token name="FillDirection">0</token>
									<token name="HorizontalAlignment">1</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">1</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIGridLayout</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX5F77CCC362694409ABEA5DCED05A7B0A">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">EnableMarketplaceImporting</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX41297F5CF3544E94920177C114BF2FF6">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX7BDA9817BD054BF68870995FBEEF0F06">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX8AAB5CA92927445F8A804E4F1C120B80">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Enable Imorting From Marketplace</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXDDA63C3B7E684D5DAC4FFFA1716F557F">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">True</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.5</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Frame" referent="RBX7C7E174B5A8948B2A60210A52D835D48">
							<Properties>
								<token name="Style">0</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.858974338</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>832</XO>
									<YS>0</YS>
									<YO>120</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">buttons_container</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIListLayout" referent="RBX01F82E671F6144FBB7B6B9AFF359A823">
								<Properties>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<UDim name="Padding">
										<S>0</S>
										<O>10</O>
									</UDim>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIListLayout</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX19C857B00DA84834834A249C48DA547A">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.915187359</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">go_back</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX0F21173414F948D0B185E56B6633EA82">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBXDDB1E919B70549A3A4CCEEC145E5E250">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX45B45BF2D806400AA6211189B5F087B2">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Go Back</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX557C2A0DE3B9455F94C3CBDE5099981C">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">instance_frame</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ImageLabel" referent="RBX72A5A6D667AE42E9988363D2ED4A556E">
							<Properties>
								<Content name="Image"><url>rbxassetid://12246187856</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<token name="ResampleMode">0</token>
								<token name="ScaleType">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.0797970146</XS>
									<XO>0</XO>
									<YS>0.857284248</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.0719818845</XS>
									<XO>0</XO>
									<YS>0.177514821</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">instance_thumbnail</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UICorner" referent="RBX4CAF638F691341F980B30A1880636A52">
								<Properties>
									<UDim name="CornerRadius">
										<S>1</S>
										<O>0</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UICorner</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIAspectRatioConstraint" referent="RBX6B955253CDC74F15976B46ABCB0F36F4">
								<Properties>
									<float name="AspectRatio">0.983752429</float>
									<token name="AspectType">0</token>
									<token name="DominantAxis">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIAspectRatioConstraint</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ScrollingFrame" referent="RBX5CBF176CDC024EBCAF505D0E70D71189">
							<Properties>
								<token name="AutomaticCanvasSize">2</token>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0</float>
								<int name="ScrollBarThickness">6</int>
								<token name="ScrollingDirection">4</token>
								<bool name="ScrollingEnabled">true</bool>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
								<token name="VerticalScrollBarInset">1</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0.75</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">true</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.500622213</XS>
									<XO>0</XO>
									<YS>0.454018265</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.912003815</XS>
									<XO>0</XO>
									<YS>0.490385652</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">info_container</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIListLayout" referent="RBXE5EA45D332864FF289BAC105D250A80B">
								<Properties>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<UDim name="Padding">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">1</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">1</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIListLayout</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UICorner" referent="RBX2D44F0589A164FF1A66657AE325152DF">
								<Properties>
									<UDim name="CornerRadius">
										<S>0</S>
										<O>12</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UICorner</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIPadding" referent="RBX17F1D8A1D6134859AF9425F601C5650F">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIPadding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBX3E95DE80F53D4C22A7DF904AD16A2561">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">InsertName</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.500813007</XS>
									<XO>0</XO>
									<YS>0.0571992099</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">header</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX9CDFCA5F876E46E2AE6F1ACAF37E33FB">
							<Properties>
								<token name="Style">0</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.858974338</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>832</XO>
									<YS>0</YS>
									<YO>120</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">buttons_container</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ImageButton" referent="RBX2C411BE6660E4836BC9D5C9BBCDC2A17">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.915187359</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">go_back</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX0F193D10093B49898F7ADC3766B91C75">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX4F7B2179E48E45329B442E213D0F850C">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX5BA177DAAD6148B18BC06008A9B8888B">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Go Back</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX1447A78ADA61466798DDD86CBD90FCB5">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.656850934</XS>
										<XO>0</XO>
										<YS>0.25</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663701892</XS>
										<XO>0</XO>
										<YS>0.341666669</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">insert_button</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBXE88C943FEF524A2E9EF342D5D007E05F">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX78D87FBBF1964F918C73EC4A66856D99">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXD59A61551946446494C81C5203CE2DD7">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Insert</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="UIListLayout" referent="RBX6A9290DB15C9432B83E76AFB688B18AD">
								<Properties>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<UDim name="Padding">
										<S>0</S>
										<O>10</O>
									</UDim>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIListLayout</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX7731A00E14064E088ACE83A9137875C5">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">insets_frame</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ScrollingFrame" referent="RBXC0C2D561D98745BA986F39A4C5CD419E">
							<Properties>
								<token name="AutomaticCanvasSize">2</token>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0</float>
								<int name="ScrollBarThickness">6</int>
								<token name="ScrollingDirection">4</token>
								<bool name="ScrollingEnabled">true</bool>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">0.75</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">true</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.499990642</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.845473051</XS>
									<XO>0</XO>
									<YS>0.579668581</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">inserts_container</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIGridLayout" referent="RBXF15538C0EB8342098F80DF5B0F5106FF">
								<Properties>
									<UDim2 name="CellPadding">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<UDim2 name="CellSize">
										<XS>0.245000005</XS>
										<XO>0</XO>
										<YS>0.449999988</YS>
										<YO>0</YO>
									</UDim2>
									<int name="FillDirectionMaxCells">0</int>
									<token name="StartCorner">0</token>
									<token name="FillDirection">0</token>
									<token name="HorizontalAlignment">1</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">1</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIGridLayout</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIPadding" referent="RBX0C27FDFDC2854B2DA7ED6DA9DC1A4B36">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>0</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>0</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIPadding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UICorner" referent="RBX290E6289D9F947DDAB420A9FC89A4744">
								<Properties>
									<UDim name="CornerRadius">
										<S>0</S>
										<O>12</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UICorner</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ImageButton" referent="RBXFFCBDBE13C344CA98AD77411507FB2E0">
							<Properties>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<token name="ScaleType">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="AutoButtonColor">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<bool name="Modal">false</bool>
								<Ref name="PressHapticEffect">null</Ref>
								<bool name="Selected">false</bool>
								<token name="Style">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">2</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.499592841</XS>
									<XO>0</XO>
									<YS>0.911242604</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.445114046</XS>
									<XO>0</XO>
									<YS>0.099999994</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">go_back</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIPadding" referent="RBXF2DA7690B43146FA86CEF877C1E93998">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBXF00B072453044BF0A9362CB6CA866A85">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<token name="StrokeSizingMode">0</token>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXA4EA4141CD9C4E5C86C88D339CB5DE2D">
								<Properties>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="OpenTypeFeatures"></string>
									<bool name="RichText">false</bool>
									<string name="Text">Go Back</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">39</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1.00319493</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">label</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBXEAAF721A0FA24ADB83123896FC02275E">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Inserts Window</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.500813007</XS>
									<XO>0</XO>
									<YS>0.0276134126</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">header</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX4C04CE5FD6B34B03AB94C8DE5E7577BF">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">2</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">bulk_export_frame</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="TextLabel" referent="RBXA13ED3ADF0C74B2FA312EABF90141817">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Bulk export to roblox</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.0946745574</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">header</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ScrollingFrame" referent="RBXCCE6F787E4464E35A97C3250775ACED5">
							<Properties>
								<token name="AutomaticCanvasSize">2</token>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<Color3 name="ScrollBarImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0.5</float>
								<int name="ScrollBarThickness">2</int>
								<token name="ScrollingDirection">2</token>
								<bool name="ScrollingEnabled">true</bool>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">true</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.142011806</YS>
									<YO>100</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-20</XO>
									<YS>0.563928306</YS>
									<YO>-110</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">settings_container</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIPadding" referent="RBX29480F61EDC042FAA88EE94AC18FC2DB">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>5</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>5</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIGridLayout" referent="RBX93F023CCA6C74B46AB31A581184AF287">
								<Properties>
									<UDim2 name="CellPadding">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<UDim2 name="CellSize">
										<XS>0.49000001</XS>
										<XO>0</XO>
										<YS>0.25</YS>
										<YO>0</YO>
									</UDim2>
									<int name="FillDirectionMaxCells">0</int>
									<token name="StartCorner">0</token>
									<token name="FillDirection">0</token>
									<token name="HorizontalAlignment">1</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">1</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIGridLayout</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX21BCF386A9914241B39D42D5F168585D">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">export_type</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBXBB73DDA40829412A80559C64069A9C86">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX2FB5CFAB74D44F7C9DE2AE1FF6B02497">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX8EF0F0A865934804A2F3668D66C269BC">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Export Type</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX7D3E84685F6240F18CCA82316B181B20">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Model</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.180000007</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX641DF80548454F0B83F2A4EA531E906E">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">export_name</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBXFAE854619EEC4B539B662067EEE90796">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX862FF42A9791470C866FD44D46F14A6B">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX878C3F5F896B44C08620B181B44296D0">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Export Name</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextBox" referent="RBXB6C1F0F1CE3D48FD879F610272FFA403">
									<Properties>
										<bool name="ClearTextOnFocus">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="MultiLine">true</bool>
										<string name="OpenTypeFeatures"></string>
										<Color3 name="PlaceholderColor3">
											<R>0.699999988</R>
											<G>0.699999988</G>
											<B>0.699999988</B>
										</Color3>
										<string name="PlaceholderText">Click here to add a name to your export</string>
										<bool name="RichText">false</bool>
										<bool name="ShowNativeInput">true</bool>
										<string name="Text"></string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextEditable">true</bool>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">21</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.180000007</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">export_name</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBXFD28B8175C5643B6ACC6ED70A674C2D4">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">export_to</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBXF6205E8F728B48EAB2ABD3FF5D05AD4F">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBXD8A570BF35444F0AB0743CA6019B947B">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX540EC1537521433B9613922B78B18A3E">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Export To Inventory</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXC81218572D5545008B258AA02795B102">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">myself</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.180000007</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX7C9B61A889DD4B7388A49CF4F2135D07">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>420</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">export_type</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBX250817C9F79247489A6D3C369066EC1C">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX93BC9A92E7CC43B19E26E51CD28ED7E8">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX085984D7BCE642C4836ADE71164A37D4">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Content Type</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX2B7FF1A26DD348DEBCE5D154694B0695">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Development Item</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">18</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.180000007</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">1</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">value</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Frame" referent="RBXCA94EA2B805843008E0934A3A451432E">
							<Properties>
								<token name="Style">0</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.858974338</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>832</XO>
									<YS>0</YS>
									<YO>120</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">buttons_container</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIListLayout" referent="RBXD3A979731ECF4E17B5EE84DDF488E10B">
								<Properties>
									<token name="HorizontalFlex">0</token>
									<token name="ItemLineAlignment">0</token>
									<UDim name="Padding">
										<S>0</S>
										<O>10</O>
									</UDim>
									<token name="VerticalFlex">0</token>
									<bool name="Wraps">false</bool>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<token name="SortOrder">2</token>
									<token name="VerticalAlignment">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UIListLayout</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBXC78027E1E55C4360933F606D064386FF">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">2</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.915187359</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">go_back</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBXB541356B5D224229A1C03F6581942359">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX03EBB3E33A314567B35EE37836477239">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX51697308BD154D35A98F25BC249C7791">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Go Back</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageButton" referent="RBX71CADFCF4B344AF3BDC8C79A048EBBB7">
								<Properties>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><null></null></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="AutoButtonColor">false</bool>
									<Ref name="HoverHapticEffect">null</Ref>
									<bool name="Modal">false</bool>
									<Ref name="PressHapticEffect">null</Ref>
									<bool name="Selected">false</bool>
									<token name="Style">0</token>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0.899999976</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">1</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.786982238</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.663999975</XS>
										<XO>0</XO>
										<YS>0.342000008</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">export</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="UIPadding" referent="RBXD3D662A805BE4B93829ABB1D7711EC7C">
									<Properties>
										<UDim name="PaddingBottom">
											<S>0</S>
											<O>10</O>
										</UDim>
										<UDim name="PaddingLeft">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingRight">
											<S>0</S>
											<O>20</O>
										</UDim>
										<UDim name="PaddingTop">
											<S>0</S>
											<O>10</O>
										</UDim>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">padding</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBX6C76FC4D6CC04599A2615733AE8D2335">
									<Properties>
										<token name="ApplyStrokeMode">0</token>
										<UDim name="BorderOffset">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="BorderStrokePosition">0</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">2</token>
										<token name="StrokeSizingMode">0</token>
										<float name="Thickness">0</float>
										<float name="Transparency">0.800000012</float>
										<int name="ZIndex">1</int>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">stroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX9AD56D79694C43CA813D9234D5D11FF4">
									<Properties>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="OpenTypeFeatures"></string>
										<bool name="RichText">false</bool>
										<string name="Text">Export</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">39</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0.100000001</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1.00319493</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
										<bool name="AutoLocalize">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">label</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBX5DA5C25B8C304516803DBF899DF953EA">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>500</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Current Loaded Item: ...</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">30</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.213486418</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.409901053</YS>
									<YO>60</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">sub_header</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX8FBE357715B34EC5BDAEB109F3933192">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Inserts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX96EBE83D7FF34FE29DC44E6DC82EFE52">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">BloodEngine</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB24736C70EFA424498F9867B6E5E6C5E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[
  @ Writer: @Smileeiles
  @ Version: v1.1.3
  @ Description:
     A droplet emitter system,
     used to emit droplets from a specified origin point.

     These droplets are then given a velocity,
     and upon landing on a surface, transform into pools.

     This process can be customized to suit various needs and genres.
]]

-- Essential definitions
local Operator = require(script.Operator)
local Settings = require(script.Settings)
local Functions = require(script.Functions)

-- Globals
local Unpack = table.unpack

-- Class definition
local BloodEngine = {}
BloodEngine.__index = BloodEngine

--[[
  Class constructor, constructs the class
  including other properties/variables.
]]
function BloodEngine.new(Data: Settings.Class)
	local self = setmetatable({}, BloodEngine)
	return self, self:Initialize(Data)
end

--[[
  Immediately called after the construction of the class,
  defines properties/variables for after-construction
]]
function BloodEngine:Initialize(Data: {})
	Functions.MultiInsert(self, {
		ActiveHandler = Settings.new(Data or {}),
		ActiveEngine = function()
			return Operator.new(self)
		end,
	})
end

--[[
  Emitter, emits droplets based on given amount,
  origin & direction.

  This is utilized when you prefer
  not to create a loop just for the
  purpose of emitting a few droplets.
]]
function BloodEngine:EmitAmount(Origin: Vector3 | BasePart, Direction: Vector3, Amount: number, Data: Settings.Class?)
	-- Class definitions
	local Handler: Settings.Class = self.ActiveHandler

	-- Variable definitions
	local DropletDelay = Handler.DropletDelay

	for _ = 1, Amount, 1 do
		-- Define variables for later use
		local DelayTime = Functions.NextNumber(Unpack(DropletDelay))

		-- Emit a droplet in the specified direction & origin
		self:Emit(Origin, Direction, Data)

		-- Delays the next droplet to be emitted
		task.wait(DelayTime)
	end
end

--[[
  EmitOnce, a variant of the Emit method; emits a single droplet.
  Unlike Emit, which uses a loop to emit multiple droplets,
  EmitOnce only emits one droplet per call.

  This is useful when you want to control the emission
  loop externally.
]]
function BloodEngine:Emit(Origin: Vector3 | BasePart, Direction: Vector3, Data: Settings.Class?)
	-- Class definitions
	local Engine: Operator.Class = self.ActiveEngine

	-- Variable definitions
	Origin = typeof(Origin) == "Instance" and Origin.Position or Origin
	Direction = Direction or Functions.GetVector({ -10, 10 }) / 10

	-- Emit a single droplet
	Engine:Emit(Origin, Direction, Data)
end

--[[
  GetSettings, returns all the settings of the
  current class instance.

  Use this function when you want to access
  the settings for external handling of the system.
]]
function BloodEngine:GetSettings(): Settings.Class
	-- Class definitions
	local Handler: Settings.Class = self.ActiveHandler

	-- Export settings
	return Handler
end

--[[
  UpdateSettings, updates the settings of the
  current class instance.

  It uses the `Handler:UpdateSettings()`, which
  uses the given `Data` array/table to update individual settings.
]]
function BloodEngine:UpdateSettings(Data: Settings.Class)
	-- Class definitions
	local Handler: Settings.Class = self.ActiveHandler

	-- Update the settings
	Handler:UpdateSettings(Data)
end

--[[
	Destroy, destroys anything associated 
	with the settings/handler and the operator/engine.
	
	Use this function when there is no longer a use
	for the created engine. (Like when a character dies, etc.)
]]
function BloodEngine:Destroy()
	-- Class definitions
	local Handler: Settings.Class = self.ActiveHandler
	local Engine: Operator.Class = self.ActiveEngine
	
	-- Destroy the handler & engine
	self.Handler = nil
	Engine:Destroy()
	self.Engine = nil
	
	-- Nullify/replace all the Engine methods
	self.UpdateSettings = Functions.Replacement
	self.GetSettings = Functions.Replacement
	
	self.EmitAmount = Functions.Replacement
	self.Emit = Functions.Replacement
end

-- Exports the class
return BloodEngine
]]></ProtectedString>
							<string name="ScriptGuid">{A0182363-4FCD-4E79-B4B2-E1D2D6378E50}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">BloodEngine</string>
							<int64 name="SourceAssetId">82208816003099</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX61281ED441184E1B8CF3D5F34B4E8ED3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[[
  @ Description:
    This is the operator of the base system/class,
    it manages the functionality of the droplets,
    the events of the casts, the limit and such.
]]

-- Variable definitions
local ParentClass = script.Parent
local Assets = ParentClass.Assets

-- Asset definitions
local Sounds = Assets.Sounds
local Essentials = Assets.Essentials
local Meshes = Assets.Meshes

-- Sound definitions
local EndFolder = Sounds.End:GetChildren()
local StartFolder = Sounds.Start:GetChildren()

-- Essential definitions
local Functions = require(ParentClass.Functions)
local PartCache = require(Essentials.PartCache)
local Settings = require(ParentClass.Settings)
local FastCast = require(Essentials.FastCast)

-- Globals
local Unpack = table.unpack

-- Constants definition
local TypeAttribute = "Type"
local DecayAttribute = "Decaying"
local ExpandAttribute = "Expanding"
local MeshMap = {
	Default = Meshes.Droplet,
	Decal = Meshes.Decal,
}

-- Type definitions
type Connections = { RBXScriptConnection }

-- Class definition
local Operator = {}
Operator.__index = Operator

--[[
  Class constructor, constructs the class
  including other properties/variables.
]]
function Operator.new(Class)
	local self = setmetatable({
		Handler = Class.ActiveHandler,
	}, Operator)

	return self, self:Initialize(), self:InitializeCast()
end

--[[
  Immediately called after the construction of the class,
  defines properties/variables for after-construction
]]
function Operator:Initialize()
	-- Variable definitions
	local Handler: Settings.Class = self.Handler
	local FolderName: string = Handler.FolderName

	-- Essential definitions
	local Type = Handler.Type
	local Limit = Handler.Limit
	local CastParams = Handler.RaycastParams

	local Folder = Functions.GetFolder(FolderName)
	local Object = Functions.GetDroplet(Handler.SplashName)

	-- Class definitions
	local Cache = PartCache.new(Object, Limit, Folder)
	
	-- Insert variables
	Functions.MultiInsert(self, {
		Registry = {},
		Connections = {},
		
		Droplet = Object,
		Cache = Cache,
		Container = Folder,
		Caster = FastCast.new(),
		Behavior = function()
			return Functions.SetupBehavior(Cache, CastParams)
		end,
	})
end

--[[
  The Cast-Setup, which is executed immediately
  following the Initialization of the class.

  It efficiently manages events
  associated with the Caster.
]]
function Operator:InitializeCast()
	-- Self definitions
	local Connections: Connections = self.Connections
	local Caster: FastCast.Class = self.Caster
	local Handler: Settings.Class = self.Handler
	local Container: Folder = self.Container

	-- Event definitions
	local LengthChanged = Caster.LengthChanged
	local RayHit = Caster.RayHit

	-- Caster Listeners
	Functions.Connect(LengthChanged:Connect(function(_, Origin, Direction, Length, _, Object: BasePart)
		if not Object then
			return
		end

		-- 3D Definition
		local ObjectSize = Object.Size
		local ObjectLength = ObjectSize.Z / 2

		local Offset = CFrame.new(0, 0, -(Length - ObjectLength))

		local GoalCFrame = CFrame.new(Origin, Origin + Direction):ToWorldSpace(Offset)

		-- Update properties
		Object.CFrame = GoalCFrame
	end), Connections)
	
	Functions.Connect(RayHit:Connect(function(_, RaycastResult: RaycastResult, Velocity, Object: BasePart?)
		if not Object then
			return nil
		end

		-- Options definitions
		local RegistryData = self.Registry[Object] or Handler
		local Size = RegistryData.StartingSize
		local SizeRange = RegistryData.DefaultSize
		local YRange = RegistryData.YSize
		local Distance = RegistryData.Distance
		local Expansion = RegistryData.Expansion
		local IsDecal = RegistryData.Type == "Decal"

		-- Variable definitions
		local CastInstance = RaycastResult.Instance
		local Position = RaycastResult.Position
		local Normal = RaycastResult.Normal

		local VectorSize, SizeY = Functions.GetVector(SizeRange), Functions.NextNumber(table.unpack(YRange))
		local GoalSize = Functions.RefineVectors(IsDecal, Vector3.new(VectorSize.X, VectorSize.Y / 4, VectorSize.X))

		local GoalAngles = Functions.GetAngles(IsDecal, IsDecal)
		local GoalCFrame = Functions.GetCFrame(Position, Normal, IsDecal) * GoalAngles

		local ClosestPart = Functions.GetClosest(Object, Distance, Container)

		local ExpansionLogic = (
			Expansion
				and ClosestPart
				and not ClosestPart:GetAttribute(DecayAttribute)
				and not ClosestPart:GetAttribute(ExpandAttribute)
				and ClosestPart:GetAttribute(TypeAttribute) == RegistryData.Type
		)

		-- Clear the registry entry
		self.Registry[Object] = nil

		-- Evaluates if the droplet is close to another pool, if so, expand.
		if ExpansionLogic then
			self:Expanse(Object, ClosestPart, Velocity, GoalSize, RegistryData)
			return nil
		end

		-- Update properties
		Object.Anchored = true
		Object.Size = Size
		Object.CFrame = GoalCFrame
		Object.Transparency = Functions.NextNumber(Unpack(RegistryData.DefaultTransparency))

		--[[
     		Transitions the droplet into a pool,
      		then handles its later functionality.
        	(Decay, Sounds, etc...)
    	]]
		Functions.CreateTween(Object, RegistryData.Tweens.Landed, { Size = GoalSize }):Play()

		self:HandleDroplet(Object, RegistryData)
		self:HitEffects(Object, Velocity, RegistryData)
		Functions.Weld(CastInstance, Object)

		return nil
	end), Connections)
end

--[[
	Destroys PartCache, FastCast, 
	and all the droplets associated with this engine/operator.
]]
function Operator:Destroy()
	-- Self definitions
	local Connections: Connections = self.Connections
	local Cache: PartCache.Class = self.Cache
	local Caster: FastCast.Class = self.Caster
	local Container: Folder = self.Container
	
	-- Destroy classes
	Cache:Dispose()
	table.clear(Caster)
	
	Functions.DisconnectAll(Connections)
	table.clone(Connections)
	
	-- Destroy main container
	if Container then
		Container:Destroy()
	end
	
	-- Null everything, making the operator unusable
	self.Connections = nil
	self.Container = nil
	self.Cache = nil
	self.Caster = nil
end

--[[
  Emitter, emits a certain amount of droplets,
  at a certain point of origin, with a certain given direction.
]]
function Operator:Emit(Origin: Vector3, Direction: Vector3, Data: Settings.Class?)
	-- Class definitions
	local Caster: FastCast.Class = self.Caster
	local Behavior: FastCast.Behavior = self.Behavior
	local Cache: PartCache.Class = self.Cache
	local Handler: Settings.Class = self.Handler
	
	-- Create a clone of the default settings, and apply specific settings if provided
	local Clone = table.clone(Handler)
	Clone:UpdateSettings(Data or {})
	Data = Clone

	-- Variable definitions
	local IsDecal = Data.Type == "Decal"
	local DropletVelocity = Data.DropletVelocity
	local Velocity = Functions.NextNumber(Unpack(DropletVelocity)) * 10

	local RandomOffset = Data.RandomOffset
	local OffsetRange = Data.OffsetRange
	local Position = Functions.GetVector(OffsetRange) / 10

	-- Final definitions
	local FinalPosition = Origin + Vector3.new(Position.X, 0, Position.Z)
	local FinalStart = (RandomOffset and FinalPosition or Origin)

	if #Cache.Open <= 0 then
		return
	end

	-- Caster definitions, fire the caster with given arguments
	local ActiveDroplet = Caster:Fire(FinalStart, Direction, Velocity, Behavior)

	local RayInfo = ActiveDroplet.RayInfo
	local Droplet: MeshPart = RayInfo.CosmeticBulletObject
	
	-- Update the mesh's look and color
	Droplet:ApplyMesh(MeshMap[Data.Type])
	Droplet.Color = Data.DropletColor
	
	-- Assign the registry entry and update the attributes
	self.Registry[Droplet] = Data
	Droplet:SetAttribute(TypeAttribute, Data.Type)
	Droplet:SetAttribute(DecayAttribute, false)
	Droplet:SetAttribute(ExpandAttribute, false)
	
	-- Execute essential functions
	self:UpdateDroplet(Droplet, Data)
	Functions.PlaySound(Functions.GetRandom(StartFolder), Droplet)
end

--[[
  A small function, designed to update the properties
  of a recently emitted droplet.
]]
function Operator:UpdateDroplet(Object: BasePart, Data: Settings.Class)
	-- Variable definitions
	local DropletTrail = Data.Trail
	local DropletVisible = Data.DropletVisible
	local IsDecal = Data.Type == "Decal"

	-- Object definitions
	local Trail = Object:FindFirstChildOfClass("Trail")

	-- Update Object properties
	Object.Transparency = DropletVisible and 0 or 1
	Trail.Enabled = DropletTrail

	-- Execute essential functions
	Functions.ApplyDecal(Object, IsDecal)
end

--[[
  Handles the given droplet/object after
  it landed on a surface.
]]
function Operator:HandleDroplet(Object: BasePart, Data: Settings.Class)
	-- Object definitions
	local Trail = Object:FindFirstChildOfClass("Trail")

	-- Variable definitions
	local Tweens = Data.Tweens
	local DecayDelay = Data.DecayDelay

	local DecayInfo = Tweens.Decay
	local DecayTime = Functions.NextNumber(Unpack(DecayDelay))

	local ScaleDown = Data.ScaleDown
	local FinalSize = ScaleDown and Vector3.new(0.01, 0.01, 0.01) or Object.Size

	-- Tween definitions
	local DecayTween = Functions.CreateTween(Object, DecayInfo, { Transparency = 1, Size = FinalSize })

	-- Update Droplet properties
	Trail.Enabled = false

	-- Listeners
	DecayTween.Completed:Connect(function()
		DecayTween:Destroy()
		Object:SetAttribute("Decaying", nil)
		self:ReturnDroplet(Object)
	end)

	-- Reset the droplet after the given DecayDelay has passed
	task.delay(DecayTime, function()
		DecayTween:Play()
		Object:SetAttribute("Decaying", true)
	end)
end

--[[
  HitEffects, a sequence of effects to enhance
  the visuals of the droplet->pool
]]
function Operator:HitEffects(Object, Velocity: Vector3, Data: Settings.Class)
	-- Variable definitions
	local SplashName = Data.SplashName
	local SplashAmount = Data.SplashAmount
	local SplashByVelocity = Data.SplashByVelocity
	local Divider = Data.VelocityDivider
	local IsDecal = Data.Type == "Decal"

	local Magnitude = Velocity.Magnitude
	local FinalVelocity = Magnitude / Divider
	local FinalAmount = (SplashByVelocity and FinalVelocity or Functions.NextNumber(Unpack(SplashAmount)))
	local Splash: Attachment = Object:FindFirstChild(SplashName)

	-- Execute essential functions
	Splash.Orientation = Vector3.new(0, 0, IsDecal and 0 or 180)
	Functions.PlaySound(Functions.GetRandom(EndFolder), Object)
	Functions.EmitParticles(Splash, FinalAmount)
end

--[[
	Simulates the pool expansion
	effect when a droplet is near
	a pool.

	It checks the distance between
	a threshold, then triggers changes
	on the droplet & pool.
]]
function Operator:Expanse(
	Object: BasePart,
	ClosestPart: BasePart,
	Velocity: Vector3, 
	Size: Vector3, 
	Data: Settings.Class
)
	-- Variable definitions
	local Divider = Data.ExpanseDivider
	local MaximumSize = Data.MaximumSize
	local IsDecal = Data.Type == "Decal"

	-- Info definitions
	local Tweens = Data.Tweens
	local Expand = Tweens.Expand

	-- Value definitions
	local PoolSize = ClosestPart.Size
	local FinalVelocity = Velocity / 20
	local GoalSize = Vector3.new(Size.X, Size.Y / Divider, Size.Z) / Divider

	local FirstSize = Functions.RefineVectors(
		IsDecal,
		Vector3.new(PoolSize.X - FinalVelocity.Z, PoolSize.Y + FinalVelocity.Y, PoolSize.Z - FinalVelocity.Z)
	)

	local LastSize = Vector3.new(PoolSize.X, PoolSize.Y, PoolSize.Z) + GoalSize

	local FinalSize = (LastSize.X < MaximumSize and LastSize or PoolSize)

	-- Update properties
	ClosestPart:SetAttribute("Expanding", true)
	ClosestPart.Size = FirstSize

	-- Transition to Expanded size
	local Tween = Functions.CreateTween(ClosestPart, Expand, { Size = FinalSize })

	Tween:Play()
	Tween.Completed:Connect(function()
		ClosestPart:SetAttribute("Expanding", nil)
		Tween:Destroy()
	end)

	-- Execute essential functions
	Functions.PlaySound(Functions.GetRandom(EndFolder), ClosestPart)
	self:ReturnDroplet(Object)
end

--[[
  Resets the given droplet/pool,
  then returns it to the Cache.
]]
function Operator:ReturnDroplet(Object: Instance)
	-- Self definitions
	local Cache: PartCache.Class = self.Cache
	local Template: Instance = self.Droplet

	-- Execute essential functions
	Functions.ResetDroplet(Object, Template)
	Cache:ReturnPart(Object) -- Ignore, ReturnPart exists
end

-- Exports the class
export type Class = typeof(Operator.new(...))

return Operator
]]></ProtectedString>
								<string name="ScriptGuid">{6CCDC616-D18D-46B3-83B7-A1A1FC69CF03}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Operator</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEB6A730E8EFD47709717C0644D228115">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[[
  @ Description:
    A class that handles settings,
    a group of keys that have an assigned value.
]]

-- Class definition
local Settings = {}
Settings.__index = Settings

--[[
  Class constructor, constructs the class
  including other properties/variables.
]]
function Settings.new(Data: {})
	local self = setmetatable({
		FolderName = "Droplets", -- Specifies the name of the folder containing the droplets.
		Type = "Default", -- Defines the droplet type. It can be either "Default" (Sphere) or "Decal".
		Limit = 500, -- Sets the maximum number of droplets that can be created.
		Filter = {}, -- An array/table of instances that should be ignored during droplet collision.
		
		YSize = { 0.1, 0.175 }, -- Specifices the range of the thickness/flatness/depth of the pool. Lesser is flatter.
		DefaultSize = { 0.4, 0.7 }, -- Specifies the default size range of a pool.
		DefaultTransparency = { 0.3, 0.4 }, -- Specifies the default transparency range of a pool.
		StartingSize = Vector3.new(0.1, 0.3, 0.1), -- Sets the initial size of the droplets upon landing.
		ScaleDown = true, -- Determines whether the pool should scale down when decaying.

		DropletDelay = { 0.01, 0.03 }, -- Sets the delay between emitting droplets in a loop (for the EmitAmount method).
		DropletVelocity = { 1, 2 }, -- Controls the velocity of the emitted droplet.
		DropletVisible = false, -- Determines if the droplet is visible upon emission.
		DropletColor = Color3.fromRGB(103, 0, 0), -- Determines the color of the emitted droplet.

		RandomOffset = true, -- Determines whether a droplet should spawn at a random offset from a given position.
		OffsetRange = { -5, 5 }, -- Specifies the offset range for the position vectors.

		SplashName = "Impact", -- The name of the attachment that releases particles on surface contact.
		SplashAmount = { 5, 10 }, -- Sets the number of particles to emit upon impact.
		SplashByVelocity = true, -- If true, sets the number of particles based on the velocity of the droplet.
		VelocityDivider = 8, -- Controls how much the velocity can affect the splash amount, Higher values reduce the effect.

		Expansion = true, -- Determines whether a pool can expand when a droplet lands on it.
		Distance = 0.2, -- Sets the distance (in studs) within which the droplet should check for nearby pools
		ExpanseDivider = 3, -- Controls how much a pool's size can increase. Higher values reduce the increase.
		MaximumSize = 0.7, -- Sets the maximum size a pool can reach.

		Trail = true, -- Controls the visibility of the trail during droplet emission.
		DecayDelay = { 10, 15 }, -- Sets the delay before the droplet decays and recycles

		-- Contains all the tweens used by the module
		Tweens = {
			Landed = TweenInfo.new(0.5, Enum.EasingStyle.Cubic), -- Used for when a droplet has landed on a surface.
			Decay = TweenInfo.new(1, Enum.EasingStyle.Cubic), -- Used for when a droplet is decaying.
			Expand = TweenInfo.new(0.5, Enum.EasingStyle.Cubic), -- Used for when a droplet is expanding (Pool Expansion).
		},
	}, Settings)

	-- Fill the default settings with values from the Data array
	for Setting, Value in Data do
		if Setting == "Tweens" then
			for Tween, Info in Value do
				self.Tweens[Tween] = Info
			end

			continue
		end

		self[Setting] = Value
	end

	return self, self:CreateParams()
end

--[[
  Updates settings with values from the provided array.
]]
function Settings:UpdateSettings(Data: {})
	-- Variable definitions
	local Filter = self.Filter
	local Params = self.RaycastParams

	for Setting, Value in Data do
		self[Setting] = Value
	end

	-- Update Param properties
	Params.FilterDescendantsInstances = Filter
end

--[[
	Manages the instantiation of the RaycastParams
	aswell as the configuration of the filter.
]]
function Settings:CreateParams()
	-- Variable definitions
	local Filter = self.Filter
	local Params = RaycastParams.new()

	-- Update Params properties
	Params.FilterType = Enum.RaycastFilterType.Exclude
	Params.FilterDescendantsInstances = Filter

	-- Assign Params as a self value
	self.RaycastParams = Params
end

-- Exports the class and its type
export type Class = typeof(Settings.new(...))

return Settings
]]></ProtectedString>
								<string name="ScriptGuid">{E7CA2315-0CFC-48C6-8153-E38DC899E75A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Settings</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD3B71462AC274986AF7934EA664A5F8B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[[
  @Description: Contains a list of useful functions.
]]

local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

-- Variable definitions
local ParentClass = script.Parent
local Assets = ParentClass.Assets

-- Asset definitions
local Images = Assets.Images
local Essentials = Assets.Essentials
local Effects = Assets.Effects

-- Effect definitions
local TrailEffects = Effects.Trail
local ImpactEffects = Effects.Impact

-- Essential definitions
local FastCast = require(Essentials.FastCast)
local Random = Random.new()

-- Globals
local Unpack = table.unpack
local Decals = Images:GetChildren()

-- Module definition
local Functions = {}

-- Variable definitions
local Properties = {
	"Size",
	"Transparency",
	"Anchored",
}

--[[
  A shorter way of doing:
  ```lua
    typeof(Variable) == "Type"
  ```
]]
function Functions.IsOfType(Any, Type: string)
	return typeof(Any) == Type
end

--[[
  Allows the ability to insert an array of
   variables efficently onto a table.
]]
function Functions.MultiInsert(List: {}, Variables: {})
	for Key, Variable in Variables do
		--[[
      Executes the variable if it's a function,
      It is expected to return a variable to later assign.
    ]]
		if Functions.IsOfType(Variable, "function") then
			Variable = Variable()
		end

		-- Adds in the variable with a key
		if Functions.IsOfType(Key, "string") then
			List[Key] = Variable
		end

		-- Adds in the variable without a key
		table.insert(List, Variable)
	end
end

--[[
  Returns the name of the specified function
  within the classs metatable.
]]
function Functions.GetFunctionName(Function, Table)
	for Name, AltFunction in Table do
		return AltFunction == Function and Name
	end

	return nil
end

--[[
  Sets up a `CastBehavior` for later use,
  then returns it.
]]
function Functions.SetupBehavior(Cache, CastParams): FastCast.Behavior
	-- Define Variables
	local Behavior = FastCast.newBehavior()
	local Gravity = Workspace.Gravity

	-- Update Behavior properties
	Behavior.Acceleration = Vector3.new(0, -Gravity, 0)
	Behavior.MaxDistance = 500
	Behavior.RaycastParams = CastParams
	Behavior.CosmeticBulletProvider = Cache

	-- Export behavior
	return Behavior
end

--[[
	Clones and parents Droplet effects from a template part.
]]
function Functions.CreateEffects(Parent: MeshPart, ImpactName: string)
	-- Variable definitions
	local Trail = TrailEffects:Clone()
	
	local Attachment0 = Instance.new("Attachment")
	local Attachment1 = Instance.new("Attachment")
	local ImpactAttachment = Instance.new("Attachment")
	
	-- Update Trail-related properties
	Trail.Attachment0 = Attachment0
	Trail.Attachment1 = Attachment1
	
	Attachment1.Position = Vector3.new(0.037, 0, 0)
	Attachment0.Name = "Attachment0"
	Attachment1.Name = "Attachment1"
	
	Attachment0.Parent = Parent
	Attachment1.Parent = Parent
	Trail.Parent = Parent

	-- Update Impact-related properties
	for _, Effect in ipairs(ImpactEffects:GetChildren()) do
		local Clone = Effect:Clone()
		Clone.Parent = ImpactAttachment
	end
	
	ImpactAttachment.Name = ImpactName
	ImpactAttachment.Parent = Parent
	ImpactAttachment.Orientation = Vector3.new(0, 0, 0)
end

--[[
	Returns an empty object template that's going to be used as a droplet.
]]
function Functions.GetDroplet(ImpactName: string, IsDecal: boolean): {}
	-- Variable definitions
	local Droplet = Instance.new("MeshPart")
	
	-- Update properties
	Droplet.Size = Vector3.new(0.1, 0.1, 0.1)
	Droplet.Transparency = 0.25
	Droplet.Material = Enum.Material.Glass
	
	Droplet.Anchored = false
	Droplet.CanCollide = false
	Droplet.CanQuery = false
	Droplet.CanTouch = false
	
	-- Export droplet
	Functions.CreateEffects(Droplet, ImpactName)
	return Droplet
end

--[[
  Returns a folder that handles droplets; If it doesn't exist,
  make a new one in Workspace.Terrain.
]]
function Functions.GetFolder(Name: string): Folder
	-- Variable definitons
	local Terrain = Workspace.Terrain
	local DropletsFolder = (Terrain:FindFirstChild(Name) or Instance.new("Folder"))

	-- Update properties
	DropletsFolder.Name = Name
	DropletsFolder.Parent = Terrain

	-- Export folder
	return DropletsFolder
end

--[[
  Returns a Vector3, given the array range.
]]
function Functions.GetVector(Range: {})
	-- Vector definition
	local Vector = Vector3.new(
		Random:NextNumber(Unpack(Range)),
		Random:NextNumber(Unpack(Range)),
		Random:NextNumber(Unpack(Range))
	)

	-- Export position with applied offset
	return Vector
end

--[[
  NextNumber; Uses a global Random class,
  this is done for efficency.
]]
function Functions.NextNumber(Minimum, Maximum): number
	return Random:NextNumber(Minimum, Maximum)
end

--[[
  An efficent way of doing TweenService:Create(...)
]]
function Functions.CreateTween(Object: Instance, Info: TweenInfo, Goal: {}): Tween
	-- Export tween
	return TweenService:Create(Object, Info, Goal)
end

--[[
  Plays a sound in the given parent,
  used to play `End` & `Start` sounds.
]]
function Functions.PlaySound(Sound: Sound, Parent: Instance)
	if not Sound then
		return
	end

	local SoundClone = Sound:Clone()
	SoundClone.Parent = Parent

	SoundClone.Ended:Connect(function()
		SoundClone:Destroy()
	end)

	SoundClone:Play()
end

--[[
  Returns a random value/object from the
  given table.
]]
function Functions.GetRandom(Table: {})
	return #Table > 0 and Table[math.random(1, #Table)]
end

--[[
  Resets the properties of the given droplet,
  used to return pools to be recycled.
]]
function Functions.ResetDroplet(Object: Instance, Original: Instance)
	-- Variable definitions
	local Decal = Object:FindFirstChildOfClass("SurfaceAppearance")
	local Weld = Object:FindFirstChildOfClass("WeldConstraint")
	local Trail = Object:FindFirstChildOfClass("Trail")

	-- Reset all properties
	for _, Property: string in Properties do
		Object[Property] = Original[Property]
	end

	-- Update outsider properties
	if Trail then
		Trail.Enabled = false
	end

	if Weld then
		Weld:Destroy()
	end

	if Decal then
		Decal:Destroy()
	end

	-- Export object
	return Object
end

--[[
	Manages the sequence of decals;
	initiates only when the Type is designated as Decals.
]]
function Functions.ApplyDecal(Object: Instance, IsDecal: boolean)
	if not IsDecal then
		return
	end

	-- Variable definitions
	local Decal: SurfaceAppearance = Functions.GetRandom(Decals):Clone()

	-- Update Decal properties
	Decal.Parent = Object
end

--[[
	Emits particles by looping
	through an attachment's children; emitting a specific
	amount of them using the given amount.
]]
function Functions.EmitParticles(Attachment: Attachment, Amount: number)
	-- Variable definitions
	local Particles = Attachment:GetChildren()

	-- Emits particles
	for _, Particle: ParticleEmitter in Particles do
		if not Particle:IsA("ParticleEmitter") then
			continue
		end

		Particle:Emit(Amount)
	end
end

--[[
	Returns the closest part within a given distance.
]]
function Functions.GetClosest(Origin: BasePart, Magnitude: number, Ancestor): BasePart
	-- Variable definitions
	local Children = Ancestor:GetChildren()
	local ClosestPart = nil
	local MinimumDistance = math.huge

	for _, Part: BasePart in Children do
		local Distance = (Origin.Position - Part.Position).Magnitude

		local Logic = (not Part.Anchored and Origin ~= Part and Distance < Magnitude and Distance < MinimumDistance)

		if not Logic then
			continue
		end

		MinimumDistance = Distance
		ClosestPart = Part
	end

	-- Export closest part
	return ClosestPart
end

--[[
	Provides the target angles; utilized to
	assign the orientation to base position or CFrame.
]]
function Functions.GetAngles(IsDecal: boolean, RandomAngles: boolean): CFrame
	-- Variable definitions
	local RandomAngle = Functions.NextNumber(0, 180)
	local AngleX = (IsDecal and -math.pi / 2 or math.pi / 2)
	local AngleY = (RandomAngles and RandomAngle or 0)

	-- Export angles
	return CFrame.Angles(AngleX, AngleY, 0)
end

--[[
	Delievers the target position; serves
	as a foundation that is subsequently
	applied with an orientation.
]]
function Functions.GetCFrame(Position: Vector3, Normal: Vector3, IsDecal: boolean): CFrame
	-- Variable definitions
	local DecalOffset = (IsDecal and (Normal / 76) or Vector3.zero)

	local Base = (Position + DecalOffset)

	local Target = (Position + Normal)

	-- Export cframe
	return CFrame.new(Base, Target)
end

--[[
	Refines the components of the given
	Vector3; utilized to implement modifications
	based on factors.
]]
function Functions.RefineVectors(IsDecal: boolean, VectorData: Vector3)
	local YVector = (IsDecal and 0 or VectorData.Y)

	return Vector3.new(VectorData.X, YVector, VectorData.Z)
end

--[[
  Weld, creates a WeldConstraint between two parts
   (Part0 and Part1).
]]
function Functions.Weld(Part0: BasePart, Part1: BasePart): WeldConstraint
	-- Variable definitions
	local Weld = Instance.new("WeldConstraint")

	-- Update Part properties
	Part1.Anchored = false

	-- Update Weld properties
	Weld.Parent = Part1
	Weld.Part0 = Part0
	Weld.Part1 = Part1

	-- Export weld
	return Weld
end

--[[
	Adds a connection to a table that holds connections.
]]
function Functions.Connect(Connection: RBXScriptConnection, Holder: { RBXScriptConnection })
	-- Update table
	table.insert(Holder, Connection)
end

--[[
	Destroys and disconnects all the connections 
	in a table that holds connections.
]]
function Functions.DisconnectAll(Holder: { RBXScriptConnection })
	-- Disconnect and destroy connections in Holder
	for Index, Connection: RBXScriptConnection in Holder do
		Connection:Disconnect()
		Holder[Index] = nil
	end
end

--[[
	Basic function used to replace the initial module methods,
	therefore avoiding errors after deletion of the module.
]]
function Functions.Replacement()
	warn("BLOOD-ENGINE - Attempt to call a deleted function.")
end

return Functions
]]></ProtectedString>
								<string name="ScriptGuid">{498FFD67-E4F4-4741-A934-C4D561A9FAA9}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Functions</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX2FA67BAB914F4A13975CA8667F8F8CB7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Assets</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXACB0808ACC554A2FB0040378A8B54E79">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Sounds</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBXE5693935574748488CAFC132ACA4B09C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Start</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBXDB4ED8CB95A9401C945965CEDBC76E1E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">End</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Sound" referent="RBXC8910DEBB99F4382A0D012E58C63D924">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181422</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 3 (SFX)</string>
											<int64 name="SourceAssetId">9114181422</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBXB8ED7F49365643C6AD53B364234F4413">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181479</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 5 (SFX)</string>
											<int64 name="SourceAssetId">9114181479</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBXA064952A3F5344598D6E5137BC3FFB4F">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114182396</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 26 (SFX)</string>
											<int64 name="SourceAssetId">9114182396</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX7F7F63661DBC43A18772CBAA0BA816CD">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181407</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 4 (SFX)</string>
											<int64 name="SourceAssetId">9114181407</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBXB21AC73440A9489D8D8303F3F4ED1464">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181256</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 1 (SFX)</string>
											<int64 name="SourceAssetId">9114181256</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX808F1F05EEDF4245A0B9C12B2B9DBA4E">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181846</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 12 (SFX)</string>
											<int64 name="SourceAssetId">9114181846</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX58F82893A93A496D86A804AD87AF8DF3">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114182402</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 27 (SFX)</string>
											<int64 name="SourceAssetId">9114182402</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX841C7AD69A8E42159E8110ECA8891C64">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114182048</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 19 (SFX)</string>
											<int64 name="SourceAssetId">9114182048</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX360E964DFE2C4E7789BEFA34403D94A4">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181708</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 10 (SFX)</string>
											<int64 name="SourceAssetId">9114181708</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX03DDD722CE204D61831EE27B08DEEDF0">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114183047</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 40 (SFX)</string>
											<int64 name="SourceAssetId">9114183047</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX728B4DC0A486426DA0AAF980F1AD45DA">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181703</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 9 (SFX)</string>
											<int64 name="SourceAssetId">9114181703</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX2386CE8722A144F68F5A7BD8A9A48593">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181526</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 7 (SFX)</string>
											<int64 name="SourceAssetId">9114181526</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX2E0F566368904E84B48A805676BFEAD5">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114181955</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 14 (SFX)</string>
											<int64 name="SourceAssetId">9114181955</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Sound" referent="RBX4728B513CC884745B73B8B193F6A3B5C">
										<Properties>
											<bool name="IsMutedForCapture">false</bool>
											<NumberRange name="LoopRegion">0 60000 </NumberRange>
											<bool name="Looped">false</bool>
											<bool name="PlayOnRemove">false</bool>
											<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
											<bool name="PlaybackRegionsEnabled">false</bool>
											<float name="PlaybackSpeed">1</float>
											<bool name="Playing">false</bool>
											<float name="RollOffMaxDistance">10000</float>
											<float name="RollOffMinDistance">10</float>
											<token name="RollOffMode">0</token>
											<Ref name="SoundGroup">null</Ref>
											<Content name="SoundId"><url>rbxassetid://9114182055</url></Content>
											<double name="TimePosition">0</double>
											<float name="Volume">0.5</float>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Drip Slapping 17 (SFX)</string>
											<int64 name="SourceAssetId">9114182055</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX3DD623E0EF04454C80398C36333B60F9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Essentials</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXBD6AEF7F8E9D4484AED12E45299C4D12">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[--!strict

--[[
	PartCache V4.0 by Xan the Dragon // Eti the Spirit -- RBX 18406183
	Update V4.0 has added Luau Strong Type Enforcement.
	
	Creating parts is laggy, especially if they are supposed to be there for a split second and/or need to be made frequently.
	This module aims to resolve this lag by pre-creating the parts and CFraming them to a location far away and out of sight.
	When necessary, the user can get one of these parts and CFrame it to where they need, then return it to the cache when they are done with it.
	
	According to someone instrumental in Roblox's backend technology, zeuxcg (https://devforum.roblox.com/u/zeuxcg/summary)...
		>> CFrame is currently the only "fast" property in that you can change it every frame without really heavy code kicking in. Everything else is expensive.
		
		- https://devforum.roblox.com/t/event-that-fires-when-rendering-finishes/32954/19
	
	This alone should ensure the speed granted by this module.
		
		
	HOW TO USE THIS MODULE:
	
	Look at the bottom of my thread for an API! https://devforum.roblox.com/t/partcache-for-all-your-quick-part-creation-needs/246641
--]]
local table = require(script:WaitForChild("Table"))

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local PartCacheStatic = {}
PartCacheStatic.__index = PartCacheStatic
PartCacheStatic.__type = "PartCache" -- For compatibility with TypeMarshaller

-- TYPE DEFINITION: Part Cache Instance
export type PartCache = {
	Open: { [number]: BasePart },
	InUse: { [number]: BasePart },
	CurrentCacheParent: Instance,
	Template: BasePart,
	ExpansionSize: number,
}

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------

-- A CFrame that's really far away. Ideally. You are free to change this as needed.
local CF_REALLY_FAR_AWAY = CFrame.new(0, 10e8, 0)

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE =
	"Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-----------------------------------------------------------
------------------------ UTILITIES ------------------------
-----------------------------------------------------------

--Similar to assert but warns instead of errors.
local function assertwarn(requirement: boolean, messageIfNotMet: string)
	if requirement == false then
		warn(messageIfNotMet)
	end
end

--Dupes a part from the template.
local function MakeFromTemplate(template: BasePart, currentCacheParent: Instance): BasePart
	local part: BasePart = template:Clone()
	-- ^ Ignore W000 type mismatch between Instance and BasePart. False alert.

	part.CFrame = CF_REALLY_FAR_AWAY
	part.Anchored = true
	part.Parent = currentCacheParent
	return part
end

function PartCacheStatic.new(template: BasePart, numPrecreatedParts: number?, currentCacheParent: Instance?): PartCache
	local newNumPrecreatedParts: number = numPrecreatedParts or 5
	local newCurrentCacheParent: Instance = currentCacheParent or workspace

	--PrecreatedParts value.
	--Same thing. Ensure it's a number, ensure it's not negative, warn if it's really huge or 0.
	assert(numPrecreatedParts > 0, "PrecreatedParts can not be negative!")
	assertwarn(
		numPrecreatedParts ~= 0,
		"PrecreatedParts is 0! This may have adverse effects when initially using the cache."
	)
	assertwarn(
		template.Archivable,
		"The template's Archivable property has been set to false, which prevents it from being cloned. It will temporarily be set to true."
	)

	local oldArchivable = template.Archivable
	template.Archivable = true
	local newTemplate: BasePart = template:Clone()
	-- ^ Ignore W000 type mismatch between Instance and BasePart. False alert.

	template.Archivable = oldArchivable
	template = newTemplate

	local object: PartCache = {
		Open = {},
		InUse = {},
		CurrentCacheParent = newCurrentCacheParent,
		Template = template,
		ExpansionSize = 10,
	}
	setmetatable(object, PartCacheStatic)

	-- Below: Ignore type mismatch nil | number and the nil | Instance mismatch on the table.insert line.
	for _ = 1, newNumPrecreatedParts do
		table.insert(object.Open, MakeFromTemplate(template, object.CurrentCacheParent))
	end
	object.Template.Parent = nil

	return object
	-- ^ Ignore mismatch here too
end

-- Gets a part from the cache, or creates one if no more are available.
function PartCacheStatic:GetPart(): BasePart
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("GetPart", "PartCache.new"))

	if #self.Open == 0 then
		warn(
			"No parts available in the cache! Creating ["
				.. self.ExpansionSize
				.. "] new part instance(s) - this amount can be edited by changing the ExpansionSize property of the PartCache instance... (This cache now contains a grand total of "
				.. tostring(#self.Open + #self.InUse + self.ExpansionSize)
				.. " parts.)"
		)
		for i = 1, self.ExpansionSize, 1 do
			table.insert(self.Open, MakeFromTemplate(self.Template, self.CurrentCacheParent))
		end
	end
	local part = self.Open[#self.Open]
	self.Open[#self.Open] = nil
	table.insert(self.InUse, part)
	return part
end

-- Returns a part to the cache.
function PartCacheStatic:ReturnPart(part: BasePart)
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("ReturnPart", "PartCache.new"))

	local index = table.indexOf(self.InUse, part)
	if index ~= nil then
		table.remove(self.InUse, index)
		table.insert(self.Open, part)
		part.CFrame = CF_REALLY_FAR_AWAY
		part.Anchored = true
	else
		error(
			'Attempted to return part "'
				.. part.Name
				.. '" ('
				.. part:GetFullName()
				.. ") to the cache, but it's not in-use! Did you call this on the wrong part?"
		)
	end
end

-- Sets the parent of all cached parts.
function PartCacheStatic:SetCacheParent(newParent: Instance)
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("SetCacheParent", "PartCache.new"))
	assert(
		newParent:IsDescendantOf(workspace) or newParent == workspace,
		"Cache parent is not a descendant of Workspace! Parts should be kept where they will remain in the visible world."
	)

	self.CurrentCacheParent = newParent
	for i = 1, #self.Open do
		self.Open[i].Parent = newParent
	end
	for i = 1, #self.InUse do
		self.InUse[i].Parent = newParent
	end
end

-- Adds numParts more parts to the cache.
function PartCacheStatic:Expand(numParts: number): ()
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("Expand", "PartCache.new"))
	if numParts == nil then
		numParts = self.ExpansionSize
	end

	for i = 1, numParts do
		table.insert(self.Open, MakeFromTemplate(self.Template, self.CurrentCacheParent))
	end
end

-- Destroys this cache entirely. Use this when you don't need this cache object anymore.
function PartCacheStatic:Dispose()
	assert(getmetatable(self) == PartCacheStatic, ERR_NOT_INSTANCE:format("Dispose", "PartCache.new"))
	for i = 1, #self.Open do
		self.Open[i]:Destroy()
	end
	for i = 1, #self.InUse do
		self.InUse[i]:Destroy()
	end
	self.Template:Destroy()
	self.Open = {}
	self.InUse = {}
	self.CurrentCacheParent = nil

	self.GetPart = nil
	self.ReturnPart = nil
	self.SetCacheParent = nil
	self.Expand = nil
	self.Dispose = nil
end

export type Class = typeof(PartCacheStatic.new(...))

return PartCacheStatic
]]></ProtectedString>
										<string name="ScriptGuid">{C6AEEBA7-9DD9-4C95-8650-5977F69D4EF7}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">PartCache</string>
										<int64 name="SourceAssetId">2904807375</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXA632EFEE36FD42E4ABEC1C1D57854753">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--!nocheck
--^ It works. Just get the type checker to shut up so that people don't send bug reports :P

--[[
	To use: local table = require(this)
	(Yes, override table.)

	Written by EtiTheSpirit. Adds custom functions to the `table` value provided by roblox (in normal cases, this would simply modify `table`, but Roblox has disabled that so we need to use a proxy)
	
	CHANGES:
		3 December 2019 @ 11:07 PM CST:
			+ Added table.join
			
			
		21 November 2019 @ 6:50 PM CST:
			+ Added new method bodies to skip/take using Luau's new methods. Drastic speed increases achieved. CREDITS: Halalaluyafail3 (See https://devforum.roblox.com/t/sandboxed-table-system-add-custom-methods-to-table/391177/12?u=etithespirit)
			+ Added table.retrieve as proposed by ^ under the name "table.range" as this name relays what it does a bit better, I think.
			+ Added table.skipAndTake as an alias method.

--]]

local RNG = Random.new()
local Table = {}

for index, value in pairs(table) do
	Table[index] = value
end

-- Returns true if the table contains the specified value.
Table.contains = function (tbl, value)
	return Table.indexOf(tbl, value) ~= nil -- This is kind of cheatsy but it promises the best performance.
end

-- A combo of table.find and table.keyOf -- This first attempts to find the ordinal index of your value, then attempts to find the lookup key if it can't find an ordinal index.
Table.indexOf = function (tbl, value)
	local fromFind = table.find(tbl, value)
	if fromFind then return fromFind end
	
	return Table.keyOf(tbl, value)
end

-- Returns the key of the specified value, or nil if it could not be found. Unlike IndexOf, this searches every key in the table, not just ordinal indices (arrays)
-- This is inherently slower due to how lookups work, so if your table is structured like an array, use table.find
Table.keyOf = function (tbl, value)
	for index, obj in pairs(tbl) do
		if obj == value then
			return index
		end
	end
	return nil
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Skips *n* objects in the table, and returns a new table that contains indices (n + 1) to (end of table)
Table.skip = function (tbl, n)
	return table.move(tbl, n+1, #tbl, 1, table.create(#tbl-n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes *n* objects from a table and returns a new table only containing those objects.
Table.take = function (tbl, n)
	return table.move(tbl, 1, n, 1, table.create(n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes the range of entries in this table in the range [start, finish] and returns that range as a table.
Table.range = function (tbl, start, finish)
	return table.move(tbl, start, finish, 1, table.create(finish - start + 1))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). An alias that calls table.skip(skip), and then takes [take] entries from the resulting table.
Table.skipAndTake = function (tbl, skip, take)
	return table.move(tbl, skip + 1, skip + take, 1, table.create(take))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Selects a random object out of tbl
Table.random = function (tbl)
	return tbl[RNG:NextInteger(1, #tbl)]
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Merges tbl0 and tbl1 together.
Table.join = function (tbl0, tbl1)
	local nt = table.create(#tbl0 + #tbl1)
	local t2 = table.move(tbl0, 1, #tbl0, 1, nt)
	return table.move(tbl1, 1, #tbl1, #tbl0 + 1, nt)
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Removes the specified object from this array.
Table.removeObject = function (tbl, obj)
	local index = Table.indexOf(tbl, obj)
	if index then
		table.remove(tbl, index)
	end
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Allocates a new table by getting the length of the current table and increasing its capacity by the specified amount.
-- This uses Roblox's table.create function.
Table.expand = function (tbl, byAmount)
	if (byAmount < 0) then
		error("Cannot expand a table by a negative amount of objects.")
	end
	
	local newtbl = table.create(#tbl + byAmount)
	for i = 1, #tbl do
		newtbl[i] = tbl[i]
	end
	return newtbl
end

return Table]]></ProtectedString>
											<string name="ScriptGuid">{258BAD04-B404-41C0-A1BA-7EDAD3609E86}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Table</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBXA08B7CB4AF7B4F6BAB613E026BE8B7B6">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:

--[[
	Written by Eti the Spirit (18406183)
	
		The latest patch notes can be located here (and do note, the version at the top of this script might be outdated. I have a thing for forgetting to change it):
		>	https://etithespirit.github.io/FastCastAPIDocs/changelog
		
		*** If anything is broken, please don't hesitate to message me! ***
		
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		YOU CAN FIND IMPORTANT USAGE INFORMATION HERE: https://etithespirit.github.io/FastCastAPIDocs
		
		YOU SHOULD ONLY CREATE ONE CASTER PER GUN.
		YOU SHOULD >>>NEVER<<< CREATE A NEW CASTER EVERY TIME THE GUN NEEDS TO BE FIRED.
		
		A caster (created with FastCast.new()) represents a "gun".
		When you consider a gun, you think of stats like accuracy, bullet speed, etc. This is the info a caster stores. 
	
	--
	
	This is a library used to create hitscan-based guns that simulate projectile physics.
	
	This means:
		- You don't have to worry about bullet lag / jittering
		- You don't have to worry about keeping bullets at a low speed due to physics being finnicky between clients
		- You don't have to worry about misfires in bullet's Touched event (e.g. where it may going so fast that it doesn't register)
		
	Hitscan-based guns are commonly seen in the form of laser beams, among other things. Hitscan simply raycasts out to a target
	and says whether it hit or not.
	
	Unfortunately, while reliable in terms of saying if something got hit or not, this method alone cannot be used if you wish
	to implement bullet travel time into a weapon. As a result of that, I made this library - an excellent remedy to this dilemma.
	
	FastCast is intended to be require()'d once in a script, as you can create as many casters as you need with FastCast.new()
	This is generally handy since you can store settings and information in these casters, and even send them out to other scripts via events
	for use.
	
	Remember -- A "Caster" represents an entire gun (or whatever is launching your projectiles), *NOT* the individual bullets.
	Make the caster once, then use the caster to fire your bullets. Do not make a caster for each bullet.
--]]

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local FastCast = {}
FastCast.DebugLogging = false
FastCast.VisualizeCasts = false
FastCast.__index = FastCast
FastCast.__type = "FastCast" -- For compatibility with TypeMarshaller

-- Extra stuff
FastCast.HighFidelityBehavior = {
	Default = 1,
	Always = 3
}

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------
local ActiveCastStatic = require(script.ActiveCast)
local Signal = require(script.Signal)
local table = require(script.Table)

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-- The name of the folder containing the 3D GUI elements for visualizing casts.
local FC_VIS_OBJ_NAME = "FastCastVisualizationObjects"

-- Format params: N/A
local ERR_OBJECT_DISPOSED = "This Caster has been disposed. It can no longer be used."

-----------------------------------------------------------
--------------------- TYPE DEFINITION ---------------------
-----------------------------------------------------------

-- This will inject all types into this context.
local TypeDefs = require(script.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

-----------------------------------------------------------
----------------------- STATIC CODE -----------------------
-----------------------------------------------------------

-- Tell the ActiveCast factory module what FastCast actually *is*.
ActiveCastStatic.SetStaticFastCastReference(FastCast)

-----------------------------------------------------------
------------------------- EXPORTS -------------------------
-----------------------------------------------------------

-- Constructor.
function FastCast.new()
	return setmetatable({
		LengthChanged = Signal.new("LengthChanged"),
		RayHit = Signal.new("RayHit"),
		RayPierced = Signal.new("RayPierced"),
		CastTerminating = Signal.new("CastTerminating"),
		WorldRoot = workspace
	}, FastCast)
end

-- Create a new ray info object.
-- This is just a utility alias with some extra type checking.
function FastCast.newBehavior(): FastCastBehavior
	-- raycastParams, maxDistance, acceleration, canPierceFunction, cosmeticBulletTemplate, cosmeticBulletContainer, autoIgnoreBulletContainer
	return {
		Parallel = false,
		RaycastParams = nil,
		Acceleration = Vector3.new(),
		MaxDistance = 1000,
		CanPierceFunction = nil,
		HighFidelityBehavior = FastCast.HighFidelityBehavior.Default,
		HighFidelitySegmentSize = 0.5,
		CosmeticBulletTemplate = nil,
		CosmeticBulletProvider = nil,
		CosmeticBulletContainer = nil,
		AutoIgnoreContainer = true
	}
end

local DEFAULT_DATA_PACKET = FastCast.newBehavior()
function FastCast:Fire(origin: Vector3, direction: Vector3, velocity: Vector3 | number, castDataPacket: FastCastBehavior?): ActiveCast
	if castDataPacket == nil then castDataPacket = DEFAULT_DATA_PACKET end
	
	local cast = ActiveCastStatic.new(self, origin, direction, velocity, castDataPacket)
	cast.RayInfo.WorldRoot = self.WorldRoot
	return cast
end

-- Export
export type Class = typeof(FastCast.new())
export type Behavior = typeof(FastCast.newBehavior())
return FastCast]]></ProtectedString>
										<string name="ScriptGuid">{02E171E0-99B0-4684-8FC8-EFF92A64BCC6}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">FastCast</string>
										<int64 name="SourceAssetId">4453855787</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX0393EA5D14E04A97867EB03DF4D5AF87">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- shut up jesser

--[[
	To use: local table = require(this)
	(Yes, override table.)

	Written by EtiTheSpirit. Adds custom functions to the `table` value provided by roblox (in normal cases, this would simply modify `table`, but Roblox has disabled that so we need to use a proxy)
	
	CHANGES:
		3 December 2019 @ 11:07 PM CST:
			+ Added table.join
			
			
		21 November 2019 @ 6:50 PM CST:
			+ Added new method bodies to skip/take using Luau's new methods. Drastic speed increases achieved. CREDITS: Halalaluyafail3 (See https://devforum.roblox.com/t/sandboxed-table-system-add-custom-methods-to-table/391177/12?u=etithespirit)
			+ Added table.retrieve as proposed by ^ under the name "table.range" as this name relays what it does a bit better, I think.
			+ Added table.skipAndTake as an alias method.

--]]

local RNG = Random.new()
local RobloxTable = table
local Table = {}

-- Returns true if the table contains the specified value.
Table.contains = function (tbl, value)
	return Table.indexOf(tbl, value) ~= nil -- This is kind of cheatsy but it promises the best performance.
end

-- A combo of table.find and table.keyOf -- This first attempts to find the ordinal index of your value, then attempts to find the lookup key if it can't find an ordinal index.
Table.indexOf = function (tbl, value)
	local fromFind = table.find(tbl, value)
	if fromFind then return fromFind end
	
	return Table.keyOf(tbl, value)
end

-- Returns the key of the specified value, or nil if it could not be found. Unlike IndexOf, this searches every key in the table, not just ordinal indices (arrays)
-- This is inherently slower due to how lookups work, so if your table is structured like an array, use table.find
Table.keyOf = function (tbl, value)
	for index, obj in pairs(tbl) do
		if obj == value then
			return index
		end
	end
	return nil
end

-- Only works on ordinal. yada yada.
Table.insertAndGetIndexOf = function (tbl, value)
	tbl[#tbl + 1] = value
	return #tbl
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Skips *n* objects in the table, and returns a new table that contains indices (n + 1) to (end of table)
Table.skip = function (tbl, n)
	return table.move(tbl, n+1, #tbl, 1, table.create(#tbl-n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes *n* objects from a table and returns a new table only containing those objects.
Table.take = function (tbl, n)
	return table.move(tbl, 1, n, 1, table.create(n))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Takes the range of entries in this table in the range [start, finish] and returns that range as a table.
Table.range = function (tbl, start, finish)
	return table.move(tbl, start, finish, 1, table.create(finish - start + 1))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). An alias that calls table.skip(skip), and then takes [take] entries from the resulting table.
Table.skipAndTake = function (tbl, skip, take)
	return table.move(tbl, skip + 1, skip + take, 1, table.create(take))
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Selects a random object out of tbl
Table.random = function (tbl)
	return tbl[RNG:NextInteger(1, #tbl)]
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Merges tbl0 and tbl1 together.
Table.join = function (tbl0, tbl1)
	local nt = table.create(#tbl0 + #tbl1)
	local t2 = table.move(tbl0, 1, #tbl0, 1, nt)
	return table.move(tbl1, 1, #tbl1, #tbl0 + 1, nt)
end

-- ONLY SUPPORTS ORDINAL TABLES (ARRAYS). Removes the specified object from this array.
Table.removeObject = function (tbl, obj)
	local index = Table.indexOf(tbl, obj)
	if index then
		table.remove(tbl, index)
	end
end

return setmetatable({}, {
	__index = function(tbl, index)
		if Table[index] ~= nil then
			return Table[index]
		else
			return RobloxTable[index]
		end
	end;

	__newindex = function(tbl, index, value)
		error("Add new table entries by editing the Module itself.")
	end;
})]]></ProtectedString>
											<string name="ScriptGuid">{88B98C7E-B97A-49A7-AF5F-48E6A0151625}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Table</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXB8D2E81444534CA5A70F13DFFA8D3499">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:
-- ActiveCast class type.
-- The ActiveCast type represents a currently running cast.


-----------------------------------------------------------
--------------------- TYPE DEFINITION ---------------------
-----------------------------------------------------------

-- This will inject all types into this context.
local TypeDefs = require(script.Parent.TypeDefinitions)

type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

local typeof = require(script.Parent.TypeMarshaller)

-----------------------------------------------------------
-------------------- MODULE DEFINITION --------------------
-----------------------------------------------------------

local ActiveCastStatic = {}
ActiveCastStatic.__index = ActiveCastStatic
ActiveCastStatic.__type = "ActiveCast" -- For compatibility with TypeMarshaller

-----------------------------------------------------------
----------------------- STATIC DATA -----------------------
-----------------------------------------------------------
local RunService = game:GetService("RunService")
local table = require(script.Parent.Table)
local FastCast = nil -- Static reference to the FastCast static module.

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

-- Format params: paramName, expectedType, actualType
local ERR_INVALID_TYPE = "Invalid type for parameter '%s' (Expected %s, got %s)"

-- The name of the folder containing the 3D GUI elements for visualizing casts in debug mode.
local FC_VIS_OBJ_NAME = "FastCastVisualizationObjects"

-- Format params: N/A
local ERR_OBJECT_DISPOSED = "This ActiveCast has been terminated. It can no longer be used."

-- If pierce callback has to run more than this many times, it will register a hit and stop calculating pierces.
-- This only applies for repeated piercings, e.g. the amount of parts that fit within the space of a single cast segment (NOT the whole bullet's trajectory over its entire lifetime)
local MAX_PIERCE_TEST_COUNT = 100

-----------------------------------------------------------
------------------------ UTILITIES ------------------------
-----------------------------------------------------------

-- Looks for a folder within workspace.Terrain that contains elements to visualize casts.
local function GetFastCastVisualizationContainer(): Instance
	local fcVisualizationObjects = workspace.Terrain:FindFirstChild(FC_VIS_OBJ_NAME)
	if fcVisualizationObjects ~= nil then
		return fcVisualizationObjects
	end
	
	fcVisualizationObjects = Instance.new("Folder")
	fcVisualizationObjects.Name = FC_VIS_OBJ_NAME
	fcVisualizationObjects.Archivable = false -- TODO: Keep this as-is? You can't copy/paste it if this is false. I have it false so that it doesn't linger in studio if you save with the debug data in there.
	fcVisualizationObjects.Parent = workspace.Terrain
	return fcVisualizationObjects
end

-----------------------------------------------------------
------------------------ DEBUGGING ------------------------
-----------------------------------------------------------

-- Print that runs only if debug mode is active.
local function PrintDebug(message: string)
	if FastCast.DebugLogging == true then
		print(message)
	end
end

-- Visualizes a ray. This will not run if FastCast.VisualizeCasts is false.
function DbgVisualizeSegment(castStartCFrame: CFrame, castLength: number): ConeHandleAdornment?
	if FastCast.VisualizeCasts ~= true then return nil end
	local adornment = Instance.new("ConeHandleAdornment")
	adornment.Adornee = workspace.Terrain
	adornment.CFrame = castStartCFrame
	adornment.Height = castLength
	adornment.Color3 = Color3.new()
	adornment.Radius = 0.25
	adornment.Transparency = 0.5
	adornment.Parent = GetFastCastVisualizationContainer()
	return adornment
end

-- Visualizes an impact. This will not run if FastCast.VisualizeCasts is false.
function DbgVisualizeHit(atCF: CFrame, wasPierce: boolean): SphereHandleAdornment?
	if FastCast.VisualizeCasts ~= true then return nil end
	local adornment = Instance.new("SphereHandleAdornment")
	adornment.Adornee = workspace.Terrain
	adornment.CFrame = atCF
	adornment.Radius = 0.4
	adornment.Transparency = 0.25
	adornment.Color3 = (wasPierce == false) and Color3.new(0.2, 1, 0.5) or Color3.new(1, 0.2, 0.2)
	adornment.Parent = GetFastCastVisualizationContainer()
	return adornment
end

-----------------------------------------------------------
------------------------ CORE CODE ------------------------
-----------------------------------------------------------

-- Thanks to zoebasil for supplying the velocity and position functions below. (I've modified these functions)
-- I was having a huge issue trying to get it to work and I had overcomplicated a bunch of stuff.
-- GetPositionAtTime is used in physically simulated rays (Where Caster.HasPhysics == true or the specific Fire has a specified acceleration).
-- This returns the location that the bullet will be at when you specify the amount of time the bullet has existed, the original location of the bullet, and the velocity it was launched with.
local function GetPositionAtTime(time: number, origin: Vector3, initialVelocity: Vector3, acceleration: Vector3): Vector3
	local force = Vector3.new((acceleration.X * time^2) / 2,(acceleration.Y * time^2) / 2, (acceleration.Z * time^2) / 2)
	return origin + (initialVelocity * time) + force
end

-- A variant of the function above that returns the velocity at a given point in time.
local function GetVelocityAtTime(time: number, initialVelocity: Vector3, acceleration: Vector3): Vector3
	return initialVelocity + acceleration * time
end

local function GetTrajectoryInfo(cast: ActiveCast, index: number): {[number]: Vector3}
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local trajectories = cast.StateInfo.Trajectories
	local trajectory = trajectories[index]
	local duration = trajectory.EndTime - trajectory.StartTime
	
	local origin = trajectory.Origin
	local vel = trajectory.InitialVelocity
	local accel = trajectory.Acceleration
	
	return {GetPositionAtTime(duration, origin, vel, accel), GetVelocityAtTime(duration, vel, accel)}
end

local function GetLatestTrajectoryEndInfo(cast: ActiveCast): {[number]: Vector3}
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	return GetTrajectoryInfo(cast, #cast.StateInfo.Trajectories)
end

local function CloneCastParams(params: RaycastParams): RaycastParams
	local clone = RaycastParams.new()
	clone.CollisionGroup = params.CollisionGroup
	clone.FilterType = params.FilterType
	clone.FilterDescendantsInstances = params.FilterDescendantsInstances
	clone.IgnoreWater = params.IgnoreWater
	return clone
end

local function SendRayHit(cast: ActiveCast, resultOfCast: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
	cast.Caster.RayHit:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
end

local function SendRayPierced(cast: ActiveCast, resultOfCast: RaycastResult, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
	cast.Caster.RayPierced:Fire(cast, resultOfCast, segmentVelocity, cosmeticBulletObject)
end

local function SendLengthChanged(cast: ActiveCast, lastPoint: Vector3, rayDir: Vector3, rayDisplacement: number, segmentVelocity: Vector3, cosmeticBulletObject: Instance?)
	--cast.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)
	cast.Caster.LengthChanged:Fire(cast, lastPoint, rayDir, rayDisplacement, segmentVelocity, cosmeticBulletObject)
end

-- Simulate a raycast by one tick.
local function SimulateCast(cast: ActiveCast, delta: number, expectingShortCall: boolean)
	
	assert(cast.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	PrintDebug("Casting for frame.")
	local latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]
	
	local origin = latestTrajectory.Origin
	local totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	local initialVelocity = latestTrajectory.InitialVelocity
	local acceleration = latestTrajectory.Acceleration
	
	local lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
	local lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)
	local lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	
	cast.StateInfo.TotalRuntime += delta
	
	-- Recalculate this.
	totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
	
	local currentTarget = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
	local segmentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration) 
	local totalDisplacement = currentTarget - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.
	
	local rayDir = totalDisplacement.Unit * segmentVelocity.Magnitude * delta
	local targetWorldRoot = cast.RayInfo.WorldRoot
	local resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)
	
	local point = currentTarget
	local part: Instance? = nil
	local material = Enum.Material.Air
	local normal = Vector3.new()
	
	if (resultOfCast ~= nil) then
		point = resultOfCast.Position
		part = resultOfCast.Instance
		material = resultOfCast.Material
		normal = resultOfCast.Normal
	end
	
	local rayDisplacement = (point - lastPoint).Magnitude
	-- For clarity -- totalDisplacement is how far the ray would have traveled if it hit nothing,
	-- and rayDisplacement is how far the ray really traveled (which will be identical to totalDisplacement if it did indeed hit nothing)
	
	SendLengthChanged(cast, lastPoint, rayDir.Unit, rayDisplacement, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
	cast.StateInfo.DistanceCovered += rayDisplacement
	
	local rayVisualization: ConeHandleAdornment? = nil
	if (delta > 0) then
		rayVisualization = DbgVisualizeSegment(CFrame.new(lastPoint, lastPoint + rayDir), rayDisplacement)
	end
	
	
	-- HIT DETECTED. Handle all that garbage, and also handle behaviors 1 and 2 (default behavior, go high res when hit) if applicable.
	-- CAST BEHAVIOR 2 IS HANDLED IN THE CODE THAT CALLS THIS FUNCTION.
	--task.synchronize()
	
	if part and part ~= cast.RayInfo.CosmeticBulletObject then
		local start = tick()
		PrintDebug("Hit something, testing now.")
		
		-- SANITY CHECK: Don't allow the user to yield or run otherwise extensive code that takes longer than one frame/heartbeat to execute.
		if (cast.RayInfo.CanPierceCallback ~= nil) then
			if expectingShortCall == false then
				if (cast.StateInfo.IsActivelySimulatingPierce) then
					cast:Terminate()
					error("ERROR: The latest call to CanPierceCallback took too long to complete! This cast is going to suffer desyncs which WILL cause unexpected behavior and errors. Please fix your performance problems, or remove statements that yield (e.g. wait() calls)")
					-- Use error. This should absolutely abort the cast.
				end
			end
			-- expectingShortCall is used to determine if we are doing a forced resolution increase, in which case this will be called several times in a single frame, which throws this error.
			cast.StateInfo.IsActivelySimulatingPierce = true
		end
		------------------------------
		
		if cast.RayInfo.CanPierceCallback == nil or (cast.RayInfo.CanPierceCallback ~= nil and cast.RayInfo.CanPierceCallback(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject) == false) then
			PrintDebug("Piercing function is nil or it returned FALSE to not pierce this hit.")
			cast.StateInfo.IsActivelySimulatingPierce = false
			
			if (cast.StateInfo.HighFidelityBehavior == 2 and latestTrajectory.Acceleration ~= Vector3.new() and cast.StateInfo.HighFidelitySegmentSize ~= 0) then
				cast.StateInfo.CancelHighResCast = false -- Reset this here.
				
				if cast.StateInfo.IsActivelyResimulating then
					cast:Terminate()
					error("Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.")
				end
				

				cast.StateInfo.IsActivelyResimulating = true
				
				-- This is a physics based cast and it needs to be recalculated.
				PrintDebug("Hit was registered, but recalculation is on for physics based casts. Recalculating to verify a real hit...")
				
				-- Split this ray segment into smaller segments of a given size.
				-- In 99% of cases, it won't divide evently (e.g. I have a distance of 1.25 and I want to divide into 0.1 -- that won't work)
				-- To fix this, the segments need to be stretched slightly to fill the space (rather than having a single shorter segment at the end)
				
				local numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments
				local numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments
				local realSegmentLength = rayDisplacement / numSegmentsReal -- this spits out 0.51, which isn't exact to the defined 0.5, but it's close
				
				-- Now the real hard part is converting this to time.
				local timeIncrement = delta / numSegmentsReal
				for segmentIndex = 1, numSegmentsReal do
					if cast.StateInfo.CancelHighResCast then
						cast.StateInfo.CancelHighResCast = false
						break
					end
					
					local subPosition = GetPositionAtTime(lastDelta + (timeIncrement * segmentIndex), origin, initialVelocity, acceleration)
					local subVelocity = GetVelocityAtTime(lastDelta + (timeIncrement * segmentIndex), initialVelocity, acceleration) 
					local subRayDir = subVelocity * delta
					local subResult = targetWorldRoot:Raycast(subPosition, subRayDir, cast.RayInfo.Parameters)
					
					local subDisplacement = (subPosition - (subPosition + subVelocity)).Magnitude
					
					if (subResult ~= nil) then
						local subDisplacement = (subPosition - subResult.Position).Magnitude
						local dbgSeg = DbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)
						if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059) end
						
						if cast.RayInfo.CanPierceCallback == nil or (cast.RayInfo.CanPierceCallback ~= nil and cast.RayInfo.CanPierceCallback(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject) == false) then
							-- Still hit even at high res
							cast.StateInfo.IsActivelyResimulating = false
							
							SendRayHit(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject)
							cast:Terminate()
							local vis = DbgVisualizeHit(CFrame.new(point), false)
							if (vis ~= nil) then vis.Color3 = Color3.new(0.0588235, 0.87451, 1) end
							return
						else
							-- Recalculating hit something pierceable instead.
							SendRayPierced(cast, subResult, subVelocity, cast.RayInfo.CosmeticBulletObject) -- This may result in CancelHighResCast being set to true.
							local vis = DbgVisualizeHit(CFrame.new(point), true)
							if (vis ~= nil) then vis.Color3 = Color3.new(1, 0.113725, 0.588235) end
							if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.305882, 0.243137, 0.329412) end
						end
					else
						local dbgSeg = DbgVisualizeSegment(CFrame.new(subPosition, subPosition + subVelocity), subDisplacement)
						if (dbgSeg ~= nil) then dbgSeg.Color3 = Color3.new(0.286275, 0.329412, 0.247059) end
						
					end
				end
				
				-- If the script makes it here, then it wasn't a real hit (higher resolution revealed that the low-res hit was faulty)
				-- Just let it keep going.
				cast.StateInfo.IsActivelyResimulating = false
			elseif (cast.StateInfo.HighFidelityBehavior ~= 1 and cast.StateInfo.HighFidelityBehavior ~= 3) then
				cast:Terminate()
				error("Invalid value " .. (cast.StateInfo.HighFidelityBehavior) .. " for HighFidelityBehavior.")
			else
				-- This is not a physics cast, or recalculation is off.
				PrintDebug("Hit was successful. Terminating.")
				SendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				cast:Terminate()
				DbgVisualizeHit(CFrame.new(point), false)
				return
			end
		else
			PrintDebug("Piercing function returned TRUE to pierce this part.")
			if rayVisualization ~= nil then
				rayVisualization.Color3 = Color3.new(0.4, 0.05, 0.05) -- Turn it red to signify that the cast was scrapped.
			end
			DbgVisualizeHit(CFrame.new(point), true)
			
			local params = cast.RayInfo.Parameters
			local alteredParts = {}
			local currentPierceTestCount = 0
			local originalFilter = params.FilterDescendantsInstances
			local brokeFromSolidObject = false
			while true do
				-- So now what I need to do is redo this entire cast, just with the new filter list
								
				-- Catch case: Is it terrain?
				if resultOfCast.Instance:IsA("Terrain") then
					if material == Enum.Material.Water then
						-- Special case: Pierced on water?
						cast:Terminate()
						error("Do not add Water as a piercable material. If you need to pierce water, set cast.RayInfo.Parameters.IgnoreWater = true instead", 0)
					end
					warn("WARNING: The pierce callback for this cast returned TRUE on Terrain! This can cause severely adverse effects.")
				end
				
				if params.FilterType == Enum.RaycastFilterType.Blacklist then
					-- blacklist
					-- DO NOT DIRECTLY TABLE.INSERT ON THE PROPERTY
					local filter = params.FilterDescendantsInstances
					table.insert(filter, resultOfCast.Instance)
					table.insert(alteredParts, resultOfCast.Instance)
					params.FilterDescendantsInstances = filter
				else
					-- whitelist
					-- method implemeneted by custom table system
					-- DO NOT DIRECTLY TABLE.REMOVEOBJECT ON THE PROPERTY
					local filter = params.FilterDescendantsInstances
					table.removeObject(filter, resultOfCast.Instance)
					table.insert(alteredParts, resultOfCast.Instance)
					params.FilterDescendantsInstances = filter
				end
				
				SendRayPierced(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				
				-- List has been updated, so let's cast again.
				resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, params)
				
				-- No hit? No simulation. Break.
				if resultOfCast == nil then
					break
				end
				
				if currentPierceTestCount >= MAX_PIERCE_TEST_COUNT then
					warn("WARNING: Exceeded maximum pierce test budget for a single ray segment (attempted to test the same segment " .. MAX_PIERCE_TEST_COUNT .. " times!)")
					break
				end
				currentPierceTestCount = currentPierceTestCount + 1;
				
				if cast.RayInfo.CanPierceCallback(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject) == false then
					brokeFromSolidObject = true
					break
				end
			end
			
			-- Restore the filter to its default state.
			cast.RayInfo.Parameters.FilterDescendantsInstances = originalFilter
			cast.StateInfo.IsActivelySimulatingPierce = false
			
			if brokeFromSolidObject then
				-- We actually hit something while testing.
				PrintDebug("Broke because the ray hit something solid (" .. tostring(resultOfCast.Instance) .. ") while testing for a pierce. Terminating the cast.")
				SendRayHit(cast, resultOfCast, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
				cast:Terminate()
				DbgVisualizeHit(CFrame.new(resultOfCast.Position), false)
				return
			end
			
			-- And exit the function here too.
		end
	end
	
	if (cast.StateInfo.DistanceCovered >= cast.RayInfo.MaxDistance) then
		-- SendRayHit(cast, nil, segmentVelocity, cast.RayInfo.CosmeticBulletObject)
		cast:Terminate()
		DbgVisualizeHit(CFrame.new(currentTarget), false)
	end
end

-----------------------------------------------------------
------------------------- EXPORTS -------------------------
-----------------------------------------------------------

-- Ctor
function ActiveCastStatic.new(caster: Caster, origin: Vector3, direction: Vector3, velocity: Vector3 | number, castDataPacket: FastCastBehavior): ActiveCast
	if typeof(velocity) == "number" then
		velocity = direction.Unit * velocity
	end	
	
	if (castDataPacket.HighFidelitySegmentSize <= 0) then
		error("Cannot set FastCastBehavior.HighFidelitySegmentSize <= 0!", 0)
	end
	
	-- Basic setup
	local cast = {
		Caster = caster,
		
		-- Data that keeps track of what's going on as well as edits we might make during runtime.
		StateInfo = {
			UpdateConnection = nil,
			Paused = false,
			TotalRuntime = 0,
			DistanceCovered = 0,
			HighFidelitySegmentSize = castDataPacket.HighFidelitySegmentSize,
			HighFidelityBehavior = castDataPacket.HighFidelityBehavior,
			IsActivelySimulatingPierce = false,
			IsActivelyResimulating = false,
			CancelHighResCast = false,
			Trajectories = {
				{
					StartTime = 0,
					EndTime = -1,
					Origin = origin,
					InitialVelocity = velocity,
					Acceleration = castDataPacket.Acceleration
				}
			}
		},
		
		-- Information pertaining to actual raycasting.
		RayInfo = {
			Parameters = castDataPacket.RaycastParams,
			WorldRoot = workspace,
			MaxDistance = castDataPacket.MaxDistance or 1000,
			CosmeticBulletObject = castDataPacket.CosmeticBulletTemplate, -- This is intended. We clone it a smidge of the way down.
			CanPierceCallback = castDataPacket.CanPierceFunction
		},
		
		UserData = {}
	}
	
	if cast.StateInfo.HighFidelityBehavior == 2 then
		cast.StateInfo.HighFidelityBehavior = 3
	end
	
	
	if cast.RayInfo.Parameters ~= nil then
		cast.RayInfo.Parameters = CloneCastParams(cast.RayInfo.Parameters)
	else
		cast.RayInfo.Parameters = RaycastParams.new()
	end

	local usingProvider = false
	if castDataPacket.CosmeticBulletProvider == nil then
		-- The provider is nil. Use a cosmetic object clone.
		if cast.RayInfo.CosmeticBulletObject ~= nil then
			cast.RayInfo.CosmeticBulletObject = cast.RayInfo.CosmeticBulletObject:Clone()
			cast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)
			cast.RayInfo.CosmeticBulletObject.Parent = castDataPacket.CosmeticBulletContainer
		end
	else
		-- The provider is not nil.
		-- Is it what we want?
		if typeof(castDataPacket.CosmeticBulletProvider) == "PartCache" then
			-- this modded version of typeof is implemented up top.
			-- Aside from that, yes, it's a part cache. Good to go!
			
			if cast.RayInfo.CosmeticBulletObject ~= nil then
				-- They also set the template. Not good. Warn + clear this up.
				warn("Do not define FastCastBehavior.CosmeticBulletTemplate and FastCastBehavior.CosmeticBulletProvider at the same time! The provider will be used, and CosmeticBulletTemplate will be set to nil.")
				cast.RayInfo.CosmeticBulletObject = nil
				castDataPacket.CosmeticBulletTemplate = nil
			end

			cast.RayInfo.CosmeticBulletObject = castDataPacket.CosmeticBulletProvider:GetPart()
			cast.RayInfo.CosmeticBulletObject.CFrame = CFrame.new(origin, origin + direction)
			usingProvider = true
		else
			warn("FastCastBehavior.CosmeticBulletProvider was not an instance of the PartCache module (an external/separate model)! Are you inputting an instance created via PartCache.new? If so, are you on the latest version of PartCache? Setting FastCastBehavior.CosmeticBulletProvider to nil.")
			castDataPacket.CosmeticBulletProvider = nil
		end
	end

	local targetContainer: Instance;
	if usingProvider then
		targetContainer = castDataPacket.CosmeticBulletProvider.CurrentCacheParent
	else
		targetContainer = castDataPacket.CosmeticBulletContainer
	end
	
	if castDataPacket.AutoIgnoreContainer == true and targetContainer ~= nil then
		local ignoreList = cast.RayInfo.Parameters.FilterDescendantsInstances
		if table.find(ignoreList, targetContainer) == nil then
			table.insert(ignoreList, targetContainer)
			cast.RayInfo.Parameters.FilterDescendantsInstances = ignoreList
		end
	end
	
	local event
	if RunService:IsClient() then
		event = RunService.RenderStepped
	else
		event = RunService.Heartbeat
	end
	
	setmetatable(cast, ActiveCastStatic)
	
	local function Stepped(delta)
		if cast.StateInfo.Paused then return end

		PrintDebug("Casting for frame.")
		local latestTrajectory = cast.StateInfo.Trajectories[#cast.StateInfo.Trajectories]
		if (cast.StateInfo.HighFidelityBehavior == 3 and latestTrajectory.Acceleration ~= Vector3.new() and cast.StateInfo.HighFidelitySegmentSize > 0) then

			local timeAtStart = tick()

			if cast.StateInfo.IsActivelyResimulating then
				cast:Terminate()
				error("Cascading cast lag encountered! The caster attempted to perform a high fidelity cast before the previous one completed, resulting in exponential cast lag. Consider increasing HighFidelitySegmentSize.")
			end

			cast.StateInfo.IsActivelyResimulating = true

			-- Actually want to calculate this early to find displacement
			local origin = latestTrajectory.Origin
			local totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime
			local initialVelocity = latestTrajectory.InitialVelocity
			local acceleration = latestTrajectory.Acceleration

			local lastPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
			local lastVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration)
			local lastDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime

			cast.StateInfo.TotalRuntime += delta

			-- Recalculate this.
			totalDelta = cast.StateInfo.TotalRuntime - latestTrajectory.StartTime

			local currentPoint = GetPositionAtTime(totalDelta, origin, initialVelocity, acceleration)
			local currentVelocity = GetVelocityAtTime(totalDelta, initialVelocity, acceleration) 
			local totalDisplacement = currentPoint - lastPoint -- This is the displacement from where the ray was on the last from to where the ray is now.

			local rayDir = totalDisplacement.Unit * currentVelocity.Magnitude * delta
			local targetWorldRoot = cast.RayInfo.WorldRoot
			local resultOfCast = targetWorldRoot:Raycast(lastPoint, rayDir, cast.RayInfo.Parameters)

			local point = currentPoint

			if (resultOfCast ~= nil) then
				point = resultOfCast.Position
			end

			local rayDisplacement = (point - lastPoint).Magnitude

			-- Now undo this. The line below in the for loop will add this time back gradually.
			cast.StateInfo.TotalRuntime -= delta

			-- And now that we have displacement, we can calculate segment size.
			local numSegmentsDecimal = rayDisplacement / cast.StateInfo.HighFidelitySegmentSize -- say rayDisplacement is 5.1, segment size is 0.5 -- 10.2 segments
			local numSegmentsReal = math.floor(numSegmentsDecimal) -- 10 segments + 0.2 extra segments
			if (numSegmentsReal == 0) then
				numSegmentsReal = 1
			end

			local timeIncrement = delta / numSegmentsReal

			for segmentIndex = 1, numSegmentsReal do
				if getmetatable(cast) == nil then return end -- Could have been disposed.
				if cast.StateInfo.CancelHighResCast then
					cast.StateInfo.CancelHighResCast = false
					break
				end
				PrintDebug("[" .. segmentIndex .. "] Subcast of time increment " .. timeIncrement)
				SimulateCast(cast, timeIncrement, true)
			end

			if getmetatable(cast) == nil then return end -- Could have been disposed.
			cast.StateInfo.IsActivelyResimulating = false

			if (tick() - timeAtStart) > 0.016 * 5 then
				warn("Extreme cast lag encountered! Consider increasing HighFidelitySegmentSize.")
			end
		else
			SimulateCast(cast, delta, false)
		end
	end
	
	cast.StateInfo.UpdateConnection = (
		castDataPacket.Parallel and event:ConnectParallel(Stepped) 
		or event:Connect(Stepped)
	)
	
	return cast
end

function ActiveCastStatic.SetStaticFastCastReference(ref)
	FastCast = ref
end

---- GETTERS AND SETTERS ----

local function ModifyTransformation(cast: ActiveCast, velocity: Vector3?, acceleration: Vector3?, position: Vector3?)
	local trajectories = cast.StateInfo.Trajectories
	local lastTrajectory = trajectories[#trajectories]
	
	-- NEW BEHAVIOR: Don't create a new trajectory if we haven't even used the current one.
	if lastTrajectory.StartTime == cast.StateInfo.TotalRuntime then
		-- This trajectory is fresh out of the box. Let's just change it since it hasn't actually affected the cast yet, so changes won't have adverse effects.
		if (velocity == nil) then
			velocity = lastTrajectory.InitialVelocity
		end
		if (acceleration == nil) then
			acceleration = lastTrajectory.Acceleration
		end
		if (position == nil) then
			position = lastTrajectory.Origin
		end	
		
		lastTrajectory.Origin = position
		lastTrajectory.InitialVelocity = velocity
		lastTrajectory.Acceleration = acceleration
	else
		-- The latest trajectory is done. Set its end time and get its location. 
		lastTrajectory.EndTime = cast.StateInfo.TotalRuntime
		
		local point, velAtPoint = unpack(GetLatestTrajectoryEndInfo(cast))
		
		if (velocity == nil) then
			velocity = velAtPoint
		end
		if (acceleration == nil) then
			acceleration = lastTrajectory.Acceleration
		end
		if (position == nil) then
			position = point
		end	
		table.insert(cast.StateInfo.Trajectories, {
			StartTime = cast.StateInfo.TotalRuntime,
			EndTime = -1,
			Origin = position,
			InitialVelocity = velocity,
			Acceleration = acceleration
		})
		cast.StateInfo.CancelHighResCast = true
	end
end

function ActiveCastStatic:SetVelocity(velocity: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, velocity, nil, nil)
end

function ActiveCastStatic:SetAcceleration(acceleration: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, nil, acceleration, nil)
end

function ActiveCastStatic:SetPosition(position: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("SetPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	ModifyTransformation(self, nil, nil, position)
end

function ActiveCastStatic:GetVelocity(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return GetVelocityAtTime(self.StateInfo.TotalRuntime - currentTrajectory.StartTime, currentTrajectory.InitialVelocity, currentTrajectory.Acceleration)
end

function ActiveCastStatic:GetAcceleration(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return currentTrajectory.Acceleration
end

function ActiveCastStatic:GetPosition(): Vector3
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("GetPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	local currentTrajectory = self.StateInfo.Trajectories[#self.StateInfo.Trajectories]
	return GetPositionAtTime(self.StateInfo.TotalRuntime - currentTrajectory.StartTime, currentTrajectory.Origin, currentTrajectory.InitialVelocity, currentTrajectory.Acceleration)
end

---- ARITHMETIC ----

function ActiveCastStatic:AddVelocity(velocity: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddVelocity", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetVelocity(self:GetVelocity() + velocity)
end

function ActiveCastStatic:AddAcceleration(acceleration: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddAcceleration", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetAcceleration(self:GetAcceleration() + acceleration)
end

function ActiveCastStatic:AddPosition(position: Vector3)
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("AddPosition", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self:SetPosition(self:GetPosition() + position)
end

---- STATE MODIFICATION ----

function ActiveCastStatic:Pause()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Pause", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self.StateInfo.Paused = true
end

function ActiveCastStatic:Resume()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Resume", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	self.StateInfo.Paused = false
end

function ActiveCastStatic:Terminate()
	assert(getmetatable(self) == ActiveCastStatic, ERR_NOT_INSTANCE:format("Terminate", "ActiveCast.new(...)"))
	assert(self.StateInfo.UpdateConnection ~= nil, ERR_OBJECT_DISPOSED)
	
	-- First: Set EndTime on the latest trajectory since it is now done simulating.
	local trajectories = self.StateInfo.Trajectories
	local lastTrajectory = trajectories[#trajectories]
	lastTrajectory.EndTime = self.StateInfo.TotalRuntime
	
	-- Disconnect the update connection.
	self.StateInfo.UpdateConnection:Disconnect()
	
	-- Now fire CastTerminating
	self.Caster.CastTerminating:FireSync(self)
	
	-- And now set the update connection object to nil.
	self.StateInfo.UpdateConnection = nil
	
	-- And nuke everything in the table + clear the metatable.
	self.Caster = nil
	self.StateInfo = nil
	self.RayInfo = nil
	self.UserData = nil
	setmetatable(self, nil)
end

return ActiveCastStatic]]></ProtectedString>
											<string name="ScriptGuid">{DCDF577C-5426-4EA5-9CD7-D15FC061ED8F}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ActiveCast</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXCA95BA03D3674046B1140218B4BD0895">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:

-- A new implementation of RBXScriptSignal that uses proper Lua OOP.
-- This was explicitly made to transport other OOP objects.
-- I would be using BindableEvents, but they don't like cyclic tables (part of OOP objects with __index)

-- Inject types
local TypeDefs = require(script.Parent.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast

local TestService = game:GetService("TestService")
local table = require(script.Parent.Table)

local SignalStatic = {}
SignalStatic.__index = SignalStatic
SignalStatic.__type = "Signal" -- For compatibility with TypeMarshaller
local ConnectionStatic = {}
ConnectionStatic.__index = ConnectionStatic
ConnectionStatic.__type = "SignalConnection" -- For compatibility with TypeMarshaller

export type Signal = {
	Name: string,
	Connections: {[number]: Connection},
	YieldingThreads: {[number]: BindableEvent}
}

export type Connection = {
	Signal: Signal?,
	Delegate: any,
	Index: number	
}

-- Format params: methodName, ctorName
local ERR_NOT_INSTANCE = "Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"

function SignalStatic.new(signalName: string): Signal
	local signalObj: Signal = {
		Name = signalName,
		Connections = {},
		YieldingThreads = {}
	}
	return setmetatable(signalObj, SignalStatic)
end

local function NewConnection(sig: Signal, func: any): Connection 
	local connectionObj: Connection = {
		Signal = sig,
		Delegate = func,
		Index = -1
	}
	return setmetatable(connectionObj, ConnectionStatic)
end

local function ThreadAndReportError(delegate: any, args: GenericTable, handlerName: string)
	local thread = coroutine.create(function ()
		delegate(unpack(args))
	end)
	local success, msg = coroutine.resume(thread)
	if not success then 
		-- For the love of god roblox PLEASE add the ability to customize message type in output statements.
		-- This "testservice" garbage at the start of my message is annoying as all hell.
		TestService:Error(string.format("Exception thrown in your %s event handler: %s", handlerName, msg))
		TestService:Checkpoint(debug.traceback(thread))
	end
end

function SignalStatic:Connect(func)
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Connect", "Signal.new()"))
	local connection = NewConnection(self, func)
	connection.Index = #self.Connections + 1
	table.insert(self.Connections, connection.Index, connection)
	return connection
end

function SignalStatic:Fire(...)
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Fire", "Signal.new()"))
	local args = table.pack(...)
	local allCons = self.Connections
	local yieldingThreads = self.YieldingThreads
	for index = 1, #allCons do
		local connection = allCons[index]
		if connection.Delegate ~= nil then
			-- Catch case for disposed signals.
			ThreadAndReportError(connection.Delegate, args, connection.Signal.Name)
		end
	end
	for index = 1, #yieldingThreads do
		local thread = yieldingThreads[index]
		if thread ~= nil then
			coroutine.resume(thread, ...)
		end
	end
end

function SignalStatic:FireSync(...)
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("FireSync", "Signal.new()"))
	local args = table.pack(...)
	local allCons = self.Connections
	local yieldingThreads = self.YieldingThreads
	for index = 1, #allCons do
		local connection = allCons[index]
		if connection.Delegate ~= nil then
			-- Catch case for disposed signals.
			connection.Delegate(unpack(args))
		end
	end
	for index = 1, #yieldingThreads do
		local thread = yieldingThreads[index]
		if thread ~= nil then
			coroutine.resume(thread, ...)
		end
	end
end

function SignalStatic:Wait()
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Wait", "Signal.new()"))
	local args = {}
	local thread = coroutine.running()
	table.insert(self.YieldingThreads, thread)
	args = { coroutine.yield() }
	table.removeObject(self.YieldingThreads, thread)
	return unpack(args)
end

function SignalStatic:Dispose()
	assert(getmetatable(self) == SignalStatic, ERR_NOT_INSTANCE:format("Dispose", "Signal.new()"))
	local allCons = self.Connections
	for index = 1, #allCons do
		allCons[index]:Disconnect()
	end
	self.Connections = {}
	setmetatable(self, nil)
end

function ConnectionStatic:Disconnect()
	assert(getmetatable(self) == ConnectionStatic, ERR_NOT_INSTANCE:format("Disconnect", "private function NewConnection()"))
	table.remove(self.Signal.Connections, self.Index)
	self.SignalStatic = nil
	self.Delegate = nil
	self.YieldingThreads = {}
	self.Index = -1
	setmetatable(self, nil)
end

return SignalStatic]]></ProtectedString>
											<string name="ScriptGuid">{306C00AD-6266-4E19-882A-6AA6AC09EF5A}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Signal</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX0E3C084852D04D29B2418622FD8417D9">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:

-- Defines all FC types.
-- Any script that requires this will have these types defined.

--[[
local TypeDefs = require(script.TypeDefinitions)
type CanPierceFunction = TypeDefs.CanPierceFunction
type GenericTable = TypeDefs.GenericTable
type Caster = TypeDefs.Caster
type FastCastBehavior = TypeDefs.FastCastBehavior
type CastTrajectory = TypeDefs.CastTrajectory
type CastStateInfo = TypeDefs.CastStateInfo
type CastRayInfo = TypeDefs.CastRayInfo
type ActiveCast = TypeDefs.ActiveCast
--]]

-- Represents the function to determine piercing.
export type CanPierceFunction = (ActiveCast, RaycastResult, Vector3) -> boolean

-- Represents any table.
export type GenericTable = {[any]: any}

-- Represents a Caster :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caster/
export type Caster = {
	WorldRoot: WorldRoot,
	LengthChanged: RBXScriptSignal,
	RayHit: RBXScriptSignal,
	RayPierced: RBXScriptSignal,
	CastTerminating: RBXScriptSignal,
	Fire: (Vector3, Vector3, Vector3 | number, FastCastBehavior) -> ()
}

-- Represents a FastCastBehavior :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/fcbehavior/
export type FastCastBehavior = {
	RaycastParams: RaycastParams?,
	MaxDistance: number,
	Acceleration: Vector3,
	HighFidelityBehavior: number,
	HighFidelitySegmentSize: number,
	CosmeticBulletTemplate: Instance?,
	CosmeticBulletProvider: any, -- Intended to be a PartCache. Dictated via TypeMarshaller.
	CosmeticBulletContainer: Instance?,
	AutoIgnoreContainer: boolean,
	CanPierceFunction: CanPierceFunction
}

-- Represents a CastTrajectory :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/casttrajectory/
export type CastTrajectory = {
	StartTime: number,
	EndTime: number,
	Origin: Vector3,
	InitialVelocity: Vector3,
	Acceleration: Vector3
}

-- Represents a CastStateInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/caststateinfo/
export type CastStateInfo = {
	UpdateConnection: RBXScriptSignal,
	HighFidelityBehavior: number,
	HighFidelitySegmentSize: number,
	Paused: boolean,
	TotalRuntime: number,
	DistanceCovered: number,
	IsActivelySimulatingPierce: boolean,
	IsActivelyResimulating: boolean,
	CancelHighResCast: boolean,
	Trajectories: {[number]: CastTrajectory}
}

-- Represents a CastRayInfo :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/castrayinfo/
export type CastRayInfo = {
	Parameters: RaycastParams,
	WorldRoot: WorldRoot,
	MaxDistance: number,
	CosmeticBulletObject: Instance?,
	CanPierceCallback: CanPierceFunction
}

-- Represents an ActiveCast :: https://etithespirit.github.io/FastCastAPIDocs/fastcast-objects/activecast/
export type ActiveCast = {
	Caster: Caster,
	StateInfo: CastStateInfo,
	RayInfo: CastRayInfo,
	UserData: {[any]: any}
}

return {}]]></ProtectedString>
											<string name="ScriptGuid">{B3CCFD84-69CA-4D7E-B937-D45D5E54CD1F}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">TypeDefinitions</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX72D1DDEEC85742EEA1187EDA3CCB7EEA">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--!nocheck
-- ^ change to strict to crash studio c:

local oldtypeof = typeof
local function typeof(objIn: any): string
	local objType = oldtypeof(objIn)
	if objType ~= "table" then return objType end

	-- Could be a custom type if it's a table.
	local meta = getmetatable(objIn)
	if oldtypeof(meta) ~= "table" then return objType end

	-- Has a metatable that's an exposed table.
	local customType: string? = meta["__type"] -- I want to mandate that this is a string.
	if customType == nil then return objType end

	-- Has a type field
	return customType
end

return typeof]]></ProtectedString>
											<string name="ScriptGuid">{5D6235A5-6E22-471B-AC66-35ED84A887DB}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">TypeMarshaller</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX94FA380038E74988B6D187B71E389F8B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Images</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="SurfaceAppearance" referent="RBXBB68D2ED16C34006B278784C0B30918D">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561421714</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137136475</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137137560</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">1</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX179D41A8E1C04F31B41917C0E95F9A6A">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420596</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137285211</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137290262</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">2</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBXFCE4ACA82AC34B318FEAABDD1485C27E">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420659</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137296940</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137300478</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">3</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBXAA8A838A66B14974BD3D0E50DB45AD88">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420780</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137181243</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137193326</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">4</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX4BAB00589ACB41F0AB439C9C448A801C">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420978</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137213848</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137214405</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">5</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBXC1577F81259143BC9EFF45767D0CDD7B">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561421515</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137159043</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137165483</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">7</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX03AF55310089478F9DDFE2BFFEA61405">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561421428</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137127341</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137131420</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">8</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX0929460C40104313AAA79B1A02E6BE7F">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561421069</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137219586</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137222458</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">9</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX4BE44E3AFA324AC6B0A955D303950D01">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561419931</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137249682</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137250443</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">10</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBXAA2012A192DD45FAB0FA543AA7D95291">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420882</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137197518</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137209199</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">11</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX4688E18FB6264D56AC58AFEE6AF4A39D">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420185</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137261860</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137263961</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">12</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX97277C6C18FC4F71A5430104CC6EC714">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://11561420301</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137265937</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137268819</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">13</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="SurfaceAppearance" referent="RBX992FBE6F78A34C4F8A76BECE5A49F58E">
									<Properties>
										<token name="AlphaMode">1</token>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="ColorMap"><url>rbxassetid://12137310288</url></Content>
										<Content name="EmissiveMaskContent">
											<null></null>
										</Content>
										<float name="EmissiveStrength">1</float>
										<Color3 name="EmissiveTint">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Content name="MetalnessMap"><null></null></Content>
										<Content name="NormalMap"><url>rbxassetid://12137311055</url></Content>
										<Content name="RoughnessMap"><url>rbxassetid://8105617920</url></Content>
										<Content name="TexturePack"><url>rbxassetid://12137314457</url></Content>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">14</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX48C9A6BF2D0A44989FDBAB4E162E3433">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Effects</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBXADDE680DF9FE4752959000F953C261F3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Impact</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ParticleEmitter" referent="RBXA3CAA9CEB07D4B4BBEE9770747DAF95B">
										<Properties>
											<Vector3 name="Acceleration">
												<X>0</X>
												<Y>-5</Y>
												<Z>5</Z>
											</Vector3>
											<float name="Brightness">1</float>
											<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
											<float name="Drag">25</float>
											<token name="EmissionDirection">1</token>
											<bool name="Enabled">true</bool>
											<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
											<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
											<token name="FlipbookLayout">0</token>
											<token name="FlipbookMode">0</token>
											<int name="FlipbookSizeX">1</int>
											<int name="FlipbookSizeY">1</int>
											<bool name="FlipbookStartRandom">false</bool>
											<NumberRange name="Lifetime">0.3 0.6 </NumberRange>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">0</float>
											<bool name="LockedToPart">false</bool>
											<token name="Orientation">1</token>
											<float name="Rate">0</float>
											<NumberRange name="RotSpeed">0 0 </NumberRange>
											<NumberRange name="Rotation">-90 90 </NumberRange>
											<token name="Shape">0</token>
											<token name="ShapeInOut">0</token>
											<float name="ShapePartial">1</float>
											<token name="ShapeStyle">0</token>
											<NumberSequence name="Size">0 0 0 0.0985037 0.276242 0 1 0.441989 0 </NumberSequence>
											<NumberRange name="Speed">5 30 </NumberRange>
											<Vector2 name="SpreadAngle">
												<X>15</X>
												<Y>15</Y>
											</Vector2>
											<NumberSequence name="Squash">0 0 0 1 0.6375 0 </NumberSequence>
											<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
											<float name="TimeScale">1</float>
											<NumberSequence name="Transparency">0 1 0 0.071831 0.81875 0 1 1 0 </NumberSequence>
											<float name="VelocityInheritance">0</float>
											<bool name="WindAffectsDrag">false</bool>
											<float name="ZOffset">0</float>
											<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Mist1</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ParticleEmitter" referent="RBX8E3A79184B954BB8A42500F38385A448">
										<Properties>
											<Vector3 name="Acceleration">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
											</Vector3>
											<float name="Brightness">1</float>
											<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
											<float name="Drag">0</float>
											<token name="EmissionDirection">1</token>
											<bool name="Enabled">true</bool>
											<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
											<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
											<token name="FlipbookLayout">0</token>
											<token name="FlipbookMode">0</token>
											<int name="FlipbookSizeX">1</int>
											<int name="FlipbookSizeY">1</int>
											<bool name="FlipbookStartRandom">false</bool>
											<NumberRange name="Lifetime">0.1 0.4 </NumberRange>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">1</float>
											<bool name="LockedToPart">false</bool>
											<token name="Orientation">3</token>
											<float name="Rate">0</float>
											<NumberRange name="RotSpeed">-40 40 </NumberRange>
											<NumberRange name="Rotation">-180 180 </NumberRange>
											<token name="Shape">0</token>
											<token name="ShapeInOut">0</token>
											<float name="ShapePartial">1</float>
											<token name="ShapeStyle">0</token>
											<NumberSequence name="Size">0 1.27072 0 1 2.0442 0 </NumberSequence>
											<NumberRange name="Speed">0.001 0.001 </NumberRange>
											<Vector2 name="SpreadAngle">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<NumberSequence name="Squash">0 0.1 0 1 0.1 0 </NumberSequence>
											<Content name="Texture"><url>rbxassetid://3193359153</url></Content>
											<float name="TimeScale">1</float>
											<NumberSequence name="Transparency">0 0.96875 0 1 1 0 </NumberSequence>
											<float name="VelocityInheritance">0</float>
											<bool name="WindAffectsDrag">false</bool>
											<float name="ZOffset">0</float>
											<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Puddle</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ParticleEmitter" referent="RBX6D2DD392854E4D5FBF9F6636BD465B5D">
										<Properties>
											<Vector3 name="Acceleration">
												<X>0</X>
												<Y>-20</Y>
												<Z>0</Z>
											</Vector3>
											<float name="Brightness">1</float>
											<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
											<float name="Drag">0</float>
											<token name="EmissionDirection">1</token>
											<bool name="Enabled">true</bool>
											<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
											<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
											<token name="FlipbookLayout">0</token>
											<token name="FlipbookMode">0</token>
											<int name="FlipbookSizeX">1</int>
											<int name="FlipbookSizeY">1</int>
											<bool name="FlipbookStartRandom">false</bool>
											<NumberRange name="Lifetime">0.6 0.8 </NumberRange>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">1</float>
											<bool name="LockedToPart">false</bool>
											<token name="Orientation">2</token>
											<float name="Rate">0</float>
											<NumberRange name="RotSpeed">0 0 </NumberRange>
											<NumberRange name="Rotation">0 0 </NumberRange>
											<token name="Shape">0</token>
											<token name="ShapeInOut">0</token>
											<float name="ShapePartial">1</float>
											<token name="ShapeStyle">0</token>
											<NumberSequence name="Size">0 0.05 0 1 0.05 0 </NumberSequence>
											<NumberRange name="Speed">6 10 </NumberRange>
											<Vector2 name="SpreadAngle">
												<X>10</X>
												<Y>10</Y>
											</Vector2>
											<NumberSequence name="Squash">0 -1.3 0 1 -1.3 0 </NumberSequence>
											<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
											<float name="TimeScale">1</float>
											<NumberSequence name="Transparency">0 0.35625 0 1 1 0 </NumberSequence>
											<float name="VelocityInheritance">0</float>
											<bool name="WindAffectsDrag">false</bool>
											<float name="ZOffset">0</float>
											<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAALkA=</BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Squirt</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="Trail" referent="RBXDDEE6B45F0574C979DF44F584882ADB1">
									<Properties>
										<Ref name="Attachment0">null</Ref>
										<Ref name="Attachment1">null</Ref>
										<float name="Brightness">1</float>
										<ColorSequence name="Color">0 0.309804 0 0 0 1 0.309804 0 0 0 </ColorSequence>
										<bool name="Enabled">false</bool>
										<bool name="FaceCamera">true</bool>
										<float name="Lifetime">0.0500000007</float>
										<float name="LightEmission">0</float>
										<float name="LightInfluence">0</float>
										<float name="MaxLength">0</float>
										<float name="MinLength">0.100000001</float>
										<Content name="Texture"><null></null></Content>
										<float name="TextureLength">1</float>
										<token name="TextureMode">0</token>
										<NumberSequence name="Transparency">0 0 0 0.502494 0.2625 0 1 1 0 </NumberSequence>
										<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Trail</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX460FDACE8F8349E7B287058D570FA714">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Folder</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBXD45D84F4288041F59699F678C2CD0597">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Meshes</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="MeshPart" referent="RBXC64F1C763D3448C59A2DE23C6BCEE397">
									<Properties>
										<bool name="DoubleSided">false</bool>
										<bool name="HasJointOffset">false</bool>
										<bool name="HasSkinnedMesh">false</bool>
										<Vector3 name="InitialSize">
											<X>200</X>
											<Y>3.25841356e-05</Y>
											<Z>200</Z>
										</Vector3>
										<Vector3 name="JointOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Content name="MeshId"><url>rbxassetid://9648592256</url></Content>
										<BinaryString name="PhysicsData"></BinaryString>
										<token name="RenderFidelity">1</token>
										<Content name="TextureID"><null></null></Content>
										<int name="VertexCount">4</int>
										<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
										<token name="FluidFidelityInternal">0</token>
										<bool name="InertiaMigrated">true</bool>
										<SharedString name="PhysicalConfigData">hFbDjtH6cycB1zhM9yA98w==</SharedString>
										<Vector3 name="UnscaledCofm">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaDiags">
											<X>1</X>
											<Y>1</Y>
											<Z>1</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaOffDiags">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="UnscaledVolume">10</float>
										<bool name="Anchored">false</bool>
										<bool name="AudioCanCollide">true</bool>
										<float name="BackParamA">-0.5</float>
										<float name="BackParamB">0.5</float>
										<token name="BackSurface">0</token>
										<token name="BackSurfaceInput">0</token>
										<float name="BottomParamA">-0.5</float>
										<float name="BottomParamB">0.5</float>
										<token name="BottomSurface">0</token>
										<token name="BottomSurfaceInput">0</token>
										<CoordinateFrame name="CFrame">
											<X>71.2647705</X>
											<Y>1.5951376</Y>
											<Z>-259.880127</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<bool name="CanCollide">false</bool>
										<bool name="CanQuery">false</bool>
										<bool name="CanTouch">false</bool>
										<bool name="CastShadow">true</bool>
										<string name="CollisionGroup">Default</string>
										<int name="CollisionGroupId">0</int>
										<Color3uint8 name="Color3uint8">4284940288</Color3uint8>
										<PhysicalProperties name="CustomPhysicalProperties">
											<CustomPhysics>false</CustomPhysics>
										</PhysicalProperties>
										<bool name="EnableFluidForces">true</bool>
										<float name="FrontParamA">-0.5</float>
										<float name="FrontParamB">0.5</float>
										<token name="FrontSurface">0</token>
										<token name="FrontSurfaceInput">0</token>
										<float name="LeftParamA">-0.5</float>
										<float name="LeftParamB">0.5</float>
										<token name="LeftSurface">0</token>
										<token name="LeftSurfaceInput">0</token>
										<bool name="Locked">false</bool>
										<bool name="Massless">false</bool>
										<token name="Material">1568</token>
										<string name="MaterialVariantSerialized"></string>
										<CoordinateFrame name="PivotOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<float name="Reflectance">0</float>
										<float name="RightParamA">-0.5</float>
										<float name="RightParamB">0.5</float>
										<token name="RightSurface">0</token>
										<token name="RightSurfaceInput">0</token>
										<int name="RootPriority">0</int>
										<Vector3 name="RotVelocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="TopParamA">-0.5</float>
										<float name="TopParamB">0.5</float>
										<token name="TopSurface">0</token>
										<token name="TopSurfaceInput">0</token>
										<float name="Transparency">0.0199999996</float>
										<Vector3 name="Velocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="size">
											<X>0.100000001</X>
											<Y>0.100000001</Y>
											<Z>0.100000001</Z>
										</Vector3>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Decal</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Attachment" referent="RBX899C5C1DA7BD421882B9C557C876829C">
										<Properties>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A0</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX6C84E2FD4E254B839AC5D1F5F7AF32E1">
										<Properties>
											<CoordinateFrame name="CFrame">
												<X>0.0369129181</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A1</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX4D3E42C6719A4E52816DAB912C1D2FCC">
										<Properties>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>2.38419062e-09</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Impact</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ParticleEmitter" referent="RBX7394D4163B2C4635B0F9C89629EC56D8">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-5</Y>
													<Z>5</Z>
												</Vector3>
												<float name="Brightness">1</float>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<float name="Drag">25</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.3 0.6 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">0</float>
												<bool name="LockedToPart">false</bool>
												<token name="Orientation">1</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">-90 90 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0 0 0.0985037 0.276242 0 1 0.441989 0 </NumberSequence>
												<NumberRange name="Speed">5 30 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>15</X>
													<Y>15</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0 0 1 0.6375 0 </NumberSequence>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 1 0 0.071831 0.81875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Mist1</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX9C08DF23E496485F937FCAB184CBD745">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>0</Y>
													<Z>0</Z>
												</Vector3>
												<float name="Brightness">1</float>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.1 0.4 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<token name="Orientation">3</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">-40 40 </NumberRange>
												<NumberRange name="Rotation">-180 180 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 1.27072 0 1 2.0442 0 </NumberSequence>
												<NumberRange name="Speed">0.001 0.001 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0.1 0 1 0.1 0 </NumberSequence>
												<Content name="Texture"><url>rbxassetid://3193359153</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.96875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Puddle</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX27B94DFA8FEA4E9DA81889D17E82991F">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-20</Y>
													<Z>0</Z>
												</Vector3>
												<float name="Brightness">1</float>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.6 0.8 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<token name="Orientation">2</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">0 0 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0.05 0 1 0.05 0 </NumberSequence>
												<NumberRange name="Speed">6 10 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>10</X>
													<Y>10</Y>
												</Vector2>
												<NumberSequence name="Squash">0 -1.3 0 1 -1.3 0 </NumberSequence>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.35625 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAALkA=</BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Squirt</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Trail" referent="RBX0DD37D998C8F4A98926DF145DAEE1C8F">
										<Properties>
											<Ref name="Attachment0">RBX899C5C1DA7BD421882B9C557C876829C</Ref>
											<Ref name="Attachment1">RBX6C84E2FD4E254B839AC5D1F5F7AF32E1</Ref>
											<float name="Brightness">1</float>
											<ColorSequence name="Color">0 0.517647 0 0 0 1 0.517647 0 0 0 </ColorSequence>
											<bool name="Enabled">false</bool>
											<bool name="FaceCamera">true</bool>
											<float name="Lifetime">0.0500000007</float>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">0</float>
											<float name="MaxLength">0</float>
											<float name="MinLength">0.100000001</float>
											<Content name="Texture"><null></null></Content>
											<float name="TextureLength">1</float>
											<token name="TextureMode">0</token>
											<NumberSequence name="Transparency">0 0 0 0.502494 0.2625 0 1 1 0 </NumberSequence>
											<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Trail</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="MeshPart" referent="RBXBAE76816E7CC46059138E8C8157AAAA8">
									<Properties>
										<bool name="DoubleSided">false</bool>
										<bool name="HasJointOffset">false</bool>
										<bool name="HasSkinnedMesh">false</bool>
										<Vector3 name="InitialSize">
											<X>1.99211502</X>
											<Y>2</Y>
											<Z>1.9960537</Z>
										</Vector3>
										<Vector3 name="JointOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Content name="MeshId"><url>rbxassetid://15372969595</url></Content>
										<BinaryString name="PhysicsData"></BinaryString>
										<token name="RenderFidelity">0</token>
										<Content name="TextureID"><null></null></Content>
										<int name="VertexCount">1324</int>
										<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
										<token name="FluidFidelityInternal">0</token>
										<bool name="InertiaMigrated">true</bool>
										<SharedString name="PhysicalConfigData">aaQQwlzZOlor7w4mpBFaRg==</SharedString>
										<Vector3 name="UnscaledCofm">
											<X>-5.7645525e-07</X>
											<Y>1.97096427e-17</Y>
											<Z>-3.71146967e-07</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaDiags">
											<X>1.65671015</X>
											<Y>1.65450311</Y>
											<Z>1.6567167</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaOffDiags">
											<X>3.34739873e-18</X>
											<Y>2.4742576e-06</Y>
											<Z>-3.32570281e-17</Z>
										</Vector3>
										<float name="UnscaledVolume">4.1594038</float>
										<bool name="Anchored">false</bool>
										<bool name="AudioCanCollide">true</bool>
										<float name="BackParamA">-0.5</float>
										<float name="BackParamB">0.5</float>
										<token name="BackSurface">0</token>
										<token name="BackSurfaceInput">0</token>
										<float name="BottomParamA">-0.5</float>
										<float name="BottomParamB">0.5</float>
										<token name="BottomSurface">0</token>
										<token name="BottomSurfaceInput">0</token>
										<CoordinateFrame name="CFrame">
											<X>90.4211121</X>
											<Y>2.14056873</Y>
											<Z>-235.98407</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<bool name="CanCollide">false</bool>
										<bool name="CanQuery">false</bool>
										<bool name="CanTouch">false</bool>
										<bool name="CastShadow">true</bool>
										<string name="CollisionGroup">Default</string>
										<int name="CollisionGroupId">0</int>
										<Color3uint8 name="Color3uint8">4283236352</Color3uint8>
										<PhysicalProperties name="CustomPhysicalProperties">
											<CustomPhysics>false</CustomPhysics>
										</PhysicalProperties>
										<bool name="EnableFluidForces">true</bool>
										<float name="FrontParamA">-0.5</float>
										<float name="FrontParamB">0.5</float>
										<token name="FrontSurface">0</token>
										<token name="FrontSurfaceInput">0</token>
										<float name="LeftParamA">-0.5</float>
										<float name="LeftParamB">0.5</float>
										<token name="LeftSurface">0</token>
										<token name="LeftSurfaceInput">0</token>
										<bool name="Locked">false</bool>
										<bool name="Massless">false</bool>
										<token name="Material">1568</token>
										<string name="MaterialVariantSerialized"></string>
										<CoordinateFrame name="PivotOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<float name="Reflectance">0</float>
										<float name="RightParamA">-0.5</float>
										<float name="RightParamB">0.5</float>
										<token name="RightSurface">0</token>
										<token name="RightSurfaceInput">0</token>
										<int name="RootPriority">0</int>
										<Vector3 name="RotVelocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="TopParamA">-0.5</float>
										<float name="TopParamB">0.5</float>
										<token name="TopSurface">0</token>
										<token name="TopSurfaceInput">0</token>
										<float name="Transparency">0.25</float>
										<Vector3 name="Velocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="size">
											<X>0.100000001</X>
											<Y>0.100000001</Y>
											<Z>0.100000001</Z>
										</Vector3>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Droplet</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Trail" referent="RBX1F42EA954D2044F990DC69D1CD91A5F2">
										<Properties>
											<Ref name="Attachment0">RBX55F7BBA45B2C4F53804EB653FEDC0153</Ref>
											<Ref name="Attachment1">RBX5B52B7921D5B4DFB850AECAF91546C8F</Ref>
											<float name="Brightness">1</float>
											<ColorSequence name="Color">0 0.309804 0 0 0 1 0.309804 0 0 0 </ColorSequence>
											<bool name="Enabled">false</bool>
											<bool name="FaceCamera">true</bool>
											<float name="Lifetime">0.0500000007</float>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">0</float>
											<float name="MaxLength">0</float>
											<float name="MinLength">0.100000001</float>
											<Content name="Texture"><null></null></Content>
											<float name="TextureLength">1</float>
											<token name="TextureMode">0</token>
											<NumberSequence name="Transparency">0 0 0 0.502494 0.2625 0 1 1 0 </NumberSequence>
											<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Trail</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX55F7BBA45B2C4F53804EB653FEDC0153">
										<Properties>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A0</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX5B52B7921D5B4DFB850AECAF91546C8F">
										<Properties>
											<CoordinateFrame name="CFrame">
												<X>0.0369129181</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A1</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX356C36094F1C42B78A176B4D183155CA">
										<Properties>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>2.38418579e-07</Y>
												<Z>0</Z>
												<R00>-1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>-1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Impact</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ParticleEmitter" referent="RBX9278312743544DC8B7CD4A2CAD4C6357">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-5</Y>
													<Z>5</Z>
												</Vector3>
												<float name="Brightness">1</float>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<float name="Drag">25</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.3 0.6 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">0</float>
												<bool name="LockedToPart">false</bool>
												<token name="Orientation">1</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">-90 90 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0 0 0.0985037 0.276242 0 1 0.441989 0 </NumberSequence>
												<NumberRange name="Speed">5 30 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>15</X>
													<Y>15</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0 0 1 0.6375 0 </NumberSequence>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 1 0 0.071831 0.81875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Mist1</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX031A52E25E984D808A6D913013103B45">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>0</Y>
													<Z>0</Z>
												</Vector3>
												<float name="Brightness">1</float>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.1 0.4 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<token name="Orientation">3</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">-40 40 </NumberRange>
												<NumberRange name="Rotation">-180 180 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 1.27072 0 1 2.0442 0 </NumberSequence>
												<NumberRange name="Speed">0.001 0.001 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0.1 0 1 0.1 0 </NumberSequence>
												<Content name="Texture"><url>rbxassetid://3193359153</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.96875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Puddle</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX0B166704096D490C8A5247F153228520">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-20</Y>
													<Z>0</Z>
												</Vector3>
												<float name="Brightness">1</float>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.6 0.8 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<token name="Orientation">2</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">0 0 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0.05 0 1 0.05 0 </NumberSequence>
												<NumberRange name="Speed">6 10 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>10</X>
													<Y>10</Y>
												</Vector2>
												<NumberSequence name="Squash">0 -1.3 0 1 -1.3 0 </NumberSequence>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.35625 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAALkA=</BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Squirt</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="MeshPart" referent="RBXCB6F0B8019354046A7B264CB6CB5D10C">
									<Properties>
										<bool name="DoubleSided">false</bool>
										<bool name="HasJointOffset">false</bool>
										<bool name="HasSkinnedMesh">false</bool>
										<Vector3 name="InitialSize">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="JointOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Content name="MeshId"><null></null></Content>
										<BinaryString name="PhysicsData"></BinaryString>
										<token name="RenderFidelity">1</token>
										<Content name="TextureID"><null></null></Content>
										<int name="VertexCount">0</int>
										<SharedString name="AeroMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
										<token name="FluidFidelityInternal">0</token>
										<bool name="InertiaMigrated">true</bool>
										<SharedString name="PhysicalConfigData">hFbDjtH6cycB1zhM9yA98w==</SharedString>
										<Vector3 name="UnscaledCofm">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaDiags">
											<X>1</X>
											<Y>1</Y>
											<Z>1</Z>
										</Vector3>
										<Vector3 name="UnscaledVolInertiaOffDiags">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="UnscaledVolume">10</float>
										<bool name="Anchored">false</bool>
										<bool name="AudioCanCollide">true</bool>
										<float name="BackParamA">-0.5</float>
										<float name="BackParamB">0.5</float>
										<token name="BackSurface">0</token>
										<token name="BackSurfaceInput">0</token>
										<float name="BottomParamA">-0.5</float>
										<float name="BottomParamB">0.5</float>
										<token name="BottomSurface">0</token>
										<token name="BottomSurfaceInput">0</token>
										<CoordinateFrame name="CFrame">
											<X>71.2647705</X>
											<Y>1.5951376</Y>
											<Z>-259.880127</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<bool name="CanCollide">false</bool>
										<bool name="CanQuery">false</bool>
										<bool name="CanTouch">false</bool>
										<bool name="CastShadow">true</bool>
										<string name="CollisionGroup">Default</string>
										<int name="CollisionGroupId">0</int>
										<Color3uint8 name="Color3uint8">4284940288</Color3uint8>
										<PhysicalProperties name="CustomPhysicalProperties">
											<CustomPhysics>false</CustomPhysics>
										</PhysicalProperties>
										<bool name="EnableFluidForces">true</bool>
										<float name="FrontParamA">-0.5</float>
										<float name="FrontParamB">0.5</float>
										<token name="FrontSurface">3</token>
										<token name="FrontSurfaceInput">0</token>
										<float name="LeftParamA">-0.5</float>
										<float name="LeftParamB">0.5</float>
										<token name="LeftSurface">0</token>
										<token name="LeftSurfaceInput">0</token>
										<bool name="Locked">false</bool>
										<bool name="Massless">false</bool>
										<token name="Material">1568</token>
										<string name="MaterialVariantSerialized"></string>
										<CoordinateFrame name="PivotOffset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
											<R00>1</R00>
											<R01>0</R01>
											<R02>0</R02>
											<R10>0</R10>
											<R11>1</R11>
											<R12>0</R12>
											<R20>0</R20>
											<R21>0</R21>
											<R22>1</R22>
										</CoordinateFrame>
										<float name="Reflectance">0</float>
										<float name="RightParamA">-0.5</float>
										<float name="RightParamB">0.5</float>
										<token name="RightSurface">0</token>
										<token name="RightSurfaceInput">0</token>
										<int name="RootPriority">0</int>
										<Vector3 name="RotVelocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<float name="TopParamA">-0.5</float>
										<float name="TopParamB">0.5</float>
										<token name="TopSurface">0</token>
										<token name="TopSurfaceInput">0</token>
										<float name="Transparency">0.0199999996</float>
										<Vector3 name="Velocity">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="size">
											<X>0.100000001</X>
											<Y>0.100000001</Y>
											<Z>0.100000001</Z>
										</Vector3>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Brick</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Attachment" referent="RBX1A5D20B59204462894974C63944D1983">
										<Properties>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A0</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX4E7FFB00B9384EF7834A0DE906D940C8">
										<Properties>
											<CoordinateFrame name="CFrame">
												<X>0.0369129181</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">A1</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Attachment" referent="RBX01223E159D604306B2C4B2ED22F7EFEA">
										<Properties>
											<CoordinateFrame name="CFrame">
												<X>0</X>
												<Y>2.38419062e-09</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Impact</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ParticleEmitter" referent="RBX61435124780D49E28D961B00BCDB5DAA">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-5</Y>
													<Z>5</Z>
												</Vector3>
												<float name="Brightness">1</float>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<float name="Drag">25</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.3 0.6 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">0</float>
												<bool name="LockedToPart">false</bool>
												<token name="Orientation">1</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">-90 90 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0 0 0.0985037 0.276242 0 1 0.441989 0 </NumberSequence>
												<NumberRange name="Speed">5 30 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>15</X>
													<Y>15</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0 0 1 0.6375 0 </NumberSequence>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 1 0 0.071831 0.81875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Mist1</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX4B8B515588EF467CBBC6B0ADDFCF8467">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>0</Y>
													<Z>0</Z>
												</Vector3>
												<float name="Brightness">1</float>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.1 0.4 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<token name="Orientation">3</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">-40 40 </NumberRange>
												<NumberRange name="Rotation">-180 180 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 1.27072 0 1 2.0442 0 </NumberSequence>
												<NumberRange name="Speed">0.001 0.001 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<NumberSequence name="Squash">0 0.1 0 1 0.1 0 </NumberSequence>
												<Content name="Texture"><url>rbxassetid://3193359153</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.96875 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAAFEA=</BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Puddle</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ParticleEmitter" referent="RBX812DA93C690945029C91FDBE8F48F095">
											<Properties>
												<Vector3 name="Acceleration">
													<X>0</X>
													<Y>-20</Y>
													<Z>0</Z>
												</Vector3>
												<float name="Brightness">1</float>
												<ColorSequence name="Color">0 0.345098 0.027451 0.027451 0 1 0.345098 0.027451 0.027451 0 </ColorSequence>
												<float name="Drag">0</float>
												<token name="EmissionDirection">1</token>
												<bool name="Enabled">true</bool>
												<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
												<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
												<token name="FlipbookLayout">0</token>
												<token name="FlipbookMode">0</token>
												<int name="FlipbookSizeX">1</int>
												<int name="FlipbookSizeY">1</int>
												<bool name="FlipbookStartRandom">false</bool>
												<NumberRange name="Lifetime">0.6 0.8 </NumberRange>
												<float name="LightEmission">0</float>
												<float name="LightInfluence">1</float>
												<bool name="LockedToPart">false</bool>
												<token name="Orientation">2</token>
												<float name="Rate">0</float>
												<NumberRange name="RotSpeed">0 0 </NumberRange>
												<NumberRange name="Rotation">0 0 </NumberRange>
												<token name="Shape">0</token>
												<token name="ShapeInOut">0</token>
												<float name="ShapePartial">1</float>
												<token name="ShapeStyle">0</token>
												<NumberSequence name="Size">0 0.05 0 1 0.05 0 </NumberSequence>
												<NumberRange name="Speed">6 10 </NumberRange>
												<Vector2 name="SpreadAngle">
													<X>10</X>
													<Y>10</Y>
												</Vector2>
												<NumberSequence name="Squash">0 -1.3 0 1 -1.3 0 </NumberSequence>
												<Content name="Texture"><url>rbxassetid://4231233461</url></Content>
												<float name="TimeScale">1</float>
												<NumberSequence name="Transparency">0 0.35625 0 1 1 0 </NumberSequence>
												<float name="VelocityInheritance">0</float>
												<bool name="WindAffectsDrag">false</bool>
												<float name="ZOffset">0</float>
												<BinaryString name="AttributesSerialize">AQAAAAkAAABFbWl0Q291bnQGAAAAAAAALkA=</BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Squirt</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Trail" referent="RBXE12A6043F0EB487AB92FDA0F75A0EAAF">
										<Properties>
											<Ref name="Attachment0">RBX1A5D20B59204462894974C63944D1983</Ref>
											<Ref name="Attachment1">RBX4E7FFB00B9384EF7834A0DE906D940C8</Ref>
											<float name="Brightness">1</float>
											<ColorSequence name="Color">0 0.517647 0 0 0 1 0.517647 0 0 0 </ColorSequence>
											<bool name="Enabled">false</bool>
											<bool name="FaceCamera">true</bool>
											<float name="Lifetime">0.0500000007</float>
											<float name="LightEmission">0</float>
											<float name="LightInfluence">0</float>
											<float name="MaxLength">0</float>
											<float name="MinLength">0.100000001</float>
											<Content name="Texture"><null></null></Content>
											<float name="TextureLength">1</float>
											<token name="TextureMode">0</token>
											<NumberSequence name="Transparency">0 0 0 0.502494 0.2625 0 1 1 0 </NumberSequence>
											<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Trail</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX94F76F2595A244FBAF636D12DEEEB115">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "BloodEngine",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 82208816003099,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Smileeiles"},
		{Text = "Description: A droplet emitter system, used to emit droplets from a specified origin point. These droplets are then given a velocity, and upon landing on a surface, transform into pools. This process can be customized to suit various needs and genres."},
		{Text = "Version: 1.1.3"},

		{Separator = "Features"},
		{Text = " Customizable droplet physics"},
		{Text = " Pool transformation system"},
		{Text = " Optimized performance"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{FE6D4C81-0370-41B2-9166-2DD2F27A4BF8}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX217545E794D046AAB45EE7D5D6346A15">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TopbarPlus</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA2CC277DD9D049FF8FD5C906F5EE96FD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "TopbarPlus",
	Thumbnail = "rbxassetid://71152585441542",
	AssetId = 92368439343389,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: ForeverHD"},
		{Text = "Description: TopbarPlus v3 uses the Mozilla Public License v2.0. You can use this application free of charge; all you need to do is provide credit back to this resource (such as link to this post) and to open source any significant changes you make to the package."},
		{Text = "Version: 3.4.0 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{D3319C08-3BC4-4E52-9753-6D4B59207E21}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX4E7D478B1BCD4D19A99CFC65ADE3283D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">TopbarPlus</string>
							<int64 name="SourceAssetId">92368439343389</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Script" referent="RBX296F1FAF56044CE1A913AC05730D4138">
							<Properties>
								<ProtectedString name="Source"><![CDATA[--[[

> TopbarPlus was developed by ForeverHD and is actively maintained
thanks to HD Admin.

> You can get in touch with me on Discord via the social link here:
https://create.roblox.com/store/asset/92368439343389/TopbarPlus

> READ_ME is Script with RunContext set to 'Client' meaning you can
store it in ReplicatedStorage and Workspace and it will still run 
like a normal LocalScript. DO NOT PLACE place in StarterPlayerScripts
(because this is a Script with RunContext). You need to create a separate
LocalScript for anything under StarterPlayerScripts. 

> You're welcome to move `Icon` and require it yourself. You can
then delete this folder and READ_ME.

> Icon is a Package for when Roblox (hopefully soon) release
public packages. This for example will enable you to receive
automatic updates, and to compare code easily between changes

> Have feedback? Post it to devforum.roblox.com/t/topbarplus/1017485
which I actively monitor. Enjoy! ~ForeverHD June 2025

--]]



local container  = script.Parent
local Icon = require(container.Icon)

Icon.new()
	:setName("Example")
	:setLabel("Example")
	:setImage(16086868244, "Deselected")
	:setImage(16086868447, "Selected")]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">2</token>
								<string name="ScriptGuid">{811B6CFC-5E9A-4E31-8406-4B70CC777C48}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">READ_ME</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF2ACEE3D4A9A4CA9A5297BB089529BF4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	
	The majority of this code is an interface designed to make it easy for you to
	work with TopbarPlus (most methods for instance reference :modifyTheme()).
	The processing overhead mainly consists of applying themes and calculating 
	appearance (such as size and width of labels) which is handled in about
	200 lines of code here and the Widget UI module. This has been achieved
	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
	features like UIListLayouts.


	v3 provides inbuilt support for controllers (simply press DPadUp),
	touch devices (phones, tablets , etc), localization (automatic resizing
	of widgets, autolocalize for relevant labels), backwards compatability
	with the old topbar, and more.


	My primary goals for the v3 re-write have been to:
		
	1. Improve code readability and organisation (reduced lines of code within
	   Icon+IconController from 3200 to ~950, separated UI elements, etc)
		
	2. Improve ease-of-use (themes now actually make sense and can account
	   for any modifications you want, converted to a package for
	   quick installation and easy-comparisons of new updates, etc)
	
	3. Provide support for all key features of the new Roblox topbar
	   while improving performance of the module (deferring and collecting
	   changes then calling as a singular, utilizing inbuilt Roblox features
	   such as UILIstLayouts, etc)

--]]



-- SERVICES
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Types = require(script.Types)



-- TYPES
export type Icon = Types.Icon



-- REFERENCE HANDLER
-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
-- therefore this ensures that the first required package becomes the dominant and only functioning module
local iconModule = script
local Reference = require(iconModule.Reference)
local referenceObject = Reference.getObject()
local leadPackage = referenceObject and referenceObject.Value
if leadPackage and leadPackage ~= iconModule then
	return require(leadPackage) :: Types.StaticIcon
end
if not referenceObject then
	Reference.addToReplicatedStorage()
end



-- MODULES
local Signal = require(iconModule.Packages.GoodSignal)
local Janitor = require(iconModule.Packages.Janitor)
local Utility = require(iconModule.Utility)
local Themes = require(iconModule.Features.Themes)
local Gamepad = require(iconModule.Features.Gamepad)
local Overflow = require(iconModule.Features.Overflow)
local Icon = {}
Icon.__index = Icon



--- LOCAL
local localPlayer = Players.LocalPlayer
local themes = iconModule.Features.Themes
local iconsDict = {}
local anyIconSelected = Signal.new()
local elements = iconModule.Elements
local totalCreatedIcons = 0
local preferredInput = {
	mobile = Enum.PreferredInput.Touch,
	desktop = Enum.PreferredInput.KeyboardAndMouse,
	console = Enum.PreferredInput.Gamepad
}



-- PUBLIC VARIABLES
Icon.baseDisplayOrderChanged = Signal.new()
Icon.baseDisplayOrder = 10
Icon.baseTheme = require(themes.Default)
Icon.isOldTopbar = false -- Logic has been moved to Container
Icon.iconsDictionary = iconsDict
Icon.insetHeightChanged = Signal.new()
Icon.container = require(elements.Container)(Icon)
Icon.topbarEnabled = true
Icon.iconAdded = Signal.new()
Icon.iconRemoved = Signal.new()
Icon.iconChanged = Signal.new()



-- PUBLIC FUNCTIONS
function Icon.getIcons()
	return Icon.iconsDictionary
end

function Icon.getIconByUID(UID)
	local match = Icon.iconsDictionary[UID]
	if match then
		return match
	end
	return nil
end

function Icon.getIcon(nameOrUID)
	local match = Icon.getIconByUID(nameOrUID)
	if match then
		return match
	end
	for _, icon in pairs(iconsDict) do
		if icon.name == nameOrUID then
			return icon
		end
	end
	return nil
end

function Icon.setTopbarEnabled(bool, isInternal)
	if typeof(bool) ~= "boolean" then
		bool = Icon.topbarEnabled
	end
	if not isInternal then
		Icon.topbarEnabled = bool
	end
	for _, screenGui in pairs(Icon.container) do
		screenGui.Enabled = bool
	end
end

function Icon.modifyBaseTheme(modifications)
	modifications = Themes.getModifications(modifications)
	for _, modification in pairs(modifications) do
		for _, detail in pairs(Icon.baseTheme) do
			Themes.merge(detail, modification)
		end
	end
	for _, icon in pairs(iconsDict) do
		icon:setTheme(Icon.baseTheme)
	end
end

function Icon.setDisplayOrder(int)
	Icon.baseDisplayOrder = int
	Icon.baseDisplayOrderChanged:Fire(int)
end



-- SETUP
task.defer(Gamepad.start, Icon)
task.defer(Overflow.start, Icon)
task.defer(function()
	local playerGui = localPlayer:WaitForChild("PlayerGui")
	for _, screenGui in pairs(Icon.container) do
		screenGui.Parent = playerGui
	end
	require(iconModule.Attribute)
end)



-- CONSTRUCTOR
function Icon.new()
	local self = {}
	setmetatable(self, Icon)

	--- Janitors (for cleanup)
	local janitor = Janitor.new()
	self.janitor = janitor
	self.themesJanitor = janitor:add(Janitor.new())
	self.singleClickJanitor = janitor:add(Janitor.new())
	self.captionJanitor = janitor:add(Janitor.new())
	self.joinJanitor = janitor:add(Janitor.new())
	self.menuJanitor = janitor:add(Janitor.new())
	self.dropdownJanitor = janitor:add(Janitor.new())

	-- Register
	local iconUID = Utility.generateUID()
	iconsDict[iconUID] = self
	janitor:add(function()
		iconsDict[iconUID] = nil
	end)

	-- Signals (events)
	self.selected = janitor:add(Signal.new())
	self.deselected = janitor:add(Signal.new())
	self.toggled = janitor:add(Signal.new())
	self.viewingStarted = janitor:add(Signal.new())
	self.viewingEnded = janitor:add(Signal.new())
	self.stateChanged = janitor:add(Signal.new())
	self.notified = janitor:add(Signal.new())
	self.noticeStarted = janitor:add(Signal.new())
	self.noticeChanged = janitor:add(Signal.new())
	self.endNotices = janitor:add(Signal.new())
	self.toggleKeyAdded = janitor:add(Signal.new())
	self.fakeToggleKeyChanged = janitor:add(Signal.new())
	self.alignmentChanged = janitor:add(Signal.new())
	self.updateSize = janitor:add(Signal.new())
	self.resizingComplete = janitor:add(Signal.new())
	self.joinedParent = janitor:add(Signal.new())
	self.menuSet = janitor:add(Signal.new())
	self.dropdownSet = janitor:add(Signal.new())
	self.updateMenu = janitor:add(Signal.new())
	self.startMenuUpdate = janitor:add(Signal.new())
	self.childThemeModified = janitor:add(Signal.new())
	self.indicatorSet = janitor:add(Signal.new())
	self.dropdownChildAdded = janitor:add(Signal.new())
	self.menuChildAdded = janitor:add(Signal.new())

	-- Properties
	self.iconModule = iconModule
	self.UID = iconUID
	self.isEnabled = true
	self.enabled = self.isEnabled -- Backwards compatability
	self.isSelected = false
	self.isViewing = false
	self.joinedFrame = false
	self.parentIconUID = false
	self.deselectWhenOtherIconSelected = true
	self.totalNotices = 0
	self.activeState = "Deselected"
	self.alignment = ""
	self.originalAlignment = ""
	self.appliedTheme = {}
	self.appearance = {}
	self.cachedInstances = {}
	self.cachedNamesToInstances = {}
	self.cachedCollectives = {}
	self.bindedToggleKeys = {}
	self.customBehaviours = {}
	self.toggleItems = {}
	self.bindedEvents = {}
	self.notices = {}
	self.menuIcons = {}
	self.dropdownIcons = {}
	self.childIconsDict = {}
	self.creationTime = os.clock()

	-- Widget is the new name for an icon
	local widget = janitor:add(require(elements.Widget)(self, Icon))
	self.widget = widget
	self:setAlignment()
	
	-- It's important we set an order otherwise icons will not align
	-- correctly within menus
	totalCreatedIcons += 1
	local ourOrder = 1+(totalCreatedIcons*0.01)
	self:setOrder(ourOrder, "deselected")
	self:setOrder(ourOrder, "selected")

	-- This applies the default them
	self:setTheme(Icon.baseTheme)

	-- Button Clicked (for states "Selected" and "Deselected")
	local clickRegion = self:getInstance("ClickRegion")
	local hasUsedMouseButton1Click = false
	local lastToggleTime = 0
	local DEBOUNCE_TIME = 0.1 -- 100ms debounce to prevent rapid toggles

	local function handleToggle()
		if self.locked then
			return
		end

		-- Debounce logic to prevent rapid toggling
		local currentTime = tick()
		if currentTime - lastToggleTime < DEBOUNCE_TIME then
			return
		end
		lastToggleTime = currentTime

		if self.isSelected then
			self:deselect("User", self)
		else
			self:select("User", self)
		end
	end

	clickRegion.MouseButton1Click:Connect(function()
		hasUsedMouseButton1Click = true
		handleToggle()
	end)

	clickRegion.TouchTap:Connect(function()
		-- This resolves the bug report by @28Pixels:
		-- https://devforum.roblox.com/t/topbarplus/1017485/1104
		-- Only use TouchTap if MouseButton1Click has never fired
		-- This handles edge cases where ONLY TouchTap works
		-- Also prevents double-toggle bug with multi-touch on mobile
		-- Credit to @sayer80 for this fix
		if not hasUsedMouseButton1Click then
			handleToggle()
		end
	end)

	-- Keys can be bound to toggle between Selected and Deselected
	janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
		if self.locked then
			return
		end
		if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
			handleToggle()
		end
	end))

	-- Button Hovering (for state "Viewing")
	-- Hovering is a state only for devices with keyboards
	-- and controllers (not touchpads)
	local function viewingStarted(dontSetState)
		if self.locked then
			return
		end
		self.isViewing = true
		self.viewingStarted:Fire(true)
		if not dontSetState then
			self:setState("Viewing", "User", self)
		end
	end
	local function viewingEnded()
		if self.locked then
			return
		end
		self.isViewing = false
		self.viewingEnded:Fire(true)
		self:setState(nil, "User", self)
	end
	self.joinedParent:Connect(function()
		if self.isViewing then
			viewingEnded()
		end
	end)
	clickRegion.MouseEnter:Connect(function()
		local dontSetState = UserInputService.PreferredInput ~= preferredInput.desktop
		viewingStarted(dontSetState)
	end)
	local touchCount = 0
	janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
	clickRegion.MouseLeave:Connect(viewingEnded)
	clickRegion.SelectionGained:Connect(viewingStarted)
	clickRegion.SelectionLost:Connect(viewingEnded)
	clickRegion.MouseButton1Down:Connect(function()
		if not self.locked and UserInputService.PreferredInput == preferredInput.mobile then
			touchCount += 1
			local myTouchCount = touchCount
			task.delay(0.2, function()
				if myTouchCount == touchCount then
					viewingStarted()
				end
			end)
		end
	end)
	clickRegion.MouseButton1Up:Connect(function()
		touchCount += 1
	end)

	-- Handle overlay on viewing
	local iconOverlay = self:getInstance("IconOverlay")
	self.viewingStarted:Connect(function()
		iconOverlay.Visible = not self.overlayDisabled
	end)
	self.viewingEnded:Connect(function()
		iconOverlay.Visible = false
	end)

	-- Deselect when another icon is selected
	janitor:add(anyIconSelected:Connect(function(incomingIcon)
		if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
			self:deselect("AutoDeselect", incomingIcon)
		end
	end))

	-- This checks if the script calling this module is a descendant of a ScreenGui
	-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
	-- client respawns. This solves one of the most asked about questions on the post
	-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
	-- the LocalScript rests within
	local source =  debug.info(2, "s")
	local sourcePath = string.split(source, ".")
	local origin = game
	local originsScreenGui
	for i, sourceName in pairs(sourcePath) do
		origin = origin:FindFirstChild(sourceName)
		if not origin then
			break
		end
		if origin:IsA("ScreenGui") then
			originsScreenGui = origin
		end
	end
	if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
		self.originsScreenGui = originsScreenGui
		Utility.localPlayerRespawned(function()
			self:destroy()
		end)
	end

	-- Additional children behaviour when toggled (mostly notices)
	self.toggled:Connect(function(isSelected)
		self.noticeChanged:Fire(self.totalNotices)
		for childIconUID, _ in pairs(self.childIconsDict) do
			local childIcon = Icon.getIconByUID(childIconUID)
			childIcon.noticeChanged:Fire(childIcon.totalNotices)
			if not isSelected and childIcon.isSelected then
				-- If an icon within a menu or dropdown is also
				-- a dropdown or menu, then close it
				for _, _ in pairs(childIcon.childIconsDict) do
					childIcon:deselect("HideParentFeature", self)
				end
			end
		end
	end)
	
	-- This closes/reopens the chat or playerlist if the icon is a dropdown
	-- In the future I'd prefer to use the position+size of the chat
	-- to determine whether to close dropdown (instead of non-right-set)
	-- but for reasons mentioned here it's unreliable at the time of
	-- writing this: https://devforum.roblox.com/t/here/2794915
	-- I could also make this better by accounting for multiple
	-- dropdowns being open (not just this one) but this will work
	-- fine for almost every use case for now.
	self.selected:Connect(function()
		local isDropdown = #self.dropdownIcons > 0
		if isDropdown then
			if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
				self.chatWasPreviouslyActive = true
				StarterGui:SetCore("ChatActive", false)
			end
			if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
				self.playerlistWasPreviouslyActive = true
				StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
			end
		end
	end)
	self.deselected:Connect(function()
		if self.chatWasPreviouslyActive then
			self.chatWasPreviouslyActive = nil
			StarterGui:SetCore("ChatActive", true)
		end
		if self.playerlistWasPreviouslyActive then
			self.playerlistWasPreviouslyActive = nil
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
		end
	end)
	
	-- There's a rare occassion where the appearance is not
	-- fully set to deselected so this ensures the icons
	-- appearance is fully as it should be
	task.delay(0.1, function()
		if self.activeState == "Deselected" then
			self.stateChanged:Fire("Deselected")
			self:refresh()
		end
	end)
	
	-- Call icon added
	Icon.iconAdded:Fire(self)

	return self
end



-- METHODS
function Icon:setName(name)
	self.widget.Name = name
	self.name = name
	return self
end

function Icon:setState(incomingStateName, fromSource, sourceIcon)
	-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
	-- a users mouse enters the widget), then informing other systems of this state change to then act upon
	-- (such as the theme handler applying the theme which corresponds to that state).
	if not incomingStateName then
		incomingStateName = (self.isSelected and "Selected") or "Deselected"
	end
	local stateName = Utility.formatStateName(incomingStateName)
	local previousStateName = self.activeState
	if previousStateName == stateName then
		return
	end
	local currentIsSelected = self.isSelected
	self.activeState = stateName
	if stateName == "Deselected" then
		self.isSelected = false
		if currentIsSelected then
			self.toggled:Fire(false, fromSource, sourceIcon)
			self.deselected:Fire(fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(false, fromSource, sourceIcon)
	elseif stateName == "Selected" then
		self.isSelected = true
		if not currentIsSelected then
			self.toggled:Fire(true, fromSource, sourceIcon)
			self.selected:Fire(fromSource, sourceIcon)
			anyIconSelected:Fire(self, fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(true, fromSource, sourceIcon)
	end
	self.stateChanged:Fire(stateName, fromSource, sourceIcon)
end

function Icon:getInstance(name)
	-- This enables us to easily retrieve instances located within the icon simply by passing its name.
	-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
	-- We cache the result for more performant retrieval in the future.
	local instance = self.cachedNamesToInstances[name]
	if instance then
		return instance
	end
	local function cacheInstance(childName, child)
		local currentCache = self.cachedInstances[child]
		if not currentCache then
			local collectiveName = child:GetAttribute("Collective")
			local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
			if cachedCollective then
				table.insert(cachedCollective, child)
			end
			self.cachedNamesToInstances[childName] = child
			self.cachedInstances[child] = true
			child.Destroying:Once(function()
				self.cachedNamesToInstances[childName] = nil
				self.cachedInstances[child] = nil
			end)
		end
	end
	local widget = self.widget
	cacheInstance("Widget", widget)
	if name == "Widget" then
		return widget
	end

	local returnChild
	local function scanChildren(parentInstance)
		for _, child in pairs(parentInstance:GetChildren()) do
			local widgetUID = child:GetAttribute("WidgetUID")
			if widgetUID and widgetUID ~= self.UID then
				-- This prevents instances within other icons from being recorded
				-- (for instance when other icons are added to this icons menu)
				continue
			end
			-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
			-- then its important we scan the real original instance instead of this clone
			local realChild = Themes.getRealInstance(child)
			if realChild then
				child = realChild
			end
			-- Finally scan its children
			scanChildren(child)
			if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
				local childName = child.Name
				cacheInstance(childName, child)
				if childName == name then
					returnChild = child
				end
			end
		end
	end
	scanChildren(widget)
	return returnChild
end

function Icon:getCollective(name)
	-- A collective is an array of instances within the Widget that have been
	-- grouped together based on a given name. This just makes it easy
	-- to act on multiple instances at once which share similar behaviours.
	-- For instance, if we want to change the icons corner size, all corner instances
	-- with the attribute "Collective" and value "WidgetCorner" could be updated
	-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
	local collective = self.cachedCollectives[name]
	if collective then
		return collective
	end
	collective = {}
	for instance, _ in pairs(self.cachedInstances) do
		if instance:GetAttribute("Collective") == name then
			table.insert(collective, instance)
		end
	end
	self.cachedCollectives[name] = collective
	return collective
end

function Icon:getInstanceOrCollective(collectiveOrInstanceName)
	-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
	-- an array of instances instead of a single instance
	local instances = {}
	local instance = self:getInstance(collectiveOrInstanceName)
	if instance then
		table.insert(instances, instance)
	end
	if #instances == 0 then
		instances = self:getCollective(collectiveOrInstanceName)
	end
	return instances
end

function Icon:getStateGroup(iconState)
	local chosenState = iconState or self.activeState
	local stateGroup = self.appearance[chosenState]
	if not stateGroup then
		stateGroup = {}
		self.appearance[chosenState] = stateGroup
	end
	return stateGroup
end

function Icon:refreshAppearance(instance, specificProperty)
	Themes.refresh(self, instance, specificProperty)
	return self
end

function Icon:refresh()
	self:refreshAppearance(self.widget)
	self.updateSize:Fire()
	return self
end

function Icon:updateParent()
	local parentIcon = Icon.getIconByUID(self.parentIconUID)
	if parentIcon then
		parentIcon.updateSize:Fire()
	end
end

function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
	-- You can specify your own custom callback to handle custom logic just before
	-- an instances property is changed by using :setBehaviour()
	local key = collectiveOrInstanceName.."-"..property
	self.customBehaviours[key] = callback
	if refreshAppearance then
		local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
		for _, instance in pairs(instances) do
			self:refreshAppearance(instance, property)
		end
	end
end

function Icon:modifyTheme(modifications, customModificationUID)
	local modificationUID = Themes.modify(self, modifications, customModificationUID)
	return self, modificationUID
end

function Icon:modifyChildTheme(modifications, modificationUID)
	-- Same as modifyTheme except for its children (i.e. icons
	-- within its dropdown or menu)
	self.childModifications = modifications
	self.childModificationsUID = modificationUID
	for childIconUID, _ in pairs(self.childIconsDict) do
		local childIcon = Icon.getIconByUID(childIconUID)
		childIcon:modifyTheme(modifications, modificationUID)
	end
	self.childThemeModified:Fire()
	return self
end

function Icon:removeModification(modificationUID)
	Themes.remove(self, modificationUID)
	return self
end

function Icon:removeModificationWith(instanceName, property, state)
	Themes.removeWith(self, instanceName, property, state)
	return self
end

function Icon:setTheme(theme)
	Themes.set(self, theme)
	return self
end

function Icon:setEnabled(bool)
	self.isEnabled = bool
	self.enabled = self.isEnabled
	self.widget.Visible = bool
	self:updateParent()
	return self
end

function Icon:select(fromSource, sourceIcon)
	self:setState("Selected", fromSource, sourceIcon)
	return self
end

function Icon:deselect(fromSource, sourceIcon)
	self:setState("Deselected", fromSource, sourceIcon)
	return self
end

function Icon:notify(customClearSignal, noticeId)
	-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
	-- users of changes/updates within your UI such as a Catalog
	-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
	-- Roblox event (e.g. Instance.new("BindableEvent").Event)
	local notice = self.notice
	if not notice then
		notice = require(elements.Notice)(self, Icon)
		self.notice = notice
	end
	self.noticeStarted:Fire(customClearSignal, noticeId)
	return self
end

function Icon:clearNotices()
	self.endNotices:Fire()
	return self
end

function Icon:disableOverlay(bool)
	self.overlayDisabled = bool
	return self
end
Icon.disableStateOverlay = Icon.disableOverlay

function Icon:setImage(imageId, iconState)
	self:modifyTheme({"IconImage", "Image", imageId, iconState})
	
	-- This code ensures icon images are preloaded if they haven't been fetched yet
	task.spawn(function()
		local newIdContent = if tonumber(imageId) then `rbxassetid://{imageId}` else imageId
		local initialAssetFetchStatus = ContentProvider:GetAssetFetchStatus(newIdContent)
	
		if initialAssetFetchStatus ~= Enum.AssetFetchStatus.Success then
			pcall(ContentProvider.PreloadAsync, ContentProvider, { newIdContent })
		end
	end)
		
	return self
end

function Icon:setLabel(text, iconState)
	self:modifyTheme({"IconLabel", "Text", text, iconState})
	return self
end

function Icon:setOrder(int, iconState)
	-- We multiply by 100 to allow for custom increments inbetween
	-- (.01, .02, etc) as LayoutOrders only support integers
	local newInt = int*100
	self:modifyTheme({"IconSpot", "LayoutOrder", newInt, iconState})
	self:modifyTheme({"Widget", "LayoutOrder", newInt, iconState})
	return self
end

function Icon:setCornerRadius(udim, iconState)
	self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
	return self
end

function Icon:align(leftCenterOrRight, isFromParentIcon)
	-- Determines the side of the screen the icon will be ordered
	local direction = tostring(leftCenterOrRight):lower()
	if direction == "mid" or direction == "centre" then
		direction = "center"
	end
	if direction ~= "left" and direction ~= "center" and direction ~= "right" then
		direction = "left"
	end
	local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
	local holders = screenGui.Holders
	local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
	if not isFromParentIcon then
		self.originalAlignment = finalDirection
	end
	local joinedFrame = self.joinedFrame
	local alignmentHolder = holders[finalDirection]
	self.screenGui = screenGui
	self.alignmentHolder = alignmentHolder
	if not self.isDestroyed then
		self.widget.Parent = joinedFrame or alignmentHolder
	end
	self.alignment = finalDirection
	self.alignmentChanged:Fire(finalDirection)
	Icon.iconChanged:Fire(self)
	return self
end
Icon.setAlignment = Icon.align

function Icon:setLeft()
	self:setAlignment("Left")
	return self
end

function Icon:setMid()
	self:setAlignment("Center")
	return self
end

function Icon:setRight()
	self:setAlignment("Right")
	return self
end

function Icon:setWidth(offsetMinimum, iconState)
	-- This sets a minimum X offset size for the widget, useful
	-- for example if you're constantly changing the label
	-- but don't want the icon to resize every time
	self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
	return self
end

function Icon:setImageScale(number, iconState)
	self:modifyTheme({"IconImageScale", "Value", number, iconState})
	return self
end

function Icon:setImageRatio(number, iconState)
	self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
	return self
end

function Icon:setTextSize(number, iconState)
	self:modifyTheme({"IconLabel", "TextSize", number, iconState})
	return self
end

function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
	fontWeight = fontWeight or Enum.FontWeight.Regular
	fontStyle = fontStyle or Enum.FontStyle.Normal
	local fontFace
	local fontType = typeof(font)
	if fontType == "number" then
		fontFace = Font.fromId(font, fontWeight, fontStyle)
	elseif fontType == "EnumItem" then
		fontFace = Font.fromEnum(font)
	elseif fontType == "string" then
		if not font:match("rbxasset") then
			fontFace = Font.fromName(font, fontWeight, fontStyle)
		end
	end
	if not fontFace then
		fontFace = Font.new(font, fontWeight, fontStyle)
	end
	self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
	return self
end

function Icon:setTextColor(Color, iconState)
	if Color == nil or Color == "" or (type(Color) ~= "userdata" or typeof(Color) ~= "Color3") then
		if Color ~= nil and Color ~= "" then
			warn("setTextColor item must be a Color3 value! Changed the color to white.")
		end
		Color = Color3.fromRGB(255, 255, 255)
	end

	self:modifyTheme({"IconLabel", "TextColor3", Color, iconState})
	return self
end

function Icon:bindToggleItem(guiObjectOrLayerCollector)
	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
		error("Toggle item must be a GuiObject or LayerCollector!")
	end
	self.toggleItems[guiObjectOrLayerCollector] = true
	self:_updateSelectionInstances()
	return self
end

function Icon:unbindToggleItem(guiObjectOrLayerCollector)
	self.toggleItems[guiObjectOrLayerCollector] = nil
	self:_updateSelectionInstances()
	return self
end

function Icon:_updateSelectionInstances()
	-- This is to assist with controller navigation and selection
	-- It converts the value true to an array
	for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
		local buttonInstancesArray = {}
		for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
			if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
				table.insert(buttonInstancesArray, instance)
			end
		end
		self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
	end
end

function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
	for toggleItem, _ in pairs(self.toggleItems) do
		if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
			local property = "Visible"
			if toggleItem:IsA("LayerCollector") then
				property = "Enabled"
			end
			toggleItem[property] = bool
		end
	end
end

function Icon:bindEvent(iconEventName, eventFunction)
	local event = self[iconEventName]
	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
	self.bindedEvents[iconEventName] = event:Connect(function(...)
		eventFunction(self, ...)
	end)
	return self
end

function Icon:unbindEvent(iconEventName)
	local eventConnection = self.bindedEvents[iconEventName]
	if eventConnection then
		eventConnection:Disconnect()
		self.bindedEvents[iconEventName] = nil
	end
	return self
end

function Icon:bindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = true
	self.toggleKeyAdded:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:unbindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = nil
	return self
end

function Icon:call(callback, ...)
	local packedArgs = table.pack(...)
	task.spawn(function()
		callback(self, table.unpack(packedArgs))
	end)
	return self
end

function Icon:addToJanitor(callback, methodName, index)
	self.janitor:add(callback, methodName, index)
	return self
end

function Icon:lock()
	-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = false
	self.locked = true
	return self
end

function Icon:unlock()
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = true
	self.locked = false
	return self
end

function Icon:debounce(seconds)
	self:lock()
	task.wait(seconds)
	self:unlock()
	return self
end

function Icon:autoDeselect(bool)
	-- When set to true the icon will deselect itself automatically whenever
	-- another icon is selected
	if bool == nil then
		bool = true
	end
	self.deselectWhenOtherIconSelected = bool
	return self
end

function Icon:oneClick(bool)
	-- When set to true the icon will automatically deselect when selected, this creates
	-- the effect of a single click button
	local singleClickJanitor = self.singleClickJanitor
	singleClickJanitor:clean()
	if bool or bool == nil then
		singleClickJanitor:add(self.selected:Connect(function()
			self:deselect("OneClick", self)
		end))
	end
	self.oneClickEnabled = true
	return self
end

function Icon:setCaption(text)
	if text == "_hotkey_" and (self.captionText) then
		return self
	end
	local captionJanitor = self.captionJanitor
	self.captionJanitor:clean()
	if not text or text == "" then
		self.caption = nil
		self.captionText = nil
		return self
	end
	local caption = captionJanitor:add(require(elements.Caption)(self))
	caption:SetAttribute("CaptionText", text)
	self.caption = caption
	self.captionText = text
	return self
end

function Icon:setCaptionHint(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.fakeToggleKey = keyCodeEnum
	self.fakeToggleKeyChanged:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:leave()
	local joinJanitor = self.joinJanitor
	joinJanitor:clean()
	return self
end

function Icon:joinMenu(parentIcon)
	Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
	parentIcon.menuChildAdded:Fire(self)
	return self
end

function Icon:setMenu(arrayOfIcons)
	self.menuSet:Fire(arrayOfIcons)
	return self
end

function Icon:setFixedMenu(arrayOfIcons)
	self:freezeMenu(arrayOfIcons)
	self:setMenu(arrayOfIcons)
end
Icon.setFrozenMenu = Icon.setFixedMenu

function Icon:freezeMenu()
	-- A frozen menu is a menu which is permanently locked in the
	-- the selected state (with its toggle hidden)
	self:select("FrozenMenu", self)
	self:bindEvent("deselected", function(icon)
		icon:select("FrozenMenu", self)
	end)
	self:modifyTheme({"IconSpot", "Visible", false})
end

function Icon:joinDropdown(parentIcon)
	parentIcon:getDropdown()
	Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
	parentIcon.dropdownChildAdded:Fire(self)
	return self
end

function Icon:getDropdown()
	local dropdown = self.dropdown
	if not dropdown then
		dropdown = require(elements.Dropdown)(self)
		self.dropdown = dropdown
		self:clipOutside(dropdown)
	end
	return dropdown
end

function Icon:setDropdown(arrayOfIcons)
	self:getDropdown()
	self.dropdownSet:Fire(arrayOfIcons)
	return self
end

function Icon:clipOutside(instance)
	-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
	-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
	-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
	-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
	-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
	local instanceClone = Utility.clipOutside(self, instance)
	self:refreshAppearance(instance)
	return self, instanceClone
end

function Icon:setIndicator(keyCode)
	-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
	-- with controllers to show the user what button to press to highlight the topbar. You don't need
	-- to set an indicator for controllers as this is handled internally within the Gamepad module
	local indicator = self.indicator
	if not indicator then
		indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
		self.indicator = indicator
	end
	self.indicatorSet:Fire(keyCode)
end

function Icon:convertLabelToNumberSpinner(numberSpinner, callback)
	task.defer(function()
		
		local label = self:getInstance("IconLabel")
		label.Transparency = 1
		numberSpinner.Parent = label.Parent
		numberSpinner.Size = UDim2.fromScale(1, 1)
		numberSpinner.AnchorPoint = Vector2.new(0.5, 0.5)
		numberSpinner.Position = UDim2.new(0.5, 0, 0.5, 0)
		numberSpinner.TextXAlignment = Enum.TextXAlignment.Center
		numberSpinner.ClipsDescendants = false

		local propertiesToChangeLabel = {
			"FontFace",
			"BorderSizePixel",
			"BorderColor3",
			"Rotation",
			"TextStrokeTransparency",
			"TextStrokeColor3",
			"TextStrokeTransparency",
			"TextColor3",
		}
		for _, property in ipairs(propertiesToChangeLabel) do
			numberSpinner[property] = label[property]
			self:addToJanitor(label:GetPropertyChangedSignal(property):Connect(function()
				numberSpinner[property] = label[property]
			end))
		end

		local minDigits = 0
		local maxDigits = 8
		local function getSpinnerSizeAndDigitCount()
			local TotalSize = 0
			local numOfDigits = 0
			for i, child in numberSpinner.Frame:GetChildren() do
				local name = string.lower(child.Name)
				if name == "digit" then
					TotalSize += child.AbsoluteSize.X
					numOfDigits += 1
				elseif name == "prefix" or name == "suffix" or name == "comma" then
					if child.Text ~= "" then
						TotalSize += child.AbsoluteSize.X
						numOfDigits += 1
					end
				end
			end
			return TotalSize, numOfDigits
		end
		
		local function getLabelParentContainerXSize()
			local firstParent = label.Parent
			local nextParent = firstParent and firstParent.Parent
			if nextParent == nil then
				return 0
			end
			if nextParent.IconImage.Visible == true then
				return numberSpinner.Frame.AbsoluteSize.X + label.Parent.Parent.IconImage.AbsoluteSize.X
			else
				return nextParent.AbsoluteSize.X
			end
		end
		local function getNumberSpinnerXSize()
			return numberSpinner.Frame.AbsoluteSize.X
		end

		local function adjustSize()
			local totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			if numOfDigits < 18 then
				self:setLabel(numberSpinner.Value)
			end

			local NumberSpinnerXSize = getNumberSpinnerXSize()

			while totalDigitXSize < NumberSpinnerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits > minDigits and numOfDigits < maxDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize += 1
				end

				NumberSpinnerXSize = getNumberSpinnerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end

			local labelParentContainerXSize = getLabelParentContainerXSize()
			while totalDigitXSize > labelParentContainerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits < maxDigits and numOfDigits > minDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize -= 1
				end

				labelParentContainerXSize = getLabelParentContainerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end
		end

		self:addToJanitor(numberSpinner.Frame.ChildAdded:Connect(adjustSize))
		self:addToJanitor(numberSpinner.Frame.ChildRemoved:Connect(adjustSize))
		self:addToJanitor(self.iconAdded:Connect(function()
			task.wait(1)
			adjustSize()
		end))

		self:updateParent()

		-- This corrects text to the size of a normal label
		numberSpinner.Name = "LabelSpinner"
		numberSpinner.Prefix = "$"
		numberSpinner.Commas = true
		numberSpinner.Decimals = 0
		numberSpinner.Duration = 0.25
		numberSpinner.Value = 10
		task.wait(0.2)
		
		if typeof(callback) == "function" then
			callback()
		end
		
	end)
	return self
end



-- DESTROY/CLEANUP
function Icon:destroy()
	if self.isDestroyed then
		return
	end
	self:clearNotices()
	if self.parentIconUID then
		self:leave()
	end
	self.isDestroyed = true
	self.janitor:clean()
	Icon.iconRemoved:Fire(self)
end
Icon.Destroy = Icon.destroy

return Icon :: Types.StaticIcon]]></ProtectedString>
								<string name="ScriptGuid">{B5F7978F-0192-4D43-A713-3399FCA9E4D7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Icon</string>
								<int64 name="SourceAssetId">16049574146</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX27AE32100A164A9CB7F2A28919914E70">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--!strict

-- GoodSignal Types (...but simpler!)

--- Connection

type Connection<Variant... = ...any> = {
	Disconnect: (self: Connection<Variant...>) -> (),
}

--- Signal

type Signal<Variant... = ...any> = {
	Connect: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
    Once: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
	Wait: (self: Signal<Variant...>) -> Variant...,
}

----------------------

export type IconState = "Deselected" | "Selected" | "Viewing"
export type Events = "selected" | "deselected" | "toggled" | "viewingStarted" | "viewingEnded" | "notified"
export type Alignment = "Left" | "Center" | "Right"
export type EventSource = "User" | "OneClick" | "AutoDeselect" | "HideParentFeature" | "Overflow"
export type Modification = { any }


type StaticFunctions = {
	getIcons: typeof(
		--[[
			Returns a dictionary of icons where the key is the icon's UID and value the icon.
		]]
		function(): { Icon }
			return (nil :: any) :: { Icon }
		end
	),
	getIcon: typeof(
		--[[
			Returns an icon of the given name or UID.
		]]
		function(nameOrUID: string): Icon?
			return nil :: any
		end
	),
	setTopbarEnabled: typeof(
		--[[
			When set to <code>false</code> all TopbarPlus ScreenGuis are hidden.
			This does not impact Roblox's Topbar.
		]]
		function(enabled: boolean)

		end
	),
	modifyBaseTheme: typeof(
		--[[
			Updates the appearance of all icons.
		]]
		function(modifications: { Modification })

		end
	),
	setDisplayOrder: typeof(
		--[[
			Sets the base DisplayOrder of all TopbarPlus ScreenGuis.
		]]
		function(order: number)

		end
	),
}

type Methods = {
	
	-- CLASS FUNCTIONS
	setName: typeof(
		--[[
			Sets the name of the Widget instance. This can be used in conjunction with <code>Icon.getIcon(name)</code>
		]]
		function(self: Icon, name: string): Icon
			return nil :: any
		end
	),
	getInstance: typeof(
		--[[
			Returns the first descendant found within the widget of name <code>instanceName</code>.
		]]
		function(self: Icon, instanceName: string): Instance?
			return (nil :: any) :: Instance?
		end
	),
	modifyTheme: typeof(
		--[[
			Updates the appearance of the icon.
		]]
		function(self: Icon, modifications: {Modification} | Modification): Icon
			return nil :: any
		end
	),
	modifyChildTheme: typeof(
		--[[
			Updates the appearance of all icons that are parented to this icon (for example when a menu or dropdown).
		]]
		function(self: Icon, modifications: { Modification }): Icon
			return nil :: any
		end
	),
	setEnabled: typeof(
		--[[
			When set to <code>false</code> the icon will be disabled and hidden.
		]]
		function(self: Icon, enabled: boolean): Icon
			return nil :: any
		end
	),
	select: typeof(
		--[[
			Selects the icon (as if it were clicked once).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	deselect: typeof(
		--[[
			Deselects the icon (as if it were clicked, then clicked again).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	notify: typeof(
		--[[
			Prompts a notice bubble which accumulates the further it is prompted.
			If the icon belongs to a dropdown or menu, then the notice will appear on the parent icon when the parent icon is deselected.
		]]
		function(self: Icon, clearNoticeEvent: Signal?): Icon
			return nil :: any
		end
	),
	clearNotices: typeof(
		--[[
			
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	disableOverlay: typeof(
		--[[
			When set to <code>true</code>, disables the shade effect which appears when the icon is pressed and released.
		]]
		function(self: Icon, disabled: boolean): Icon
			return nil :: any
		end
	),
	setImage: typeof(
		--[[
			Applies an image to the icon based on the given <code>imageId</code>. <code>imageId</code> can be an assetId or a complete asset string.
		]]
		function(self: Icon, imageId: string | number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setLabel: typeof(
		--[[
			
		]]
		function(self: Icon, text: string, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setOrder: typeof(
		--[[
			
		]]
		function(self: Icon, order: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setCornerRadius: typeof(
		--[[
			
		]]
		function(self: Icon, udim: UDim2, iconState: IconState?): Icon
			return nil :: any
		end
	),
	align: typeof(
		--[[
			This enables you to set the icon to the <code>"Left"</code> (default), <code>"Center"</code> or <code>"Right"</code> side of the screen.
		]]
		function(self: Icon, alignment: Alignment?): Icon
			return nil :: any
		end
	),
	setWidth: typeof(
		--[[
			This sets the minimum width the icon can be (it can be larger for instance when setting a long label). The default width is <code>44</code>.
		]]
		function(self: Icon, minimumSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageScale: typeof(
		--[[
			How large the image is relative to the icon. The default value is <code>0.5</code>.
		]]
		function(self: Icon, scale: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageRatio: typeof(
		--[[
			How stretched the image will appear. The default value is <code>1</code> (a perfect square).
		]]
		function(self: Icon, ratio: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextSize: typeof(
		--[[
			The size of the icon labels' text. The default value is <code>16</code>.
		]]
		function(self: Icon, textSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextColor: typeof(
		--[[
			The color of the icon labels' text
		]]
		function(self: Icon, color: Color3, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextFont: typeof(
		--[[
			Sets the labels FontFace.
			<code>font</code> can be a font family name (such as <code>"Creepster"</code>),
			a font enum (such as <code>Enum.Font.Bangers</code>),
			a font ID (such as <code>12187370928</code>),
			or font family link (such as <code>"rbxasset://fonts/families/Sarpanch.json"</code>).
		]]
		function(self: Icon, font: string | Enum.Font, fontWeight: Enum.FontWeight?, fontStyle: Enum.FontSize?, iconState: IconState?): Icon
			return nil :: any
		end
	),
	bindToggleItem: typeof(
		--[[
			Binds a GuiObject or LayerCollector to appear and disappeared when the icon is toggled.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	unbindToggleItem: typeof(
		--[[
			Unbinds the given GuiObject or LayerCollector from the toggle.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	bindEvent: typeof(
		--[[
			Connects to an icon event with <code>iconEventName</code>.
			It's important to remember all event names are in <code>camelCase</code>.
			<code>callback</code> is called with arguments <code>(self, ...)</code> when the event is triggered.
		]]
		function(self: Icon, event: Events, callback: (...any) -> ()): Icon
			return nil :: any
		end
	),
	unbindEvent: typeof(
		--[[
			Unbinds the connection of the associated <code>iconEventName</code>.
		]]
		function(self: Icon, event: Events): Icon
			return nil :: any
		end
	),
	bindToggleKey: typeof(
		--[[
			Binds a keycode which toggles the icon when pressed.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	unbindToggleKey: typeof(
		--[[
			Unbinds the given keycode.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	call: typeof(
		--[[
			Calls the function immediately via <code>task.spawn</code>.
			The first argument passed is the icon itself.
			This is useful when needing to extend the behaviour of an icon while remaining in the chain.
		]]
		function(self: Icon, func: (self: Icon) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	addToJanitor: typeof(
		--[[
			Passes the given userdata to the icons janitor to be destroyed/disconnected on the icons destruction.
			If a function is passed, it will be called when the icon is destroyed.
		]]
		function(self: Icon, userdata: unknown): Icon
			return nil :: any
		end
	),
	lock: typeof(
		--[[
			Prevents the icon being toggled by user-input (such as clicking), however, the icon can still be toggled via localscript using methods such as <code>icon:select()</code>.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	unlock: typeof(
		--[[
			Re-enables user-input to toggle the icon again.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	debounce: typeof(
		--[[
			Locks the icon, yields for the given time, then unlocks the icon, effectively shorthand for <code>icon:lock() task.wait(seconds) icon:unlock()</code>.
			This is useful for applying cooldowns (to prevent an icon from being pressed again) after an icon has been selected or deselected.
		]]
		function(self: Icon, seconds: number): Icon
			return nil :: any
		end
	),
	autoDeselect: typeof(
		--[[
			When set to <code>true</code> (the default) the icon is deselected when another icon (with autoDeselect enabled) is pressed.
			Set to <code>false</code> to prevent the icon being deselected when another icon is selected (a useful behaviour in dropdowns).
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	oneClick: typeof(
		--[[
			When set to true the icon will automatically deselect when selected.
			This creates the effect of a single click button.
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	setCaption: typeof(
		--[[
			Sets a caption. To remove, pass <code>nil</code> as <code>text</code>.
		]]
		function(self: Icon, text: string?): Icon
			return nil :: any
		end
	),
	setCaptionHint: typeof(
		--[[
			This customizes the appearance of the caption's hint without having to use <code>icon:bindToggleKey</code>.
		]]
		function(self: Icon, keyCode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	setDropdown: typeof(
		--[[
			Creates a vertical dropdown based upon the given table array of icons.
			Pass an empty table <code>{}</code> to remove the dropdown.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinDropdown: typeof(
		--[[
			Joins the dropdown of <code>parentIcon</code>.
			This is what <code>icon:setDropdown</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parent: Icon): Icon
			return nil :: any
		end
	),
	setMenu: typeof(
		--[[
			Creates a horizontal menu based upon the given array of icons.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	setFixedMenu: typeof(
		--[[
			Creates a menu that is always selected and has it's close button hidden.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinMenu: typeof(
		--[[
			Joins the menu of <code>parentIcon</code>.
			This is what <code>icon:setMenu</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parentIcon: Icon): Icon
			return nil :: any
		end
	),
	leave: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	convertLabelToNumberSpinner: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon, numberSpinner: any, func: (...any) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	destroy: typeof(
		--[[
			Clears all connections and destroys all instances associated with the icon.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
} & StaticFunctions

type Fields = {
	-- CLASS PROPERTIES
	name: string,
	isSelected: boolean,
	isEnabled: boolean,
	totalNotices: number,
	locked: boolean,

	-- CLASS EVENTS
	selected: Signal<EventSource>,
	deselected: Signal<EventSource>,
	toggled: Signal<boolean, EventSource>,
	viewingStarted: Signal,
	viewingEnded: Signal,
	notified: Signal,
}

export type Icon = Methods & StaticFunctions --typeof(setmetatable({} :: Fields, MT))

export type StaticIcon = {
	new: typeof(
		--[[
			Constructs an empty <code>32x32</code> icon on the topbar.
		]]
		function(): Icon
			return (nil :: any) :: Icon
		end
	),
} & StaticFunctions

return {}]]></ProtectedString>
									<string name="ScriptGuid">{65C3D69B-10BF-4CC4-9F5C-D7F0A4E54270}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Types</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX53FAAA5AC0BA4BA296877237F3D9F96F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--!strict
-- LOCAL
local VERSION = {}



-- SHARED
VERSION.appVersion = "v3.4.0"
VERSION.latestVersion = nil :: string?



-- FUNCTIONS
function VERSION.getLatestVersion(): string?
	local DEVELOPMENT_PLACE_ID = 117501901079852
	local latestVersion = VERSION.latestVersion
	if latestVersion then
		return latestVersion
	end
	local placeName = ""
	while true do
		local success, hdDevelopmentDetails = pcall(function()
			return game:GetService("MarketplaceService"):GetProductInfo(DEVELOPMENT_PLACE_ID)
		end)
		if success and hdDevelopmentDetails then
			placeName = hdDevelopmentDetails.Name
			break
		end
		task.wait(1)
	end
	latestVersion = string.match(placeName, "^TopbarPlus (.*)$")
	if latestVersion then
		latestVersion = latestVersion:gsub("%s+", "") -- Remove all whitespace (spaces, tabs, newlines)
	end
	VERSION.latestVersion = latestVersion
	return latestVersion
end

function VERSION.getAppVersion()
	return VERSION.appVersion
end

function VERSION.isUpToDate()
	local latestVersion = VERSION.getLatestVersion()
	local appVersion = VERSION.getAppVersion()
	return latestVersion ~= nil and latestVersion == appVersion
end



return VERSION]]></ProtectedString>
									<string name="ScriptGuid">{2202B746-1816-40F9-9E6D-F772B2F1B72D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">VERSION</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX86EE5894D9B548E0810F019501DEEF77">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[-- This module enables you to place Icon wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
-- cause icons to overlap with each other

local replicatedStorage = game:GetService("ReplicatedStorage")
local Reference = {}
Reference.objectName = "TopbarPlusReference"

function Reference.addToReplicatedStorage()
	local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
	objectValue.Name = Reference.objectName
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    return objectValue
end

function Reference.getObject()
	local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
    if objectValue then
        return objectValue
    end
    return false
end

return Reference]]></ProtectedString>
									<string name="ScriptGuid">{63688DFD-9B95-4C6C-946B-F844BC4623DB}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Reference</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE4FF0210717D44458979D9F5A1A62F2A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	TopbarPlus was developed by ForeverHD and is possible thanks to HD Admin.

	By using TopbarPlus in your experience or application, you agree to either:
		1. Keep Attribute unchanged, or
		2. If an experience, to credit TopbarPlus in your description, or in a
		   devforum post linked from your experience's description.

	v3 has involved over 350 hours of work to develop, so please consider supporting
	its development by reporting any issues or feedback you have at its repository:
	https://github.com/1ForeverHD/TopbarPlus

	You can get in touch with me on Discord via the social link here:
	https://create.roblox.com/store/asset/92368439343389/TopbarPlus

	Many thanks! ~Ben, June 10th 2025
	
]]

task.defer(function()
	local RunService = game:GetService("RunService")
	local VERSION = require(script.Parent.VERSION)
	local appVersion = VERSION.getAppVersion()
	local latestVersion = VERSION.getLatestVersion()
	local isOutdated = not VERSION.isUpToDate()
	if not RunService:IsStudio() then
		print(` Running TopbarPlus {appVersion} by @ForeverHD & HD Admin`)
	end
	if isOutdated then
		warn(`A new version of TopbarPlus ({latestVersion}) is available: https://devforum.roblox.com/t/topbarplus/1017485`)
	end
end)

return {}]]></ProtectedString>
									<string name="ScriptGuid">{DC2940F5-EB81-4FC2-B32F-C1279AE0A56A}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Attribute</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF2EBD64AA88540139B96000FEA381BD6">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[-- Just generic utility functions which I use and repeat across all my projects



-- LOCAL
local Utility = {}
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer



-- FUNCTIONS
function Utility.createStagger(delayTime, callback, delayInitially)
	-- This creates and returns a function which when called
	-- acts identically to callback, however will only be called
	-- for a maximum of once per delayTime. If the returned function
	-- is called more than once during the delayTime, then it will
	-- wait until the expiryTime then perform another recall.
	-- This is useful for visual interfaces and effects which may be
	-- triggered multiple times within a frame or short period, but which
	-- we don't necessary need to (for performance reasons).
	local staggerActive = false
	local multipleCalls = false
	if not delayTime or delayTime == 0 then
		-- We make 0.01 instead of 0 because devices can now run at
		-- different frame rates
		delayTime = 0.01
	end
	local function staggeredCallback(...)
		if staggerActive then
			multipleCalls = true
			return
		end
		local packedArgs = table.pack(...)
		staggerActive = true
		multipleCalls = false
		task.spawn(function()
			if delayInitially then
				task.wait(delayTime)
			end
			callback(table.unpack(packedArgs))
		end)
		task.delay(delayTime, function()
			staggerActive = false
			if multipleCalls then
				-- This means it has been called at least once during
				-- the stagger period, so call again
				staggeredCallback(table.unpack(packedArgs))
			end
		end)
	end
	return staggeredCallback
end

function Utility.round(n)
	-- Credit to Darkmist101 for this
	return math.floor(n + 0.5)
end

function Utility.reverseTable(t)
	for i = 1, math.floor(#t/2) do
		local j = #t - i + 1
		t[i], t[j] = t[j], t[i]
	end
end

function Utility.copyTable(t)
	-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = Utility.copyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end

local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
function Utility.generateUID(length)
	length = length or 8
	local UID = ""
	local list = validCharacters
	local total = #list
	for i = 1, length do
		local randomCharacter = list[math.random(1, total)]
		UID = UID..randomCharacter
	end
	return UID
end

local instanceTrackers = {}
function Utility.setVisible(instance, bool, sourceUID)
	-- This effectively works like a buff object but
	-- incredibly simplified. It stacks false values
	-- so that if there is more than more than, the 
	-- instance remains hidden even if set visible true
	local tracker = instanceTrackers[instance]
	if not tracker then
		tracker = {}
		instanceTrackers[instance] = tracker
		instance.Destroying:Once(function()
			instanceTrackers[instance] = nil
		end)
	end
	if not bool then
		tracker[sourceUID] = true
	else
		tracker[sourceUID] = nil
	end
	local isVisible = bool
	if bool then
		for sourceUID, _ in pairs(tracker) do
			isVisible = false
			break
		end
	end
	instance.Visible = isVisible
end

function Utility.formatStateName(incomingStateName)
	return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
end

function Utility.localPlayerRespawned(callback)
	-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
	-- In these scenarios, traditional methods like CharacterAdded won't be called by the
	-- time the localscript has been destroyed, therefore we listen for removing instead
	-- If humanoid and health == 0, then reset/died normally, else was
	-- forcefully reset via a method such as LoadCharacter
	-- We wrap this behaviour in case any additional quirks need to be accounted for
	localPlayer.CharacterRemoving:Connect(callback)
end

function Utility.getClippedContainer(screenGui)
	-- We always want clipped items to display in front hence
	-- why we have this
	local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
	if not clippedContainer then
		clippedContainer = Instance.new("Folder")
		clippedContainer.Name = "ClippedContainer"
		clippedContainer.Parent = screenGui
	end
	return clippedContainer
end

local Janitor = require(script.Parent.Packages.Janitor)
local GuiService = game:GetService("GuiService")
function Utility.clipOutside(icon, instance)
	local cloneJanitor = icon.janitor:add(Janitor.new())
	instance.Destroying:Once(function()
		cloneJanitor:Destroy()
	end)
	icon.janitor:add(instance)

	local originalParent = instance.Parent
	local clone = cloneJanitor:add(Instance.new("Frame"))
	clone:SetAttribute("IsAClippedClone", true)
	clone.Name = instance.Name
	clone.AnchorPoint = instance.AnchorPoint
	clone.Size = instance.Size
	clone.Position = instance.Position
	clone.BackgroundTransparency = 1
	clone.LayoutOrder = instance.LayoutOrder
	clone.Parent = originalParent

	local valueInstance = Instance.new("ObjectValue")
	valueInstance.Name = "OriginalInstance"
	valueInstance.Value = instance
	valueInstance.Parent = clone

	local valueInstanceCopy = valueInstance:Clone()
	instance:SetAttribute("HasAClippedClone", true)
	valueInstanceCopy.Name = "ClippedClone"
	valueInstanceCopy.Value = clone
	valueInstanceCopy.Parent = instance

	local screenGui
	local Icon = require(icon.iconModule)
	local container = Icon.container
	local function updateScreenGui()
		local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
		screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else container[originalScreenGui.Name.."Clipped"]
		instance.AnchorPoint = Vector2.new(0, 0)
		instance.Parent = Utility.getClippedContainer(screenGui)
	end
	cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
	updateScreenGui()

	-- Lets copy over children that modify size
	for _, child in pairs(instance:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			child:Clone().Parent = clone
		end
	end

	-- If the icon is hidden, its important we are too (as
	-- setting a parent to visible = false no longer makes
	-- this hidden)
	local widget = icon.widget
	local isOutsideParent = false
	local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
	local function updateVisibility()
		if ignoreVisibilityUpdater then
			return
		end
		local isVisible = widget.Visible
		if isOutsideParent then
			isVisible = false
		end
		Utility.setVisible(instance, isVisible, "ClipHandler")
	end
	cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))

	local previousScroller
	local function checkIfOutsideParentXBounds()
		-- Defer so that roblox's properties reflect their true values
		task.defer(function()
			-- If the instance is within a parent item (such as a dropdown or menu)
			-- then we hide it if it exceeds the bounds of that parent
			local parentInstance
			local ourUID = icon.UID
			local nextIconUID = ourUID
			local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
			if shouldClipToParent then
				for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
					local nextIcon = Icon.getIconByUID(nextIconUID)
					if not nextIcon then
						break
					end
					local nextParentInstance = nextIcon.joinedFrame
					nextIconUID = nextIcon.parentIconUID
					if not nextParentInstance then
						break
					end
					parentInstance = nextParentInstance
					if parentInstance and parentInstance.Name == "DropdownScroller" then
						break
					end
				end
			end
			if not parentInstance then
				isOutsideParent = false
				updateVisibility()
				return
			end
			local pos = instance.AbsolutePosition
			local halfSize = instance.AbsoluteSize/2
			local parentPos = parentInstance.AbsolutePosition
			local parentSize = parentInstance.AbsoluteSize
			local posHalf = (pos + halfSize)
			local exceededLeft = posHalf.X < parentPos.X
			local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
			local exceededTop = posHalf.Y < parentPos.Y
			local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
			local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
			if hasExceeded ~= isOutsideParent then
				isOutsideParent = hasExceeded
				updateVisibility()
			end
			if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
				previousScroller = parentInstance
				local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
					checkIfOutsideParentXBounds()
				end)
				cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
			end
		end)
	end

	local camera = workspace.CurrentCamera
	local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
	local function trackProperty(property)
		local absoluteProperty = "Absolute"..property
		local function updateProperty()
			local cloneValue = clone[absoluteProperty]
			local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
			if property == "Position" then

				-- This binds the instances within the bounds of the screen
				local SIDE_PADDING = 4
				local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
				local inputX = absoluteValue.X.Offset
				if inputX < SIDE_PADDING then
					inputX = SIDE_PADDING
				elseif inputX > limitX then
					inputX = limitX
				end
				absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)

				-- AbsolutePosition does not perfectly match with TopbarInsets enabled
				-- This corrects this
				local topbarInset = GuiService.TopbarInset
				local viewportWidth = workspace.CurrentCamera.ViewportSize.X
				local guiWidth = screenGui.AbsoluteSize.X
				local guiOffset = screenGui.AbsolutePosition.X
				--local widthDifference = guiOffset - topbarInset.Min.X
				local oldTopbarCenterOffset = 0--widthDifference/30
				local offsetX = if Icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset
				
				-- Also add additionalOffset
				offsetX -= additionalOffsetX
				absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)

				-- Finally check if within its direct parents bounds
				checkIfOutsideParentXBounds()

			end
			instance[property] = absoluteValue
		end
		
		-- This defer is essential as the listener may be in a different screenGui to the actor
		local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))
		cloneJanitor:add(clone:GetAttributeChangedSignal("ForceUpdate"):Connect(function()
			updatePropertyStaggered()
		end))

		-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
		-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
		-- within this type of screenGui DO NOT accurately update to match their new
		-- real world position; instead they jump around almost randomly for a few frames.
		-- I have spent way too many hours trying to solve this bug, I think the only way
		-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
		-- have time to redesign the entire system around that at the moment.
		-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
		local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))
		
		-- When the screenGui is resized (such as when chat is hidden/shown), we need
		-- to update the position of the clone. Ths especially fixes the following:
		-- https://devforum.roblox.com/t/bug/1017485/1732
		if property == "Position" then
			cloneJanitor:add(screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updatePropertyStaggered()
			end))
		end

	end
	task.delay(0.1, checkIfOutsideParentXBounds)
	checkIfOutsideParentXBounds()
	updateVisibility()
	trackProperty("Position")
	
	-- Track visiblity changes
	cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
		--print("Visiblity changed:", instance, clone, instance.Visible)
		--clone.Visible = instance.Visible
	end))

	-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
	local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
	if shouldTrackCloneSize then
		trackProperty("Size")
	else
		cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			local absolute = instance.AbsoluteSize
			clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end))
	end

	return clone
end

function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)

	-- This is resonsible for moving the icon under a feature like a dropdown
	local joinJanitor = originalIcon.joinJanitor
	joinJanitor:clean()
	if not scrollingFrameOrFrame then
		originalIcon:leave()
		return
	end
	originalIcon.parentIconUID = parentIcon.UID
	originalIcon.joinedFrame = scrollingFrameOrFrame
	local function updateAlignent()
		local parentAlignment = parentIcon.alignment
		if parentAlignment == "Center" then
			parentAlignment = "Left"
		end
		originalIcon:setAlignment(parentAlignment, true)
	end
	joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
	updateAlignent()
	originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
	originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
	if parentIcon.childModifications then
		-- We defer so that the default values (such as dropdown
		-- minimum width can be applied before any custom
		-- child modifications from the user)
		task.defer(function()
			originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
		end)
	end
	--
	local clickRegion = originalIcon:getInstance("ClickRegion")
	local function makeSelectable()
		clickRegion.Selectable = parentIcon.isSelected
	end
	joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
	task.defer(makeSelectable)
	joinJanitor:add(function()
		clickRegion.Selectable = true
	end)
	--

	-- We track icons in arrays and dictionaries using their UID instead of the icon
	-- itself to prevent heavy cyclical tables when printing the icons
	local originalIconUID = originalIcon.UID
	table.insert(iconsArray, originalIconUID)
	parentIcon:autoDeselect(false)
	parentIcon.childIconsDict[originalIconUID] = true
	if not parentIcon.isEnabled then
		parentIcon:setEnabled(true)
	end
	originalIcon.joinedParent:Fire(parentIcon)

	-- This is responsible for removing it from that feature and updating
	-- their parent icon so its informed of the icon leaving it
	joinJanitor:add(function()
		local joinedFrame = originalIcon.joinedFrame
		if not joinedFrame then
			return
		end
		for i, iconUID in pairs(iconsArray) do
			if iconUID == originalIconUID then
				table.remove(iconsArray, i)
				break
			end
		end
		local Icon = require(originalIcon.iconModule)
		local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
		if not parentIcon then
			return
		end
		originalIcon:setAlignment(originalIcon.originalAlignment)
		originalIcon.parentIconUID = false
		originalIcon.joinedFrame = false
		--originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
		originalIcon:removeModification("JoinModification")
		
		local parentHasNoChildren = true
		local parentChildIcons = parentIcon.childIconsDict
		parentChildIcons[originalIconUID] = nil
		for childIconUID, _ in pairs(parentChildIcons) do
			parentHasNoChildren = false
			break
		end
		if parentHasNoChildren and not parentIcon.isAnOverflow then
			parentIcon:setEnabled(false)
		end
		updateAlignent()

	end)

end



return Utility]]></ProtectedString>
									<string name="ScriptGuid">{B21FFAEF-2697-490B-AAEE-E06E33E38AA5}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Utility</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="PackageLink" referent="RBXE84043BD99A0465BA02328B2FB7526E9">
								<Properties>
									<bool name="AutoUpdate">false</bool>
									<string name="DefaultName"></string>
									<int name="ModifiedState">-1</int>
									<Content name="PackageIdSerialize"><url>rbxassetid://102254594775361</url></Content>
									<BinaryString name="SerializedDefaultAttributes"></BinaryString>
									<int64 name="VersionIdSerialize">15</int64>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">PackageLink</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX273D96158BCC4C0C82DA3C36969A9AB9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Elements</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX787B7E12BF5749D9B515F41351F06B18">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local CAPTION_COLOR = Color3.fromRGB(39, 41, 48)
local TEXT_SIZE = 15
return function(icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local clickRegion = icon:getInstance("ClickRegion")
	local caption = Instance.new("CanvasGroup")
	caption.Name = "Caption"
	caption.AnchorPoint = Vector2.new(0.5, 0)
	caption.BackgroundTransparency = 1
	caption.BorderSizePixel = 0
	caption.GroupTransparency = 1
	caption.Position = UDim2.fromOffset(0, 0)
	caption.Visible = true
	caption.ZIndex = 30
	caption.Parent = clickRegion

	local box = Instance.new("Frame")
	box.Name = "Box"
	box.AutomaticSize = Enum.AutomaticSize.XY
	box.BackgroundColor3 = CAPTION_COLOR
	box.Position = UDim2.fromOffset(4, 7)
	box.ZIndex = 12
	box.Parent = caption

	local header = Instance.new("TextLabel")
	header.Name = "Header"
	header.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	header.Text = "Caption"
	header.TextColor3 = Color3.fromRGB(255, 255, 255)
	header.TextSize = TEXT_SIZE
	header.TextTruncate = Enum.TextTruncate.None
	header.TextWrapped = false
	header.TextXAlignment = Enum.TextXAlignment.Left
	header.AutomaticSize = Enum.AutomaticSize.X
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Size = UDim2.fromOffset(0, 16)
	header.ZIndex = 18
	header.Parent = box

	local layout = Instance.new("UIListLayout")
	layout.Name = "Layout"
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = box

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "CaptionCorner"
	UICorner.Parent = box

	local padding = Instance.new("UIPadding")
	padding.Name = "Padding"
	padding.PaddingBottom = UDim.new(0, 12)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingTop = UDim.new(0, 12)
	padding.Parent = box

	local hotkeys = Instance.new("Frame")
	hotkeys.Name = "Hotkeys"
	hotkeys.AutomaticSize = Enum.AutomaticSize.Y
	hotkeys.BackgroundTransparency = 1
	hotkeys.LayoutOrder = 3
	hotkeys.Size = UDim2.fromScale(1, 0)
	hotkeys.Visible = false
	hotkeys.Parent = box

	local layout1 = Instance.new("UIListLayout")
	layout1.Name = "Layout1"
	layout1.Padding = UDim.new(0, 6)
	layout1.FillDirection = Enum.FillDirection.Vertical
	layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout1.HorizontalFlex = Enum.UIFlexAlignment.None
	layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
	layout1.VerticalFlex = Enum.UIFlexAlignment.None
	layout1.SortOrder = Enum.SortOrder.LayoutOrder
	layout1.Parent = hotkeys

	local keyTag1 = Instance.new("ImageLabel")
	keyTag1.Name = "Key1"
	keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
	keyTag1.ImageTransparency = 0.7
	keyTag1.ScaleType = Enum.ScaleType.Slice
	keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
	keyTag1.AutomaticSize = Enum.AutomaticSize.X
	keyTag1.BackgroundTransparency = 1
	keyTag1.LayoutOrder = 1
	keyTag1.Size = UDim2.fromOffset(0, 30)
	keyTag1.ZIndex = 15
	keyTag1.Parent = hotkeys

	local inset = Instance.new("UIPadding")
	inset.Name = "Inset"
	inset.PaddingLeft = UDim.new(0, 8)
	inset.PaddingRight = UDim.new(0, 8)
	inset.Parent = keyTag1

	local labelContent = Instance.new("TextLabel")
	labelContent.AutoLocalize = false
	labelContent.Name = "LabelContent"
	labelContent.FontFace = Font.new(
		"rbxasset://fonts/families/GothamSSm.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	labelContent.Text = ""
	labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
	labelContent.TextSize = TEXT_SIZE
	labelContent.AutomaticSize = Enum.AutomaticSize.X
	labelContent.BackgroundTransparency = 1
	labelContent.Position = UDim2.fromOffset(0, -1)
	labelContent.Size = UDim2.fromScale(1, 1)
	labelContent.ZIndex = 16
	labelContent.Parent = keyTag1
	
	local caret = Instance.new("ImageLabel")
	caret.Name = "Caret"
	caret.Image = "rbxassetid://101906294438076"
	caret.ImageColor3 = CAPTION_COLOR
	caret.AnchorPoint = Vector2.new(0, 0.5)
	caret.BackgroundTransparency = 1
	caret.Position = UDim2.new(0, 0, 0, 4)
	caret.Size = UDim2.fromOffset(16, 8)
	caret.ZIndex = 12
	caret.Parent = caption

	local dropShadow = Instance.new("ImageLabel")
	dropShadow.Visible = true
	dropShadow.Name = "DropShadow"
	dropShadow.Image = "rbxassetid://124920646932671"
	dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	dropShadow.ImageTransparency = 0.45
	dropShadow.ScaleType = Enum.ScaleType.Slice
	dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
	dropShadow.BackgroundTransparency = 1
	dropShadow.Position = UDim2.fromOffset(0, 5)
	dropShadow.Size = UDim2.new(1, 0, 0, 48)
	dropShadow.Parent = caption
	box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
	end)
	
	-- It's important we match the sizes as this is not
	-- handles within clipOutside (as it assumes the sizes
	-- are already the same)
	local captionJanitor = icon.captionJanitor
	local _, captionClone = icon:clipOutside(caption)
	captionClone.AutomaticSize = Enum.AutomaticSize.None
	local function matchSize()
		local absolute = caption.AbsoluteSize
		captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
	end
	captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
	matchSize()
	
	
	
	-- This handles the appearing/disappearing/positioning of the caption
	local isCompletelyEnabled = false
	local captionHeader = caption.Box.Header
	local UserInputService = game:GetService("UserInputService")
	local function updateHotkey(keyCodeEnum)
		local hasKeyboard = UserInputService.KeyboardEnabled
		local text = caption:GetAttribute("CaptionText") or ""
		local hideHeader = text == "_hotkey_"
		if not hasKeyboard and hideHeader then
			icon:setCaption()
			return
		end
		captionHeader.Text = text
		captionHeader.Visible = not hideHeader
		if keyCodeEnum then
			labelContent.Text = keyCodeEnum.Name
			hotkeys.Visible = true
		end
		if not hasKeyboard then
			hotkeys.Visible = false
		end
	end
	caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)

	local EASING_STYLE = Enum.EasingStyle.Quad
	local TWEEN_SPEED = 0.2
	local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
	local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local function getCaptionPosition(customEnabled)
		local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
		local yOut = 2
		local yIn = yOut + 8
		local yOffset = if enabled then yIn else yOut
		return UDim2.new(0.5, 0, 1, yOffset)
	end
	local function updatePosition(forcedEnabled)
		
		-- Ignore changes if not enabled to reduce redundant calls
		if not isCompletelyEnabled then
			return
		end
		
		-- Currently the one thing which isn't accounted for are the bounds of the screen
		-- This would be an issue if someone sets a long caption text for the left or
		-- right most icon
		local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
		local startPosition = getCaptionPosition(not enabled)
		local endPosition = getCaptionPosition(enabled)
		
		-- It's essential we reset the carets position to prevent the x sizing bounds
		-- of the caption from infinitely scaling up
		if enabled then
			local caretY = caret.Position.Y.Offset
			caret.Position = UDim2.fromOffset(0, caretY)
			caption.AutomaticSize = Enum.AutomaticSize.XY
			caption.Size = UDim2.fromOffset(32, 53)
		else
			local absolute = caption.AbsoluteSize
			caption.AutomaticSize = Enum.AutomaticSize.Y
			caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end
		
		-- We initially default to the opposite state
		local previousCaretX
		local function updateCaret()
			local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
			local caretY = caret.Position.Y.Offset
			local newCaretPosition = UDim2.fromOffset(caretX, caretY)
			if previousCaretX ~= caretX then
				-- Again, it's essential we reset the caret if
				-- a difference in X position is detected otherwise
				-- a slight quirk with AutomaticCanvas can cause
				-- the caption to infinitely scale
				previousCaretX = caretX
				caret.Position = UDim2.fromOffset(0, caretY)
				task.wait()
			end
			caret.Position = newCaretPosition
		end
		captionClone.Position = startPosition
		updateCaret()
		
		-- Now we tween into the new state
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
		local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
		tween:Play()
		tween.Completed:Once(function()
			updateCaretConnection:Disconnect()
		end)
		
	end
	captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updatePosition()
	end))
	updatePosition(false)
	
	captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
	for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
		updateHotkey(keyCodeEnum)
		break
	end
	captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
	local fakeToggleKey = icon.fakeToggleKey
	if fakeToggleKey then
		updateHotkey(fakeToggleKey)
	end

	local function setCaptionEnabled(enabled)
		if isCompletelyEnabled == enabled then
			return
		end
		local joinedFrame = icon.joinedFrame
		if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
			enabled = false
		end
		isCompletelyEnabled = enabled
		local newTransparency = (enabled and 0) or 1
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tweenTransparency = TweenService:Create(caption, tweenInfo, {
			GroupTransparency = newTransparency
		})
		tweenTransparency:Play()
		if enabled then
			captionClone:SetAttribute("ForceUpdate", true)
		end
		updatePosition()
		updateHotkey()
	end
	
	local WAIT_DURATION = 0.5
	local RECOVER_PERIOD = 0.3
	local Icon = require(icon.iconModule)
	captionJanitor:add(icon.stateChanged:Connect(function(stateName)
		if stateName == "Viewing" then
			local lastClock = Icon.captionLastClosedClock
			local clockDifference = (lastClock and os.clock() - lastClock) or 999
			local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
			task.delay(waitDuration, function()
				if icon.activeState == "Viewing" then
					setCaptionEnabled(true)
				end
			end)
		else
			Icon.captionLastClosedClock = os.clock()
			setCaptionEnabled(false)
		end
	end))
	
	return caption
end]]></ProtectedString>
										<string name="ScriptGuid">{3FB5366E-5008-4CF7-B6C1-5E9D5678A979}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Caption</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXC2985FEA15584BCDB4A3B396C64C9B0B">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local hasBecomeOldTheme = false
local previousInsetHeight = 0
return function(Icon)
	
	-- Has to be included for the time being due to this bug mentioned here:
	-- https://devforum.roblox.com/t/bug/2973508/7
	local GuiService = game:GetService("GuiService")
	local Players =  game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local container = {}
	local Signal = require(script.Parent.Parent.Packages.GoodSignal)
	local insetChanged = Signal.new()
	local guiInset = GuiService:GetGuiInset()
	local startInset = 0
	local yDownOffset = 0
	local ySizeOffset = 0
	local checkCount = 0
	local isConsoleScreen = false
	local isUsingVR = false
	local function checkInset(status)
		local currentHeight = GuiService.TopbarInset.Height
		local isOldTopbar = currentHeight <= 36
		

		-- These additional checks are needed to ensure *it is actually* the old topbar
		-- and not a client which takes a really long time to load
		-- There's unfortunately no APIs to do this a prettier way
		isConsoleScreen = GuiService:IsTenFootInterface()
		isUsingVR = UserInputService.VREnabled
		Icon.isOldTopbar = isOldTopbar
		checkCount += 1
		if currentHeight == 0 and status == nil then
			task.defer(function()
				task.wait(8)
				checkInset("ForceConvertToOld")
			end)
		elseif checkCount == 1 then
			task.delay(5, function()
				local localPlayer = Players.LocalPlayer
				localPlayer:WaitForChild("PlayerGui")
				if checkCount == 1 then
					checkInset()
				end
			end)
		end

		-- Conver to old theme if verified
		if Icon.isOldTopbar and not isConsoleScreen and not isUsingVR and hasBecomeOldTheme == false and (currentHeight ~= 0 or status == "ForceConvertToOld") then
			hasBecomeOldTheme = true
			task.defer(function()
				-- If oldtopbar, apply the Classic theme
				local themes = script.Parent.Parent.Features.Themes
				local Classic = require(themes.Classic)
				Icon.modifyBaseTheme(Classic)

				-- Also configure the oldtopbar correctly
				local function decideToHideTopbar()
					if GuiService.MenuIsOpen then
						Icon.setTopbarEnabled(false, true)
					else
						Icon.setTopbarEnabled()
					end
				end
				GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
				decideToHideTopbar()
			end)
		end

		-- Modify the offsets slightly depending on device type
		guiInset = GuiService:GetGuiInset()
		startInset = if isOldTopbar then 12 else guiInset.Y - 50
		yDownOffset = if isOldTopbar then 2 else 0 --if isOldTopbar then 2 else 0 
		ySizeOffset = -2
		if isConsoleScreen then
			startInset = 10
			yDownOffset = 0 ---9
		end
		if GuiService.TopbarInset.Height == 0 and not hasBecomeOldTheme then
			yDownOffset += 13
			ySizeOffset = 50
		end

		-- Now inform other areas of the change
		insetChanged:Fire(guiInset)
		local insetHeight = guiInset.Y
		if insetHeight ~= previousInsetHeight then
			previousInsetHeight = insetHeight
			task.defer(function()
				Icon.insetHeightChanged:Fire(insetHeight)
			end)
		end
		
	end
	GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(checkInset)
	checkInset("FirstTime")

	local screenGui = Instance.new("ScreenGui")
	insetChanged:Connect(function()
		screenGui:SetAttribute("StartInset", startInset)
	end)
	screenGui.Name = "TopbarStandard"
	screenGui.Enabled = true
	screenGui.DisplayOrder = Icon.baseDisplayOrder
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true
	screenGui.ResetOnSpawn = false
	screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
	container[screenGui.Name] = screenGui
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGui.DisplayOrder = Icon.baseDisplayOrder
	end)

	local holders = Instance.new("Frame")
	holders.Name = "Holders"
	holders.BackgroundTransparency = 1
	insetChanged:Connect(function()
		local holderY = if isUsingVR then 36 else 56
		local holderSize = if isConsoleScreen then UDim2.new(1, 0, 0, holderY) else UDim2.new(1, 0, 1, ySizeOffset)
		holders.Position = UDim2.new(0, 0, 0, yDownOffset)
		holders.Size = holderSize
	end)
	holders.Visible = true
	holders.ZIndex = 1
	holders.Parent = screenGui
	
	local screenGuiCenter = screenGui:Clone()
	local holdersCenter = screenGuiCenter.Holders
	local function updateCenteredHoldersHeight()
		holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
	end
	screenGuiCenter.Name = "TopbarCentered"
	screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	end)
	container[screenGuiCenter.Name] = screenGuiCenter
	
	insetChanged:Connect(updateCenteredHoldersHeight)
	updateCenteredHoldersHeight()
	
	local screenGuiClipped = screenGui:Clone()
	screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
	screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	end)
	container[screenGuiClipped.Name] = screenGuiClipped
	
	local screenGuiCenterClipped = screenGuiCenter:Clone()
	screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
	screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	end)
	container[screenGuiCenterClipped.Name] = screenGuiCenterClipped
	
	local holderReduction = -24
	local left = Instance.new("ScrollingFrame")
	left:SetAttribute("IsAHolder", true)
	left.Name = "Left"
	insetChanged:Connect(function()
		left.Position = UDim2.fromOffset(startInset, 0)
	end)
	left.Size = UDim2.new(1, holderReduction, 1, 0)
	left.BackgroundTransparency = 1
	left.Visible = true
	left.ZIndex = 1
	left.Active = false
	left.ClipsDescendants = true
	left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
	left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	left.AutomaticCanvasSize = Enum.AutomaticSize.X
	left.ScrollingDirection = Enum.ScrollingDirection.X
	left.ScrollBarThickness = 0
	left.BorderSizePixel = 0
	left.Selectable = false
	left.ScrollingEnabled = false--true
	left.ElasticBehavior = Enum.ElasticBehavior.Never
	left.Parent = holders
	
	local UIListLayout = Instance.new("UIListLayout")
	insetChanged:Connect(function()
		UIListLayout.Padding = UDim.new(0, startInset)
	end)
	UIListLayout.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	UIListLayout.Parent = left
	
	local center = left:Clone()
	insetChanged:Connect(function()
		center.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	center.ScrollingEnabled = false
	center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	center.Name = "Center"
	center.Parent = holdersCenter
	
	local right = left:Clone()
	insetChanged:Connect(function()
		right.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	right.Name = "Right"
	right.AnchorPoint = Vector2.new(1, 0)
	right.Position = UDim2.new(1, -12, 0, 0)
	right.Parent = holders

	-- This is important so that all elements update instantly
	insetChanged:Fire(guiInset)

	return container
end]]></ProtectedString>
										<string name="ScriptGuid">{30966F32-BE94-4366-8E93-0066D097CEAB}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Container</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX5077773292D644AB899E7E843F5D6606">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local widget = icon.widget
	local contents = icon:getInstance("Contents")
	local indicator = Instance.new("Frame")
	indicator.Name = "Indicator"
	indicator.LayoutOrder = 9999999
	indicator.ZIndex = 6
	indicator.Size = UDim2.new(0, 42, 0, 42)
	indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicator.BackgroundTransparency = 1
	indicator.Position = UDim2.new(1, 0, 0.5, 0)
	indicator.BorderSizePixel = 0
	indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicator.Parent = contents

	local indicatorButton = Instance.new("Frame")
	indicatorButton.Name = "IndicatorButton"
	indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
	indicatorButton.BorderSizePixel = 0
	indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.Parent = indicator
	
	local GuiService = game:GetService("GuiService")
	local GamepadService = game:GetService("GamepadService")
	local ourClickRegion = icon:getInstance("ClickRegion")
	local function selectionChanged()
		local selectedClickRegion = GuiService.SelectedObject
		if selectedClickRegion == ourClickRegion then
			indicatorButton.BackgroundTransparency = 1
			indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
		else
			indicatorButton.BackgroundTransparency = 0.75
			indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1, 1)
		end
	end
	icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
	selectionChanged()

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.LayoutOrder = 2
	imageLabel.ZIndex = 15
	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.Image = "rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png"
	imageLabel.Parent = indicatorButton

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = indicatorButton

	local UserInputService = game:GetService("UserInputService")
	local function setIndicatorVisible(visibility)
		if visibility == nil then
			visibility = indicator.Visible
		end
		if GamepadService.GamepadCursorEnabled then
			visibility = false
		end
		if visibility then
			icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
		elseif indicator.Visible then
			icon:removeModification("IndicatorPadding")
		end
		icon:modifyTheme({"Indicator", "Visible", visibility})
		icon.updateSize:Fire()
	end
	icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
	icon.indicatorSet:Connect(function(keyCode)
		local visibility = false
		if keyCode then
			imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
			visibility = true
		end
		setIndicatorVisible(visibility)
	end)

	local function updateSize()
		local ySize = widget.AbsoluteSize.Y*0.96
		indicator.Size = UDim2.new(0, ySize, 0, ySize)
	end
	widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
	updateSize()

	return indicator
end]]></ProtectedString>
										<string name="ScriptGuid">{D116B6CA-9B39-4434-886B-054A43B84FEA}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Indicator</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX505B7CB52BED410EA279E27C211CD93C">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[return function(icon)

	local menu = Instance.new("ScrollingFrame")
	menu.Name = "Menu"
	menu.BackgroundTransparency = 1
	menu.Visible = true
	menu.ZIndex = 1
	menu.Size = UDim2.fromScale(1, 1)
	menu.ClipsDescendants = true
	menu.TopImage = ""
	menu.BottomImage = ""
	menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
	menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	menu.ScrollingEnabled = true
	menu.ScrollingDirection = Enum.ScrollingDirection.X
	menu.ZIndex = 20
	menu.ScrollBarThickness = 3
	menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	menu.ScrollBarImageTransparency = 0.8
	menu.BorderSizePixel = 0
	menu.Selectable = false
	
	local Icon = require(icon.iconModule)
	local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
	menuUIListLayout.Name = "MenuUIListLayout"
	menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	menuUIListLayout.Parent = menu

	local menuGap = Instance.new("Frame")
	menuGap.Name = "MenuGap"
	menuGap.BackgroundTransparency = 1
	menuGap.Visible = false
	menuGap.AnchorPoint = Vector2.new(0, 0.5)
	menuGap.ZIndex = 5
	menuGap.Parent = menu
	
	local hasStartedMenu = false
	local Themes = require(script.Parent.Parent.Features.Themes)
	local function totalChildrenChanged()
		
		local menuJanitor = icon.menuJanitor
		local totalIcons = #icon.menuIcons
		if hasStartedMenu then
			if totalIcons <= 0 then
				menuJanitor:clean()
				hasStartedMenu = false
			end
			return
		end
		hasStartedMenu = true
		
		-- Listen for changes
		menuJanitor:add(icon.toggled:Connect(function()
			if #icon.menuIcons > 0 then
				icon.updateSize:Fire()
			end
		end))
		
		-- Modify appearance of menu icon when joined
		local _, modificationUID = icon:modifyTheme({
			{"Menu", "Active", true},
		})
		task.defer(function()
			menuJanitor:add(function()
				icon:removeModification(modificationUID)
			end)
		end)
		
		-- For right-aligned icons, this ensures their menus
		-- close button appear instantly when selected (instead
		-- of partially hidden from view)
		local previousCanvasX = menu.AbsoluteCanvasSize.X
		local function rightAlignCanvas()
			if icon.alignment == "Right" then
				local newCanvasX = menu.AbsoluteCanvasSize.X
				local difference = previousCanvasX - newCanvasX
				previousCanvasX = newCanvasX
				menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
			end
		end
		menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
		menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))
		
		-- Apply a close selected image if the user hasn't applied thier own
		local stateGroup = icon:getStateGroup()
		local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
		local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
		if imageDeselected == imageSelected then
			local fontLink = "rbxasset://fonts/families/FredokaOne.json"
			local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
			icon:removeModificationWith("IconLabel", "Text", "Viewing")
			icon:removeModificationWith("IconLabel", "Image", "Viewing")
			icon:modifyTheme({
				{"IconLabel", "FontFace", fontFace, "Selected"},
				{"IconLabel", "Text", "X", "Selected"},
				{"IconLabel", "TextSize", 20, "Selected"},
				{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
				{"IconImage", "Image", "", "Selected"},
			})
		end

		-- Change order of spot when alignment changes
		local menuGap = icon:getInstance("MenuGap")
		local function updateAlignent()
			local alignment = icon.alignment
			local spotIndex = -99999
			local gapIndex = -99998
			if alignment == "Right" then
				spotIndex = 99999
				gapIndex = 99998
			end
			icon:modifyTheme({"IconSpot", "LayoutOrder", spotIndex})
			menuGap.LayoutOrder = gapIndex
		end
		menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
		updateAlignent()
		
		-- This updates the scrolling frame to only display a scroll
		-- length equal to the distance produced by its MaxIcons
		menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
			local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
			local canvasY = menu.CanvasSize.Y
			menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
		end)
		menuJanitor:add(icon.updateMenu:Connect(function()
			local maxIcons = menu:GetAttribute("MaxIcons")
			if not maxIcons then
				return
			end
			local orderedInstances = {}
			for _, child in pairs(menu:GetChildren()) do
				local widgetUID = child:GetAttribute("WidgetUID")
				if widgetUID and child.Visible then
					table.insert(orderedInstances, {child, child.AbsolutePosition.X})
				end
			end
			table.sort(orderedInstances, function(groupA, groupB)
				return groupA[2] < groupB[2]
			end)
			local totalWidth = 0
			for i = 1, maxIcons do
				local group = orderedInstances[i]
				if not group then
					break
				end
				local child = group[1]
				local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
				totalWidth += width
			end
			menu:SetAttribute("MenuWidth", totalWidth)
		end))
		local function startMenuUpdate()
			task.delay(0.1, function()
				icon.startMenuUpdate:Fire()
			end)
		end
		menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
		menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
		startMenuUpdate()
	end
	
	icon.menuChildAdded:Connect(totalChildrenChanged)
	icon.menuSet:Connect(function(arrayOfIcons)
		-- Reset any previous icons
		for i, otherIconUID in pairs(icon.menuIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Apply new icons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinMenu(icon)
			end
		end
	end)
	
	return menu
end]]></ProtectedString>
										<string name="ScriptGuid">{1EF97056-C0AC-47DD-B128-9A1AD93B3D54}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Menu</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX4DBCE564AE2D4260BB45BDF3823643A8">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local notice = Instance.new("Frame")
	notice.Name = "Notice"
	notice.ZIndex = 25
	notice.AutomaticSize = Enum.AutomaticSize.X
	notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
	notice.BorderSizePixel = 0
	notice.BackgroundTransparency = 0.1
	notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	notice.Visible = false
	notice.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = notice

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Parent = notice

	local noticeLabel = Instance.new("TextLabel")
	noticeLabel.Name = "NoticeLabel"
	noticeLabel.ZIndex = 26
	noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	noticeLabel.AutomaticSize = Enum.AutomaticSize.X
	noticeLabel.Size = UDim2.new(1, 0, 1, 0)
	noticeLabel.BackgroundTransparency = 1
	noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
	noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.FontSize = Enum.FontSize.Size14
	noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.Text = "1"
	noticeLabel.TextWrapped = true
	noticeLabel.TextWrap = true
	noticeLabel.Font = Enum.Font.Arial
	noticeLabel.Parent = notice
	
	local iconModule = script.Parent.Parent
	local packages = iconModule.Packages
	local Janitor = require(packages.Janitor)
	local Signal = require(packages.GoodSignal)
	local Utility = require(iconModule.Utility)
	icon.noticeChanged:Connect(function(totalNotices)

		-- Notice amount
		if not totalNotices then
			return
		end
		local exceeded99 = totalNotices > 99
		local noticeDisplay = (exceeded99 and "99+") or totalNotices
		noticeLabel.Text = noticeDisplay
		if exceeded99 then
			noticeLabel.TextSize = 11
		end

		-- Should enable
		local enabled = true
		if totalNotices < 1 then
			enabled = false
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
		if icon.isSelected and dropdownOrMenuActive then
			enabled = false
		elseif parentIcon and not parentIcon.isSelected then
			enabled = false
		end
		Utility.setVisible(notice, enabled, "NoticeHandler")

	end)
	icon.noticeStarted:Connect(function(customClearSignal, noticeId)
	
		if not customClearSignal then
			customClearSignal = icon.deselected
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		if parentIcon then
			parentIcon:notify(customClearSignal)
		end
		
		local noticeJanitor = icon.janitor:add(Janitor.new())
		local noticeComplete = noticeJanitor:add(Signal.new())
		noticeJanitor:add(icon.endNotices:Connect(function()
			noticeComplete:Fire()
		end))
		noticeJanitor:add(customClearSignal:Connect(function()
			noticeComplete:Fire()
		end))
		noticeId = noticeId or Utility.generateUID()
		icon.notices[noticeId] = {
			completeSignal = noticeComplete,
			clearNoticeEvent = customClearSignal,
		}
		local function updateNotice()
			icon.noticeChanged:Fire(icon.totalNotices)
		end
		icon.notified:Fire(noticeId)
		icon.totalNotices += 1
		updateNotice()
		noticeComplete:Once(function()
			noticeJanitor:destroy()
			icon.totalNotices -= 1
			icon.notices[noticeId] = nil
			updateNotice()
		end)
	end)
	
	-- Establish the notice
	notice:SetAttribute("ClipToJoinedParent", true)
	icon:clipOutside(notice)
	
	return notice
end]]></ProtectedString>
										<string name="ScriptGuid">{A148C372-4966-4C73-9532-458CD8E8661F}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Notice</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0D5E469F173C402F8B8B6CABC7D7953F">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[return function(Icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local selectionContainer = Instance.new("Frame")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Visible = false
	
	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	selection.BackgroundTransparency = 1
	selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
	selection.BorderSizePixel = 0
	selection.Parent = selectionContainer

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Name = "UIStroke"
	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	UIStroke.Color = Color3.fromRGB(255, 255, 255)
	UIStroke.Thickness = 3
	UIStroke.Parent = selection

	local selectionGradient = Instance.new("UIGradient")
	selectionGradient.Name = "SelectionGradient"
	selectionGradient.Parent = UIStroke

	local UICorner = Instance.new("UICorner")
	UICorner:SetAttribute("Collective", "IconCorners")
	UICorner.Name = "UICorner"
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = selection
	
	local RunService = game:GetService("RunService")
	local GuiService = game:GetService("GuiService")
	local rotationSpeed = 1
	selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
		rotationSpeed = selection:GetAttribute("RotationSpeed")
	end)
	RunService.Heartbeat:Connect(function()
		if not GuiService.SelectedObject then
			return
		end
		selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
	end)

	return selectionContainer
	
end]]></ProtectedString>
										<string name="ScriptGuid">{472FEA02-747F-4C47-8A57-8386B217F885}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Selection</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1F9255289ACC4681B03860EB6A54F236">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
-- the icon (aka Widget) instance.
-- This contains the core components of the icon such as the button, image, label and notice. It's
-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)

return function(icon, Icon)

	local widget = Instance.new("Frame")
	widget:SetAttribute("WidgetUID", icon.UID)
	widget.Name = "Widget"
	widget.BackgroundTransparency = 1
	widget.Visible = true
	widget.ZIndex = 20
	widget.Active = false
	widget.ClipsDescendants = true

	local button = Instance.new("Frame")
	button.Name = "IconButton"
	button.Visible = true
	button.ZIndex = 2
	button.BorderSizePixel = 0
	button.Parent = widget
	button.ClipsDescendants = true
	button.Active = false -- This is essential for mobile scrollers to work when dragging
	icon.deselected:Connect(function()
		button.ClipsDescendants = true
		task.delay(0.2, function()
			if icon.isSelected then
				button.ClipsDescendants = false
			end
		end)
	end)

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("IconButton", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(button, "BackgroundTransparency")
	end))

	local iconCorner = Instance.new("UICorner")
	iconCorner:SetAttribute("Collective", "IconCorners")
	iconCorner.Name = "UICorner"
	iconCorner.Parent = button

	local menu = require(script.Parent.Menu)(icon)
	local menuUIListLayout = menu.MenuUIListLayout
	local menuGap = menu.MenuGap
	menu.Parent = button

	local iconSpot = Instance.new("Frame")
	iconSpot.Name = "IconSpot"
	iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
	iconSpot.BackgroundTransparency = 0.9
	iconSpot.Visible = true
	iconSpot.AnchorPoint = Vector2.new(0, 0.5)
	iconSpot.ZIndex = 5
	iconSpot.Parent = menu

	local iconSpotCorner = iconCorner:Clone()
	iconSpotCorner.Parent = iconSpot

	local overlay = iconSpot:Clone()
	overlay.UICorner.Name = "OverlayUICorner"
	overlay.Name = "IconOverlay"
	overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	overlay.ZIndex = iconSpot.ZIndex + 1
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.AnchorPoint = Vector2.new(0, 0)
	overlay.Visible = false
	overlay.Parent = iconSpot

	local clickRegion = Instance.new("TextButton")
	clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
	clickRegion.Name = "ClickRegion"
	clickRegion.BackgroundTransparency = 1
	clickRegion.Visible = true
	clickRegion.Text = ""
	clickRegion.ZIndex = 20
	clickRegion.Selectable = true
	clickRegion.SelectionGroup = true
	clickRegion.Parent = iconSpot
	
	local Gamepad = require(script.Parent.Parent.Features.Gamepad)
	Gamepad.registerButton(clickRegion)

	local clickRegionCorner = iconCorner:Clone()
	clickRegionCorner.Parent = clickRegion

	local contents = Instance.new("Frame")
	contents.Name = "Contents"
	contents.BackgroundTransparency = 1
	contents.Size = UDim2.fromScale(1, 1)
	contents.Parent = iconSpot

	local contentsList = Instance.new("UIListLayout")
	contentsList.Name = "ContentsList"
	contentsList.FillDirection = Enum.FillDirection.Horizontal
	contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
	contentsList.SortOrder = Enum.SortOrder.LayoutOrder
	contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
	contentsList.Padding = UDim.new(0, 3)
	contentsList.Parent = contents

	local paddingLeft = Instance.new("Frame")
	paddingLeft.Name = "PaddingLeft"
	paddingLeft.LayoutOrder = 1
	paddingLeft.ZIndex = 5
	paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingLeft.BackgroundTransparency = 1
	paddingLeft.BorderSizePixel = 0
	paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingLeft.Parent = contents

	local paddingCenter = Instance.new("Frame")
	paddingCenter.Name = "PaddingCenter"
	paddingCenter.LayoutOrder = 3
	paddingCenter.ZIndex = 5
	paddingCenter.Size = UDim2.new(0, 0, 1, 0)
	paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingCenter.BackgroundTransparency = 1
	paddingCenter.BorderSizePixel = 0
	paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingCenter.Parent = contents

	local paddingRight = Instance.new("Frame")
	paddingRight.Name = "PaddingRight"
	paddingRight.LayoutOrder = 5
	paddingRight.ZIndex = 5
	paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingRight.BackgroundTransparency = 1
	paddingRight.BorderSizePixel = 0
	paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingRight.Parent = contents

	local iconLabelContainer = Instance.new("Frame")
	iconLabelContainer.Name = "IconLabelContainer"
	iconLabelContainer.LayoutOrder = 4
	iconLabelContainer.ZIndex = 3
	iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
	iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
	iconLabelContainer.BackgroundTransparency = 1
	iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	iconLabelContainer.Parent = contents

	local iconLabel = Instance.new("TextLabel")
	local viewportX = workspace.CurrentCamera.ViewportSize.X+200
	iconLabel.Name = "IconLabel"
	iconLabel.LayoutOrder = 4
	iconLabel.ZIndex = 15
	iconLabel.AnchorPoint = Vector2.new(0, 0)
	iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
	iconLabel.ClipsDescendants = false
	iconLabel.BackgroundTransparency = 1
	iconLabel.Position = UDim2.fromScale(0, 0)
	iconLabel.RichText = true
	iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
	iconLabel.Text = ""
	iconLabel.TextWrapped = true
	iconLabel.TextWrap = true
	iconLabel.TextScaled = false
	iconLabel.Active = false
	iconLabel.AutoLocalize = true
	iconLabel.Parent = iconLabelContainer

	local iconImage = Instance.new("ImageLabel")
	iconImage.Name = "IconImage"
	iconImage.LayoutOrder = 2
	iconImage.ZIndex = 15
	iconImage.AnchorPoint = Vector2.new(0, 0.5)
	iconImage.Size = UDim2.new(0, 0, 0.5, 0)
	iconImage.BackgroundTransparency = 1
	iconImage.Position = UDim2.new(0, 11, 0.5, 0)
	iconImage.ScaleType = Enum.ScaleType.Stretch
	iconImage.Active = false
	iconImage.Parent = contents

	local iconImageCorner = iconCorner:Clone()
	iconImageCorner:SetAttribute("Collective", nil)
	iconImageCorner.CornerRadius = UDim.new(0, 0)
	iconImageCorner.Name = "IconImageCorner"
	iconImageCorner.Parent = iconImage

	local TweenService = game:GetService("TweenService")
	local resizingCount = 0
	local function handleLabelAndImageChangesUnstaggered(forceUpdateString)

		-- We defer changes by a frame to eliminate all but 1 requests which
		-- could otherwise stack up to 20+ requests in a single frame
		-- We then repeat again once to account for any final changes
		-- Deferring is also essential because properties are set immediately
		-- afterwards (therefore calculations will use the correct values)
		task.defer(function()
			local indicator = icon.indicator
			local usingIndicator = indicator and indicator.Visible
			local usingText = usingIndicator or iconLabel.Text ~= ""
			local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
			local _alignment = Enum.HorizontalAlignment.Center
			local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
			local buttonSize = NORMAL_BUTTON_SIZE
			if usingImage and not usingText then
				iconLabelContainer.Visible = false
				iconImage.Visible = true
				paddingLeft.Visible = false
				paddingCenter.Visible = false
				paddingRight.Visible = false
			elseif not usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = false
				paddingLeft.Visible = true
				paddingCenter.Visible = false
				paddingRight.Visible = true
			elseif usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = true
				paddingLeft.Visible = true
				paddingCenter.Visible = not usingIndicator
				paddingRight.Visible = not usingIndicator
				_alignment = Enum.HorizontalAlignment.Left
			end
			button.Size = buttonSize

			local function getItemWidth(item)
				local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
				return targetWidth
			end
			local contentsPadding = contentsList.Padding.Offset
			local initialWidgetWidth = contentsPadding --0
			local textWidth = iconLabel.TextBounds.X
			iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
			for _, child in pairs(contents:GetChildren()) do
				if child:IsA("GuiObject") and child.Visible == true then
					local itemWidth = getItemWidth(child)
					initialWidgetWidth += itemWidth + contentsPadding
				end
			end
			local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
			local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
			local widgetBorderSize = widget:GetAttribute("BorderSize")
			local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
			local menuIcons = icon.menuIcons
			local additionalWidth = 0
			local hasMenu = #menuIcons > 0
			local showMenu = hasMenu and icon.isSelected
			if showMenu then
				for _, frame in pairs(menu:GetChildren()) do
					if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
						additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
					end
				end
				if not iconSpot.Visible then
					widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
				end
				additionalWidth -= (widgetBorderSize*0.5)
				widgetWidth += additionalWidth - (widgetBorderSize*0.75)
			end
			menuGap.Visible = showMenu and iconSpot.Visible
			local desiredWidth = widget:GetAttribute("DesiredWidth")
			if desiredWidth and widgetWidth < desiredWidth then
				widgetWidth = desiredWidth
			end

			icon.updateMenu:Fire()
			local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
			local spotWidth = preWidth-(widgetBorderSize*2)
			local menuWidth = menu:GetAttribute("MenuWidth")
			local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
			if totalMenuWidth then
				local maxWidth = menu:GetAttribute("MaxWidth")
				if maxWidth then
					totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
				end
				menu:SetAttribute("MenuCanvasWidth", widgetWidth)
				if totalMenuWidth < widgetWidth then
					widgetWidth = totalMenuWidth
				end
			end

			local style = Enum.EasingStyle.Quint
			local direction = Enum.EasingDirection.Out
			local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
			local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
			local SPEED = 750
			local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
			local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
			TweenService:Create(iconSpot, spotTweenInfo, {
				Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
				Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
			}):Play()
			TweenService:Create(clickRegion, spotTweenInfo, {
				Size = UDim2.new(0, spotWidth, 1, 0),
			}):Play()
			local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
			local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
			if updateInstantly then
				widget.Size = newWidgetSize
			end
			widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
			local movingTween = TweenService:Create(widget, widgetTweenInfo, {
				Size = newWidgetSize,
			})
			movingTween:Play()
			resizingCount += 1
			for i = 1, widgetTweenInfo.Time * 100 do
				task.delay(i/100, function()
					Icon.iconChanged:Fire(icon)
				end)
			end
			task.delay(widgetTweenInfo.Time-0.2, function()
				resizingCount -= 1
				task.defer(function()
					if resizingCount == 0 then
						icon.resizingComplete:Fire()
					end
				end)
			end)
			icon:updateParent()
		end)
	end
	local Utility = require(script.Parent.Parent.Utility)
	local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
	local firstTimeSettingFontFace = true
	icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
	icon:setBehaviour("IconLabel", "FontFace", function(value)
		local previousFontFace = iconLabel.FontFace
		if previousFontFace == value then
			return
		end
		task.spawn(function()
			--[[
			local fontLink = value.Family
			if string.match(fontLink, "rbxassetid://") then
				local ContentProvider = game:GetService("ContentProvider")
				local assets = {fontLink}
				ContentProvider:PreloadAsync(assets)
			end--]]

			-- Afaik there's no way to determine when a Font Family has
			-- loaded (even with ContentProvider), so we just have to try
			-- a few times and hope it loads within the refresh period
			handleLabelAndImageChanges()
			if firstTimeSettingFontFace then
				firstTimeSettingFontFace = false
				for i = 1, 10 do
					task.wait(1)
					handleLabelAndImageChanges()
				end
			end
		end)
	end)
	local function updateBorderSize()
		task.defer(function()
			local borderOffset = widget:GetAttribute("BorderSize")
			local alignment = icon.alignment
			local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
			menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
			menuGap.Size = UDim2.fromOffset(borderOffset, 0)
			menuUIListLayout.Padding = UDim.new(0, 0)
			handleLabelAndImageChanges()
		end)
	end
	icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
	icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
	icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
	icon.updateSize:Connect(handleLabelAndImageChanges)
	icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
	icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
	icon:setBehaviour("IconImage", "Image", function(value)
		local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
		if iconImage.Image ~= textureId then
			handleLabelAndImageChanges()
		end
		return textureId
	end)
	icon.alignmentChanged:Connect(function(newAlignment)
		if newAlignment == "Center" then
			newAlignment = "Left"
		end
		menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
		updateBorderSize()
	end)

	-- Localization support (refresh icon size whenever player changes language changes in-game)
	local Players = game:GetService("Players")
	local localPlayer = Players.LocalPlayer
	local lastLocaleId = localPlayer.LocaleId
	icon.janitor:add(localPlayer:GetPropertyChangedSignal("LocaleId"):Connect(function()
		task.delay(0.2, function()
			local newLocaleId = localPlayer.LocaleId
			if newLocaleId ~= lastLocaleId then
				lastLocaleId = newLocaleId
				icon:refresh()
				task.wait(0.5)
				icon:refresh()
			end
		end)
	end))
	
	local iconImageScale = Instance.new("NumberValue")
	iconImageScale.Name = "IconImageScale"
	iconImageScale.Parent = iconImage
	iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
		iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
	end)

	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
	UIAspectRatioConstraint.Name = "IconImageRatio"
	UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
	UIAspectRatioConstraint.Parent = iconImage

	local iconGradient = Instance.new("UIGradient")
	iconGradient.Name = "IconGradient"
	iconGradient.Enabled = true
	iconGradient.Parent = button

	local iconSpotGradient = Instance.new("UIGradient")
	iconSpotGradient.Name = "IconSpotGradient"
	iconSpotGradient.Enabled = true
	iconSpotGradient.Parent = iconSpot

	return widget
end]]></ProtectedString>
										<string name="ScriptGuid">{07860B1F-E48F-4EE4-91A9-254E50E329DB}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Widget</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2CCCD13D47DE4A9D8D9D94AD00B586E9">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Themes = require(script.Parent.Parent.Features.Themes)
local PADDING = 0 -- used to be 8
return function(icon)
	
	local dropdown = Instance.new("Frame") -- Instance.new("CanvasGroup")
	dropdown.Name = "Dropdown"
	dropdown.AutomaticSize = Enum.AutomaticSize.X
	dropdown.BackgroundTransparency = 1
	dropdown.BorderSizePixel = 0
	dropdown.AnchorPoint = Vector2.new(0.5, 0)
	dropdown.Position = UDim2.new(0.5, 0, 1, 10)
	dropdown.ZIndex = -2
	dropdown.ClipsDescendants = true
	dropdown.Parent = icon.widget

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("Dropdown", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(dropdown, "BackgroundTransparency")
	end))

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "DropdownCorner"
	UICorner.CornerRadius = UDim.new(0, 10)
	UICorner.Parent = dropdown

	local dropdownScroller = Instance.new("ScrollingFrame")
	dropdownScroller.Name = "DropdownScroller"
	dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
	dropdownScroller.BackgroundTransparency = 1
	dropdownScroller.BorderSizePixel = 0
	dropdownScroller.AnchorPoint = Vector2.new(0, 0)
	dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
	dropdownScroller.ZIndex = -1
	dropdownScroller.ClipsDescendants = true
	dropdownScroller.Visible = true
	dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.None --ScrollBar
	dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
	dropdownScroller.Active = false
	dropdownScroller.ScrollingEnabled = true
	dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
	dropdownScroller.ScrollBarThickness = 5
	dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	dropdownScroller.ScrollBarImageTransparency = 0.8
	dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	dropdownScroller.Selectable = false
	dropdownScroller.Active = true
	dropdownScroller.Parent = dropdown

	local TweenDuration = Instance.new("NumberValue") -- this helps to change the speed to open / close in modifyTheme()
	TweenDuration.Name = "DropdownSpeed"
	TweenDuration.Value = 0.07
	TweenDuration.Parent = dropdown

	local dropdownPadding = Instance.new("UIPadding")
	dropdownPadding.Name = "DropdownPadding"
	dropdownPadding.PaddingTop = UDim.new(0, PADDING)
	dropdownPadding.PaddingBottom = UDim.new(0, PADDING)
	dropdownPadding.Parent = dropdownScroller

	local dropdownList = Instance.new("UIListLayout")
	dropdownList.Name = "DropdownList"
	dropdownList.FillDirection = Enum.FillDirection.Vertical
	dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
	dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
	dropdownList.Parent = dropdownScroller

	local dropdownJanitor = icon.dropdownJanitor
	local Icon = require(icon.iconModule)
	icon.dropdownChildAdded:Connect(function(childIcon)
		local _, modificationUID = childIcon:modifyTheme({
			{"Widget", "BorderSize", 0},
			{"IconCorners", "CornerRadius", UDim.new(0, 10)},
			{"Widget", "MinimumWidth", 190},
			{"Widget", "MinimumHeight", 58},
			{"IconLabel", "TextSize", 20},
			{"IconOverlay", "Size", UDim2.new(1, 0, 1, 0)},
			{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
			{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
			{"Selection", "Size", UDim2.new(1, -PADDING, 1, -PADDING)},
			{"Selection", "Position", UDim2.new(0, PADDING/2, 0, PADDING/2)},
		})
		task.defer(function()
			childIcon.joinJanitor:add(function()
				childIcon:removeModification(modificationUID)
			end)
		end)
	end)
	icon.dropdownSet:Connect(function(arrayOfIcons)
		for i, otherIconUID in pairs(icon.dropdownIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinDropdown(icon)
			end
		end
	end)

	local function updateMaxIcons()
		--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return 0 end
		local children = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(children, child)
			end
		end

		table.sort(children, function(a, b) return a.AbsolutePosition.Y < b.AbsolutePosition.Y end)
		local totalHeight = 0
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local child = children[i]
			if not child then break end
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height *= (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset
		return totalHeight
	end
	
	local openTween = nil
	local closeTween = nil
	local currentSpeedMultiplier = nil
	local currentTweenInfo = nil
	local function getTweenInfo()
		local speedMultiplier = Themes.getInstanceValue(dropdown, "MaxIcons") or 1
		if currentSpeedMultiplier and currentSpeedMultiplier == speedMultiplier and currentTweenInfo then
			return currentTweenInfo
		end
		local newTweenInfo = TweenInfo.new(
			TweenDuration.Value * speedMultiplier,
			Enum.EasingStyle.Exponential,
			Enum.EasingDirection.Out
		)
		currentTweenInfo = newTweenInfo
		currentSpeedMultiplier = speedMultiplier
		return newTweenInfo
	end
	local function updateVisibility()
		-- Update visibiliy of dropdown using tween transition
		local tweenInfo = getTweenInfo()
		
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end

		if icon.isSelected then
			local height = updateMaxIcons()
			dropdown.Visible = true
			dropdown.BackgroundTransparency = 0 -- no transparency so it looks solid
			dropdown.Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0) -- reset height to 0 before tween

			openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
			openTween:Play()
			openTween.Completed:Connect(function()
				openTween = nil
			end)
		else
			local closeTweenInfo = TweenInfo.new(0)
			closeTween = TweenService:Create(dropdown, closeTweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0)})
			closeTween:Play()
			closeTween.Completed:Connect(function()
				closeTween = nil
			end)
		end
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
	updateVisibility()
	--task.delay(0.2, updateVisibility)

	local function updateChildSize()
		local tweenInfo = getTweenInfo()
		if not icon.isSelected then return end
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end
		
		RunService.Heartbeat:Wait()
		
		local height = updateMaxIcons()

		openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
		openTween:Play()
		openTween.Completed:Connect(function()	
			openTween = nil
		end)
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))

	-- Ensures canvas and size stay synced (original updateMaxIcons logic)
	local updateCount = 0
	local isUpdating = false

	-- This updates the scrolling frame to only display a scroll
	-- length equal to the distance produced by its MaxIcons
	local function updateMaxIconsListener()
		updateCount += 1
		if isUpdating then return end
		local myUpdateCount = updateCount
		isUpdating = true
		task.defer(function()
			isUpdating = false
			if updateCount ~= myUpdateCount then
				updateMaxIconsListener()
			end
		end)
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return end

		local orderedInstances = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
			end
		end
		table.sort(orderedInstances, function(a, b) return a[2] < b[2] end)

		local totalHeight = 0
		local hasSetNextSelection = false
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local group = orderedInstances[i]
			if not group then break end
			local child = group[1]
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height = height * (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
			if isReduced then
				continue
			end
			local iconUID = child:GetAttribute("WidgetUID")
			local childIcon = iconUID and Icon.getIconByUID(iconUID)
			if childIcon then
				local nextSelection = nil
				if not hasSetNextSelection then
					hasSetNextSelection = true
					nextSelection = icon:getInstance("ClickRegion")
				end
				childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
			end
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset

		dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)

	end

	dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateChildSize)) -- rezise the dropdown when icon delects or adds
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateChildSize))
	dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIconsListener))
	updateMaxIconsListener()

	-- Ensures each child listens to visibility changes
	local function connectVisibilityListeners(child)
		if child:IsA("GuiObject") then
			child:GetPropertyChangedSignal("Visible"):Connect(updateChildSize)
			child:GetPropertyChangedSignal("Size"):Connect(updateChildSize) -- -- update max icons when child size changes
		end
	end
	
	-- For existing children
	for _, child in pairs(dropdownScroller:GetChildren()) do
		connectVisibilityListeners(child)
	end
	-- For new children
	dropdownScroller.ChildAdded:Connect(function(child)
		RunService.Heartbeat:Wait()
		connectVisibilityListeners(child)
		updateChildSize()
	end)

	-- On start, hide dropdown (prevent it showing as opened)
	dropdown.Visible = false

	return dropdown
end]]></ProtectedString>
										<string name="ScriptGuid">{4A646599-B1C3-42F1-BEED-5FC90567620B}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Dropdown</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX7892822834824F278A33634A2C3AC626">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Features</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX31EE52DB94C34A74A9C8887F53E54FA4">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- As the name suggests, this handles everything related to gamepads
-- (i.e. Xbox or Playstation controllers) and their navigation
-- I created a separate module for gamepads (and not touchpads or
-- keyboards) because gamepads are greatly more unqiue and require
-- additional tailored programming



-- SERVICES
local GamepadService = game:GetService("GamepadService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")



-- LOCAL
local DEFAULT_HIGHLIGHT_KEY = Enum.KeyCode.DPadUp -- The default key to highlight the topbar icon
local GAMEPAD_INPUT = Enum.PreferredInput.Gamepad
local Gamepad = {}
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Gamepad.start(incomingIcon)
	
	-- Public variables
	Icon = incomingIcon
	Icon.highlightKey = if Icon.highlightKey ~= nil then Icon.highlightKey else DEFAULT_HIGHLIGHT_KEY -- What controller key to highlight the topbar (or set to false to disable)
	Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most
	
	-- We defer so the developer can make changes before the
	-- gamepad controls are initialized
	task.delay(1, function()
		-- Some local utility
		local iconsDict = Icon.iconsDictionary
		local function getIconFromSelectedObject()
			local clickRegion = GuiService.SelectedObject
			local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
			local icon = iconUID and iconsDict[iconUID]
			return icon
		end
		
		-- This enables users to instantly open up their last selected icon
		local previousHighlightedIcon
		local usedIndicatorOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local usedBOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local Selection = require(script.Parent.Parent.Elements.Selection)
		local function updateSelectedObject()
			local icon = getIconFromSelectedObject()
			local isUsingGamepad = UserInputService.PreferredInput == GAMEPAD_INPUT
			if icon then
				if isUsingGamepad then
					local clickRegion = icon:getInstance("ClickRegion")
					local selection = icon.selection
					if not selection then
						selection = icon.janitor:add(Selection(Icon))
						selection:SetAttribute("IgnoreVisibilityUpdater", true)
						selection.Parent = icon.widget
						icon.selection = selection
						icon:refreshAppearance(selection) --icon:clipOutside(selection)
					end
					clickRegion.SelectionImageObject = selection.Selection
				end
				if previousHighlightedIcon and previousHighlightedIcon ~= icon then
					previousHighlightedIcon:setIndicator()
				end
				local newIndicator = if isUsingGamepad and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
				previousHighlightedIcon = icon
				Icon.lastHighlightedIcon = icon
				icon:setIndicator(newIndicator)
			else
				local newIndicator = if isUsingGamepad and not usedIndicatorOnce then Icon.highlightKey else nil
				if not previousHighlightedIcon then
					previousHighlightedIcon = Gamepad.getIconToHighlight()
				end
				if newIndicator == Icon.highlightKey then
					-- We only display the highlightKey once to show
					-- the user how to highlight the topbar icon
					usedIndicatorOnce = true
				else
					--usedBOnce = true
				end
				if previousHighlightedIcon then
					previousHighlightedIcon:setIndicator(newIndicator)
				end
			end
		end
		GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)

		-- This listens for a gamepad being present/added/removed
		local function preferredInputChanged()
			local preferredInput = UserInputService.PreferredInput
			local isUsingGamepad = preferredInput == GAMEPAD_INPUT

			if not isUsingGamepad then
				usedIndicatorOnce = false
				usedBOnce = false
			end
			updateSelectedObject()
		end
		UserInputService:GetPropertyChangedSignal("PreferredInput"):Connect(preferredInputChanged)
		preferredInputChanged()

		-- This allows for easy highlighting of the topbar when the
		-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
		-- If you'd like to disable, do ``Icon.highlightKey = false``
		UserInputService.InputBegan:Connect(function(input, touchingAnObject)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				-- Sometimes the Roblox gamepad glitches when combined with a cursor
				-- This fixes that by unhighlighting if the cursor is pressed down
				-- (i.e. a mouse click)
				local icon = getIconFromSelectedObject()
				if icon then
					GuiService.SelectedObject = nil
				end
				return
			end
			if input.KeyCode ~= Icon.highlightKey then
				return
			end
			local iconToHighlight = Gamepad.getIconToHighlight()
			if iconToHighlight then
				if GamepadService.GamepadCursorEnabled then
					task.wait(0.2)
					GamepadService:DisableGamepadCursor()
				end
				local clickRegion = iconToHighlight:getInstance("ClickRegion")
				GuiService.SelectedObject = clickRegion
			end
		end)
	end)
end

function Gamepad.getIconToHighlight()
	-- If an icon has already been selected, returns the last selected icon
	-- Else if more than 0 icons, it selects the left-most icon
	local iconsDict = Icon.iconsDictionary
	local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
	if not iconToHighlight then
		local currentX
		for _, icon in pairs(iconsDict) do
			if icon.parentIconUID then
				continue
			end
			local thisX = icon.widget.AbsolutePosition.X
			if not currentX or thisX < currentX then
				iconToHighlight = icon
				currentX = iconToHighlight.widget.AbsolutePosition.X
			end
		end
	end
	return iconToHighlight
end

-- This called when the icon's ClickRegion is created
function Gamepad.registerButton(buttonInstance)
	-- This provides a basic level of support for controllers by making
	-- the icons easy to highlight via the virtual cursor, then
	-- when selected, focuses in on the selected icon and hops
	-- between other nearby icons simply by toggling the joystick
	local inputBegan = false
	buttonInstance.InputBegan:Connect(function(input)
		-- Two wait frames required to ensure inputBegan is detected within
		-- UserInputService.InputBegan. We do this because object.InputBegan
		-- does not return the correct input objects (unlike the service)
		inputBegan = true
		task.wait()
		task.wait()
		inputBegan = false
	end)
	local connection = UserInputService.InputBegan:Connect(function(input)
		task.wait()
		if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
			-- We focus on an icon when selected via the virtual cursor
			task.wait(0.2)
			GamepadService:DisableGamepadCursor()
			GuiService.SelectedObject = buttonInstance
			return
		end
		local isSelected = GuiService.SelectedObject == buttonInstance
		local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
		local keyName = input.KeyCode.Name
		if table.find(unselectKeyCodes, keyName) and isSelected then
			-- We unfocus when back button is pressed, but ignore
			-- if the virtual cursor is disabled otherwise it will be
			-- impossible to select the topbar
			if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
				GuiService.SelectedObject = nil
			end
		end
	end)
	buttonInstance.Destroying:Once(function()
		connection:Disconnect()
	end)
end



return Gamepad]]></ProtectedString>
										<string name="ScriptGuid">{0CD02B9F-75AB-4FA0-A36A-813B6DE3A35C}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Gamepad</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXF801A5A99F324033B99A00B49C9CE898">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- When designing your game for many devices and screen sizes, icons may occasionally
-- particularly for smaller devices like phones, overlap with other icons or the bounds
-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring



-- LOCAL
local Overflow = {}
local holders = {}
local orderedAvailableIcons = {}
local iconsDict
local currentCamera = workspace.CurrentCamera
local overflowIcons = {}
local overflowIconUIDs = {}
local Utility = require(script.Parent.Parent.Utility)
local beginCheckingCenterIcons = false
local beganSecondaryCenterCheck = false
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Overflow.start(incomingIcon)
	Icon = incomingIcon
	iconsDict = Icon.iconsDictionary
	local primaryScreenGui
	for _, screenGui in pairs(Icon.container) do
		if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
			primaryScreenGui = screenGui
		end
		for _, holder in pairs(screenGui.Holders:GetChildren()) do
			if holder:GetAttribute("IsAHolder") then
				holders[holder.Name] = holder
			end
		end
	end

	-- We listen for changes in icons (such as them being added, removed,
	-- the setting of a different alignment, the widget size changing, etc)
	local beginOverflow = false
	local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
		if not beginOverflow then
			return
		end
		if not ignoreAvailable then
			Overflow.updateAvailableIcons("Center")
		end
		Overflow.updateBoundary("Left")
		Overflow.updateBoundary("Right")
	end)
	task.delay(0.5, function()
		beginOverflow = true
		updateBoundaries()
	end)
	task.delay(2, function()
		-- This is essential to prevent central icons begin added
		-- left or right due to incomplete UIListLayout calculations
		-- within the first few frames
		beginCheckingCenterIcons = true
		updateBoundaries()
	end)
	Icon.iconAdded:Connect(updateBoundaries)
	Icon.iconRemoved:Connect(updateBoundaries)
	Icon.iconChanged:Connect(updateBoundaries)
	currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
		updateBoundaries(true)
	end)
	primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updateBoundaries(true)
	end)
end

function Overflow.getWidth(icon, getMaxWidth)
	local widget = icon.widget
	return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
end

function Overflow.getAvailableIcons(alignment)
	local ourOrderedIcons = orderedAvailableIcons[alignment]
	if not ourOrderedIcons then
		ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	end
	return ourOrderedIcons
end

function Overflow.updateAvailableIcons(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon)
	local ourTotal = 0
	local ourOrderedIcons = {}
	for _, icon in pairs(iconsDict) do
		local parentUID = icon.parentIconUID
		local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
		local isOverflow = overflowIconUIDs[icon.UID]
		if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow and icon.isEnabled then
			table.insert(ourOrderedIcons, icon)
			ourTotal += 1
		end
	end

	-- Ignore if no icons are available
	if ourTotal <= 0 then
		return {}
	end

	-- This sorts these icons by smallest order, or if equal, left-most position
	-- (even for the right alignment because all icons are sorted left-to-right)
	table.sort(ourOrderedIcons, function(iconA, iconB)
		local orderA = iconA.widget.LayoutOrder
		local orderB = iconB.widget.LayoutOrder
		local hasParentA = iconA.parentIconUID
		local hasParentB = iconB.parentIconUID
		if hasParentA == hasParentB then
			if orderA < orderB then
				return true
			end
			if orderA > orderB then
				return false
			end
			return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
		elseif hasParentB then
			return false
		elseif hasParentA then
			return true
		end
		return nil
	end)

	-- Finish up
	orderedAvailableIcons[alignment] = ourOrderedIcons
	return ourOrderedIcons

end

function Overflow.getRealXPositions(alignment, orderedIcons)
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local isLeft = alignment == "Left"
	local holder = holders[alignment]
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local holderUIList = holder.UIListLayout
	local topbarInset = holderUIList.Padding.Offset
	local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
	local realXPositions = {}
	if isLeft then
		Utility.reverseTable(orderedIcons)
	end
	for i = #orderedIcons, 1, -1 do
		local icon = orderedIcons[i]
		local sizeX = Overflow.getWidth(icon)
		if not isLeft then
			absoluteX -= sizeX
		end
		realXPositions[icon.UID] = absoluteX
		if isLeft then
			absoluteX += sizeX
		end
		absoluteX += (isLeft and topbarInset) or -topbarInset
	end
	return realXPositions
end

function Overflow.updateBoundary(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local topbarInset = holderUIList.Padding.Offset
	local topbarPadding = holderUIList.Padding.Offset
	local BOUNDARY_GAP = topbarInset
	local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	local boundWidth = 0
	local ourTotal = 0
	for _, icon in pairs(ourOrderedIcons) do
		boundWidth += Overflow.getWidth(icon) + topbarPadding
		ourTotal += 1
	end
	if ourTotal <= 0 then
		return
	end
	
	-- These are the icons with menus which icons will be moved into
	-- when overflowing
	local isCentral = alignment == "Center"
	local isLeft = alignment == "Left"
	local isRight = not isLeft
	local overflowIcon = overflowIcons[alignment]
	if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
		local order = (isLeft and -9999999) or 9999999
		overflowIcon = Icon.new()--:setLabel(`{alignment}`)
		overflowIcon:setImage(6069276526, "Deselected")
		overflowIcon:setName("Overflow"..alignment)
		overflowIcon:setOrder(order)
		overflowIcon:setAlignment(alignment)
		overflowIcon:autoDeselect(false)
		overflowIcon.isAnOverflow = true
		--overflowIcon:freezeMenu()
		overflowIcon:select("OverflowStart", overflowIcon)
		overflowIcon:setEnabled(false)
		overflowIcons[alignment] = overflowIcon
		overflowIconUIDs[overflowIcon.UID] = true
		if not Icon.closeableOverflowMenus then
			local iconSpot = overflowIcon:getInstance("IconSpot")
			iconSpot.Visible = false
		end
	end

	-- The default boundary is the point where both the left-most-right-icon
	-- and left-most-right-icon meet OR the opposite side of the screen
	local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
	local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
	local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
	local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
	local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
	if nearestOppositeIcon then
		local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
		local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
		local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
		boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
	end
	
	-- We get the left-most icon (if left alignment) or right-most-icon (if
	-- right alignment) of the central icons group to see if we need to change
	-- the boundary (if the central icon boundary is smaller than the alignment
	-- boundary then we use the central)
	local totalChecks = 0
	local usingNearestCenter = false
	local function checkToShiftCentralIcon()
		local centerOrderedIcons = Overflow.getAvailableIcons("Center")
		local centerPos = (isLeft and 1) or #centerOrderedIcons
		local nearestCenterIcon = centerOrderedIcons[centerPos]
		local function secondaryCheck()
			if not beganSecondaryCenterCheck then
				beganSecondaryCenterCheck = true
				task.delay(3, Overflow.updateBoundary, alignment)
			end
		end
		if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
			local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
			local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
			local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
			local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
			local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
			local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
			local hasShifted = false
			if isLeft then
				if centerBoundary < removeBoundary then
					if not beginCheckingCenterIcons then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Left")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			elseif isRight then
				if centerBoundary > removeBoundary then
					if not beginCheckingCenterIcons or removeBoundary < 0 then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Right")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			end
			if hasShifted then
				totalChecks += 1
				if totalChecks <= 4 then
					Overflow.updateAvailableIcons("Center")
					checkToShiftCentralIcon()
				end
			end
		end
	end
	checkToShiftCentralIcon()
	
	--[[
	This updates the maximum size of the overflow menus
	The menu determines its bounds from the smallest of either:
	 	1. The closest center-aligned icon (i.e. the boundary)
	 	2. The edge of the opposite overflow menu UNLESS...
	 	3. ... the edge exceeds more than half the screenGui
	--]]
	if overflowIcon then
		local menuBoundary = boundary
		local menu = overflowIcon:getInstance("Menu")
		local holderXEndPos = holderXPos + holderXSize
		local menuWidth = holderXSize
		if menu and oppositeOverflowIcon then
			local oppositeWidget = oppositeOverflowIcon.widget
			local oppositeXPos = oppositeWidget.AbsolutePosition.X
			local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
			local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
			local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
			local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
			if not usingNearestCenter then
				local halfwayXPos = holderXPos + holderXSize/2
				local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
				menuBoundary = halfwayBoundary
				if isDominant then
					menuBoundary = oppositeBoundary
				end
			end
			menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
		end
		local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
		menuWidth = Utility.round(menuWidth)
		if menu and currentMaxWidth ~= menuWidth then
			menu:SetAttribute("MaxWidth", menuWidth)
		end
	end

	-- Parent ALL icons of that alignment into the overflow if at least on
	-- sibling exceeds the bounds.
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local widgetX = Overflow.getWidth(icon)
		local xPos = realXPositions[icon.UID]
		if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
			joinOverflow = true
		end
	end
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local isOverflow = overflowIconUIDs[icon.UID]
		if not isOverflow then
			if joinOverflow and not icon.parentIconUID then
				icon:joinMenu(overflowIcon)
			elseif not joinOverflow and icon.parentIconUID then
				icon:leave()
			end
		end
	end
	
	-- Hide the overflows when not in use
	if overflowIcon.isEnabled ~= joinOverflow then
		overflowIcon:setEnabled(joinOverflow)
	end
	
	-- Have the menus auto selected
	if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
		overflowIcon.overflowAlreadyOpened = true
		overflowIcon:select()
	end

end



return Overflow]]></ProtectedString>
										<string name="ScriptGuid">{0261DE4B-D2DF-43AE-AEF9-7743BC89E418}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Overflow</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXDC9F41D999D849949BFFE4E0A70D0FF1">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
	return nil
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
										<string name="ScriptGuid">{EA30EFAC-65FC-4A54-AC42-394E1E4EA328}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Themes</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX76657F0C5F8041FEA8A8242FBE4AE712">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
											<string name="ScriptGuid">{DFC504B1-E561-43AD-A4E8-AD505741D3D8}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Classic</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXF3D8FB7A9D20467B8839418E999C2140">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "DesiredWidth", 44, "Deselected"},
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
  	{"IconButton", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.08, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconImageRatio", "AspectRatio", 1, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.85, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
  	{"Dropdown", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.08, "Deselected"},
	{"Dropdown", "MaxIcons", 4.5, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
											<string name="ScriptGuid">{1438AA05-1B91-4927-B26A-50674211ADE6}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Default</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXD14A8DDA02564437900CF84137B03F05">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Packages</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX14A709026BCE466F99C8FDB505CF06E1">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end
Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end
Signal.Destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal]]></ProtectedString>
										<string name="ScriptGuid">{DD537714-2F9A-4983-98B9-04666D830912}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">GoodSignal</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX09598C8EA9D348EEB56F9A432F41D6A9">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------
This package was modified by ForeverHD.

PACKAGE MODIFICATIONS:
	1. Added pascalCase aliases for all methods
	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
	3. Slight change to how promises are tracked
	4. Added isAnInstanceBeingDestroyed check to line 228
	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
	6. Likely some additional changes which weren't record here
	7. Removed comments as these were detected by Moonwave
-------------------------------------
--]]



-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local function getPromiseReference()
	return false
end

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	IGNORE_MEMORY_DEBUG = true,
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	["Promise"] = "cancel";
	RBXScriptConnection = "Disconnect";
}

function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

function Janitor.__index:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local objectType = typeof(Object)
	if objectType == "table" and string.match(tostring(Object), "Promise") then
		objectType = "Promise"
		--local status = Object:getStatus()
		--print("status =", status, status == "Rejected")
	end
	MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
	end

	local OriginalTraceback = debug.traceback("")
	self[Object] = {MethodName, OriginalTraceback}
	return Object
end
Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

function Janitor.__index:AddPromise(PromiseObject)
	local Promise = getPromiseReference()
	if Promise then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
						PromiseObject:cancel()
					end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	local Promise = getPromiseReference()
	if Promise and Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]
	if This then
		local Object = This[Index]

		if Object then
			local ObjectDetail = self[Object]
			local MethodName = ObjectDetail and ObjectDetail[1]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
	return nil
end

function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, ObjectDetail in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			local MethodName = ObjectDetail[1]
			local OriginalTraceback = ObjectDetail[2]
			local function warnUser(warning)
				local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
				local addedLine = OriginalTraceback
				warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
			end
			if MethodName == true then
				local success, warning = pcall(Object)
				if not success then
					warnUser(warning)
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					local success, warning = pcall(ObjectMethod, Object)
					local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
					if not success and not isAnInstanceBeingDestroyed then
						warnUser(warning)
					end
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
										<string name="ScriptGuid">{9EE33865-24BF-47B1-8D36-A490775E63D2}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Janitor</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX63D2D1E0511744B8B8EE6C89CFBE4B72">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">SmoothShiftLock</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0296DBF0472C438DA0C0764129A2A15C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "SmoothShiftLock",
	Thumbnail = "rbxassetid://18622284295",
	AssetId = 18598633874,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Nekothyl"},
		{Text = "Description: THE shift lock library, a easy alternative to the default roblox shiftlock."},
		{Text = "Version: 1.3.0 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{2F99FBAD-AF40-4EB3-80D5-76B60A2F94BF}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Model" referent="RBX5362775955BB462389B0F9CD84E17433">
						<Properties>
							<token name="LevelOfDetail">0</token>
							<CoordinateFrame name="ModelMeshCFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<Vector3 name="ModelMeshSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="ModelStreamingMode">0</token>
							<bool name="NeedsPivotMigration">false</bool>
							<Ref name="PrimaryPart">null</Ref>
							<float name="ScaleFactor">1</float>
							<SharedString name="SlimHash">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<OptionalCoordinateFrame name="WorldPivotData">
								<CFrame>
									<X>86.6030807</X>
									<Y>0</Y>
									<Z>-123.296478</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CFrame>
							</OptionalCoordinateFrame>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SmoothShiftLock</string>
							<int64 name="SourceAssetId">18598633874</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX4FF9E226D51E49EF9D5CCE12DF824320">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[[

	-<< SmoothShiftLock Setup Guide >>-
	
	1. Put "DisableDefaultShiftLock" script into ServerScriptService.
		(Alternatively click on StarterPlayer and in properties under Controls find EnableMouseLockOption and uncheck the box)
	2. Put "CustomShiftLock" script into StarterPlayer>StarterPlayerScripts.

	Congratulations, you've successfully set up SmoothShiftLock!
	The settings of SmoothShiftLock are located at CustomShiftLock>SmoothShiftLock (Line 31)
	
	
	
	
	-<< For Advanced Scripters >>-
	
	To access the module's methods, simply require the SmoothShiftLock module script.
	Example:
	
	```
	local SmoothShiftLock = require(CustomShiftLock.SmoothShiftLock);
	print(SmoothShiftLock:IsEnabled());
	```
	
	@ Variables:
		.Enabled - ShiftLock's enabled state.
		
	@ Methods:
		:Enable() - Enables the whole module.
		:Disable() - Disables the whole module.
		:IsEnabled(): boolean - Returns ShiftLock's enabled state.
		:ToggleShiftLock(Enable: boolean?) - Toggles the ShiftLock, if Enable parameter is provided then ShiftLock will be toggled to it.
		
		
--]]]]></ProtectedString>
								<string name="ScriptGuid">{41CA6B03-9347-4F71-8B0C-C82DB7DE60D4}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SETUP GUIDE</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX6562102D9B724399B2998F5DDB5B4128">
							<Properties>
								<ProtectedString name="Source"><![CDATA[--[[

	Put this into ServerScriptService

--]]

local StarterPlayer = game:GetService("StarterPlayer");
StarterPlayer.EnableMouseLockOption = false;]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{AD810EDD-C1F5-40E2-A9A6-7F877C018B60}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">DisableDefaultShiftLock</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="LocalScript" referent="RBX91D4517678FA450EB716FF4E9DA48C3D">
							<Properties>
								<ProtectedString name="Source"><![CDATA[--[[

	Put this into StarterPlayer>StarterPlayerScripts

--]]

require(script:WaitForChild("SmoothShiftLock"));]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{87BE3DBE-FC0C-4AE5-9C67-AC7BDEDF2C11}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">CustomShiftLock</string>
								<int64 name="SourceAssetId">13628590040</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXA80DC81FA9BE4278A26063D21753273A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	@ Name: SmoothShiftLock
	@ Author: x33
	@ Version: 1.3.0
	
	@ Variables:
		.Enabled - ShiftLock's enabled state.
		
	@ Methods:
		:Enable() - Enables the whole module.
		:Disable() - Disables the whole module.
		:IsEnabled(): boolean - Returns ShiftLock's enabled state.
		:ToggleShiftLock(Enable: boolean?) - Toggles the ShiftLock, if Enable parameter is provided then ShiftLock will be toggled to it.

--]]

local SmoothShiftLock = {};
SmoothShiftLock.__index = SmoothShiftLock;

--// [ Locals: ]

--// Services
local Workspace = game:GetService("Workspace");
local Players = game:GetService("Players");
local RunService = game:GetService("RunService");
local ContextActionService = game:GetService("ContextActionService");
local UserInputService = game:GetService("UserInputService");

--// Utilities
local Maid = require(script:WaitForChild("Maid"));
local Spring = require(script:WaitForChild("Spring"));

--// Instances
local LocalPlayer = Players.LocalPlayer;
local PlayerMouse = LocalPlayer:GetMouse();
local Camera = Workspace.CurrentCamera;

--// Configuration
local Config = {
	MOBILE_SUPPORT              = false,                      --// Adds a button to toggle the shift lock for touchscreen devices
	SMOOTH_CHARACTER_ROTATION   = true,                       --// If your character should rotate smoothly or not
	CHARACTER_ROTATION_SPEED    = 3,                          --// How quickly character rotates smoothly
	TRANSITION_SPRING_DAMPER    = 0.7,                        --// Camera transition spring damper, test it out to see what works for you
	CAMERA_TRANSITION_IN_SPEED  = 10,                         --// How quickly locked camera moves to offset position
	CAMERA_TRANSITION_OUT_SPEED = 14,                         --// How quickly locked camera moves back from offset position
	LOCKED_CAMERA_OFFSET        = Vector3.new(1.75, 0.25, 0), --// Locked camera offset
	LOCKED_MOUSE_ICON           =                             --// Locked mouse icon
		"rbxasset://textures/MouseLockedCursor.png",
	SHIFT_LOCK_KEYBINDS         =                             --// Shift lock keybinds
		{Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift}
};

--// [ Constructor: ]
function SmoothShiftLock.new()
	local self = setmetatable({}, SmoothShiftLock);
	
	--// Utilities
	self._runtimeMaid = Maid.new();
	self._shiftlockMaid = Maid.new();
	self._cameraOffsetSpring = Spring.new(Vector3.new(0, 0, 0));
	self._cameraOffsetSpring.Damper = Config.TRANSITION_SPRING_DAMPER;

	--// Variables
	self.Enabled = false;
	
	--// Setup
	self:Enable();
	
	return self;
end;

--// [ Module Functions: ]
function SmoothShiftLock:Enable()
	self:_refreshCharacterVariables();
	self._runtimeMaid:GiveTask(LocalPlayer.CharacterAdded:Connect(function()
		self:_refreshCharacterVariables();
	end));
	
	--// Bind Keybinds
	ContextActionService:BindActionAtPriority("ShiftLockSwitchAction", function(Name, State, Input)
		return self:_doShiftLockSwitch(Name, State, Input);
	end, Config.MOBILE_SUPPORT, Enum.ContextActionPriority.Medium.Value, unpack(Config.SHIFT_LOCK_KEYBINDS));

	--// Camera Offset
	self._runtimeMaid:GiveTask(RunService.RenderStepped:Connect(function()
		if self.Head.LocalTransparencyModifier > 0.6 then return; end;

		local CameraCFrame = Camera.CoordinateFrame;
		local Distance = (self.Head.Position - CameraCFrame.p).magnitude;

		--// Camera offset
		if Distance > 1 then	
			Camera.CFrame = (Camera.CFrame * CFrame.new(self._cameraOffsetSpring.Position)); 
			if self.Enabled and UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
				self:_updateMouseState();
			end;
		end;
	end));
end;

function SmoothShiftLock:Disable()
	self._runtimeMaid:DoCleaning();
	self._shiftlockMaid:DoCleaning();
	
	--// Unbind Keybinds
	ContextActionService:UnbindAction("ShiftLockSwitchAction");
end;

--// [ Internal Functions: ]
function SmoothShiftLock:_refreshCharacterVariables()
	self.Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait();
	self.RootPart = self.Character:WaitForChild("HumanoidRootPart");
	self.Humanoid = self.Character:WaitForChild("Humanoid");
	self.Head = self.Character:WaitForChild("Head");
end;

--// Internal function for ContextActionService
function SmoothShiftLock:_doShiftLockSwitch(_, State: Enum.UserInputState)
	if State == Enum.UserInputState.Begin then
		self:ToggleShiftLock();
		return Enum.ContextActionResult.Sink;
	end;

	return Enum.ContextActionResult.Pass;
end;

--// Update the mouse behaviour
function SmoothShiftLock:_updateMouseState()
	UserInputService.MouseBehavior = (self.Enabled and Enum.MouseBehavior.LockCenter) or Enum.MouseBehavior.Default;
end;

--// Update the mouse icon
function SmoothShiftLock:_updateMouseIcon()
	PlayerMouse.Icon = (self.Enabled and Config.LOCKED_MOUSE_ICON :: string) or "";
end;

--// Transition the camera to lock offset
function SmoothShiftLock:_transitionLockOffset()
	if self.Enabled then
		self._cameraOffsetSpring.Speed = Config.CAMERA_TRANSITION_IN_SPEED;
		self._cameraOffsetSpring.Target = Config.LOCKED_CAMERA_OFFSET;
	else
		self._cameraOffsetSpring.Speed = Config.CAMERA_TRANSITION_OUT_SPEED;
		self._cameraOffsetSpring.Target = Vector3.new(0, 0, 0);
	end;
end;

--// [ External Functions: ]
function SmoothShiftLock:IsEnabled(): boolean
	return self.Enabled;
end;

--// ShiftLock toggle function
function SmoothShiftLock:ToggleShiftLock(Enable: boolean?)
	if Enable ~= nil then
		self.Enabled = Enable;
	else
		self.Enabled = not self.Enabled;
	end;

	self:_updateMouseState();
	self:_updateMouseIcon();
	self:_transitionLockOffset();
	if self.Enabled then
		self._shiftlockMaid:GiveTask(RunService.RenderStepped:Connect(function(Delta: number)
			if (self.Humanoid and self.RootPart) then 
				self.Humanoid.AutoRotate = not self.Enabled;
			end;
			
			--// Rotate the character
			if self.Humanoid.Sit then return; end;
			if Config.SMOOTH_CHARACTER_ROTATION then
				local x, y, z = Camera.CFrame:ToOrientation();
				self.RootPart.CFrame = self.RootPart.CFrame:Lerp(CFrame.new(self.RootPart.Position) * CFrame.Angles(0, y, 0), Delta * 5 * Config.CHARACTER_ROTATION_SPEED);
			else
				local x, y, z = Camera.CFrame:ToOrientation();
				self.RootPart.CFrame = CFrame.new(self.RootPart.Position) * CFrame.Angles(0, y, 0);
			end;
		end));
	else
		self.Humanoid.AutoRotate = true;
		self._shiftlockMaid:DoCleaning();
	end;
end;

return SmoothShiftLock.new();]]></ProtectedString>
									<string name="ScriptGuid">{F5ECD0F6-D05C-4ED8-B78D-DD863C8DF4A4}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">SmoothShiftLock</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX744F2658FC3945E2BF6F7FDA3F2FBBA5">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[--[=[
	Manages the cleaning of events and other things. Useful for
	encapsulating state and make deconstructors easy.

	See the [Five Powerful Code Patterns talk](https://developer.roblox.com/en-us/videos/5-powerful-code-patterns-behind-top-roblox-games)
	for a more in-depth look at Maids in top games.

	```lua
	local maid = Maid.new()

	maid:GiveTask(function()
		print("Cleaning up")
	end)

	maid:GiveTask(workspace.ChildAdded:Connect(print))

	-- Disconnects all events, and executes all functions
	maid:DoCleaning()
	```

	@class Maid
]=]
-- luacheck: pop

local Maid = {}
Maid.ClassName = "Maid"

--[=[
	Constructs a new Maid object

	```lua
	local maid = Maid.new()
	```

	@return Maid
]=]
function Maid.new()
	return setmetatable({
		_tasks = {}
	}, Maid)
end

--[=[
	Returns true if the class is a maid, and false otherwise.

	```lua
	print(Maid.isMaid(Maid.new())) --> true
	print(Maid.isMaid(nil)) --> false
	```

	@param value any
	@return boolean
]=]
function Maid.isMaid(value)
	return type(value) == "table" and value.ClassName == "Maid"
end

--[=[
	Returns Maid[key] if not part of Maid metatable

	```lua
	local maid = Maid.new()
	maid._current = Instance.new("Part")
	print(maid._current) --> Part

	maid._current = nil
	print(maid._current) --> nil
	```

	@param index any
	@return MaidTask
]=]
function Maid:__index(index)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--[=[
	Add a task to clean up. Tasks given to a maid will be cleaned when
	maid[index] is set to a different value.

	Task cleanup is such that if the task is an event, it is disconnected.
	If it is an object, it is destroyed.

	```
	Maid[key] = (function)         Adds a task to perform
	Maid[key] = (event connection) Manages an event connection
	Maid[key] = (thread)           Manages a thread
	Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
	Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
	Maid[key] = nil                Removes a named task.
	```

	@param index any
	@param newTask MaidTask
]=]
function Maid:__newindex(index, newTask)
	if Maid[index] ~= nil then
		error(("Cannot use '%s' as a Maid key"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]

	if oldTask == newTask then
		return
	end

	tasks[index] = newTask

	if oldTask then
		if type(oldTask) == "function" then
			oldTask()
		elseif type(oldTask) == "thread" then
			task.cancel(oldTask)
		elseif typeof(oldTask) == "RBXScriptConnection" then
			oldTask:Disconnect()
		elseif oldTask.Destroy then
			oldTask:Destroy()
		end
	end
end

--[=[
	Gives a task to the maid for cleanup, but uses an incremented number as a key.

	@param task MaidTask -- An item to clean
	@return number -- taskId
]=]
function Maid:GiveTask(task)
	if not task then
		error("Task cannot be false or nil", 2)
	end

	local taskId = #self._tasks+1
	self[taskId] = task

	if type(task) == "table" and (not task.Destroy) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

--[=[
	Gives a promise to the maid for clean.

	@param promise Promise<T>
	@return Promise<T>
]=]
function Maid:GivePromise(promise)
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--[=[
	Cleans up all tasks and removes them as entries from the Maid.

	:::note
	Signals that are already connected are always disconnected first. After that
	any signals added during a cleaning phase will be disconnected at random times.
	:::

	:::tip
	DoCleaning() may be recursively invoked. This allows the you to ensure that
	tasks or other tasks. Each task will be executed once.

	However, adding tasks while cleaning is not generally a good idea, as if you add a
	function that adds itself, this will loop indefinitely.
	:::
]=]
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, job in pairs(tasks) do
		if typeof(job) == "RBXScriptConnection" then
			tasks[index] = nil
			job:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, job = next(tasks)
	while job ~= nil do
		tasks[index] = nil
		if type(job) == "function" then
			job()
		elseif type(job) == "thread" then
			task.cancel(job)
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		elseif job.Destroy then
			job:Destroy()
		end
		index, job = next(tasks)
	end
end

--[=[
	Alias for [Maid.DoCleaning()](/api/Maid#DoCleaning)

	@function Destroy
	@within Maid
]=]
Maid.Destroy = Maid.DoCleaning

return Maid
]]></ProtectedString>
										<string name="ScriptGuid">{ED2C0EB8-E344-4BB3-8E1E-C23362F81956}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Maid</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX814CF1122D9E492A80F711938C032E4D">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[--[=[
	A physical model of a spring, useful in many applications.
	A spring is an object that will compute based upon Hooke's law. Properties only evaluate
	upon index making this model good for lazy applications.
	```lua
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local spring = Spring.new(Vector3.new(0, 0, 0))
	RunService.RenderStepped:Connect(function()
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then
			spring.Target = Vector3.new(0, 0, 1)
		else
			spring.Target = Vector3.new(0, 0, 0)
		end
		print(spring.Position) -- A smoothed out version of the input keycode W
	end)
	```
	A good visualization can be found here, provided by Defaultio:
	https://www.desmos.com/calculator/hn2i9shxbz
	@class Spring
]=]
local Spring = {}

--[=[
	Constructs a new Spring at the position and target specified, of type T.
	```lua
	-- Linear spring
	local linearSpring = Spring.new(0)
	-- Vector2 spring
	local vector2Spring = Spring.new(Vector2.new(0, 0))
	-- Vector3 spring
	local vector3Spring = Spring.new(Vector3.new(0, 0, 0))
	```
	@param initial T -- The initial parameter is a number or Vector3 (anything with * number and addition/subtraction).
	@param clock? () -> number -- The clock function is optional, and is used to update the spring
	@return Spring<T>
]=]
function Spring.new(initial, clock)
	local target = initial or 0
	clock = clock or os.clock
	return setmetatable({
		_clock = clock;
		_time0 = clock();
		_position0 = target;
		_velocity0 = 0*target;
		_target = target;
		_damper = 1;
		_speed = 1;
	}, Spring)
end

--[=[
	Impulses the spring, increasing velocity by the amount given. This is useful to make something shake,
	like a Mac password box failing.
	@param velocity T -- The velocity to impulse with
	@return ()
]=]
function Spring:Impulse(velocity)
	self.Velocity = self.Velocity + velocity
end

--[=[
	Instantly skips the spring forwards by that amount time
	@param delta number -- Time to skip forwards
	@return ()
]=]
function Spring:TimeSkip(delta)
	local now = self._clock()
	local position, velocity = self:_positionVelocity(now+delta)
	self._position0 = position
	self._velocity0 = velocity
	self._time0 = now
end

--[=[
	The current position at the given clock time. Assigning the position will change the spring to have that position.
	```lua
	local spring = Spring.new(0)
	print(spring.Position) --> 0
	```
	@prop Position T
	@within Spring
]=]
--[=[
	Alias for [Spring.Position](/api/Spring#Position)
	@prop p T
	@within Spring
]=]
--[=[
	The current velocity. Assigning the velocity will change the spring to have that velocity.
	```lua
	local spring = Spring.new(0)
	print(spring.Velocity) --> 0
	```
	@prop Velocity T
	@within Spring
]=]
--[=[
	Alias for [Spring.Velocity](/api/Spring#Velocity)
	@prop v T
	@within Spring
]=]
--[=[
	The current target. Assigning the target will change the spring to have that target.
	```lua
	local spring = Spring.new(0)
	print(spring.Target) --> 0
	```
	@prop Target T
	@within Spring
]=]
--[=[
	Alias for [Spring.Target](/api/Spring#Target)
	@prop t T
	@within Spring
]=]
--[=[
	The current damper, defaults to 1. At 1 the spring is critically damped. At less than 1, it
	will be underdamped, and thus, bounce, and at over 1, it will be critically damped.
	@prop Damper number
	@within Spring
]=]
--[=[
	Alias for [Spring.Damper](/api/Spring#Damper)
	@prop d number
	@within Spring
]=]
--[=[
	The speed, defaults to 1, but should be between [0, infinity)
	@prop Speed number
	@within Spring
]=]
--[=[
	Alias for [Spring.Speed](/api/Spring#Speed)
	@prop s number
	@within Spring
]=]
--[=[
	The current clock object to syncronize the spring against.
	@prop Clock () -> number
	@within Spring
]=]
function Spring:__index(index)
	if Spring[index] then
		return Spring[index]
	elseif index == "Value" or index == "Position" or index == "p" then
		local position, _ = self:_positionVelocity(self._clock())
		return position
	elseif index == "Velocity" or index == "v" then
		local _, velocity = self:_positionVelocity(self._clock())
		return velocity
	elseif index == "Target" or index == "t" then
		return self._target
	elseif index == "Damper" or index == "d" then
		return self._damper
	elseif index == "Speed" or index == "s" then
		return self._speed
	elseif index == "Clock" then
		return self._clock
	else
		error(("%q is not a valid member of Spring"):format(tostring(index)), 2)
	end
end

function Spring:__newindex(index, value)
	local now = self._clock()

	if index == "Value" or index == "Position" or index == "p" then
		local _, velocity = self:_positionVelocity(now)
		self._position0 = value
		self._velocity0 = velocity
		self._time0 = now
	elseif index == "Velocity" or index == "v" then
		local position, _ = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = value
		self._time0 = now
	elseif index == "Target" or index == "t" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._target = value
		self._time0 = now
	elseif index == "Damper" or index == "d" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._damper = value
		self._time0 = now
	elseif index == "Speed" or index == "s" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._speed = value < 0 and 0 or value
		self._time0 = now
	elseif index == "Clock" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._clock = value
		self._time0 = value()
	else
		error(("%q is not a valid member of Spring"):format(tostring(index)), 2)
	end
end

function Spring:_positionVelocity(now)
	local p0 = self._position0
	local v0 = self._velocity0
	local p1 = self._target
	local d = self._damper
	local s = self._speed

	local t = s*(now - self._time0)
	local d2 = d*d

	local h, si, co
	if d2 < 1 then
		h = math.sqrt(1 - d2)
		local ep = math.exp(-d*t)/h
		co, si = ep*math.cos(h*t), ep*math.sin(h*t)
	elseif d2 == 1 then
		h = 1
		local ep = math.exp(-d*t)/h
		co, si = ep, ep*t
	else
		h = math.sqrt(d2 - 1)
		local u = math.exp((-d + h)*t)/(2*h)
		local v = math.exp((-d - h)*t)/(2*h)
		co, si = u + v, u - v
	end

	local a0 = h*co + d*si
	local a1 = 1 - (h*co + d*si)
	local a2 = si/s

	local b0 = -s*si
	local b1 = s*si
	local b2 = h*co - d*si

	return
		a0*p0 + a1*p1 + a2*v0,
		b0*p0 + b1*p1 + b2*v0
end

return Spring]]></ProtectedString>
										<string name="ScriptGuid">{B61AB3D7-2065-41EB-A78D-337744CB2237}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Spring</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX94E43DF8F9C942E1B325BDD754CCDE70">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">SimplePath</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA9363C1B05A14E11925900E6528ED6ED">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------------------------------------

Created by: @V3N0M_Z
Reference: https://v3n0m-z.github.io/RBLX-SimplePath/
License: MIT

---------------------------------------------------------------------
]]

local DEFAULT_SETTINGS = {

	TIME_VARIANCE = 0.07;

	COMPARISON_CHECKS = 1;

	JUMP_WHEN_STUCK = true;
}

---------------------------------------------------------------------

local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local function output(func, msg)
	func(((func == error and "SimplePath Error: ") or "SimplePath: ")..msg)
end
local Path = {
	StatusType = {
		Idle = "Idle";
		Active = "Active";
	};
	ErrorType = {
		LimitReached = "LimitReached";
		TargetUnreachable = "TargetUnreachable";
		ComputationError = "ComputationError";
		AgentStuck = "AgentStuck";
	};
}
Path.__index = function(table, index)
	if index == "Stopped" and not table._humanoid then
		output(error, "Attempt to use Path.Stopped on a non-humanoid.")
	end
	return (table._events[index] and table._events[index].Event)
		or (index == "LastError" and table._lastError)
		or (index == "Status" and table._status)
		or Path[index]
end

--Used to visualize waypoints
local visualWaypoint = Instance.new("Part")
visualWaypoint.Size = Vector3.new(0.3, 0.3, 0.3)
visualWaypoint.Anchored = true
visualWaypoint.CanCollide = false
visualWaypoint.Material = Enum.Material.Neon
visualWaypoint.Shape = Enum.PartType.Ball

--[[ PRIVATE FUNCTIONS ]]--
local function declareError(self, errorType)
	self._lastError = errorType
	self._events.Error:Fire(errorType)
end

--Create visual waypoints
local function createVisualWaypoints(waypoints)
	local visualWaypoints = {}
	for _, waypoint in ipairs(waypoints) do
		local visualWaypointClone = visualWaypoint:Clone()
		visualWaypointClone.Position = waypoint.Position
		visualWaypointClone.Parent = workspace
		visualWaypointClone.Color =
			(waypoint == waypoints[#waypoints] and Color3.fromRGB(0, 255, 0))
			or (waypoint.Action == Enum.PathWaypointAction.Jump and Color3.fromRGB(255, 0, 0))
			or Color3.fromRGB(255, 139, 0)
		table.insert(visualWaypoints, visualWaypointClone)
	end
	return visualWaypoints
end

--Destroy visual waypoints
local function destroyVisualWaypoints(waypoints)
	if waypoints then
		for _, waypoint in ipairs(waypoints) do
			waypoint:Destroy()
		end
	end
	return
end

--Get initial waypoint for non-humanoid
local function getNonHumanoidWaypoint(self)
	--Account for multiple waypoints that are sometimes in the same place
	for i = 2, #self._waypoints do
		if (self._waypoints[i].Position - self._waypoints[i - 1].Position).Magnitude > 0.1 then
			return i
		end
	end
	return 2
end

--Make NPC jump
local function setJumpState(self)
	pcall(function()
		if self._humanoid:GetState() ~= Enum.HumanoidStateType.Jumping and self._humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
			self._humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
		end
	end)
end

--Primary move function
local function move(self)
	if self._waypoints[self._currentWaypoint].Action == Enum.PathWaypointAction.Jump then
		setJumpState(self)
	end
	self._humanoid:MoveTo(self._waypoints[self._currentWaypoint].Position)
end

--Disconnect MoveToFinished connection when pathfinding ends
local function disconnectMoveConnection(self)
	self._moveConnection:Disconnect()
	self._moveConnection = nil
end

--Fire the WaypointReached event
local function invokeWaypointReached(self)
	local lastWaypoint = self._waypoints[self._currentWaypoint - 1]
	local nextWaypoint = self._waypoints[self._currentWaypoint]
	self._events.WaypointReached:Fire(self._agent, lastWaypoint, nextWaypoint)
end

local function moveToFinished(self, reached)
	
	--Stop execution if Path is destroyed
	if not getmetatable(self) then return end

	--Handle case for non-humanoids
	if not self._humanoid then
		if reached and self._currentWaypoint + 1 <= #self._waypoints then
			invokeWaypointReached(self)
			self._currentWaypoint += 1
		elseif reached then
			self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
			self._target = nil
			self._events.Reached:Fire(self._agent, self._waypoints[self._currentWaypoint])
		else
			self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
			self._target = nil
			declareError(self, self.ErrorType.TargetUnreachable)
		end
		return
	end

	if reached and self._currentWaypoint + 1 <= #self._waypoints  then --Waypoint reached
		if self._currentWaypoint + 1 < #self._waypoints then
			invokeWaypointReached(self)
		end
		self._currentWaypoint += 1
		move(self)
	elseif reached then --Target reached, pathfinding ends
		disconnectMoveConnection(self)
		self._status = Path.StatusType.Idle
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		self._events.Reached:Fire(self._agent, self._waypoints[self._currentWaypoint])
	else --Target unreachable
		disconnectMoveConnection(self)
		self._status = Path.StatusType.Idle
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		declareError(self, self.ErrorType.TargetUnreachable)
	end
end

--Refer to Settings.COMPARISON_CHECKS
local function comparePosition(self)
	if self._currentWaypoint == #self._waypoints then return end
	self._position._count = ((self._agent.PrimaryPart.Position - self._position._last).Magnitude <= 0.07 and (self._position._count + 1)) or 0
	self._position._last = self._agent.PrimaryPart.Position
	if self._position._count >= self._settings.COMPARISON_CHECKS then
		if self._settings.JUMP_WHEN_STUCK then
			setJumpState(self)
		end
		declareError(self, self.ErrorType.AgentStuck)
	end
end

--[[ STATIC METHODS ]]--
function Path.GetNearestCharacter(fromPosition)
	local character, dist = nil, math.huge
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character and (player.Character.PrimaryPart.Position - fromPosition).Magnitude < dist then
			character, dist = player.Character, (player.Character.PrimaryPart.Position - fromPosition).Magnitude
		end
	end
	return character
end

--[[ CONSTRUCTOR ]]--
function Path.new(agent, agentParameters, override)
	if not (agent and agent:IsA("Model") and agent.PrimaryPart) then
		output(error, "Pathfinding agent must be a valid Model Instance with a set PrimaryPart.")
	end

	local self = setmetatable({
		_settings = override or DEFAULT_SETTINGS;
		_events = {
			Reached = Instance.new("BindableEvent");
			WaypointReached = Instance.new("BindableEvent");
			Blocked = Instance.new("BindableEvent");
			Error = Instance.new("BindableEvent");
			Stopped = Instance.new("BindableEvent");
		};
		_agent = agent;
		_humanoid = agent:FindFirstChildOfClass("Humanoid");
		_path = PathfindingService:CreatePath(agentParameters);
		_status = "Idle";
		_t = 0;
		_position = {
			_last = Vector3.new();
			_count = 0;
		};
	}, Path)

	--Configure settings
	for setting, value in pairs(DEFAULT_SETTINGS) do
		self._settings[setting] = self._settings[setting] == nil and value or self._settings[setting]
	end

	--Path blocked connection
	self._path.Blocked:Connect(function(...)
		if (self._currentWaypoint <= ... and self._currentWaypoint + 1 >= ...) and self._humanoid then
			setJumpState(self)
			self._events.Blocked:Fire(self._agent, self._waypoints[...])
		end
	end)

	return self
end


--[[ NON-STATIC METHODS ]]--
function Path:Destroy()
	for _, event in ipairs(self._events) do
		event:Destroy()
	end
	self._events = nil
	if rawget(self, "_visualWaypoints") then
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
	end
	self._path:Destroy()
	setmetatable(self, nil)
	for k, _ in pairs(self) do
		self[k] = nil
	end
end

function Path:Stop()
	if not self._humanoid then
		output(error, "Attempt to call Path:Stop() on a non-humanoid.")
		return
	end
	if self._status == Path.StatusType.Idle then
		output(function(m)
			warn(debug.traceback(m))
		end, "Attempt to run Path:Stop() in idle state")
		return
	end
	disconnectMoveConnection(self)
	self._status = Path.StatusType.Idle
	self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
	self._events.Stopped:Fire(self._model)
end

function Path:Run(target)

	--Non-humanoid handle case
	if not target and not self._humanoid and self._target then
		moveToFinished(self, true)
		return
	end

	--Parameter check
	if not (target and (typeof(target) == "Vector3" or target:IsA("BasePart"))) then
		output(error, "Pathfinding target must be a valid Vector3 or BasePart.")
	end

	--Refer to Settings.TIME_VARIANCE
	if os.clock() - self._t <= self._settings.TIME_VARIANCE and self._humanoid then
		task.wait(os.clock() - self._t)
		declareError(self, self.ErrorType.LimitReached)
		return false
	elseif self._humanoid then
		self._t = os.clock()
	end

	--Compute path
	local pathComputed, _ = pcall(function()
		self._path:ComputeAsync(self._agent.PrimaryPart.Position, (typeof(target) == "Vector3" and target) or target.Position)
	end)

	--Make sure path computation is successful
	if not pathComputed
		or self._path.Status == Enum.PathStatus.NoPath
		or #self._path:GetWaypoints() < 2
		or (self._humanoid and self._humanoid:GetState() == Enum.HumanoidStateType.Freefall) then
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		task.wait()
		declareError(self, self.ErrorType.ComputationError)
		return false
	end

	--Set status to active; pathfinding starts
	self._status = (self._humanoid and Path.StatusType.Active) or Path.StatusType.Idle
	self._target = target

	--Set network owner to server to prevent "hops"
	pcall(function()
		self._agent.PrimaryPart:SetNetworkOwner(nil)
	end)

	--Initialize waypoints
	self._waypoints = self._path:GetWaypoints()
	self._currentWaypoint = 2

	--Refer to Settings.COMPARISON_CHECKS
	if self._humanoid then
		comparePosition(self)
	end

	--Visualize waypoints
	destroyVisualWaypoints(self._visualWaypoints)
	self._visualWaypoints = (self.Visualize and createVisualWaypoints(self._waypoints))

	--Create a new move connection if it doesn't exist already
	self._moveConnection = self._humanoid and (self._moveConnection or self._humanoid.MoveToFinished:Connect(function(...)
		moveToFinished(self, ...)
	end))

	--Begin pathfinding
	if self._humanoid then
		self._humanoid:MoveTo(self._waypoints[self._currentWaypoint].Position)
	elseif #self._waypoints == 2 then
		self._target = nil
		self._visualWaypoints = destroyVisualWaypoints(self._visualWaypoints)
		self._events.Reached:Fire(self._agent, self._waypoints[2])
	else
		self._currentWaypoint = getNonHumanoidWaypoint(self)
		moveToFinished(self, true)
	end
	return true
end

return Path]]></ProtectedString>
							<string name="ScriptGuid">{86307859-57C7-4880-969F-40F5A46F8E58}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">SimplePath</string>
							<int64 name="SourceAssetId">6744337775</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC8A87E2F863E4E709F5FFE82DD425B79">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "SimplePath",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 6744337775,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @V3N0M_Z"},
		{Text = "Description: A simple pathfinding library, easy to use and Powerful."},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{89336CEE-15B0-41C3-A895-402E1DB2DBD5}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX5FA2A4D5666646E2AE21C960EAF0DC33">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Ragdoll</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX44D9523836374B4AABA0EFF13071B8DE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[

local RunService = game:GetService("RunService")


local debugPrintMode = script:GetAttribute("DebugPrintMode")

local ragdollModule = {}

local ragdollData = {}

local RagdollModes = script.RagdollModes

local function getConstraintType(motor, modeModule)
	if modeModule.Motors[motor.Name] then
		return modeModule.Motors[motor.Name]
	end
	for constraintType, constraintValue in modeModule.Motors do
		if string.find(motor.Name, constraintType) then
			return constraintValue
		end
	end
	return modeModule.DefaultConstraintType or "Default"
end

local function getLimbAttachments(motor, r6)
	if r6 then
		local name = "RagdollMotorAttachment"
		local at0 = Instance.new("Attachment")
		local at1 = Instance.new("Attachment")
		at0.CFrame = motor.C0
		at1.CFrame = motor.C1
		at0.Name = name
		at1.Name = name
		at0.Parent = motor.Part0
		at1.Parent = motor.Part1
		return at0, at1
	end
	
	local joint_name = motor.Name
	local part0 = motor.Part0
	local at0 = motor.Parent:FindFirstChild(joint_name.."Attachment") or motor.Parent:FindFirstChild(joint_name.."RigAttachment")
	local at1 = part0:FindFirstChild(joint_name.."Attachment") or part0:FindFirstChild(joint_name.."RigAttachment")
	
	while motor and not at0 do
		motor.Parent.ChildAdded:Wait()
		at0 = motor.Parent:FindFirstChild(joint_name.."Attachment") or motor.Parent:FindFirstChild(joint_name.."RigAttachment")
	end
	while motor and not at1 do
		part0.ChildAdded:Wait()
		at1 = part0:FindFirstChild(joint_name.."Attachment") or part0:FindFirstChild(joint_name.."RigAttachment")
	end
	if not motor then
		return
	end
	return at0, at1
end

local function applyImpact(character: Model, impactData: table)
	--[[impactData
			Part: Can be [Part in character] or [name of part in character]. If nil then this will default to HumanoidRootPart if available
			Hit: [Vector3] Position on impactData.Part to apply impact. If nil then defaults to impactData.Part's position
			Direction: [Vector3] Direction of impact
			Speed: [number] Speed of impact (default = 350)
			Lifetime: [number] Amount of time that the impact will last (default = 0.3)
			UseLinearVelocity: [bool] If true, use a LinearVelocity Instance instead of VectorForce Instance
	]]
	local part = typeof(impactData.Part) == "Instance" and impactData.Part or (not impactData.Part and character:FindFirstChild("HumanoidRootPart")) or character:FindFirstChild(impactData.Part)
	if part then
		if part:IsA("Accessory") then
			part = part:FindFirstChildOfClass("BasePart")
		end
		if part and part:IsDescendantOf(character) and impactData.Direction then
			local speed = impactData.Speed or 350
			local unit = impactData.Direction.Unit
			if not (unit.Magnitude > 0) then
				return
			end
			
			local impactPoint = Instance.new("Attachment")
			impactPoint.Name = "ImpactPoint"
			impactPoint.Parent = part
			impactPoint.Position = impactData.Hit or part.Position
			
			local force
			if impactData.UseLinearVelocity then
				force = Instance.new("LinearVelocity")
				force.ForceLimitsEnabled = false
				force.VectorVelocity = unit * speed
			else
				force = Instance.new("VectorForce")
				force.Force = unit * speed
			end
			force.Attachment0 = impactPoint
			force.Name = "ImpactVelocity"
			force.Parent = part
			
			
			force.RelativeTo = Enum.ActuatorRelativeTo.World
			
			task.delay(impactData.Lifetime or 0.3, function()
				if force then
					force:Destroy()
				end
				if impactPoint then
					impactPoint:Destroy()
				end
			end)
		end
	end
end

local function rigMotor(character, motor, modeModule, r6)
	if not motor:IsA("Motor6D") then
		return
	end
	
	local constraints = getConstraintType(motor, modeModule)
	if constraints == "None" then
		if debugPrintMode then
			print("[" .. script.Name ..  "] ConstraintType: [None] applied to Motor: [" .. motor.Name .. "]")
		end
		return
	end
	if typeof(constraints) == "string" then
		constraints = {constraints}
	end
	
	local attach0, attach1 = getLimbAttachments(motor, r6)
	if r6 then
		local data = ragdollData[character]
		table.insert(data.R6Attachments, attach0)
		table.insert(data.R6Attachments, attach1)
	end

	local newConstraintAdded = false
	
	for _, constraintValue in constraints do
		local isConstraintInstance = typeof(constraintValue) == "Instance"
		local constraintName = isConstraintInstance and constraintValue.Name or constraintValue
		if debugPrintMode then
			print("[" .. script.Name ..  "] ConstraintType: [" .. constraintName .. "] applied to Motor: [" .. motor.Name .. "]")
		end
		
		if not isConstraintInstance and not modeModule.ConstraintTypes[constraintValue] then
			if debugPrintMode then
				warn("[" .. script.Name ..  "] Missing ConstraintType: [" .. constraintName .. "]")
			end
			continue
		end
		local newConstraint
		if not isConstraintInstance then
			newConstraint = modeModule.ConstraintTypes[constraintValue](character, motor, r6, attach0, attach1)
		else
			newConstraint = constraintValue:Clone()
		end
		
		if newConstraint then
			newConstraintAdded = true
			newConstraint.Name = "Ragdoll" .. newConstraint.ClassName
			
			local usePart0 = pcall(function()
				newConstraint.Part0 = newConstraint.Part0
			end)
			if usePart0 then
				newConstraint.Part0 = motor.Part0
				newConstraint.Part1 = motor.Part1
			else
				if not attach0 then
					newConstraint:Destroy()
					continue
				end
				newConstraint.Attachment0 = attach0
				newConstraint.Attachment1 = attach1
			end
			newConstraint.Enabled = false
			newConstraint.Parent = motor.Parent

			table.insert(ragdollData[character].Constraints, newConstraint)
		end
	end
	if newConstraintAdded then
		table.insert(ragdollData[character].Motors, motor)
	elseif debugPrintMode then
		warn("[" .. script.Name .. "] No return value among ConstraintTypes: [", constraints, "] (Motor: [" .. motor.Name .. "])")
	end
end

local function addToMotorsTable(motors: table, newEntry: Instance, nameOverride: string)
	local name = nameOverride or newEntry.Name
	
	if name == "Default" then
		table.insert(motors, newEntry)
		return
	end
	
	if not motors[name] then
		motors[name] = {}
	end
	table.insert(motors[name], newEntry)
end

local function loadRagdollMode(instance: Instance)
	if instance:IsA("ModuleScript") then
		return require(instance)
	elseif instance:IsA("Folder") then
		local modeData = {}
		
		local constraintsFolder = instance:FindFirstChild("Constraints")
		local settingsFolder = instance:FindFirstChild("Settings")
		local functionsModule = instance:FindFirstChild("RagdollStateFunctions")
		functionsModule = functionsModule and require(functionsModule)
		modeData.Motors = {}
		modeData.ConstraintTypes = "LoadedFromInstance"
		modeData.DefaultConstraintType = {}
		
		if constraintsFolder then
			for _, constraintType in constraintsFolder:GetChildren() do
				local selectedMotorsTable
				if constraintType.Name == "Default" then	
					selectedMotorsTable = modeData.DefaultConstraintType
				else
					selectedMotorsTable = modeData.Motors
				end
				if constraintType:IsA("Folder") then
					for _, subConstraintType in constraintType:GetChildren() do
						if subConstraintType:IsA("StringValue") and subConstraintType.Value == "None" then
							if debugPrintMode then
								warn("[" .. script.Name .. "]" .. [[ Do not use keyword "None" inside a Folder]])
							end
							continue
						end
						addToMotorsTable(selectedMotorsTable, subConstraintType, constraintType.Name)
					end
				else
					if constraintType:IsA("StringValue") and constraintType.Value == "None"  then
						modeData.Motors[constraintType.Name] = "None"
						continue
					end
					addToMotorsTable(selectedMotorsTable, constraintType)
				end
			end
		end
		
		if #modeData.DefaultConstraintType == 0 then
			modeData.DefaultConstraintType = "None"
		end
		
		if settingsFolder then
			for _, setting in settingsFolder:GetChildren() do
				modeData[setting.Name] = setting.Value
			end
		end
		
		if functionsModule then
			for name, func in functionsModule do
				modeData[name] = func
			end
		end
		
		return modeData
	end
	if debugPrintMode then
		warn("[" .. script.Name .. "] Unsupported Ragdoll Mode type [" .. instance.ClassName .. "] (Must be a Folder or ModuleScript)")
	end
end

local function onPlayerAdded(player: Player, ragdollMode: string)
	if player.Character then
		task.spawn(function()
			ragdollModule.RigCharacter(player.Character, ragdollMode)
		end)
	end
	player.CharacterAdded:Connect(function(character)
		ragdollModule.RigCharacter(character, ragdollMode)
	end)
end

function ragdollModule.RigPlayers(ragdollMode: string)
	if ragdollModule.PlayersRigged then
		return
	end
	ragdollModule.PlayersRigged = true
	for _, player in game.Players:GetPlayers() do
		task.spawn(onPlayerAdded, player, ragdollMode)
	end
	game.Players.PlayerAdded:Connect(function(player)
		onPlayerAdded(player, ragdollMode)
	end)
end

function ragdollModule.RigCharacter(character:Model, ragdollMode: string)
	local humanoid = character:WaitForChild("Humanoid")
	local r6 = humanoid.RigType.Value == 0
	
	local defaultMode = RagdollModes:GetAttribute("DefaultMode")
	
	local modeModuleObject = ragdollMode and RagdollModes:FindFirstChild(ragdollMode) or 
		(defaultMode and defaultMode ~= "" and RagdollModes:FindFirstChild(defaultMode) or RagdollModes:FindFirstChild("Default"))
	local modeModule = loadRagdollMode(modeModuleObject)
	
	local r6ModeModule = modeModule.R6RagdollMode
	if r6ModeModule and r6 then
		if typeof(r6ModeModule) == "table" then
			modeModule = r6ModeModule
		elseif typeof(r6ModeModule) == "string" then
			modeModule = loadRagdollMode(RagdollModes:FindFirstChild(r6ModeModule))
		elseif typeof(r6ModeModule) == "Instance" and (r6ModeModule:IsA("ModuleScript") or r6ModeModule:IsA("Folder")) then
			modeModule = loadRagdollMode(r6ModeModule)
		elseif debugPrintMode then
			warn("[" .. script.Name .. "] Unsupported R6RagdollMode type. Must be a string(that matches a module in RagdollModes folder), ModuleScript (return table or object)")
		end
	end
	
	if ragdollData[character] then
		ragdollModule.UnrigCharacter(character)
	end
	ragdollData[character] = {Motors = {}, Constraints = {}, Connections = {}, R6Attachments = {}, RagdollMode = modeModule}
	local data = ragdollData[character]
	
	
	humanoid.BreakJointsOnDeath = modeModule.BreakJointsOnDeath
	
	local player = game.Players:GetPlayerFromCharacter(character)
	local stateManager = player and character:FindFirstChild("PlayerRagdollManager") or character:FindFirstChild("NPCRagdollManager")
	
	if not stateManager then
		stateManager = player and script.PlayerRagdollManager:Clone() or script.NPCRagdollManager:Clone()
		stateManager.Parent = character
		stateManager.Enabled = true
	end

	for _, instance in pairs(character:GetDescendants()) do
		task.spawn(rigMotor, character, instance, modeModule, r6)
	end
	data.Connections.DescendantAdded = character.DescendantAdded:Connect(function(instance)
		rigMotor(character, instance, modeModule, r6)
	end)
	data.Connections.Destroyed = character:GetPropertyChangedSignal("Parent"):Connect(function()
		if not character.Parent then
			ragdollModule.UnrigCharacter(character)
		end
	end)

	data.Functions = {}
	data.Functions.PreRagdollEnabledFunction = modeModule.PreRagdollEnabledFunction
	data.Functions.AfterRagdollEnabledFunction = modeModule.AfterRagdollEnabledFunction
	data.Functions.PreRagdollDisabledFunction = modeModule.PreRagdollDisabledFunction
	data.Functions.AfterRagdollDisabledFunction = modeModule.AfterRagdollDisabledFunction
	
	data.Functions.RagdollRiggedFunction = modeModule.RagdollRiggedFunction
	data.Functions.RagdollUnriggedFunction = modeModule.RagdollUnriggedFunction
	
	if data.Functions.RagdollRiggedFunction then
		data.Functions.RagdollRiggedFunction(character, data)
	end
	character:SetAttribute("RagdollMode", modeModuleObject.Name)
	character:SetAttribute("RagdollLoaded", true)
end

function ragdollModule.UnrigCharacter(character:Model)
	local data = ragdollData[character]
	if not data then
		return
	end
	if character.Parent then
		ragdollModule.DisableRagdoll(character)
		character:SetAttribute("RagdollLoaded", false)
		character:SetAttribute("RagdollMode", nil)
		if character:FindFirstChild("Humanoid") then
			character.Humanoid.BreakJointsOnDeath = true
		end
	end
	
	for _, connection in data.Connections do
		connection:Disconnect()
	end
	for i, constraint in data.Constraints do
		constraint:Destroy()
	end
	for _, attachment in data.R6Attachments do
		attachment:Destroy()
	end
	if data.Functions.RagdollUnriggedFunction then
		data.Functions.RagdollUnriggedFunction(character, data)
	end
	ragdollData[character] = nil
end

function ragdollModule.EnableRagdoll(character: Model, impactData: table)
	--Check if character is fully loaded and not already in ragdoll state
	if not character then
		return
	end
	if not character:GetAttribute("RagdollLoaded") then
		if debugPrintMode then
			warn("[" .. script.Name ..  "] (Enable) Ragdoll module not initialized for character: " .. character:GetFullName())
		end
		return
	end
	if character:GetAttribute("Ragdolled") then
		return
	end
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoidRootPart or not humanoid then
		return
	end
	
	local data = ragdollData[character]
	
	if data.Functions.PreRagdollEnabledFunction then
		local returnValue = data.Functions.PreRagdollEnabledFunction(character, data, impactData)
		if returnValue == "Sink" then
			return
		elseif typeof(returnValue) == "table" then
			impactData = returnValue
		end
	end
	
	if script:GetAttribute("SetNPCOwnershipToServer") and not game.Players:GetPlayerFromCharacter(character) then
		if humanoidRootPart:CanSetNetworkOwnership() then
			humanoidRootPart:SetNetworkOwner(nil)
		end
	end
	

	--Update ragdoll state
	character:SetAttribute("Ragdolled", true)

	--Set humanoid states and root part properties
	
	--humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
	--humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
	humanoid.AutoRotate = false

	humanoidRootPart.CanCollide = false
	
	

	--Enable constraints, disable motors
	for _, constraint in data.Constraints do
		constraint.Enabled = true
	end
	for _, motor in data.Motors do
		motor.Enabled = false
	end
	
	--Apply impact velocity if available
	if impactData then
		--RunService.Heartbeat:Wait()
		applyImpact(character, impactData)
	end
	
	if data.Functions.AfterRagdollEnabledFunction then
		data.Functions.AfterRagdollEnabledFunction(character, data, impactData)
	end
end

function ragdollModule.DisableRagdoll(character: Model)
	--Check if character is fully loaded and not already in ragdoll state
	if not character then
		return
	end
	if not character:GetAttribute("RagdollLoaded") then
		if debugPrintMode then
			warn("[" .. script.Name ..  "] (Disable) Ragdoll module not initialized for character: " .. character:GetFullName())
		end
		return
	end
	if not character:GetAttribute("Ragdolled") then
		return
	end
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoidRootPart or not humanoid then
		return
	end
	
	local data = ragdollData[character]
	
	if data.Functions.PreRagdollDisabledFunction then
		local returnValue = data.Functions.PreRagdollDisabledFunction(character, data)
		if returnValue == "Sink" then
			return
		end
	end
	
	
	humanoidRootPart.CanCollide = true
	humanoid.AutoRotate = true

	for _, constraint in data.Constraints do
		constraint.Enabled = false
	end
	for _, motor in data.Motors do
		motor.Enabled = true
	end

	character:SetAttribute("Ragdolled", false)
	
	if data.Functions.AfterRagdollDisabledFunction then
		data.Functions.AfterRagdollDisabledFunction(character, data)
	end
	
	if script:GetAttribute("SetNPCOwnershipToServer") and not game.Players:GetPlayerFromCharacter(character) then
		if humanoidRootPart:CanSetNetworkOwnership() then
			humanoidRootPart:SetNetworkOwnershipAuto()
		end
	end
end

return ragdollModule
]]></ProtectedString>
							<string name="ScriptGuid">{8E304F84-1BAE-452E-9943-A840FA7A797B}</string>
							<BinaryString name="AttributesSerialize"><![CDATA[AwAAAA4AAABEZWJ1Z1ByaW50TW9kZQMAFwAAAFNldE5QQ093bmVyc2hpcFRvU2VydmVyAwEH
AAAAVmVyc2lvbgIDAAAAMS4x]]></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Ragdoll</string>
							<int64 name="SourceAssetId">87270072599288</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="LocalScript" referent="RBXC141D1C42B95407D8AD4798F5EDBD558">
							<Properties>
								<ProtectedString name="Source"><![CDATA[local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid: Humanoid = character:WaitForChild("Humanoid")
character:GetAttributeChangedSignal("Ragdolled"):Connect(function()
	local newState = character:GetAttribute("Ragdolled")
	if newState then
		humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
	else
		humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
		
	end
end)]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{EFD9B0BF-F10B-4980-876C-70179BB2FAD4}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PlayerRagdollManager</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX647A88BE433B483D99643DD6EA45FCCF">
							<Properties>
								<ProtectedString name="Source"><![CDATA[local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")

character:GetAttributeChangedSignal("Ragdolled"):Connect(function()
	local newState = character:GetAttribute("Ragdolled")
	if newState then
		humanoid:ChangeState(Enum.HumanoidStateType.Physics)
		humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
	else
		humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
		humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)

	end
end)
]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{A7423B39-4798-4387-99C8-D47F9250D4F4}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">NPCRagdollManager</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7285BB9BD1F64418B1A16ECAA10F36E0">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local Ragdoll = script.Parent
local ConstraintTypes = Ragdoll.ConstraintTypes

return function(...)
	local constraintTypeModules = {...}
	
	local sendingTable = {}
	
	for _, constraintTypeModule in constraintTypeModules do
		local module = constraintTypeModule
		if typeof(module) == "string" then
			module = ConstraintTypes:FindFirstChild(module)
		end
		
		if module then
			
			if typeof(module) ~= "table" then
				module = require(module)
			end
			for i, v in module do
				sendingTable[i] = v
			end
			
		elseif Ragdoll:GetAttribute("DebugPrintMode") then
			if constraintTypeModule then
				warn("Module: [" .. constraintTypeModule .. "] does not exist in ConstraintTypes folder(" .. ConstraintTypes:GetFullName() .. ")")
			else
				warn("ConstraintType module does not exist")
			end
		end
	end
	
	return sendingTable
end
]]></ProtectedString>
								<string name="ScriptGuid">{C2785C36-4B55-48B5-9413-90FC41493514}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">LoadConstraintTypes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX9407456F91964183AE4484FEB2F5230F">
							<Properties>
								<ProtectedString name="Source"><![CDATA[--[[
Made by Ike
Devforum Post: https://devforum.roblox.com/t/customizable-ragdoll-module-create-your-own-custom-ragdolls/3545305

FEATURES
	
	R15 and R6 compatibility
	Player and NPC support
	Premade scripts (Button to Ragdoll, Ragdoll Death)
	Customizable: You can create your own ragdoll settings
	Multiple RagdollModes: You can rig each character with different ragdoll settings

QUICKSTART
	
	You can place the Ragdoll Module where you'd like, but I recommend placing it in ServerScriptService
	This module comes with a default RagdollMode that should work just fine for most users, and is optimized for both R15 and R6.
	I have made two scripts (Button to Ragdoll, Ragdoll Death) that you can use to easily add this module into your experience
	These are located in the PremadeScripts Folder in the module. See the README in this folder for installation instructions.
	See section "PREMADE SCRIPTS SETTINGS" for settings
	
BASIC USAGE

	1.
	Load the module
	local Ragdoll = require(ServerScriptService.Ragdoll)
	2. Rig characters, you can do this by rigging each character individually
		Ragdoll.RigCharacter(character, ragdollMode)
		--if ragdollMode is nil, then it will apply a default value (either the RagdollModes Folder's DefaultMode attribute or "Default")
		--If the character is already rigged, this function will automatically unrig the character before rigging it again with the new ragdollMode
		--It's a good idea to run this as soon as possible instead of rigging, then immediately ragdolling. But if you can't avoid it, it should still work fine
	OR you can rig every player and players that join after by using
		Ragdoll.RigPlayers(ragdollMode)
	3. Ragdoll/unragdoll the character
		Ragdoll.EnableRagdoll(character, impactData) --(impactData is explained in the Module Functions section)
		Ragdoll.DisableRagdoll(character)


MODULE SETTINGS
	DebugPrintMode: Gives information that may be helpful when debugging, especially for catching typos
	(RagdollModes Folder) DefaultMode: Set this to the name of a module in this folder that you want to be the default mode. If this is blank, "Default" will be used instead


PREMADESCRIPTS SETTINGS
	
	Each script has settings that you can change. These will either be an attribute ( in the Property window) or as a module named "Configuration"
	The following section will explain what each setting does

	PressButtonToRagdoll
		(ButtonRagdollServer)
			RagdollMode: Set this to the name of the RagdollMode you want to use (in RagdollModes folder), will use the default RagdollMode if empty
			AutoRigPlayers: If enabled, automatically rigs every player and players who join later. If using multiple scripts that have this setting,
				make sure to only have it enabled on one script
			ApplyMoveDirectionVelocity: If enabled, adds Humanoid's MoveDirection to ragdoll's velocity
		
		(ButtonRagdollClient Configuration Module)
			Cooldown: How many seconds until player can ragdoll again
			CreateMobileButton: If true, will make a mobile button
			KeyCode: Keyboard button to activate
			ControllerCode: Controller button to activate
			RemoteEvent: RemoteEvent to fire to toggle ragdoll state
	
	RagdollDeath
		RagdollMode: Set this to the name of the RagdollMode you want to use (in RagdollModes folder), will use the default RagdollMode if empty
		AutoRigPlayers: If enabled, automatically rigs every player and players who join later. If using multiple scripts that have this setting,
				make sure to only have it enabled on one script
		ApplyMoveDirectionVelocity: If enabled, adds Humanoid's MoveDirection to ragdoll's velocity
		FixDoubleDeathSound: Fixes double death sound by removing the player's HumanoidStateManager on death
		CreateDummy: If enabled creates a separate character on death. this prevents it from being destroyed when the character respawns
			Note: If you enable this, make sure to place the DummyCamera localscript in StarterPlayerScripts (this script is located in the RagdollDeath script)
		DummyLifetime: If CreateDummy is enabled, after this amount of seconds, the dummy will be removed
			
		


CREATING A NEW RAGDOLLMODE

	(Check out the ExampleTemplate Module in RagdollModes Folder for detailed explanations on what everything does.)
	
	Create a new RagdollMode ModuleScript
		Open the RagdollModes folder. Every RagdollMode needs to be placed here to work. You can copy and paste the Default or ExampleTemplate ModuleScript
		to use as a base if you would like
		and modify those if you would like. ExampleTemplate lists and explains every setting/function in detail.
		
	Create a ConstraintTypes (table or ModuleScript in ConstraintTypes Folder)
	If you use a ModuleScript, I have created a module to load multiple ConstraintTypes modules, 
	you can use this module by doing 
		local LoadConstraintTypes = require(Ragdoll.LoadConstraintTypes)
		local ConstraintTypes = LoadConstraintTypes("Example", "Example2")
	You can load as many as you want, just note that each module will overwrite each module to the left of it (this only applies to matching entries)
	(example: "ConstraintType1" in "Example2" will overwrite "ConstraintType1" in "Example")
	This is the format for each ConstraintType in the ConstraintTypes table
		ConstraintTypes.ConstraintName = function(character, motor, r6, attach0, attach1) --You can omit the parameters if you aren't using them
			local newConstraint = Instance.new([ClassName]) --This instance needs an Enabled property and either a Attachment0/1 or Part0/1 property to work
			--modify newConstraint
			return newConstraint
		end
	(IMPORTANT) Make sure to set the RagdollMode.ConstraintTypes to the ConstraintTypes table
	Once you are done creating your ConstraintTypes table, now you can pick which ConstraintType is applied to each motor in the RagdollMode.Motors table
	Motors table format:
		MotorName = "ConstraintType"
	MotorName is the characters motor that "ConstraintType" will be applied to
	The MotorName can either be the exact Motor6D name or a part of it. For example MotorName "RightShoulder" will only apply to the "RightShoulder" Motor6D,
	while MotorName "Shoulder" will apply to both Motor6Ds "LeftShoulder" and "RightShoulder"
	"ConstraintType" can also be set to a table to apply multiple ConstraintTypes to one Motor6D (MotorName = {"ConstraintType1", "ConstraintType2"})
	This can be useful if you want to add trails to your ragdoll
	If a MotorName is set to nil it will use the RagdollMode.DefaultConstraintType value (below the Motors table). If set to "None" that motor will be
	skipped and will not be disabled when the character ragdolls
	If RagdollMode.DefaultConstraintType is not set, it will default to "Default"
	There are two more settings: R6RagdollMode and BreakJointsOnDeath, both these settings can be deleted if you aren't using them
		R6Ragdollmode: if the characters rig is R6, this RagdollMode will be loaded instead. If this is set to nil, then the current RagdollMode will be used for both
			R6 and R15
			This value can be a ModuleScript object, a loaded ModuleScript, or a string (must match a ModuleScript in RagdollModes Folder)
		BreakJointsOnDeath: disables the character falling apart on death (defaults to false)
	There are also four functions that fire when the character is ragdolled/unragdolled. See the ExampleTemplate for instructions on how to use these.
	If you don't need them, they can be deleted
	Your RagdollMode should now be ready to use! Don't forget to test it and if you are using my PremadeScripts, then change the RagdollMode setting to your new
	RagdollMode
	
	


MODULE FUNCTIONS
	
	Ragdoll.RigCharacter(character, ragdollMode)
		Rigs character by setting up attachments and constraints using ragdollMode
		Before rigging, this function will automatically unrig the character if it is already rigged
		if ragdollMode is nil, it will default to the default RagdollMode folder setting or "Default"
	
	Ragdoll.UnrigCharacter(character)
		Removes constraints and new attachments created, and unragdolls the character
		
	Ragdoll.EnableRagdoll(character, impactData)
		Will ragdoll the character if it is rigged, and not already in a ragdolled state,
		impactData affects the velocity applied to the character (this can be nil for no added velocity)
		
		impactData usage:
			impactData = {
				Part = Can be [Part in character] or [name of part in character]. If nil then this will default to HumanoidRootPart if available
				Hit = [Vector3] Position on impactData.Part to apply impact. If nil then defaults to impactData.Part's position
				Direction = [Vector3] Direction of impact
				Speed = [number] Speed of impact (default = 350)
				Lifetime = [number] Amount of time that the impact will last (default = 0.3)
				UseLinearVelocity = [bool] If true, use a LinearVelocity Instance instead of VectorForce Instance
			}
			
	Ragdoll.DisableRagdoll(character)
		Will unragdoll the character if it is rigged, and in a ragdolled state
		This function will be called automatically when UnrigCharacter() is called

	Ragdoll.RigPlayers(ragdollMode)
		Automatically rigs every player with the provided ragdollMode
		If this function was already run, it will not run again
	

CHARACTER ATTRIBUTES

	These are the attributes applied to each character model rigged by this module:
		Ragdolled = boolean : This is enabled when the character is in a ragdolled state
		RagdollLoaded = boolean : This is enabled after character is done being rigged and is ready to be ragdolled
		RagdollMode = string : This is the currently selected RagdollMode for the character (Note that this will not change if R6RagdollMode setting gets applied)

]]
]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{4242C3B8-5CB8-41EC-8235-95A70A9326D6}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">(READ ME) Instructions</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX0FA50F3832574CD29EFEF75B4AA0538E">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABEZWZhdWx0TW9kZQIHAAAARGVmYXVsdA==</BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">RagdollModes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXF5797B46708141F5A03647F056EB313A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}
local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes)

local ConstraintTypes = LoadConstraintTypes("Default")

ConstraintTypes.Default = function()
	local constraint = Instance.new("BallSocketConstraint")
	return constraint
end

ragdollMode.Motors = {
	Root = "Weld",
	Neck = "NeckHinge",
	Wrist = "WristAnkleSocket",
	Ankle = "WristAnkleSocket",
}
ragdollMode.DefaultConstraintType = "Default"
ragdollMode.ConstraintTypes = ConstraintTypes

return ragdollMode
]]></ProtectedString>
									<string name="ScriptGuid">{54703410-B92A-4D7E-ACB3-8A5D25554277}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Elastic</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6A9EE8CC826946CF9D6AFC855FEF6D65">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}
local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes)

local ConstraintTypes = LoadConstraintTypes("Default")

ConstraintTypes.Default = function(character, motor)
	local constraint = Instance.new("RopeConstraint")
	constraint.Visible = true
	constraint.Color = motor.Parent.BrickColor
	constraint.Length = 2
	return constraint
end
ConstraintTypes.Trail = function()
	local trail = Instance.new("Trail")
	trail.Lifetime = 0.1
	trail.Transparency = NumberSequence.new(0.5, 1)
	trail.WidthScale = NumberSequence.new(0.8, 0)
	return trail
end

ragdollMode.Motors = {
	Neck = "NeckHinge",
	Root = "Weld",
	Wrist = "WristAnkleSocket",
	Ankle = "WristAnkleSocket",
	Waist = "Weld",
}
ragdollMode.DefaultConstraintType = {"Default", "Trail"}
ragdollMode.ConstraintTypes = ConstraintTypes

return ragdollMode
]]></ProtectedString>
									<string name="ScriptGuid">{675C62F8-B551-4264-95A9-6FDD6B1B9115}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Rope</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB4C195E74F594C8EB06B2F97146D2E7D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}

local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes) --Loads ConstraintTypes from ConstraintType Folder

local ConstraintTypes = LoadConstraintTypes("Default") -- List all the Constraint Types you want to load (continued on next line)
--(continued) Matching ConstraintTypes will be overwritten by the next argument (example LoadConstraintTypes("a", "b") "b" will overwrite "a")
--(continued) Values with Different names will not be overwritten (example "Weld" will only overwrite which has the name "Weld")
--(continued) Accepted argument types: String ("" [Must be in Ragdoll.ConstraintTypes]), ModuleScript (Instance), or a table (can be a loaded ModuleScript)

ConstraintTypes.Example = function(character, motor, r6, attach0, attach1) -- This is an example ConstraintTypes entry that I will use to explain its function
	--Notice that this entry is local to this script only and will not write to the "Default" ModuleScript it is loaded from. This is a feature of the
	--LoadConstraintTypes ModuleScript
	--If you use a loaded ModuleScript as your ConstraintTypes table (example: require(ConstraintTypes.Default)) any entry you make will write to that Module,
	--and also overwrite that entry if there is a matching one
	--[[Parameters: 
		character: The characterModel being rigged
		motor: The motor that this ConstraintType is being applied to
		r6: This is true if the character is an R6 rig
		attach0, attach1: These are the attachments used by the ConstraintType. if the character's rig is R6, new attachments will be made when rigging the character,
		but if the rig is R15, it will use the attachments already created by Roblox's CoreScripts, so be careful when modifying these
		]]
	
	local newConstraint = Instance.new("BallSocketConstraint") --The constraint instance to be used. Make sure to return this and only one constraint per ConstraintType
	--The requirements for a constraint is that it needs an Enabled property and either a Part0/Part1 or Attachment0/Attachment1 property
	
	newConstraint.LimitsEnabled = true
	--Modify the constraint before returning if you wish
	
	return newConstraint --Return the newly created constraint
end


ragdollMode.Motors = { --Applied motors. The only keyword is "None", this keyword will skip that motor, meaning it won't be disabled when ragdolling
	--You can apply multiple ConstraintTypes to each motor by using a table (example: Waist = {"Weld", "Example", "Trail"})
	Root = "Weld", --"Root" is the motor in the character model, "Weld" is the ConstraintType

	Neck = "NeckHinge", 
	Waist = "Weld",

	Shoulder = "Default",
	Elbow = "ElbowSocket",
	Wrist = "WristAnkleSocket",

	Hip = "Default",
	Knee = "KneeSocket",
	Ankle = "WristAnkleSocket",
}
--Motors: 

ragdollMode.R6RagdollMode = nil --Will load this module instead if character rig is R6
ragdollMode.DefaultConstraintType = "None" --Default ConstraintType, this value will be used when a Motor is set to nil
ragdollMode.ConstraintTypes = ConstraintTypes --This is the table of ConstraintTypes that this module will be using during gameplay
ragdollMode.BreakJointsOnDeath = false --Defaults to true


-- Below are the functions that will fire when the character's ragdoll enables or disables, rigs/ unrigs
-- You can delete these if you don't want to use them
-- The Pre function fires before changes are made to the character, and After is once all changes are made
-- The Rigged function fires right after the rigData table is created, Unrigged fires right before the rigData table is deleted
-- Returning "Sink" for the Pre functions will cancel the ragdoll enable/disable
-- You can change data in impactData and it will affect the characters velocity, just make sure to check if impactData exists before trying to make changes
--(example) if impactData then impactData.Speed *= 2 end
-- If you set impactData to a new table (example impactData = {}) in the PreRagdollEnableFunction, the main module will not use that new table
-- To get around this, you can return the new table. So any table set as the return value will be used as impactData in the main module
-- Changing impactData in the AfterRagdollEnabledFunction doesn't do anything. It is there mainly for if you want to see if impactData is being updated properly

--rigData is a table that is created when a character is rigged. It is structured like so:
--Constraints: Constraints created by the current RagdollMode
--Motors: Character's Motor6Ds that are in use by the current RagdollMode
--R6Attachments: A table of attachments that is created when rigging if the character's rig is R6
--Connections: A table of connections made when rigging the character (mainly used for cleanup, and to rig motors)
--RagdollMode: The loaded RagdollMode Module
--Functions: A table of the below functions ([Pre/After]Ragdoll[Enabled/Disabled]Function)

--You will probably only need the Constraints table and maybe the Motors or R6Attachments table, the rest you can ignore

ragdollMode.PreRagdollEnabledFunction = function(character, rigData, impactData)

end
ragdollMode.AfterRagdollEnabledFunction = function(character, rigData, impactData)

end
ragdollMode.PreRagdollDisabledFunction = function(character, rigData, beingUnrigged)

end
ragdollMode.AfterRagdollDisabledFunction = function(character, rigData, beingUnrigged)

end

ragdollMode.RagdollRiggedFunction = function(character, rigData)
	
end
ragdollMode.RagdollUnriggedFunction = function(character, rigData)
	
end

return ragdollMode
]]></ProtectedString>
									<string name="ScriptGuid">{A128E68D-9D38-428F-BA7A-3C793A694AF0}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ExampleTemplate</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX247CF6531C714932A3467460CA57730E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}
local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes)

local ConstraintTypes = LoadConstraintTypes("Default", "R6AttachmentFix")


ragdollMode.Motors = {
	Root = "Weld",

	Neck = "NeckHinge",
	Shoulder = {"Default", "R6ShoulderFix"},
	Hip = {"Default", "R6HipFix"},
}

ragdollMode.DefaultConstraintType = "Default"
ragdollMode.ConstraintTypes = ConstraintTypes

ragdollMode.PreRagdollEnabledFunction = function(character, rigData, impactData)
	
	if not impactData or (impactData.Direction and impactData.Direction.Magnitude == 0) then
		local root = character:FindFirstChild("HumanoidRootPart")
		local humanoid = character:FindFirstChild("Humanoid")
		if root and humanoid and humanoid.MoveDirection.Magnitude == 0 then
			local params = RaycastParams.new()
			params.FilterType = Enum.RaycastFilterType.Exclude
			params.FilterDescendantsInstances = {character}
			local result = workspace:Raycast(root.Position, root.CFrame.UpVector * -3.5, params)
			if result then
				impactData = {
					Part = root,
					Speed = 13,
					Direction = root.CFrame.LookVector * -1,
					Lifetime = 0.13,
					UseLinearVelocity = true,
				}
				return impactData
			end
		end
	else
		impactData.Speed /= 1.917
	end
end

return ragdollMode
]]></ProtectedString>
									<string name="ScriptGuid">{B0778628-2758-49CE-A5D7-D6E345B3BB08}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DefaultR6</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXCB060B9D9BBA49D39B432EFB45B96E4F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RagdollModule = script.Parent.Parent

local ragdollMode = {}
local LoadConstraintTypes = require(RagdollModule.LoadConstraintTypes)

local ConstraintTypes = LoadConstraintTypes("Default")

ragdollMode.Motors = {
	Root = "Weld",

	Neck = "NeckHinge",
	Waist = "Weld",

	Shoulder = nil,
	Elbow = "ElbowSocket",
	Wrist = "WristAnkleSocket",

	Hip = nil,
	Knee = "KneeSocket",
	Ankle = "WristAnkleSocket",
}

ragdollMode.R6RagdollMode = "DefaultR6"
ragdollMode.DefaultConstraintType = "Default"
ragdollMode.ConstraintTypes = ConstraintTypes

return ragdollMode
]]></ProtectedString>
									<string name="ScriptGuid">{C8C0CE77-8AC9-42C4-9ACD-918FF5A5E693}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Default</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX00C5CA1659624FC2B6A8FFF20FE114E4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">FolderExampleTemplate</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX55F4907DF92F4566A91F1C48F02A006F">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local ragdollStateFunctions = {}

-- Below are the functions that will fire when the character's ragdoll enables or disables, rigs/ unrigs
-- You can delete these if you don't want to use them
-- The Pre function fires before changes are made to the character, and After is once all changes are made
-- The Rigged function fires right after the rigData table is created, Unrigged fires right before the rigData table is deleted
-- Returning "Sink" for the Pre functions will cancel the ragdoll enable/disable
-- You can change data in impactData and it will affect the characters velocity, just make sure to check if impactData exists before trying to make changes
--(example) if impactData then impactData.Speed *= 2 end
-- If you set impactData to a new table (example impactData = {}) in the PreRagdollEnableFunction, the main module will not use that new table
-- To get around this, you can return the new table. So any table set as the return value will be used as impactData in the main module
-- Changing impactData in the AfterRagdollEnabledFunction doesn't do anything. It is there mainly for if you want to see if impactData is being updated properly

--rigData is a table that is created when a character is rigged. It is structured like so:
--Constraints: Constraints created by the current RagdollMode
--Motors: Character's Motor6Ds that are in use by the current RagdollMode
--R6Attachments: A table of attachments that is created when rigging if the character's rig is R6
--Connections: A table of connections made when rigging the character (mainly used for cleanup, and to rig motors)
--RagdollMode: The loaded RagdollMode Module
--Functions: A table of the below functions ([Pre/After]Ragdoll[Enabled/Disabled]Function)

--You will probably only need the Constraints table and maybe the Motors or R6Attachments table, the rest you can ignore

ragdollStateFunctions.PreRagdollEnabledFunction = function(character, rigData, impactData)
	
end
ragdollStateFunctions.AfterRagdollEnabledFunction = function(character, rigData, impactData)
	
end
ragdollStateFunctions.PreRagdollDisabledFunction = function(character, rigData, beingUnrigged)

end
ragdollStateFunctions.AfterRagdollDisabledFunction = function(character, rigData, beingUnrigged)

end

ragdollStateFunctions.RagdollRiggedFunction = function(character, rigData)

end
ragdollStateFunctions.RagdollUnriggedFunction = function(character, rigData)
	
end

return ragdollStateFunctions
]]></ProtectedString>
										<string name="ScriptGuid">{2501208D-EAAE-4F4F-B7E9-E0CDFF74D5D6}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">RagdollStateFunctions</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBXABB8684449434BCBB38F4023A28708B8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Constraints</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="WeldConstraint" referent="RBX57644FCD169C45C28917D15ED1E35558">
										<Properties>
											<CoordinateFrame name="CFrame0">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<Ref name="Part0Internal">null</Ref>
											<Ref name="Part1Internal">null</Ref>
											<int name="State">3</int>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Root</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Folder" referent="RBXB404DF91EE244088BF3BE69F3A83B7C7">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Default</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="BallSocketConstraint" referent="RBX7904879ACBD34BF0B380A2AB1D58ACBE">
											<Properties>
												<bool name="LimitsEnabled">true</bool>
												<float name="MaxFrictionTorqueXml">0</float>
												<float name="Radius">0.150000006</float>
												<float name="Restitution">0</float>
												<bool name="TwistLimitsEnabled">false</bool>
												<float name="TwistLowerAngle">-45</float>
												<float name="TwistUpperAngle">45</float>
												<float name="UpperAngle">45</float>
												<Ref name="Attachment0">null</Ref>
												<Ref name="Attachment1">null</Ref>
												<int name="Color">1009</int>
												<bool name="Enabled">true</bool>
												<bool name="Visible">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">BallSocketConstraint</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="WeldConstraint" referent="RBX1D555A44C6A141D29580C4AAF3EC667C">
										<Properties>
											<CoordinateFrame name="CFrame0">
												<X>0</X>
												<Y>0</Y>
												<Z>0</Z>
												<R00>1</R00>
												<R01>0</R01>
												<R02>0</R02>
												<R10>0</R10>
												<R11>1</R11>
												<R12>0</R12>
												<R20>0</R20>
												<R21>0</R21>
												<R22>1</R22>
											</CoordinateFrame>
											<Ref name="Part0Internal">null</Ref>
											<Ref name="Part1Internal">null</Ref>
											<int name="State">3</int>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Waist</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="HingeConstraint" referent="RBX1EB5CFFFA4F6445E8170FFC51C976DDB">
										<Properties>
											<token name="ActuatorType">0</token>
											<float name="AngularResponsiveness">45</float>
											<float name="AngularSpeed">0</float>
											<float name="AngularVelocity">0</float>
											<bool name="LimitsEnabled">true</bool>
											<float name="LowerAngle">-10</float>
											<float name="MotorMaxAcceleration">500000</float>
											<float name="MotorMaxTorque">0</float>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<float name="ServoMaxTorque">0</float>
											<bool name="SoftlockServoUponReachingTarget">false</bool>
											<float name="TargetAngle">0</float>
											<float name="UpperAngle">10</float>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<int name="Color">1009</int>
											<bool name="Enabled">true</bool>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Neck</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="BallSocketConstraint" referent="RBXFFC345801DB4462E98DDC2F0BF8820D6">
										<Properties>
											<bool name="LimitsEnabled">true</bool>
											<float name="MaxFrictionTorqueXml">0</float>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<bool name="TwistLimitsEnabled">true</bool>
											<float name="TwistLowerAngle">-10</float>
											<float name="TwistUpperAngle">90</float>
											<float name="UpperAngle">45</float>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<int name="Color">1009</int>
											<bool name="Enabled">true</bool>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Knee</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="BallSocketConstraint" referent="RBX1A54B17E84EB4C6D9CC600CC2F8C011C">
										<Properties>
											<bool name="LimitsEnabled">true</bool>
											<float name="MaxFrictionTorqueXml">0</float>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<bool name="TwistLimitsEnabled">true</bool>
											<float name="TwistLowerAngle">-120</float>
											<float name="TwistUpperAngle">10</float>
											<float name="UpperAngle">45</float>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<int name="Color">1009</int>
											<bool name="Enabled">true</bool>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Elbow</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="BallSocketConstraint" referent="RBX7331637B36194B868D11DCA81A563D73">
										<Properties>
											<bool name="LimitsEnabled">true</bool>
											<float name="MaxFrictionTorqueXml">0</float>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<bool name="TwistLimitsEnabled">true</bool>
											<float name="TwistLowerAngle">-15</float>
											<float name="TwistUpperAngle">15</float>
											<float name="UpperAngle">10</float>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<int name="Color">1009</int>
											<bool name="Enabled">true</bool>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Wrist</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="BallSocketConstraint" referent="RBXF8890BA9F28E49CB9CF02B7ED7F5FEB2">
										<Properties>
											<bool name="LimitsEnabled">true</bool>
											<float name="MaxFrictionTorqueXml">0</float>
											<float name="Radius">0.150000006</float>
											<float name="Restitution">0</float>
											<bool name="TwistLimitsEnabled">true</bool>
											<float name="TwistLowerAngle">-15</float>
											<float name="TwistUpperAngle">15</float>
											<float name="UpperAngle">10</float>
											<Ref name="Attachment0">null</Ref>
											<Ref name="Attachment1">null</Ref>
											<int name="Color">1009</int>
											<bool name="Enabled">true</bool>
											<bool name="Visible">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Ankle</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX550ECA5F30184C68807C87D5D7424286">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Settings</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ObjectValue" referent="RBXD0FBF40BCD174929B8827BCB0725D7D8">
										<Properties>
											<Ref name="Value">null</Ref>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">R6RagdollMode</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="BoolValue" referent="RBX6C3B18692D034EC595F9102FF48B6D57">
										<Properties>
											<bool name="Value">false</bool>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">BreakJointsOnDeath</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX99265A0E4AC846C2AB180C7E2DA55791">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">ConstraintTypes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX336F9303DF35411996C4EA6E82A31D6B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local constraintType = {}

constraintType.R6ShoulderFix = function(character, motor, r6, attach0, attach1)
	if r6 then
		attach0.CFrame = attach0.CFrame + attach1.CFrame.LookVector * -0.3
		attach1.CFrame = attach1.CFrame + attach1.CFrame.LookVector * -0.3
	end
end

constraintType.R6HipFix = function(character, motor, r6, attach0, attach1)
	if r6 then
		attach0.CFrame = attach0.CFrame + attach1.CFrame.LookVector * 0.3
		attach1.CFrame = attach1.CFrame + attach1.CFrame.LookVector * 0.3
	end
end

return constraintType
]]></ProtectedString>
									<string name="ScriptGuid">{BF69CA83-7088-4623-80C9-BFB2629FB728}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">R6AttachmentFix</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX28CD3EF095194691A36E22534D41B315">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local constraintTypes = {}

constraintTypes.Default = function(character)
	local constraint = Instance.new("BallSocketConstraint")
	constraint.LimitsEnabled = true
	constraint.TwistLimitsEnabled = true
	return constraint
end
constraintTypes.Weld = function()
	local weld = Instance.new("WeldConstraint")
	return weld
end
constraintTypes.NeckHinge = function()
	local hinge = Instance.new("HingeConstraint")
	hinge.LimitsEnabled = true
	hinge.UpperAngle = 10
	hinge.LowerAngle = -10
	return hinge
end
constraintTypes.KneeSocket = function()
	local constraint = Instance.new("BallSocketConstraint")
	constraint.LimitsEnabled = true
	constraint.TwistLimitsEnabled = true
	constraint.TwistUpperAngle = 90
	constraint.TwistLowerAngle = -10
	return constraint
end
constraintTypes.ElbowSocket = function()
	local constraint = Instance.new("BallSocketConstraint")
	constraint.LimitsEnabled = true
	constraint.TwistLimitsEnabled = true
	constraint.TwistUpperAngle = 10
	constraint.TwistLowerAngle = -120
	return constraint
end
constraintTypes.WristAnkleSocket = function()
	local constraint = Instance.new("BallSocketConstraint")
	constraint.LimitsEnabled = true
	constraint.TwistLimitsEnabled = true
	constraint.UpperAngle = 10
	constraint.TwistUpperAngle = 15
	constraint.TwistLowerAngle = -15
	return constraint
end

return constraintTypes
]]></ProtectedString>
									<string name="ScriptGuid">{619ABB37-54F1-430C-83E5-9C4814D6147D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Default</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX76CB2A0210624478A127873DB56418A8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PremadeScripts</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Script" referent="RBX5A9C2A6E2FD549BC916AA36D27C4C490">
								<Properties>
									<ProtectedString name="Source"><![CDATA[--[[
To install a premade script, open the folder, check each folder for scripts and enable them.
Each script may or may not have its own settings as either Attributes (in the Property window) or a module inside the script named "Configuration",
feel free to change these settings as you wish (you can look up what each setting does in the Instructions folder located in the main Ragdoll module or Devforum post)
Then place each folder into the matching service in the Explorer and press Control + U with the folder selected to ungroup it.

Note for RagdollDeath script: place the script "DummyCamera" into StarterPlayerScripts if you have CreateDummy enabled (disabled by default)
]]
]]></ProtectedString>
									<bool name="Disabled">true</bool>
									<Content name="LinkedSource"><null></null></Content>
									<token name="RunContext">0</token>
									<string name="ScriptGuid">{F3781C75-2348-4B5E-A2BA-2DB9A365FE08}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">(READ ME) How to install</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBXBDE1B66527474AE6941BAD6DF565C70F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">PressButtonToRagdoll</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX1A9F6FF73201438B8FD477B6CE94B752">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ServerScriptService</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Script" referent="RBX20F4067EE0C74EB4B0F764B518EF3B25">
										<Properties>
											<ProtectedString name="Source"><![CDATA[local ServerScriptService = game:GetService("ServerScriptService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")


local Ragdoll = require(script.Module.Value or ServerScriptService.Ragdoll)
local remote = ReplicatedStorage.ChangeRagdollState

local mode = script:GetAttribute("RagdollMode")

if script:GetAttribute("AutoRigPlayers") then
	Ragdoll.RigPlayers(mode ~= "" and mode)
end

remote.OnServerEvent:Connect(function(player, state)
	if player.Character then
		local newState = state or player.Character:GetAttribute("Ragdolled") and "Unragdoll" or "Ragdoll"
		if newState == "Ragdoll" then
			local humanoid = player.Character:FindFirstChild("Humanoid")
			local root:Part = player.Character:FindFirstChild("HumanoidRootPart")
			if not humanoid or not root then
				return
			end
			local impact
			if script:GetAttribute("ApplyMoveDirectionVelocity") then
				impact = {}
				impact.Part = "Head"
				impact.Direction = humanoid.MoveDirection
				impact.Speed = 23 + root.AssemblyLinearVelocity.Magnitude
				impact.Lifetime = 0.13
				impact.UseLinearVelocity = true
			end
			Ragdoll.EnableRagdoll(player.Character, humanoid.FloorMaterial ~= Enum.Material.Air and impact)
		elseif newState == "Unragdoll" then
			Ragdoll.DisableRagdoll(player.Character)
		end
	end
end)]]></ProtectedString>
											<bool name="Disabled">true</bool>
											<Content name="LinkedSource"><null></null></Content>
											<token name="RunContext">0</token>
											<string name="ScriptGuid">{76BC3F22-45CA-4028-B947-6357B9FA0264}</string>
											<BinaryString name="AttributesSerialize"><![CDATA[AwAAABoAAABBcHBseU1vdmVEaXJlY3Rpb25WZWxvY2l0eQMBDgAAAEF1dG9SaWdQbGF5ZXJz
AwELAAAAUmFnZG9sbE1vZGUCAAAAAA==]]></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ButtonRagdollServer</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ObjectValue" referent="RBXAE28656993BB423F8C23495D6B6805DE">
											<Properties>
												<Ref name="Value">RBX44D9523836374B4AABA0EFF13071B8DE</Ref>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Module</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXE5CEC0238E36489F9695038BBB91FB3E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">StarterCharacterScripts</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="LocalScript" referent="RBX9A02924F996C4E4F9E0E9C1945FE229C">
										<Properties>
											<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local configuration = require(script:WaitForChild("Configuration"))



local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local db = false

local function changeRagdollState(actionName, inputState, inputObject)
	if inputState ~= Enum.UserInputState.Begin then
		return
	end
	if db then
		return
	end
	if humanoid and humanoid.Health <= 0 then
		return
	end
	db = true
	configuration.RemoteEvent:FireServer()
	task.wait(configuration.Cooldown)
	db = false
	return Enum.ContextActionResult.Sink
end

ContextActionService:BindAction("Ragdoll", changeRagdollState, configuration.CreateMobileButton, configuration.KeyCode, configuration.ControllerCode)
ContextActionService:SetTitle("Ragdoll", configuration.KeyCode.Name)
local button = ContextActionService:GetButton("Ragdoll")
if button then
	ContextActionService:SetPosition("Ragdoll", UDim2.new(0.9, -button.Size.X.Offset, 0.4, -button.Size.Y.Offset))
end
]]></ProtectedString>
											<bool name="Disabled">true</bool>
											<Content name="LinkedSource"><null></null></Content>
											<token name="RunContext">0</token>
											<string name="ScriptGuid">{FA508208-6740-444A-B1F3-46358E760DD0}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ButtonRagdollClient</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX7BD69E6EF7F044A489EF2152EF6789A4">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local configuration = {}

configuration.Cooldown = 0.25
configuration.CreateMobileButton = true

configuration.KeyCode = Enum.KeyCode.F
configuration.ControllerCode = Enum.KeyCode.ButtonX

configuration.RemoteEvent = ReplicatedStorage.ChangeRagdollState

return configuration
]]></ProtectedString>
												<string name="ScriptGuid">{44DB7BA3-E233-44B2-B7F7-267FE3DE7FF5}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Configuration</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXE84CB54DEFBD4C608127D4E2BEAF8715">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ReplicatedStorage</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="RemoteEvent" referent="RBX61CEF2C7073848ACA42F198AB31BFF2D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ChangeRagdollState</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX3238805A89E445ED989AC82F3AFE2CAD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">RagdollDeath</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX7055D0BE48DC49D4900E98A62EC8DFDD">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ServerScriptService</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Script" referent="RBX1823151B25134FDA81E0762C6BC61069">
										<Properties>
											<ProtectedString name="Source"><![CDATA[local ServerScriptService = game:GetService("ServerScriptService")

local Ragdoll = require(script.Module.Value or ServerScriptService.Ragdoll)

local mode = script:GetAttribute("RagdollMode")

if script:GetAttribute("AutoRigPlayers") then
	Ragdoll.RigPlayers(mode ~= "" and mode)
end

local deadFolder = script:GetAttribute("CreateDummy") and Instance.new("Folder")
local deadStorage
if deadFolder then
	deadFolder.Name = "DeadCharacters"
	deadFolder.Parent = workspace
	
	deadStorage = Instance.new("Folder")
	deadStorage.Name = "DeadCharacterStorage"
	deadStorage.Parent = game.ReplicatedStorage
	
	local folder = script:FindFirstChildOfClass("Folder")
	if folder and folder:FindFirstChild("DummyCamera") then
		warn("[" .. script.Name ..  "] Since you are using CreateDummy, please move the DummyCamera script into StarterPlayerScripts to fix the camera. It is located in a folder in this script")
	end
end

local function onCharacterAdded(character)
	local player = game.Players:GetPlayerFromCharacter(character)
	local humanoid = character:WaitForChild("Humanoid")
	local root = character:WaitForChild("HumanoidRootPart")
	
	humanoid.Died:Connect(function()
		if player and script:GetAttribute("FixDoubleDeathSound") then
			local clientManager = character:FindFirstChild("PlayerRagdollManager")
			if clientManager then
				clientManager:Destroy()
			end
		end
		if deadFolder and player then
			character.Archivable = true
			local dummy = character:Clone()
			dummy.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
			for _, characterScript in dummy:GetChildren() do
				if characterScript:IsA("LocalScript") or characterScript:IsA("Script") then
					characterScript:Destroy()
				end
			end
			character.Parent = deadStorage
			dummy.Parent = deadFolder
			Ragdoll.RigCharacter(dummy, character:GetAttribute("RagdollMode"))
			
			dummy.Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
			dummy.Humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
			dummy.Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
			local oldCharacter = character
			character = dummy
			
			task.delay(2, function()
				if oldCharacter then
					oldCharacter:Destroy()
				end
			end)
			task.delay(script:GetAttribute("DummyLifetime"), function()
				if character then
					character:Destroy()
				end
			end)
		end
		local impact
		if script:GetAttribute("ApplyMoveDirectionVelocity") then
			impact = {}
			impact.Part = "Head"
			impact.Direction = humanoid.MoveDirection
			impact.Speed = 23 + root.AssemblyLinearVelocity.Magnitude
			impact.Lifetime = 0.13
			impact.UseLinearVelocity = true
		end
		
		Ragdoll.EnableRagdoll(character, humanoid.FloorMaterial ~= Enum.Material.Air and impact)
	end)
end

local function onPlayerAdded(player)
	
	if player.Character then
		task.spawn(onCharacterAdded, player.Character)
	end
	player.CharacterAdded:Connect(onCharacterAdded)
end

for _, player in game.Players:GetPlayers() do
	task.spawn(onPlayerAdded, player)
end
game.Players.PlayerAdded:Connect(onPlayerAdded)
]]></ProtectedString>
											<bool name="Disabled">true</bool>
											<Content name="LinkedSource"><null></null></Content>
											<token name="RunContext">0</token>
											<string name="ScriptGuid">{C8EA7462-48C1-4EA3-BCD2-A9D50ED5EC8B}</string>
											<BinaryString name="AttributesSerialize"><![CDATA[BgAAABoAAABBcHBseU1vdmVEaXJlY3Rpb25WZWxvY2l0eQMBDgAAAEF1dG9SaWdQbGF5ZXJz
AwELAAAAQ3JlYXRlRHVtbXkDAA0AAABEdW1teUxpZmV0aW1lBgAAAAAAACRAEwAAAEZpeERv
dWJsZURlYXRoU291bmQDAQsAAABSYWdkb2xsTW9kZQIAAAAA]]></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">RagdollDeath</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ObjectValue" referent="RBX2B988921BDA34F4CAF48C694996B5976">
											<Properties>
												<Ref name="Value">RBX44D9523836374B4AABA0EFF13071B8DE</Ref>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Module</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="Folder" referent="RBX7270302EA96349218BE20159F503865D">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Place into StarterPlayerScripts if CreateDummy is enabled</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="LocalScript" referent="RBXB4ACFEEC6C0843EEBD4190ACE31446AF">
												<Properties>
													<ProtectedString name="Source"><![CDATA[local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera

local folder = workspace:WaitForChild("DeadCharacters")
folder.ChildAdded:Connect(function(dummy)
	if dummy.Name == player.Name then
		local humanoid = dummy:WaitForChild("Humanoid")
		camera.CameraSubject = humanoid
	end
end)]]></ProtectedString>
													<bool name="Disabled">true</bool>
													<Content name="LinkedSource"><null></null></Content>
													<token name="RunContext">0</token>
													<string name="ScriptGuid">{23A39563-FA65-4BE1-ACF5-5D2F0DC39039}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">DummyCamera</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXE66D30D0E7854435B3FE1573C7D1B308">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "Ragdoll",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Ike"},
		{Text = "Description: A Powerful and easy ragdoll library for r15 and r6 rigs, with npc support and a lot more!"},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{842413D8-E6A0-4AB4-AA66-DCF55334F3B4}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX8E463E679D83433FB685FFFB4E134381">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">QuestPP</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXDE082781B2344DE4BA07E7F5C7863E0E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native

--[[
      ___   __ __    ___  _____ ______     __        __
     /   \ |  |  |  /  _]/ ___/|      |   |  |      |  |
    |     ||  |  | /  [_(   \_ |      | __|  |__  __|  |__
    |  Q  ||  |  ||    _]\__  ||_|  |_||        ||        |
    |     ||  :  ||   [_ /  \ |  |  |  |__    __||__    __|
    |     ||     ||     |\    |  |  |     |  |      |  |
     \__,_| \__,_||_____| \___|  |__|     |__|      |__|
    Created by ArtSeb
    v1.0.1
    
    The ultimate quest module for Roblox!
    Handles everything from leveling systems to item collection and achievements.

    Features:
    - Simple quest creation and management
    - Progress tracking with events
    - Temporary and completion-based quests
    - Easy quest retrieval system
    - Quest locking mechanism

    Documentation:
    local QuestPP = require(PathToQuest++)
    
    -- Create a new quest
    local quest = QuestPP.new({
        Name = "Quest Name",
        Objective = "Quest Objective",
        Type = "Temporary" | "Completion",	-- Defaults to "Completion"
        TimeLimit = 1000,					-- Optional (for Temporary quests only)
        Key = "UniqueQuestKey123",			-- Used to retrieve quest later
        RewardCallback = function(quest)	-- Optional
            -- Reward player here
        end,
        CompletionCondition = function(quest) -- Optional
            -- Return true if quest should complete immediately
        end,
    })
    
    -- Quest API --
    quest:addProgress(0.5)			-- Add progress (0-1 scale)
    quest:complete()				-- Complete quest immediately
    quest:lock()					-- Lock quest to make it read-only
    quest:destroy()					-- Clean up quest
    
    -- Module API --
    QuestPP:getQuestFromKey(key)	-- Retrieve quest by key
    QuestPP:GetNormal()				-- Get module instance
    
    -- Events --
    quest.Changed					-- Fires when progress changes
    quest.Completed					-- Fires when quest completes
    quest.Destroying				-- Fires before quest destruction
    
    Socials:
    - Discord: ArtSeb
    - Twitter: @art_seb117
]]

local Quest = {}
Quest.__index = Quest
local Quests = {}
local Types = require(script.Types)

export type Quest = Types.Quest

-- Public Functions --
function Quest:getQuestFromKey(key: any)
	local match = Quests[key]
	if match then
		return match
	end
	return nil
end

function Quest:getNormal()
	return script
end

function Quest:getQuests()
	return Quests
end

-- Constructor --
function Quest.new(customization: QuestCustomization)
	local self = {}
	setmetatable(self, Quest)

	-- Initialize quest properties
	self.name = customization.Name
	self.objective = customization.Objective
	self.type = customization.Type or "Completion"
	self.timeLimit = customization.TimeLimit
	self.key = customization.Key

	Quests[self.key] = self

	self._rewardCallback = customization.RewardCallback
	self._completionCondition = customization.CompletionCondition

	self.currentProgress = 0
	self.isCompleted = false
	self._destroyed = false
	self.isLocked = false
	self._completionCheckRunning = false
	
	-- Create events
	self.Changed = Instance.new("BindableEvent")
	self.Changed.Name = "Changed"

	self.Completed = Instance.new("BindableEvent")
	self.Completed.Name = "Completed"

	self.Destroying = Instance.new("BindableEvent")
	self.Destroying.Name = "Destroying"

	-- Create instance representation
	self._instance = self:_createInstance()

	-- Set up time limit if applicable
	if self.type == "Temporary" then
		assert(self.timeLimit, "A Quest with the Temporary type must have a TimeLimit")
		task.delay(self.timeLimit, function()
			if not self.isCompleted then
				--print(self.isCompleted)
				self:destroy()
			end
		end)
	end

	-- Start completion condition checker if it exists
	if self._completionCondition then
		self:_startCompletionChecker()
	end

	return self
end

-- Internal method to create the instance representation
function Quest:_createInstance()
	local instance = Instance.new("Configuration")
	instance.Name = tostring(self.key)

	-- Create child values
	local function createValue(className, name, value)
		local val = Instance.new(className)
		val.Name = name
		val.Value = value
		val.Parent = instance
		return val
	end

	createValue("StringValue", "Q_Name", self.name)
	createValue("StringValue", "Q_Objective", self.objective)
	createValue("NumberValue", "Q_Progress", self.currentProgress)
	createValue("BoolValue", "Q_Completed", self.isCompleted)
	createValue("BoolValue", "Q_Locked", self.isLocked)
	
	self.Completed.Parent = instance
	self.Changed.Parent = instance
	self.Destroying.Parent = instance

	instance.Parent = script
	return instance
end

-- Internal method to start the completion condition checker
function Quest:_startCompletionChecker()
	if self._completionCheckRunning or self._destroyed then return end

	self._completionCheckRunning = true

	task.spawn(function()
		while not self._destroyed and not self.isCompleted and not self.isLocked do
			-- Check if progress is complete
			if self.currentProgress >= 1 then
				self:complete()
				break
			end

			-- Check custom completion condition
			if self._completionCondition then
				local success, result = pcall(self._completionCondition, self)
				if success and result then
					self:complete()
					break
				end
			end

			-- Wait a bit before checking again
			task.wait(0.1)
		end

		self._completionCheckRunning = false
	end)
end

function Quest:lock()
	if self._destroyed then return end

	self.isLocked = true
	if self._instance and self._instance:FindFirstChild("Q_Locked") then
		self._instance.Q_Locked.Value = true
	end
end

function Quest:destroy()
	if self._destroyed then return end

	self._destroyed = true
	self.Destroying:Fire()

	Quests[self.key] = nil

	self._instance:Destroy()
	self.Changed:Destroy()
	self.Completed:Destroy()
	self.Destroying:Destroy()

	-- Clear table
	table.clear(self)
	setmetatable(self, nil)
end

function Quest:addProgress(amount: number)
	if self._destroyed or self.isCompleted or self.isLocked then return end

	self.currentProgress = math.clamp(self.currentProgress + amount, 0, 1)
	self._instance.Q_Progress.Value = self.currentProgress
	self.Changed:Fire(self.currentProgress)

	-- Check for automatic completion if progress reaches 1
	if self.currentProgress >= 1 then
		self:complete()
	end

	-- Restart completion checker if it's not running
	if self._completionCondition and not self._completionCheckRunning and not self.isCompleted then
		self:_startCompletionChecker()
	end
end

function Quest:complete()
	if self._destroyed or self.isCompleted or self.isLocked then return end

	self.isCompleted = true
	self._instance.Q_Completed.Value = true
	self.Completed:Fire()

	if self._rewardCallback then
		self._rewardCallback(self)
	end
end

return Quest :: Types.StaticQuest]]></ProtectedString>
							<string name="ScriptGuid">{8B0EEAEF-F27C-4F02-B21D-50327D3F0D33}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">QuestPP</string>
							<int64 name="SourceAssetId">83392252086224</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX04E77D47BF8044A9888D102980EF72F2">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!strict

type StaticMethods = {
	getQuestFromKey: typeof(
		--[[
		Returns a SAME SIDE Quest from a given key

		A quest made on the server can be only accessed on the server and vice versa
		]]
		function(key: string): Quest?
			return nil :: any
		end
	),
	getNormal: typeof(
		--[[
		Returns the module script instance
		]]
		function(): ModuleScript
			return nil :: any
		end
	),
	getQuests: typeof(
		--[[
		Returns all of the quests
		]]
		function(): { Quest }
			return nil :: any
		end
	),
}

export type QuestCustomization = {
	Name: string,
	Objective: string,
	Type: "Temporary" | "Completion"?,
	TimeLimit: number?,
	Key: any,
	RewardCallback: ((quest: Quest) -> ())?,
	CompletionCondition: ((quest: Quest) -> (boolean | nil))?,
}

local MT = {} :: Methods
type Methods = {
	__index: typeof(MT),
	
	-- QUEST FUNCTIONS --
	destroy: typeof(
		--[=[
    	Cleans up the quest and all its resources
		]=]
		function(self: Quest): ()
			return nil :: any
		end
	),
	addProgress: typeof(
		--[=[
    	Adds progress to the quest
   		Amount = progress to add (0-1 scale)
		]=]
		function(self: Quest, amount: number): ()
			return nil :: any
		end
	),
	complete: typeof(
		--[=[
    	Completes the quest immediately
		]=]
		function(self: Quest): ()
			return nil :: any
		end
	),
	lock: typeof(
		--[=[
		Locks the quest so it's read only
		]=]
		function(self: Quest): ()
			return nil :: any
		end
	)
}

export type Fields = {
	-- Properties
	name: string,
	objective: string,
	type: "Temporary" | "Completion"?,
	timeLimit: number?,
	key: any,
	currentProgress: number,
	isCompleted: boolean,
	isLocked: boolean,
	
	-- Events
	changed: BindableEvent,
	completed: BindableEvent,
	destroying: BindableEvent,
}

export type Quest = typeof(setmetatable({}::Fields, MT))

export type StaticQuest = {
	new: typeof(
		--[=[
		Creates a new quest.
		]=]
		function(customization: QuestCustomization): Quest
			return nil :: any
		end
	)
} & StaticMethods

return {}
]]></ProtectedString>
								<string name="ScriptGuid">{E8846BB2-110C-4B88-842C-F3303DBC2D10}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Types</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1CA2A5694A324709876E69E102E83167">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return {
	Name = "QuestPP",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: ArtSeb"},
		{Text = "Description: The ultimate quest module for Roblox! Handles everything from leveling systems to item collection and achievements."},
		{Text = "Version: 1.0.1 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Advanced scripting knowledge"}
	}
}]]></ProtectedString>
								<string name="ScriptGuid">{A81B0404-EEC2-4E96-9826-D187A8093E6E}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Config</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXF10A8D82F16B4CD5861EF5DABA4A806A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "QuestPP",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 83392252086224,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: ArtSeb"},
		{Text = "Description: The ultimate quest module for Roblox! Handles everything from leveling systems to item collection and achievements."},
		{Text = "Version: 1.0.1 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Advanced scripting knowledge"}
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{781CA3BC-710F-4F9A-BD17-C10449025163}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX707889247E6844FEB691443E760F0E7F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ProfileStore</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX03F0E34046E64FC0B78E624EE1574A7F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[
MAD STUDIO (by loleris)

-[ProfileStore]---------------------------------------

	Periodic DataStore saving solution with session locking
	
	WARNINGS FOR "Profile.Data" VALUES:
	 	! Do not create numeric tables with gaps - attempting to store such tables will result in an error.
		! Do not create mixed tables (some values indexed by number and others by a string key)
			- only numerically indexed  data will be stored.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	Members:
	
		ProfileStore.IsClosing          [bool]
			-- Set to true after a game:BindToClose() trigger
			
		ProfileStore.IsCriticalState    [bool]
			-- Set to true when ProfileStore experiences too many consecutive errors
		
		ProfileStore.OnError            [Signal] (message, store_name, profile_key)
			-- Most ProfileStore errors will be caught and passed to this signal
			
		ProfileStore.OnOverwrite        [Signal] (store_name, profile_key)
			-- Triggered when a DataStore key was likely used to store data that wasn't
			a ProfileStore profile or the ProfileStore structure was invalidly manually
			altered for that DataStore key
			
		ProfileStore.OnCriticalToggle   [Signal] (is_critical)
			-- Triggered when ProfileStore experiences too many consecutive errors
		
		ProfileStore.DataStoreState     [string] ("NotReady", "NoInternet", "NoAccess", "Access")
			-- This value resembles ProfileStore's access to the DataStore; The value starts
			as "NotReady" and will eventually change to one of the other 3 possible values.
	
	Functions:
	
		ProfileStore.New(store_name, template?) --> [ProfileStore]
			store_name   [string] -- DataStore name
			template     [table] or nil -- Profiles will default to given table (hard-copy) when no data was saved previously
			
		ProfileStore.SetConstant(name, value)
			name    [string]
			value   [number]
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore]
			-- Reflection of ProfileStore methods, but the methods will now query a mock
			DataStore with no relation to the real DataStore
			
		ProfileStore.Name   [string]
		
	Methods [ProfileStore]:
	
		ProfileStore:StartSessionAsync(profile_key, params?) --> [Profile] or nil
			profile_key [string] -- DataStore key
			params      nil or [table]: -- Custom params; E.g. {Steal = true}
				{
					Steal = true, -- Pass this to disregard an existing session lock
					Cancel = fn() -> (boolean), -- Pass this to create a request cancel condition.
						-- If the cancel function returns true, ProfileStore will stop trying to
						-- start the session and return nil
				}
			
		ProfileStore:MessageAsync(profile_key, message) --> is_success [bool]
			profile_key [string] -- DataStore key
			message     [table] -- Data to be messaged to the profile
			
		ProfileStore:GetAsync(profile_key, version?) --> [Profile] or nil
			-- Reads a profile without starting a session - will not autosave
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:VersionQuery(profile_key, sort_direction?, min_date?, max_date?) --> [VersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:RemoveAsync(profile_key) --> is_success [bool]
			-- Completely removes profile data from the DataStore / mock DataStore with no way to recover it.

	Methods [VersionQuery]:

		VersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile is similar to profiles returned by ProfileStore:GetAsync()
		
	Members [Profile]:
	
		Profile.Data               [table]
			-- When the profile is active changes to this table are guaranteed to be saved
		Profile.LastSavedData      [table] (Read-only)
			-- Last snapshot of "Profile.Data" that has been successfully saved to the DataStore;
			Useful for proper developer product purchase receipt handling
		
		Profile.FirstSessionTime   [number] (Read-only)
			-- os.time() timestamp of the first profile session
			
		Profile.SessionLoadCount   [number] (Read-only) -- Amount of times a session was started for this profile
			
		Profile.Session            [table] (Read-only) {PlaceId = number, JobId = string} / nil
			-- Set to a table if this profile is in use by a server; nil if released

		Profile.RobloxMetaData     [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds            [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo            [DataStoreKeyInfo] -- Changes before OnAfterSave signal
		
		Profile.OnSave             [Signal] ()
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			
		Profile.OnLastSave         [Signal] (reason [string]: "Manual", "External", "Shutdown")
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			for the last time; A reason is provided for the last save:
				- "Manual"   - Profile:EndSession() was called
				- "Shutdown" - The server that has ownership of this profile is shutting down
				- "External" - Another server has started a session for this profile
			Note that this event will not trigger for when a profile session is ended by
			another server trying to take ownership of the session - this is impossible to
			do without compromising on ProfileStore's speed.
			
		Profile.OnSessionEnd       [Signal] ()
			-- Triggered when the profile session is terminated on this server
		
		Profile.OnAfterSave        [Signal] (last_saved_data)
			-- Triggered after a successful save
			last_saved_data [table] -- Profile.LastSavedData
			
		Profile.ProfileStore       [ProfileStore] -- ProfileStore object this profile belongs to
		Profile.Key                [string] -- DataStore key
		
	Methods [Profile]:
	
		Profile:IsActive() --> [bool] -- If "true" is returned, changes to Profile.Data are guaranteed to save;
			This guarantee is only valid until code yields (e.g. task.wait() is used).
			
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
			from the "template" argument that was passed to "ProfileStore.New()"
			
		Profile:EndSession() -- Call after the server has finished working with this profile
			e.g., after the player leaves (Profile object will become inactive)

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)
			user_id   [number]
			
		Profile:MessageHandler(fn) -- Sets a message handler for this profile
			fn [function] (message [table], processed [function]())
			-- The handler function receives a message table and a callback function;
			The callback function is to be called when a message has been processed
			- this will discard the message from the profile message cache; If the
			callback function is not called, other message handlers will also be triggered
			with unprocessed message data.
			
		Profile:Save() -- If the profile session is still active makes an UpdateAsync call
			to the DataStore to immediately save profile data

		Profile:SetAsync() -- Forcefully saves changes to the profile; Only for profiles
			loaded with ProfileStore:GetAsync() or ProfileStore:VersionQuery()
		
--]]

local AUTO_SAVE_PERIOD = 300 -- (Seconds) Time between when changes to a profile are saved to the DataStore
local LOAD_REPEAT_PERIOD = 10 -- (Seconds) Time between successive profile reads when handling a session conflict
local FIRST_LOAD_REPEAT = 5 -- (Seconds) Time between first and second profile read when handling a session conflict
local SESSION_STEAL = 40 -- (Seconds) Time until a session conflict is resolved with the waiting server stealing the session
local ASSUME_DEAD = 630 -- (Seconds) If a profile hasn't had updates for this long, quickly assume an active session belongs to a crashed server
local START_SESSION_TIMEOUT = 120 -- (Seconds) If a session can't be started for a profile for this long, stop repeating calls to the DataStore

local CRITICAL_STATE_ERROR_COUNT = 5 -- Assume critical state if this many issues happen in a short amount of time
local CRITICAL_STATE_ERROR_EXPIRE = 120 -- (Seconds) Individual issue expiration
local CRITICAL_STATE_EXPIRE = 120 -- (Seconds) Critical state expiration

local MAX_MESSAGE_QUEUE = 1000 -- Max messages saved in a profile that were sent using "ProfileStore:MessageAsync()"

----- Dependencies -----

-- local Util = require(game.ReplicatedStorage.Shared.Util)
-- local Signal = Util.Signal

local Signal do

	local FreeRunnerThread

	--[[
		Yield-safe coroutine reusing by stravant;
		Sources:
		https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063
		https://gist.github.com/stravant/b75a322e0919d60dde8a0316d1f09d2f
	--]]

	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		-- The handler finished running, this runner thread is free again.
		FreeRunnerThread = acquired_runner_thread
	end

	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end

	local Connection = {}
	Connection.__index = Connection

	local SignalClass = {}
	SignalClass.__index = SignalClass

	function Connection:Disconnect()

		if self.is_connected == false then
			return
		end

		local signal = self.signal
		self.is_connected = false
		signal.listener_count -= 1

		if signal.head == self then
			signal.head = self.next
		else
			local prev = signal.head
			while prev ~= nil and prev.next ~= self do
				prev = prev.next
			end
			if prev ~= nil then
				prev.next = self.next
			end
		end

	end

	function SignalClass.New()

		local self = {
			head = nil,
			listener_count = 0,
		}
		setmetatable(self, SignalClass)

		return self

	end

	function SignalClass:Connect(listener: (...any) -> ())

		if type(listener) ~= "function" then
			error(`[{script.Name}]: \"listener\" must be a function; Received {typeof(listener)}`)
		end

		local connection = {
			listener = listener,
			signal = self,
			next = self.head,
			is_connected = true,
		}
		setmetatable(connection, Connection)

		self.head = connection
		self.listener_count += 1

		return connection

	end

	function SignalClass:GetListenerCount(): number
		return self.listener_count
	end

	function SignalClass:Fire(...)
		local item = self.head
		while item ~= nil do
			if item.is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item.listener, ...)
			end
			item = item.next
		end
	end

	function SignalClass:Wait()
		local co = coroutine.running()
		local connection
		connection = self:Connect(function(...)
			connection:Disconnect()
			task.spawn(co, ...)
		end)
		return coroutine.yield()
	end

	Signal = table.freeze({
		New = SignalClass.New,
	})

end

----- Private -----

local ActiveSessionCheck = {} -- {[session_token] = profile, ...}
local AutoSaveList = {} -- {profile, ...} -- Loaded profile table which will be circularly auto-saved
local IssueQueue = {} -- {issue_time, ...}

local DataStoreService = game:GetService("DataStoreService")
local MessagingService = game:GetService("MessagingService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access" = "NotReady"

local MockStore = {}
local UserMockStore = {}
local MockFlag = false

local OnError = Signal.New() -- (message, store_name, profile_key)
local OnOverwrite = Signal.New() -- (store_name, profile_key)

local UpdateQueue = { -- For stability sake, we won't do UpdateAsync calls for the same key until all previous calls finish
	--[[
		[session_token] = {
			coroutine, ...
		},
		...
	--]]
}

local function WaitInUpdateQueue(session_token) --> next_in_queue()

	local is_first = false

	if UpdateQueue[session_token] == nil then
		is_first = true
		UpdateQueue[session_token] = {}
	end

	local queue = UpdateQueue[session_token]

	if is_first == false then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	return function()
		local next_co = table.remove(queue, 1)
		if next_co ~= nil then
			coroutine.resume(next_co)
		else
			UpdateQueue[session_token] = nil
		end
	end

end

local function SessionToken(store_name, profile_key, is_mock)

	local session_token = "L_" -- Live

	if is_mock == true then
		session_token = "U_" -- User mock
	elseif DataStoreState ~= "Access" then
		session_token = "M_" -- Mock, cause no DataStore access
	end

	session_token ..= store_name .. "\0" .. profile_key

	return session_token

end

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == "string" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == "table" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == "table" and type(v) == "table" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

local function RegisterError(error_message, store_name, profile_key) -- Called when a DataStore API call errors
	warn(`[{script.Name}]: DataStore API error (STORE:{store_name}; KEY:{profile_key}) - {tostring(error_message)}`)
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	OnError:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterOverwrite(store_name, profile_key) -- Called when a corrupted profile is loaded
	warn(`[{script.Name}]: Invalid profile was overwritten (STORE:{store_name}; KEY:{profile_key})`)
	OnOverwrite:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep("0", 16) .. "."
			.. string.rep("0", 10 - string.len(version_id_string)) .. version_id_string
			.. "." .. string.rep("0", 16) .. "." .. "01",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = DeepCopyTable(transform)
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function UpdateAsync(profile_store, profile_key, transform_params, is_user_mock, is_get_call, version) --> loaded_data, key_info
	--transform_params = {
	--	ExistingProfileHandle = function(latest_data),
	--	MissingProfileHandle = function(latest_data),
	--	EditProfile = function(latest_data),
	--}

	local loaded_data, key_info

	local next_in_queue = WaitInUpdateQueue(SessionToken(profile_store.Name, profile_key, is_user_mock))

	local success = true

	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local overwritten = false
			local global_updates = {0, {}}

			if latest_data == nil then

				missing_profile = true

			elseif type(latest_data) ~= "table" then

				missing_profile = true
				overwritten = true

			else

				if type(latest_data.Data) == "table" and type(latest_data.MetaData) == "table" and type(latest_data.GlobalUpdates) == "table" then

					-- Regular profile structure detected:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates

					if transform_params.ExistingProfileHandle ~= nil then
						transform_params.ExistingProfileHandle(latest_data)
					end

				elseif latest_data.Data == nil and latest_data.MetaData == nil and type(latest_data.GlobalUpdates) == "table" then

					-- Regular structure not detected, but GlobalUpdate data exists:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates or global_updates
					missing_profile = true

				else

					missing_profile = true
					overwritten = true

				end

			end

			-- Profile was not created or corrupted and no GlobalUpdate data exists:
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates,
				}
				if transform_params.MissingProfileHandle ~= nil then
					transform_params.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if transform_params.EditProfile ~= nil then
				transform_params.EditProfile(latest_data)
			end

			-- Invalid data handling (Silently override with empty profile)
			if overwritten == true then
				latest_data.WasOverwritten = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end

		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

			loaded_data, key_info = MockUpdateAsync(UserMockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		elseif DataStoreState ~= "Access" then -- Used when API access is disabled

			loaded_data, key_info = MockUpdateAsync(MockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		else

			if is_get_call == true then

				if version ~= nil then

					local success, error_message = pcall(function()
						loaded_data, key_info = profile_store.data_store:GetVersionAsync(profile_key, version)
					end)

					if success == false and type(error_message) == "string" and string.find(error_message, "not valid") ~= nil then
						warn(`[{script.Name}]: Passed version argument is not valid; Traceback:\n` .. debug.traceback())
					end

				else

					loaded_data, key_info = profile_store.data_store:GetAsync(profile_key)

				end

				loaded_data = transform_function(loaded_data)

			else

				loaded_data, key_info = profile_store.data_store:UpdateAsync(profile_key, transform_function)

			end

		end

	end)

	next_in_queue()

	if success == true and type(loaded_data) == "table" then
		-- Invalid data handling:
		if loaded_data.WasOverwritten == true and is_get_call ~= true then
			RegisterOverwrite(
				profile_store.Name,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		-- Error handling:
		RegisterError(
			error_message or "Undefined error",
			profile_store.Name,
			profile_key
		)
		-- Return nothing:
		return nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

local function ReadMockFlag(): boolean
	local is_mock = MockFlag
	MockFlag = false
	return is_mock
end

local function WaitForStoreReady(profile_store)
	while profile_store.is_ready == false do
		task.wait()
	end
end

local function AddProfileToAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = profile

	-- Add at AutoSaveIndex and move AutoSaveIndex right:

	table.insert(AutoSaveList, AutoSaveIndex, profile)

	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end

end

local function RemoveProfileFromAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = nil

	local auto_save_index = table.find(AutoSaveList, profile)

	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end

end

local function SaveProfileAsync(profile, is_ending_session, is_overwriting, last_save_reason)

	if type(profile.Data) ~= "table" then
		error(`[{script.Name}]: Developer code likely set "Profile.Data" to a non-table value! (STORE:{profile.ProfileStore.Name}; KEY:{profile.Key})`)
	end

	profile.OnSave:Fire()
	if is_ending_session == true then
		profile.OnLastSave:Fire(last_save_reason or "Manual")
	end

	if is_ending_session == true and is_overwriting ~= true then
		if profile.roblox_message_subscription ~= nil then
			profile.roblox_message_subscription:Disconnect()
		end
		RemoveProfileFromAutoSave(profile)
		profile.OnSessionEnd:Fire()
	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1

	-- Compare "SessionLoadCount" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again

	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	local exp_backoff = 1

	while repeat_save_flag == true do

		if is_ending_session ~= true then
			repeat_save_flag = false
		end

		local loaded_data, key_info = UpdateAsync(
			profile.ProfileStore,
			profile.Key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					-- Check if this session still owns the profile:

					local session_owns_profile = false

					if is_overwriting ~= true then

						local active_session = latest_data.MetaData.ActiveSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == "table" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
						end

					else
						session_owns_profile = true
					end

					-- We may only edit the profile if this server has ownership of the profile:

					if session_owns_profile == true then

						-- Clear processed updates (messages):

						local locked_updates = profile.locked_global_updates -- [index] = true, ...
						local active_updates = latest_data.GlobalUpdates[2]
						-- ProfileService module format: {{update_id, version_id, update_locked, update_data}, ...}
						-- ProfileStore module format: {{update_id, update_data}, ...}

						if next(locked_updates) ~= nil then
							local i = 1
							while i <= #active_updates do
								local update = active_updates[i]
								if locked_updates[update[1]] == true then
									table.remove(active_updates, i)
								else
									i += 1
								end
							end
						end

						-- Save profile data:

						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then

							latest_data.MetaData.LastUpdate = os.time()

							if is_ending_session == true then
								latest_data.MetaData.ActiveSession = nil
							end

						else

							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil

						end

					end

				end,
			},
			profile.is_mock
		)

		if loaded_data ~= nil and key_info ~= nil then

			if is_overwriting == true then
				break
			end

			repeat_save_flag = false

			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false

			if type(active_session) == "table" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
			end

			local force_load_session = loaded_data.MetaData.ForceLoadSession
			local force_load_pending = false
			if type(force_load_session) == "table" then
				force_load_pending = not IsThisSession(force_load_session)
			end

			local is_active = profile:IsActive()

			-- If another server is trying to start a session for this profile - end the session:

			if force_load_pending == true and session_owns_profile == true then
				if is_active == true then
					SaveProfileAsync(profile, true, false, "External")
				end
				break
			end

			-- Clearing processed update list / Detecting new updates:

			local locked_updates = profile.locked_global_updates -- [index] = true, ...
			local received_updates = profile.received_global_updates -- [index] = true, ...
			local active_updates = loaded_data.GlobalUpdates[2]

			local new_updates = {} -- {}, ...
			local still_pending = {} -- [index] = true, ...

			for _, update in ipairs(active_updates) do
				if locked_updates[update[1]] == true then
					still_pending[update[1]] = true
				elseif received_updates[update[1]] ~= true then
					received_updates[update[1]] = true
					table.insert(new_updates, update)
				end
			end

			for index in pairs(locked_updates) do
				if still_pending[index] ~= true then
					locked_updates[index] = nil
				end
			end

			-- Updating profile values:

			profile.KeyInfo = key_info
			profile.LastSavedData = loaded_data.Data
			profile.global_updates = loaded_data.GlobalUpdates and loaded_data.GlobalUpdates[2] or {}

			if session_owns_profile == true then
				if is_active == true and is_ending_session ~= true then

					-- Processing new global updates (messages):

					for _, update in ipairs(new_updates) do

						local index = update[1]
						local update_data = update[#update] -- Backwards compatibility with ProfileService

						for _, handler in ipairs(profile.message_handlers) do

							local is_processed = false
							local processed_callback = function()
								is_processed = true
								locked_updates[index] = true
							end

							local send_update_data = DeepCopyTable(update_data)

							task.spawn(handler, send_update_data, processed_callback)

							if is_processed == true then
								break
							end

						end

					end

				end
			else

				if profile.roblox_message_subscription ~= nil then
					profile.roblox_message_subscription:Disconnect()
				end

				if is_active == true then
					RemoveProfileFromAutoSave(profile)
					profile.OnSessionEnd:Fire()
				end

			end

			profile.OnAfterSave:Fire(profile.LastSavedData)

		elseif repeat_save_flag == true then

			-- DataStore call likely resulted in an error; Repeat the DataStore call shortly
			task.wait(exp_backoff)
			exp_backoff = math.min(if last_save_reason == "Shutdown" then 8 else 20, exp_backoff * 2)

		end

	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1

end

----- Public -----

--[[
	Saved profile structure:
	
	{
		Data = {},
		
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id, unique_session_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			LastUpdate = 0, -- os.time()
			MetaTags = {}, -- Backwards compatibility with ProfileService
		},
		
		RobloxMetaData = {},
		UserIds = {},
		
		GlobalUpdates = {
			update_index,
			{
				{update_index, data}, ...
			},
		},
	}

--]]

export type JSONAcceptable = { JSONAcceptable } | { [string]: JSONAcceptable } | number | string | boolean | buffer

export type Profile<T> = {
	Data: T & JSONAcceptable,
	LastSavedData: T & JSONAcceptable,
	FirstSessionTime: number,
	SessionLoadCount: number,
	Session: {PlaceId: number, JobId: string}?,
	RobloxMetaData: JSONAcceptable,
	UserIds: {number},
	KeyInfo: DataStoreKeyInfo,
	OnSave: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnLastSave: {Connect: (self: any, listener: (reason: "Manual" | "External" | "Shutdown") -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnSessionEnd: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnAfterSave: {Connect: (self: any, listener: (last_saved_data: T & JSONAcceptable) -> ()) -> ({Disconnect: (self: any) -> ()})},
	ProfileStore: JSONAcceptable,
	Key: string,

	IsActive: (self: any) -> (boolean),
	Reconcile: (self: any) -> (),
	EndSession: (self: any) -> (),
	AddUserId: (self: any, user_id: number) -> (),
	RemoveUserId: (self: any, user_id: number) -> (),
	MessageHandler: (self: any, fn: (message: JSONAcceptable, processed: () -> ()) -> ()) -> (),
	Save: (self: any) -> (),
	SetAsync: (self: any) -> (),
}

export type VersionQuery<T> = {
	NextAsync: (self: any) -> (Profile<T>?),
}

type ProfileStoreStandard<T> = {
	Name: string,
	StartSessionAsync: (self: any, profile_key: string, params: {Steal: boolean?}) -> (Profile<T>?),
	MessageAsync: (self: any, profile_key: string, message: JSONAcceptable) -> (boolean),
	GetAsync: (self: any, profile_key: string, version: string?) -> (Profile<T>?),
	VersionQuery: (self: any, profile_key: string, sort_direction: Enum.SortDirection?, min_date: DateTime | number | nil, max_date: DateTime | number | nil) -> (VersionQuery<T>),
	RemoveAsync: (self: any, profile_key: string) -> (boolean),
}

export type ProfileStore<T> = {
	Mock: ProfileStoreStandard<T>,
} & ProfileStoreStandard<T>

type ConstantName = "AUTO_SAVE_PERIOD" | "LOAD_REPEAT_PERIOD" | "FIRST_LOAD_REPEAT" | "SESSION_STEAL"
| "ASSUME_DEAD" | "START_SESSION_TIMEOUT" | "CRITICAL_STATE_ERROR_COUNT" | "CRITICAL_STATE_ERROR_EXPIRE"
| "CRITICAL_STATE_EXPIRE" | "MAX_MESSAGE_QUEUE"

export type ProfileStoreModule = {
	IsClosing: boolean,
	IsCriticalState: boolean,
	OnError: {Connect: (self: any, listener: (message: string, store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnOverwrite: {Connect: (self: any, listener: (store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnCriticalToggle: {Connect: (self: any, listener: (is_critical: boolean) -> ()) -> ({Disconnect: (self: any) -> ()})},
	DataStoreState: "NotReady" | "NoInternet" | "NoAccess" | "Access",
	New: <T>(store_name: string, template: (T & JSONAcceptable)?) -> (ProfileStore<T>),
	SetConstant: (name: ConstantName, value: number) -> ()
}

local Profile = {}
Profile.__index = Profile

function Profile.New(raw_data, key_info, profile_store, key, is_mock, session_token)

	local data = raw_data.Data or {}
	local session = raw_data.MetaData and raw_data.MetaData.ActiveSession or nil

	local global_updates = raw_data.GlobalUpdates and raw_data.GlobalUpdates[2] or {}
	local received_global_updates = {}

	for _, update in ipairs(global_updates) do
		received_global_updates[update[1]] = true
	end

	local self = {

		Data = data,
		LastSavedData = DeepCopyTable(data),

		FirstSessionTime = raw_data.MetaData and raw_data.MetaData.ProfileCreateTime or 0,
		SessionLoadCount = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		Session = session and {PlaceId = session[1], JobId = session[2]},

		RobloxMetaData = raw_data.RobloxMetaData or {},
		UserIds = raw_data.UserIds or {},
		KeyInfo = key_info,

		OnAfterSave = Signal.New(),
		OnSave = Signal.New(),
		OnLastSave = Signal.New(),
		OnSessionEnd = Signal.New(),

		ProfileStore = profile_store,
		Key = key,

		load_timestamp = os.clock(),
		is_mock = is_mock,
		session_token = session_token or "",
		load_index = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		locked_global_updates = {},
		received_global_updates = received_global_updates,
		message_handlers = {},
		global_updates = global_updates,

	}
	setmetatable(self, Profile)

	return self

end

function Profile:IsActive()
	return ActiveSessionCheck[self.session_token] == self
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self.ProfileStore.template)
end

function Profile:EndSession()
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true, nil, "Manual") -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :AddUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	if user_id < 0 and self.is_mock ~= true and DataStoreState == "Access" then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end

end

function Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)

	if type(user_id) ~= "number" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :RemoveUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:SetAsync() -- Saves the profile to the DataStore and removes the session lock

	if self.view_mode ~= true then
		error(`[{script.Name}]: :SetAsync() can only be used in view mode`)
	end

	SaveProfileAsync(self, nil, true)

end

function Profile:MessageHandler(fn)

	if type(fn) ~= "function" then
		error(`[{script.Name}]: fn argument is not a function`)
	end

	if self.view_mode ~= true and self:IsActive() ~= true then
		return -- Don't process messages if the profile session was ended
	end

	local locked_updates = self.locked_global_updates
	table.insert(self.message_handlers, fn)

	for _, update in ipairs(self.global_updates) do

		local index = update[1]
		local update_data = update[#update] -- Backwards compatibility with ProfileService

		if locked_updates[index] ~= true then

			local processed_callback = function()
				locked_updates[index] = true
			end

			local send_update_data = DeepCopyTable(update_data)

			task.spawn(fn, send_update_data, processed_callback)

		end

	end

end

function Profile:Save()

	if self.view_mode == true then
		error(`[{script.Name}]: Can't save profile in view mode; Should you be calling :SetAsync() instead?`)
	end

	if self:IsActive() == false then
		warn(`[{script.Name}]: Attempted saving an inactive profile (STORE:{self.ProfileStore.Name}; KEY:{self.Key});`
			.. ` Traceback:\n` .. debug.traceback())
		return
	end

	-- Move the profile right behind the auto save index to delay the next auto save for it:
	RemoveProfileFromAutoSave(self)
	AddProfileToAutoSave(self)

	-- Perform save in new thread:
	task.spawn(SaveProfileAsync, self)

end

local ProfileStore: ProfileStoreModule = {

	IsClosing = false,
	IsCriticalState = false,
	OnError = OnError, -- (message, store_name, profile_key)
	OnOverwrite = OnOverwrite, -- (store_name, profile_key)
	OnCriticalToggle = Signal.New(), -- (is_critical)
	DataStoreState = "NotReady", -- ("NotReady", "NoInternet", "NoAccess", "Access")

}
ProfileStore.__index = ProfileStore

function ProfileStore.SetConstant(name, value)

	if type(value) ~= "number" then
		error(`[{script.Name}]: Invalid value type`)
	end

	if name == "AUTO_SAVE_PERIOD" then
		AUTO_SAVE_PERIOD = value
	elseif name == "LOAD_REPEAT_PERIOD" then
		LOAD_REPEAT_PERIOD = value
	elseif name == "FIRST_LOAD_REPEAT" then
		FIRST_LOAD_REPEAT = value
	elseif name == "SESSION_STEAL" then
		SESSION_STEAL = value
	elseif name == "ASSUME_DEAD" then
		ASSUME_DEAD = value
	elseif name == "START_SESSION_TIMEOUT" then
		START_SESSION_TIMEOUT = value
	elseif name == "CRITICAL_STATE_ERROR_COUNT" then
		CRITICAL_STATE_ERROR_COUNT = value
	elseif name == "CRITICAL_STATE_ERROR_EXPIRE" then
		CRITICAL_STATE_ERROR_EXPIRE = value
	elseif name == "CRITICAL_STATE_EXPIRE" then
		CRITICAL_STATE_EXPIRE = value
	elseif name == "MAX_MESSAGE_QUEUE" then
		MAX_MESSAGE_QUEUE = value
	else
		error(`[{script.Name}]: Invalid constant name was provided`)
	end

end

function ProfileStore.Test()
	return {
		ActiveSessionCheck = ActiveSessionCheck,
		AutoSaveList = AutoSaveList,
		ActiveProfileLoadJobs = ActiveProfileLoadJobs,
		ActiveProfileSaveJobs = ActiveProfileSaveJobs,
		MockStore = MockStore,
		UserMockStore = UserMockStore,
		UpdateQueue = UpdateQueue,
	}
end

function ProfileStore.New(store_name, template)

	template = template or {}

	if type(store_name) ~= "string" then
		error(`[{script.Name}]: Invalid or missing "store_name"`)
	elseif string.len(store_name) == 0 then
		error(`[{script.Name}]: store_name cannot be an empty string`)
	elseif string.len(store_name) > 50 then
		error(`[{script.Name}]: store_name is too long`)
	end

	if type(template) ~= "table" then
		error(`[{script.Name}]: Invalid template argument`)
	end

	local self
	self = {

		Mock = {

			Name = store_name,

			StartSessionAsync = function(_, profile_key)
				MockFlag = true
				return self:StartSessionAsync(profile_key)
			end,
			MessageAsync = function(_, profile_key, message)
				MockFlag = true
				return self:MessageAsync(profile_key, message)
			end,
			GetAsync = function(_, profile_key, version)
				MockFlag = true
				return self:GetAsync(profile_key, version)
			end,
			VersionQuery = function(_, profile_key, sort_direction, min_date, max_date)
				MockFlag = true
				return self:VersionQuery(profile_key, sort_direction, min_date, max_date)
			end,
			RemoveAsync = function(_, profile_key)
				MockFlag = true
				return self:RemoveAsync(profile_key)
			end
		},

		Name = store_name,

		template = template,
		data_store = nil,
		load_jobs = {},
		mock_load_jobs = {},
		is_ready = true,

	}
	setmetatable(self, ProfileStore)

	local options = Instance.new("DataStoreOptions")
	options:SetExperimentalFeatures({v2 = true})

	if DataStoreState == "NotReady" then

		-- The module is not sure whether DataStores are accessible yet:

		self.is_ready = false

		task.spawn(function()

			repeat task.wait() until DataStoreState ~= "NotReady"

			if DataStoreState == "Access" then
				self.data_store = DataStoreService:GetDataStore(store_name, nil, options)
			end

			self.is_ready = true

		end)

	elseif DataStoreState == "Access" then

		self.data_store = DataStoreService:GetDataStore(store_name, nil, options)

	end

	return self

end

local function RobloxMessageSubscription(profile, unique_session_id)

	local last_roblox_message = 0

	local roblox_message_subscription = MessagingService:SubscribeAsync("PS_" .. unique_session_id, function(message)
		if type(message.Data) == "table" and message.Data.LoadCount == profile.SessionLoadCount then
			-- High reaction rate, based on numPlayers  10 DataStore budget as of writing
			if os.clock() - last_roblox_message > 6 then 
				last_roblox_message = os.clock()
				if profile:IsActive() == true then
					if message.Data.EndSession == true then
						SaveProfileAsync(profile, true, false, "External")
					else
						profile:Save()
					end
				end
			end
		end
	end)

	if profile:IsActive() == true then
		profile.roblox_message_subscription = roblox_message_subscription
	else
		roblox_message_subscription:Disconnect()
	end

end

function ProfileStore:StartSessionAsync(profile_key, params)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if params ~= nil and type(params) ~= "table" then
		error(`[{script.Name}]: Invalid params`)
	end

	params = params or {}

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	local session_token = SessionToken(self.Name, profile_key, is_mock)

	if ActiveSessionCheck[session_token] ~= nil then
		error(`[{script.Name}]: Profile (STORE:{self.Name}; KEY:{profile_key}) is already loaded in this session`)
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1

	local is_user_cancel = false

	local function cancel_condition()
		if is_user_cancel == false then
			if params.Cancel ~= nil then
				is_user_cancel = params.Cancel() == true
			end
			return is_user_cancel
		end
		return true
	end

	local user_steal = params.Steal == true

	local force_load_steps = 0 -- Session conflict handling values
	local request_force_load = true
	local steal_session = false

	local start = os.clock()
	local exp_backoff = 1

	while ProfileStore.IsClosing == false and cancel_condition() == false do

		-- Load profile:

		-- SPECIAL CASE - If StartSessionAsync is called for the same key again before another StartSessionAsync finishes,
		-- grab the DataStore return for the new call. The early call will return nil. This is supposed to retain
		-- expected and efficient behavior in cases where a player would quickly rejoin the same server.

		LoadIndex += 1
		local load_id = LoadIndex
		local profile_load_jobs = is_mock == true and self.mock_load_jobs or self.load_jobs
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}

		local loaded_data, key_info
		local unique_session_id = HttpService:GenerateGUID(false)

		if profile_load_job ~= nil then

			profile_load_job[1] = load_id -- Steal load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

		else

			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job

			profile_load_job[2] = table.pack(UpdateAsync(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession

						if active_session == nil then
							latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
							latest_data.MetaData.ForceLoadSession = nil
						elseif type(active_session) == "table" then
							if IsThisSession(active_session) == false then
								local last_update = latest_data.MetaData.LastUpdate
								if last_update ~= nil then
									if os.time() - last_update > ASSUME_DEAD then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
										return
									end
								end
								if steal_session == true or user_steal == true then
									local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true
									if force_load_interrupted == false or user_steal == true then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
									end
								elseif request_force_load == true then
									latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
								end
							else
								latest_data.MetaData.ForceLoadSession = nil
							end
						end

					end,
					MissingProfileHandle = function(latest_data)

						local is_cancel = ProfileStore.IsClosing == true or cancel_condition() == true

						latest_data.Data = DeepCopyTable(self.template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = if is_cancel == false then {PlaceId, JobId, unique_session_id} else nil,
							ForceLoadSession = nil,
							MetaTags = {}, -- Backwards compatibility with ProfileService
						}

					end,
					EditProfile = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						if active_session ~= nil and IsThisSession(active_session) == true then
							latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
							latest_data.MetaData.LastUpdate = os.time()
						end

					end,
				},
				is_mock
				))
			if profile_load_job[1] == load_id then -- Load job hasn't been stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job stolen
			end
		end

		-- Handle load_data:

		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then

				if IsThisSession(active_session) == true then

					-- Profile is now taken by this session:

					local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock, session_token)
					AddProfileToAutoSave(profile)

					if is_mock ~= true and DataStoreState == "Access" then

						-- Use MessagingService to quickly detect session conflicts and resolve them quickly:
						task.spawn(RobloxMessageSubscription, profile, unique_session_id) -- Blocking prevention

					end

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						-- The server has initiated a shutdown by the time this profile was loaded
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- Don't return the profile object
					end

					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile

				else

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					-- Profile is taken by some other session:

					local force_load_session = loaded_data.MetaData.ForceLoadSession
					local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true

					if force_load_interrupted == false then

						if request_force_load == false then
							force_load_steps = force_load_steps + 1
							if force_load_steps >= math.ceil(SESSION_STEAL / LOAD_REPEAT_PERIOD) then
								steal_session = true
							end
						end

						-- Request the remote server to end its session:
						if type(active_session[3]) == "string" then
							local session_load_count = loaded_data.MetaData.SessionLoadCount or 0
							task.spawn(MessagingService.PublishAsync, MessagingService, "PS_" .. active_session[3], {LoadCount = session_load_count, EndSession = true})
						end

						-- Attempt to load the profile again after a delay
						local wait_until = os.clock() + if request_force_load == true then FIRST_LOAD_REPEAT else LOAD_REPEAT_PERIOD
						repeat task.wait() until os.clock() >= wait_until or ProfileStore.IsClosing == true

					else
						-- Another session tried to load this profile:
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					request_force_load = false -- Only request a force load once

				end

			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely that this server started shutting down
			end
		else

			-- A DataStore call has likely ended in an error:

			local default_timeout = false

			if params.Cancel == nil then
				default_timeout = os.clock() - start >= START_SESSION_TIMEOUT
			end

			if default_timeout == true or ProfileStore.IsClosing == true or cancel_condition() == true then
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

			task.wait(exp_backoff)  -- Repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- Game started shutting down or the request was cancelled - don't return the profile

end

function ProfileStore:MessageAsync(profile_key, message)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if type(message) ~= "table" then
		error(`[{script.Name}]: message must be a table`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Updating profile:

		local loaded_data = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local global_updates = latest_data.GlobalUpdates
					local update_list = global_updates[2]
					--{
					--	update_index,
					--	{
					--		{update_index, data}, ...
					--	},
					--},

					global_updates[1] += 1
					table.insert(update_list, {global_updates[1], message})

					-- Clearing queue if above limit:

					while #update_list > MAX_MESSAGE_QUEUE do
						table.remove(update_list, 1)
					end

				end,
			},
			is_mock
		)

		if loaded_data ~= nil then

			local session_token = SessionToken(self.Name, profile_key, is_mock)

			local profile = ActiveSessionCheck[session_token]

			if profile ~= nil then

				-- The message was sent to a profile that is active in this server:
				profile:Save()

			else

				local meta_data = loaded_data.MetaData or {}
				local active_session = meta_data.ActiveSession
				local session_load_count = meta_data.SessionLoadCount or 0

				if type(active_session) == "table" and type(active_session[3]) == "string" then
					-- Request the remote server to auto-save sooner and receive the message:
					task.spawn(MessagingService.PublishAsync, MessagingService, "PS_" .. active_session[3], {LoadCount = session_load_count})
				end

			end

			return true

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return false

end

function ProfileStore:GetAsync(profile_key, version)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	if version ~= nil and (is_mock or DataStoreState ~= "Access") then
		return nil -- No version support in mock mode
	end

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Load profile:

		local loaded_data, key_info = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)

					latest_data.Data = DeepCopyTable(self.template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {}, -- Backwards compatibility with ProfileService
					}

				end,
				EditProfile = nil,
			},
			is_mock,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)

		-- Handle load_data:

		if loaded_data ~= nil then

			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end

			local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock)
			profile.view_mode = true

			return profile

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return nil -- Game started shutting down - don't return the profile

end

function ProfileStore:RemoveAsync(profile_key)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local wipe_status = false

	local next_in_queue = WaitInUpdateQueue(SessionToken(self.Name, profile_key, is_mock))

	if is_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

		local mock_data_store = UserMockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				UserMockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	elseif DataStoreState ~= "Access" then -- Used when API access is disabled

		local mock_data_store = MockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				MockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	else -- Live DataStore

		wipe_status = pcall(function()
			self.data_store:RemoveAsync(profile_key)
		end)

	end

	next_in_queue()

	return wipe_status

end

local ProfileVersionQuery = {}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery.New(profile_store, profile_key, sort_direction, min_date, max_date, is_mock)

	local self = {
		profile_store = profile_store,
		profile_key = profile_key,
		sort_direction = sort_direction,
		min_date = min_date,
		max_date = max_date,

		query_pages = nil,
		query_index = 0,
		query_failure = false,

		is_query_yielded = false,
		query_queue = {},

		is_mock = is_mock,
	}
	setmetatable(self, ProfileVersionQuery)

	return self

end

function MoveVersionQueryQueue(self) -- Hidden ProfileVersionQuery method
	while #self.query_queue > 0 do

		local queue_entry = table.remove(self.query_queue, 1)

		task.spawn(queue_entry)

		if self.is_query_yielded == true then
			break
		end

	end
end

local VersionQueryNextAsyncStackingFlag = false
local WarnAboutVersionQueryOnce = false

function ProfileVersionQuery:NextAsync()

	local is_stacking = VersionQueryNextAsyncStackingFlag == true
	VersionQueryNextAsyncStackingFlag = false

	WaitForStoreReady(self.profile_store)

	if ProfileStore.IsClosing == true then
		return nil -- Silently fail :NextAsync() requests
	end

	if self.is_mock == true or DataStoreState ~= "Access" then
		if IsStudio == true and WarnAboutVersionQueryOnce == false then
			WarnAboutVersionQueryOnce = true
			warn(`[{script.Name}]: :VersionQuery() is not supported in mock mode!`)
		end
		return nil -- Silently fail :NextAsync() requests
	end

	local profile
	local is_finished = false

	local function query_job()

		if self.query_failure == true then
			is_finished = true
			return
		end

		-- First "next" call loads version pages:

		if self.query_pages == nil then

			self.is_query_yielded = true

			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local list_success, error_message = pcall(function()
				self.query_pages = self.profile_store.data_store:ListVersionsAsync(
					self.profile_key,
					self.sort_direction,
					self.min_date,
					self.max_date
				)
				self.query_index = 0
			end)

			if list_success == false or self.query_pages == nil then
				warn(`[{script.Name}]: Version query fail - {tostring(error_message)}`)
				self.query_failure = true
			end

			self.is_query_yielded = false

			MoveVersionQueryQueue(self)

			return

		end

		local current_page = self.query_pages:GetCurrentPage()
		local next_item = current_page[self.query_index + 1]

		-- No more entries:

		if self.query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self.is_query_yielded = true
			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local success, error_message = pcall(function()
				self.query_pages:AdvanceToNextPageAsync()
				self.query_index = 0
			end)

			if success == false or #self.query_pages:GetCurrentPage() == 0 then
				self.query_failure = true
			end

			self.is_query_yielded = false
			MoveVersionQueryQueue(self)

			return

		end

		-- Next page item:

		self.query_index += 1
		profile = self.profile_store:GetAsync(self.profile_key, next_item.Version)
		is_finished = true

	end

	if self.is_query_yielded == false then
		query_job()
	else
		if is_stacking == true then
			table.insert(self.query_queue, 1, query_job)
		else
			table.insert(self.query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

function ProfileStore:VersionQuery(profile_key, sort_direction, min_date, max_date)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	-- Type check:

	if sort_direction ~= nil and (typeof(sort_direction) ~= "EnumItem"
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error(`[{script.Name}]: Invalid sort_direction ({tostring(sort_direction)})`)
	end

	if min_date ~= nil and typeof(min_date) ~= "DateTime" and typeof(min_date) ~= "number" then
		error(`[{script.Name}]: Invalid min_date ({tostring(min_date)})`)
	end

	if max_date ~= nil and typeof(max_date) ~= "DateTime" and typeof(max_date) ~= "number" then
		error(`[{script.Name}]: Invalid max_date ({tostring(max_date)})`)
	end

	min_date = typeof(min_date) == "DateTime" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == "DateTime" and max_date.UnixTimestampMillis or max_date

	return ProfileVersionQuery.New(self, profile_key, sort_direction, min_date, max_date, is_mock)

end

-- DataStore API access check:

if IsStudio == true then

	task.spawn(function()

		local new_state = "NoAccess"

		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
		end)

		local no_internet_access = status == false and string.find(message, "ConnectFail", 1, true) ~= nil

		if no_internet_access == true then
			warn(`[{script.Name}]: No internet access - check your network connection`)
		end

		if status == false and
			(string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, "must publish", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			new_state = if no_internet_access == true then "NoInternet" else "NoAccess"
			print(`[{script.Name}]: Roblox API services unavailable - data will not be saved`)
		else
			new_state = "Access"
			print(`[{script.Name}]: Roblox API services available - data will be saved`)
		end

		DataStoreState = new_state
		ProfileStore.DataStoreState = new_state

	end)

else

	DataStoreState = "Access"
	ProfileStore.DataStoreState = "Access"

end

-- Update loop:

RunService.Heartbeat:Connect(function()

	-- Auto saving:

	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = AUTO_SAVE_PERIOD / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile.load_timestamp < AUTO_SAVE_PERIOD / 2 then
				-- This profile is freshly loaded - auto saving immediately is not necessary:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile.load_timestamp >= AUTO_SAVE_PERIOD / 2 then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end

	-- Critical state handling:

	if ProfileStore.IsCriticalState == false then
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			ProfileStore.IsCriticalState = true
			ProfileStore.OnCriticalToggle:Fire(true)
			CriticalStateStart = os.clock()
			warn(`[{script.Name}]: Entered critical state`)
		end
	else
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > CRITICAL_STATE_EXPIRE then
			ProfileStore.IsCriticalState = false
			ProfileStore.OnCriticalToggle:Fire(false)
			warn(`[{script.Name}]: Critical state ended`)
		end
	end

	-- Issue queue:

	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > CRITICAL_STATE_ERROR_EXPIRE then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end

end)

-- Release all loaded profiles when the server is shutting down:

task.spawn(function()

	while DataStoreState == "NotReady" do
		task.wait()
	end

	if DataStoreState ~= "Access" then

		game:BindToClose(function()
			ProfileStore.IsClosing = true
			task.wait() -- Mock shutdown delay
		end)

		return -- Don't wait for profiles to properly save in mock mode so studio could end the simulation faster

	end

	game:BindToClose(function()

		ProfileStore.IsClosing = true

		-- Release all active profiles:
		-- (Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released)

		local on_close_save_job_count = 0
		local active_profiles = {}
		for index, profile in ipairs(AutoSaveList) do
			active_profiles[index] = profile
		end

		-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
		for _, profile in ipairs(active_profiles) do
			if profile:IsActive() == true then
				on_close_save_job_count = on_close_save_job_count + 1
				task.spawn(function() -- Save profile on new thread
					SaveProfileAsync(profile, true, nil, "Shutdown")
					on_close_save_job_count = on_close_save_job_count - 1
				end)
			end
		end

		-- Yield until all active profile jobs are finished:
		while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
			task.wait()
		end

		return -- We're done!

	end)

end)

return ProfileStore]]></ProtectedString>
							<string name="ScriptGuid">{7B667C90-B5AE-4041-A76C-C35011A3E431}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ProfileStore</string>
							<int64 name="SourceAssetId">109379033046155</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0238ED63593B4E7A83F7903C5A5C101D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "ProfileStore",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 109379033046155,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Loleris"},
		{Text = "Description: Periodic DataStore saving solution with session locking"},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Advanced scripting knowledge"}
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{9B780DAC-B21A-42D1-B0D1-32E425FC5B2C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXE4F9530576524A4CA69EE3FC9635B257">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">NeoHotbarLoader</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="LocalScript" referent="RBX4544D82F9E784DD988C3AAAE709B9EE1">
						<Properties>
							<ProtectedString name="Source"><![CDATA[local NeoHotbar = require(script.NeoHotbar)

NeoHotbar:Start()]]></ProtectedString>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{EADDE651-7774-4545-8F79-7733EFF325E2}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">NeoHotbarLoader</string>
							<int64 name="SourceAssetId">15617827028</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX96A32D90330149C987DBF63A85C004A4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source">return require(script.Packages[&quot;NeoHotbar&quot;])</ProtectedString>
								<string name="ScriptGuid">{CCFE89E9-8F36-41CA-82B2-57D97A5B67EF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">NeoHotbar</string>
								<int64 name="SourceAssetId">15617827028</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX9D2D67CEBACA430090B70915B09CFFF2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Packages</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX4F38BCA422A34D9296A5A54458F77CCE">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["elttob_fusion@0.2.0"]["fusion"])
]]></ProtectedString>
										<string name="ScriptGuid">{02811EA8-EE71-4850-8916-9C1064ACE26C}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Fusion</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXE676461345454A2BACDD8B9A9850EFEB">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["hexcede_fusion-utils@0.1.2"]["fusion-utils"])
]]></ProtectedString>
										<string name="ScriptGuid">{A6C57CDE-99F4-4299-A968-CC1213998F30}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">FusionUtils</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX268A8BEC4F20463C99FF412B9564824F">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

local States = require(script.States)
local HotbarGui = require(script.Components.Hotbar)

local GAMEPAD_SELECTOR_INDEXERS = { Left = -1, Right = 1 }

if not RunService:IsStudio() then
	print("NeoHotbar by Avafe ")
end

--[=[
	@class NeoHotbar
]=]
local NeoHotbar = {
	Started = false,
	States = States,
}

--[=[
	Initializes NeoHotbar and deploys its UI with default settings.
]=]
function NeoHotbar:Start()
	if self.Started then
		warn("NeoHotbar has already been started. It cannot be started again.")
		return
	end

	self.Started = true

	States:Start()

	self:_CreateGui()
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)

	UserInputService.InputEnded:Connect(function(Input)
		if not States.Enabled:get() then return end
		if UserInputService:GetFocusedTextBox() then return end

		local ToolSlots = States.ToolSlots:get()

		if Input.UserInputType == Enum.UserInputType.Keyboard then
			local InputNumber = tonumber(UserInputService:GetStringForKeyCode(Input.KeyCode))
			if InputNumber then
				local ToolSlot = ToolSlots[InputNumber]
				if ToolSlot then
					States:ToggleToolEquipped(ToolSlot.Tool:get())
				end
				States.ManagementMode.Active:set(false)
			elseif Input.KeyCode == Enum.KeyCode.Backquote then
				if States.ManagementMode.Enabled:get() then
					States.ManagementMode.Active:set(not States.ManagementMode.Active:get())
				end
			end
		elseif Input.UserInputType == Enum.UserInputType.Gamepad1 then
			local EquippedToolSlot, EquippedToolSlotIndex = States:GetEquippedToolSlot()
			local SelectorDirection

			if Input.KeyCode == Enum.KeyCode.ButtonL1 then
				SelectorDirection = "Left"
			elseif Input.KeyCode == Enum.KeyCode.ButtonR1 then
				SelectorDirection = "Right"
			else
				return
			end

			local ToolSlot
			if EquippedToolSlot then
				local ToolSlotIndex = EquippedToolSlotIndex + GAMEPAD_SELECTOR_INDEXERS[SelectorDirection]
				ToolSlot = ToolSlots[ToolSlotIndex]
				ToolSlot = ToolSlot or EquippedToolSlot -- Set equipped tool to be unequipped if reached end
			else
				if not ToolSlot then -- For default / wrapover selection based on direction
					if SelectorDirection == "Left" then
						ToolSlot = ToolSlots[#ToolSlots]
					elseif SelectorDirection == "Right" then
						ToolSlot = ToolSlots[1]
					end
				end
			end

			States:ToggleToolEquipped(ToolSlot.Tool:get())
			States.ManagementMode.Active:set(false)
		elseif (Input.UserInputType == Enum.UserInputType.MouseButton1) or (Input.UserInputType == Enum.UserInputType.Touch) then
			local InteractedGuiObjects = Players.LocalPlayer.PlayerGui:GetGuiObjectsAtPosition(Input.Position.X, Input.Position.Y)
			
			local GuiWithinToolSlots
			for _, GuiObject in ipairs(InteractedGuiObjects) do
				local NeoHotbarAncestor = GuiObject:FindFirstAncestor("NeoHotbar")
				if NeoHotbarAncestor == self._HotbarGui then
					GuiWithinToolSlots = true
					break
				end
			end

			if not GuiWithinToolSlots then
				States.ManagementMode.Active:set(false)
				States.ContextMenu.Active:set(false)
			end
		end
	end)
end

--[=[
	Sets whether NeoHotbar or not is enabled. Disabling hides the hotbar and turns off keybinds.

	@param Enabled -- Whether or not to enable NeoHotbar.
]=]
function NeoHotbar:SetEnabled(Enabled: boolean)
	if typeof(Enabled) ~= "boolean" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can change if it's enabled or not.")
		return
	end

	States.Enabled:set(Enabled)

	States.ManagementMode.Active:set(false)
	States.ContextMenu.Active:set(false)
end

--[=[
	Sets whether or not ToolTips are enabled.

	@param Enabled -- Whether or not to enable.
]=]
function NeoHotbar:SetToolTipsEnabled(Enabled: boolean)
	if typeof(Enabled) ~= "boolean" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can change if ToolTips are enabled or not.")
		return
	end

	States.ToolTip.Enabled:set(Enabled)
end

--[=[
	Sets whether or not players can rearrange the tools in their hotbar.

	@param Enabled -- Whether or not to enable.
]=]
function NeoHotbar:SetManagementEnabled(Enabled: boolean)
	if typeof(Enabled) ~= "boolean" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can change if hotbar management is enabled.")
		return
	end

	States.ManagementMode.Enabled:set(Enabled)
end

--[=[
	Sets whether or not players can open the context menu. *(the one that appears when you right click on a tool)*

	@param Enabled -- Whether or not to enable.
]=]
function NeoHotbar:SetContextMenuEnabled(Enabled: boolean)
	if typeof(Enabled) ~= "boolean" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can change if the context menu is enabled or not.")
		return
	end

	States.ContextMenu.Enabled:set(Enabled)
end

--[=[
	Overrides NeoHotbar's UI with a new set of Gui objects.

	@param CustomGuiSet -- The parent folder containing your custom Gui objects.
	@param DefaultEffectsEnabled -- Whether or not to enable NeoHotbar's built-in UI effects. Not compatible with ultra-customized themes.
]=]
function NeoHotbar:OverrideGui(CustomGuiSet: Folder, DefaultEffectsEnabled: boolean?)
	if typeof(CustomGuiSet) ~= "Instance" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can override its GUI.")
		return
	end
	
	if DefaultEffectsEnabled == nil then
		DefaultEffectsEnabled = false
	end

	States.InstanceSet:set(CustomGuiSet)
	States.DefaultEffectsEnabled:set(DefaultEffectsEnabled)
	self._HotbarGui:Destroy()
	self:_CreateGui()
end

--[=[
	Reset NeoHotbar's UI back to the default.
]=]
function NeoHotbar:ResetGui()
	if not self.Started then
		warn("NeoHotbar needs to be started before you can reset its GUI.")
		return
	end

	States.InstanceSet:set(script.DefaultInstances)
	States.DefaultEffectsEnabled:set(true)
	self._HotbarGui:Destroy()
	self:_CreateGui()
end

--[=[
	Adds a custom button to the hotbar, prepended to the left-most side.

	@param ButtonName -- The name/identifier of the button to be added.
	@param IconImage -- The image URI to be used on the button icon. E.g. "rbxassetid://".
	@param Callback -- The function called upon button activation (click/touch/etc).
	@param GamepadKeybind -- A gamepad keycode to trigger your custom button.
]=]
function NeoHotbar:AddCustomButton(ButtonName: string, IconImage: string, Callback: any, GamepadKeybind: EnumItem?)
	if typeof(ButtonName) ~= "string" then return end
	if typeof(IconImage) ~= "string" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can add or remove custom buttons.")
		return
	end

	local CustomButtons = States.CustomButtons:get()
	table.insert(CustomButtons, {
		Name = ButtonName,
		Icon = IconImage,
		Callback = Callback,
		GamepadKeybind = GamepadKeybind,
	})
	States.CustomButtons:set(CustomButtons)

	if GamepadKeybind then
		ContextActionService:BindAction(`NeoHotbar_{ButtonName}`, function(_, InputState: EnumItem)
			if InputState == Enum.UserInputState.End then
				Callback()
			end
		end, false, GamepadKeybind)
	end
end

--[=[
	Removes the specified custom button from the hotbar.

	@param ButtonName -- The name of the button to be removed.
]=]
function NeoHotbar:RemoveCustomButton(ButtonName: string)
	if typeof(ButtonName) ~= "string" then return end

	if not self.Started then
		warn("NeoHotbar needs to be started before you can add or remove custom buttons.")
		return
	end

	local CustomButton = States:FindCustomButton(ButtonName)
	assert(CustomButton, 'Custom button "' .. ButtonName .. '" could not be found.')

	local CustomButtons = States.CustomButtons:get()
	table.remove(CustomButtons, table.find(CustomButtons, CustomButton))
	States.CustomButtons:set(CustomButtons)

	if CustomButton.GamepadKeybind then
		ContextActionService:UnbindAction(`NeoHotbar_{ButtonName}`)
	end
end

--[=[
	Returns the specified custom button if found.

	@param ButtonName -- The name of the button to be searched for.
]=]
function NeoHotbar:FindCustomButton(ButtonName: string)
	if typeof(ButtonName) ~= "string" then return end

	return States:FindCustomButton(ButtonName)
end

--[=[
	@private

	Builds NeoHotbar's UI. Only intended for internal use.
]=]
function NeoHotbar:_CreateGui()
	self._HotbarGui = HotbarGui({
		Parent = Players.LocalPlayer.PlayerGui,
	})
end

return NeoHotbar]]></ProtectedString>
										<string name="ScriptGuid">{22610283-5435-4FC0-9192-5080B5153EF8}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">NeoHotbar</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX862DD5E3E1B143F8A248561C7651720A">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local NeoHotbar = script.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)

local Value = Fusion.Value
local Observer = Fusion.Observer

local States = {
	Enabled = Value(true),
	InstanceSet = Value(NeoHotbar.DefaultInstances),
	DefaultEffectsEnabled = Value(true),
	ManagementMode = {
		Enabled = Value(true),
		Active = Value(false),
		Swapping = {
			PrimarySlot = Value(),
			SecondarySlot = Value(),
		},
	},
	ToolTip = {
		Enabled = Value(true),
		Visible = Value(false),
		Text = Value(""),
	},
	ContextMenu = {
		Enabled = Value(true),
		Active = Value(false),
		GuiObject = Value(),
		Actions = Value(),
	},
	ToolSlots = Value({}),
	CustomButtons = Value({}),
	GamepadInUse = Value(false),
}

function States:DropTool(Tool: Tool)
	States.Humanoid:EquipTool(Tool)
	Tool.Parent = workspace
end

function States:ToggleToolEquipped(Tool: Tool)
	if Tool.Parent == States.Backpack then
		States.Humanoid:EquipTool(Tool)
	else
		States.Humanoid:UnequipTools()
	end
end

function States:SwapToolSlots(SlotIndex1: number, SlotIndex2: number)
	local ToolSlots = States.ToolSlots:get()
	local ToolSlot1, ToolSlot2 = ToolSlots[SlotIndex1], ToolSlots[SlotIndex2]
	if ToolSlot1 and ToolSlot2 then
		ToolSlots[SlotIndex1] = ToolSlot2
		ToolSlots[SlotIndex2] = ToolSlot1
	end
	States.ToolSlots:set(ToolSlots)
end

function States:ToggleContextMenuToSlot(ToolButton: Instance, Tool: Tool)
	if States.ContextMenu.GuiObject:get() ~= ToolButton then
		States:SetContextMenuToSlot(ToolButton, Tool)
	else
		States.ContextMenu.Active:set(false)
		States.ContextMenu.GuiObject:set(nil)
		States.ContextMenu.Actions:set({})
	end
end

function States:SetContextMenuToSlot(ToolButton: GuiObject, Tool: Tool)
	if typeof(ToolButton) ~= "Instance" then
		return
	end
	if typeof(Tool) ~= "Instance" then
		return
	end
	if not Tool:IsA("Tool") then
		return
	end

	local Actions = {}
	if Tool.CanBeDropped then
		table.insert(Actions, {
			Name = "Drop",
			Function = function()
				States:DropTool(Tool)
			end,
		})
	end
	self.ContextMenu.Actions:set(Actions)

	if #Actions >= 1 then
		if self.ContextMenu.Enabled:get() then
			self.ContextMenu.GuiObject:set(ToolButton)
			self.ContextMenu.Active:set(true)
		end
	else
		self.ContextMenu.GuiObject:set(nil)
		self.ContextMenu.Active:set(false)
	end

	self.ToolTip.Visible:set(false)
end

function States:GetEquippedToolSlot()
	local ToolSlots = self.ToolSlots:get()
	for _, ToolSlot in ipairs(ToolSlots) do
		if ToolSlot.Equipped:get() then
			local Index = table.find(ToolSlots, ToolSlot)
			return ToolSlot, Index
		end
	end
end

function States:FindCustomButton(ButtonName: string)
	local CustomButtons = self.CustomButtons:get()
	for _, CustomButton in ipairs(CustomButtons) do
		if CustomButton.Name == ButtonName then
			return CustomButton
		end
	end
end

function States:_FindToolSlot(Tool: Tool)
	local ToolSlots = self.ToolSlots:get()
	for ToolNum, ToolSlot in ipairs(ToolSlots) do
		if ToolSlot.Tool:get() == Tool then
			return ToolNum
		end
	end
end

function States:_UpdateToolTip(ToolTip: string | nil)
	if ToolTip == nil then
		self.ToolTip.Visible:set(false)
	else
		if utf8.len(ToolTip) >= 1 then
			self.ToolTip.Text:set(ToolTip)
			self.ToolTip.Visible:set(States.ToolTip.Enabled:get() and true)
			if self.ToolTipProcess then
				task.cancel(self.ToolTipProcess)
			end
			self.ToolTipProcess = task.delay(2, function()
				self.ToolTip.Visible:set(false)
			end)
		else
			self.ToolTip.Visible:set(false)
		end
	end
end

function States:_UpdateToolTipListener(Tool: Tool | nil)
	if self.ToolTipChangedSignal then
		self.ToolTipChangedSignal:Disconnect()
	end

	if Tool then
		self.ToolTipChangedSignal = Tool:GetPropertyChangedSignal("ToolTip"):Connect(function()
			self:_UpdateToolTip(Tool.ToolTip)
		end)
	end
end

function States:_ToolAdded(Tool: Tool)
	if Tool:IsA("Tool") then
		local NewToolSlots = self.ToolSlots:get()
		local ToolSlot = NewToolSlots[self:_FindToolSlot(Tool)]
		if not ToolSlot then
			table.insert(NewToolSlots, {
				Tool = Value(Tool),
				Equipped = Value(Tool.Parent == self.Character),
			})
			ToolSlot = NewToolSlots[self:_FindToolSlot(Tool)]
		else
			ToolSlot.Equipped:set(Tool.Parent == self.Character)
		end
		self.ToolSlots:set(NewToolSlots)

		if ToolSlot.Equipped:get() then
			if self.ManagementMode.Active:get() then
				task.defer(function()
					if Tool.Parent == self.Character then
						self.ManagementMode.Active:set(false)
						self.ContextMenu.Active:set(false)

						if CollectionService:HasTag(GuiService.SelectedObject, "NeoHotbarToolButton") then
							GuiService.SelectedObject = nil
						end
					end
				end)
			else
				self:_UpdateToolTip(Tool.ToolTip)
				self:_UpdateToolTipListener(Tool)
			end
		end
	end
end

function States:_ToolRemoved(Tool: Tool)
	local NewToolSlots = self.ToolSlots:get()
	local ToolNum = self:_FindToolSlot(Tool)
	local ToolSlot = NewToolSlots[ToolNum]
	if ToolSlot then
		if Tool.Parent ~= self.Backpack and Tool.Parent ~= self.Character then
			table.remove(NewToolSlots, ToolNum)
			self:_UpdateToolTip()
		else
			ToolSlot.Equipped:set(Tool.Parent == self.Character)
		end
		self.ToolSlots:set(NewToolSlots)

		self:_UpdateToolTipListener()
	end
end

function States:_ScanToolDir(ToolDir: Instance)
	for _, Child in ipairs(ToolDir:GetChildren()) do
		self:_ToolAdded(Child)
	end
end

function States:_CharacterAdded(NewChar: Model)
	self.ToolSlots:set({})

	self.Character = NewChar
	self.Humanoid = self.Character:WaitForChild("Humanoid")

	self.Character.ChildAdded:Connect(function(Tool)
		self:_ToolAdded(Tool)
	end)
	self.Character.ChildRemoved:Connect(function(Tool)
		self:_ToolRemoved(Tool)
	end)
	self:_ScanToolDir(self.Character)

	self.Backpack = Players.LocalPlayer:WaitForChild("Backpack")
	self.Backpack.ChildAdded:Connect(function(Tool)
		self:_ToolAdded(Tool)
	end)
	self.Backpack.ChildRemoved:Connect(function(Tool)
		self:_ToolRemoved(Tool)
	end)
	self:_ScanToolDir(self.Backpack)
end

function States:_UpdateGamepadInUse(Input: InputObject)
	local Gamepads = {
		Enum.UserInputType.Gamepad1,
		Enum.UserInputType.Gamepad2,
		Enum.UserInputType.Gamepad3,
		Enum.UserInputType.Gamepad4,
		Enum.UserInputType.Gamepad5,
		Enum.UserInputType.Gamepad6,
		Enum.UserInputType.Gamepad7,
		Enum.UserInputType.Gamepad8,
	}
	States.GamepadInUse:set(table.find(Gamepads, Input.UserInputType) ~= nil)
end

function States:Start()
	self.Backpack = Players.LocalPlayer:WaitForChild("Backpack")

	Players.LocalPlayer.CharacterAdded:Connect(function(Char)
		self:_CharacterAdded(Char)
	end)
	local ExistingCharacter = Players.LocalPlayer.Character
	if ExistingCharacter then
		self:_CharacterAdded(ExistingCharacter)
	end

	Observer(self.ManagementMode.Active):onChange(function()
		if self.ManagementMode.Active:get() then
			if self.Humanoid then
				self.Humanoid:UnequipTools()
			end
		else
			States.ManagementMode.Swapping.PrimarySlot:set(nil)
			States.ManagementMode.Swapping.SecondarySlot:set(nil)
		end
	end)

	UserInputService.InputChanged:Connect(function(Input: InputObject)
		self:_UpdateGamepadInUse(Input)
	end)
	UserInputService.InputEnded:Connect(function(Input: InputObject)
		self:_UpdateGamepadInUse(Input)
	end)
end

return States
]]></ProtectedString>
											<string name="ScriptGuid">{27D503DF-AA01-4528-BE1D-CE3FE8E79F0F}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">States</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX1E2A71092CE44654A6A57227F27CAE6C">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[local GuiModules = {script.Parent.Components.Hotbar}

return function(Target)
    local Guis = {}

    for _, GuiModule in ipairs(GuiModules) do
        local GuiNameSplit = string.split(GuiModule.Name, ".")
        local StorySuffix = GuiNameSplit[2]
        
        if not StorySuffix and GuiModule:IsA("ModuleScript") then
            local Gui = require(GuiModule)
            table.insert(Guis, Gui {
                Parent = Target
            })
        end
    end

    return function()
        for _, Gui in ipairs(Guis) do
            Gui:Destroy()
        end
    end
end]]></ProtectedString>
											<string name="ScriptGuid">{46ECD976-F80B-4718-8372-604333EB6CF5}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Hotbar.story</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Folder" referent="RBXEDBA58D6473E40F19B1350044FA7C821">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Components</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX1AF4596DCE0644699E6BBAE0370176E6">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child

return function(Props: table)
	Props.Image = EnsureProp(Props.Image, "string", "")

	return Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		[Child "Image"] = {
			Image = Props.Image
		}
	}
end]]></ProtectedString>
												<string name="ScriptGuid">{DBF21866-94A4-439A-9520-35450DB98940}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ButtonImage</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX408DC55201CE48C09869EA2152B44355">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Hydrate = Fusion.Hydrate

return function(Props: table)
	Props.Text = EnsureProp(Props.Text, "string", "Text")

	local ButtonText = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		Text = Props.Text,
	}

	if States.DefaultEffectsEnabled:get() then
		Hydrate(ButtonText)({
			FontFace = Font.fromName("GothamSsm")
		})
	end

	return ButtonText
end]]></ProtectedString>
												<string name="ScriptGuid">{BD60E87A-F75D-435E-B486-DE5ECD95BA6F}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ButtonText</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX756D1AF91E5E4A72941FF625F08B6F06">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)

local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child
local Children = Fusion.Children
local ForValues = Fusion.ForValues

local Components = NeoHotbar.Components
local ContextActionButton = require(Components.ContextActionButton)

return function()
	return Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		Visible = States.ContextMenu.Active,

		[Child "Actions"] = {
			[Children] = {
				ForValues(States.ContextMenu.Actions, function(Action)
					return ContextActionButton({
						Action = Action,
					})
				end, Fusion.cleanup),
			},
		},
	}
end
]]></ProtectedString>
												<string name="ScriptGuid">{483D31E2-0928-4706-A0D7-EEEDDE1CB5C0}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ContextMenu</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXB39661B7CD8747938EC5F051C2E93E9C">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Children = Fusion.Children
local OnEvent = Fusion.OnEvent
local Hydrate = Fusion.Hydrate

local Components = NeoHotbar.Components

local ButtonImage = require(Components.ButtonImage)
local ButtonHint = require(Components.ButtonHint)

return function(Props: table)
	Props.LayoutOrder = EnsureProp(Props.LayoutOrder, "number", 0)
	Props.Callback = EnsureProp(Props.Callback, "function", function()end)
	Props.Icon = EnsureProp(Props.Icon, "string", "")
	Props.GamepadKeybind = EnsureProp(Props.GamepadKeybind, "EnumItem", nil)
	
	return Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		LayoutOrder = Props.LayoutOrder,

		[OnEvent "Activated"] = function()
			if Props.Callback:get() then
				Props.Callback:get()()
			end
		end,

		[Children] = {
			ButtonImage {
				Image = Props.Icon
			},
			ButtonHint {
				Keycode = Props.GamepadKeybind
			}
		}
	}
end]]></ProtectedString>
												<string name="ScriptGuid">{026505FC-C4D8-4F3A-9B2D-8D40E43F3D98}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">CustomButton</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX65F5F4C8DB8B4B8389EFA49FE72F6E8F">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Computed = Fusion.Computed
local Children = Fusion.Children
local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child
local ForPairs = Fusion.ForPairs

local Components = NeoHotbar.Components

local ToolButton = require(Components.ToolButton)
local CustomButton = require(Components.CustomButton)
local ToolTip = require(Components.ToolTip)

return function(Props: table)
	Props.Parent = EnsureProp(Props.Parent, "Instance", nil)

	local Hotbar = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		Name = "NeoHotbar",
		Parent = Props.Parent,
		Enabled = States.Enabled,

		[Child "Hotbar"] = {
			[Child "Buttons"] = {
				[Child "CustomButtons"] = {
					Visible = Computed(function()
						return not States.ManagementMode.Active:get()
					end),

					[Children] = ForPairs(States.CustomButtons, function(ButtonNum, ButtonEntry)
						return ButtonNum,
							CustomButton {
								Icon = ButtonEntry.Icon,
								Callback = ButtonEntry.Callback,
								LayoutOrder = ButtonEntry.LayoutOrder,
								GamepadKeybind = ButtonEntry.GamepadKeybind,
							}
					end, Fusion.cleanup),
				},
				[Child "ToolSlots"] = {
					[Children] = ForPairs(States.ToolSlots, function(ToolNum, ToolSlot)
						return ToolNum,
							ToolButton {
								Tool = ToolSlot.Tool,
								Equipped = ToolSlot.Equipped,
								ToolNumber = ToolNum,
								LayoutOrder = ToolNum,
							}
					end, Fusion.cleanup),
				},
			},

			[Children] = {
				ToolTip {},
			},
		},
	}

	if States.DefaultEffectsEnabled:get() then
		local Padding = Computed(function()
			local ManagementModeEnabled = States.ManagementMode.Active:get()
			return UDim.new(0, (ManagementModeEnabled and 4) or 0)
		end)

		Hydrate(Hotbar) {
			[Child "Hotbar"] = {
				[Child "Buttons"] = {
					[Child "ToolSlots"] = {
						BackgroundTransparency = Computed(function()
							return (States.ManagementMode.Active:get() and 0.8) or 1
						end),

						[Child "UIPadding"] = {
							PaddingTop = Padding,
							PaddingBottom = Padding,
							PaddingRight = Padding,
							PaddingLeft = Padding,
						},
						[Child "UIStroke"] = {
							Enabled = States.ManagementMode.Active,
						},
					},
					[Child "UIListLayout"] = {
						Padding = Computed(function()
							local ToolSlots = States.ToolSlots:get()
							local CustomButtons = States.CustomButtons:get()
							local OffsetPadding = ((#ToolSlots >= 1 and #CustomButtons >= 1) and 10) or 0
							return UDim.new(0, OffsetPadding)
						end),
					},
				},
			},
		}
	end

	return Hotbar
end
]]></ProtectedString>
												<string name="ScriptGuid">{EB00646B-393C-4BF9-A961-53FEC8FA2FF7}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Hotbar</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX38E609C76FDA43BCA194D118F2A9F835">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Children = Fusion.Children
local Computed = Fusion.Computed
local OnEvent = Fusion.OnEvent
local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child
local Value = Fusion.Value
local New = Fusion.New
local Observer = Fusion.Observer
local Cleanup = Fusion.Cleanup

local Components = NeoHotbar.Components

local ButtonText = require(Components.ButtonText)
local ButtonImage = require(Components.ButtonImage)
local ContextMenu = require(Components.ContextMenu)

local Mouse = Players.LocalPlayer:GetMouse()
local PlayerGui = Players.LocalPlayer:FindFirstChild("PlayerGui")

local HoveredToolSlot = Value()

local MouseMoveConnection: RBXScriptConnection
local TouchMoveConnection: RBXScriptConnection

UserInputService.InputEnded:Connect(function(Input: InputObject)
	if (Input.UserInputType == Enum.UserInputType.MouseButton1) or Input.UserInputType == Enum.UserInputType.Touch then
		if MouseMoveConnection then
			MouseMoveConnection:Disconnect()
		end
		if TouchMoveConnection then
			TouchMoveConnection:Disconnect()
		end

		if States.ManagementMode.Swapping.PrimarySlot:get() and States.ManagementMode.Swapping.SecondarySlot:get() then
			States:SwapToolSlots(
				States.ManagementMode.Swapping.PrimarySlot:get():GetAttribute("SlotNumber"),
				States.ManagementMode.Swapping.SecondarySlot:get():GetAttribute("SlotNumber")
			)
		end
		States.ManagementMode.Swapping.PrimarySlot:set(nil)
		States.ManagementMode.Swapping.SecondarySlot:set(nil)
	end
end)

local function SelectionMove(X: number, Y: number)
	if PlayerGui then
		local Objects = PlayerGui:GetGuiObjectsAtPosition(X, Y)
		for _, Object in ipairs(Objects) do
			if CollectionService:HasTag(Object, "NeoHotbarToolButton") then
				if Object ~= HoveredToolSlot:get() then
					HoveredToolSlot:set(Object)
					States.ManagementMode.Swapping.SecondarySlot:set(Object)
				end
			end
		end
	end
end

return function(Props: table)
	Props.LayoutOrder = EnsureProp(Props.LayoutOrder, "number", 1)
	Props.Equipped = EnsureProp(Props.Equipped, "boolean", false)
	Props.Tool = EnsureProp(Props.Tool, "Tool", Instance.new("Tool"))
	Props.ToolNumber = EnsureProp(Props.ToolNumber, "number", 1)

	local Holding = Value(false)
	local ObserverDisconnects = {}

	local ToolButton
	ToolButton = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		LayoutOrder = Props.LayoutOrder,

		[OnEvent "Activated"] = function()
			if States.ManagementMode.Active:get() then
				local SwappedTool = false
				if GuiService.SelectedObject == ToolButton then
					if States.ManagementMode.Swapping.PrimarySlot:get() then
						States.ManagementMode.Swapping.SecondarySlot:set(ToolButton)
						States:SwapToolSlots(
							States.ManagementMode.Swapping.PrimarySlot:get():GetAttribute("SlotNumber"),
							States.ManagementMode.Swapping.SecondarySlot:get():GetAttribute("SlotNumber")
						)

						States.ManagementMode.Swapping.PrimarySlot:set()
						States.ManagementMode.Swapping.SecondarySlot:set()
						SwappedTool = true
					else
						States.ManagementMode.Swapping.PrimarySlot:set(ToolButton)
					end
				end

				if SwappedTool then
					States.ContextMenu.Active:set(false)
				else
					States:ToggleContextMenuToSlot(ToolButton, Props.Tool:get())
				end
			else
				States:ToggleToolEquipped(Props.Tool:get())
			end
		end,
		[OnEvent "MouseButton2Click"] = function()
			States:ToggleContextMenuToSlot(ToolButton, Props.Tool:get())
		end,
		[OnEvent "MouseButton1Down"] = function()
			Holding:set(true)

			if States.ManagementMode.Enabled:get() then
				if not States.ManagementMode.Active:get() or GuiService.SelectedObject == ToolButton then
					if States.HotbarHoldProcess then
						task.cancel(States.HotbarHoldProcess)
					end
					States.HotbarHoldProcess = task.delay(0.25, function()
						if Holding:get() == true then
							Holding:set(false)

							States.ManagementMode.Active:set(not States.ManagementMode.Active:get())
							States.ToolTip.Visible:set(false)
							States.ContextMenu.Active:set(false)

							if
								(not States.ManagementMode.Active:get()) and (GuiService.SelectedObject == ToolButton)
							then
								GuiService.SelectedObject = nil
							end
						end
					end)
				end
			end

			if States.ManagementMode.Active:get() and GuiService.SelectedObject ~= ToolButton then
				States.ManagementMode.Swapping.PrimarySlot:set(ToolButton)

				MouseMoveConnection = Mouse.Move:Connect(function()
					SelectionMove(Mouse.X, Mouse.Y)
				end)
				TouchMoveConnection = UserInputService.TouchMoved:Connect(function(Input: InputObject)
					SelectionMove(Input.Position.X, Input.Position.Y)
				end)
			end
		end,
		[OnEvent "MouseButton1Up"] = function()
			Holding:set(false)

			if States.ManagementMode.Swapping.PrimarySlot:get() == ToolButton then
				States.ManagementMode.Swapping.PrimarySlot:set(nil)
			end

			if MouseMoveConnection then
				MouseMoveConnection:Disconnect()
			end
			if TouchMoveConnection then
				TouchMoveConnection:Disconnect()
			end
		end,
		[OnEvent "MouseLeave"] = function()
			Holding:set(false)
		end,

		[Cleanup] = function()
			if MouseMoveConnection then
				MouseMoveConnection:Disconnect()
			end
			for _, Disconnect in ipairs(ObserverDisconnects) do
				Disconnect()
			end
		end,

		[Child "ToolNumber"] = {
			Text = Props.ToolNumber,
			Font = (States.DefaultEffectsEnabled:get() and Enum.Font.Gotham) or nil,
		},

		[Children] = {
			Computed(function()
				if Props.Tool:get().TextureId ~= "" then
					return ButtonImage {
						Image = Computed(function()
							local Image
							if Props.Tool:get() then
								Image = Props.Tool:get().TextureId
							end
							return Image or ""
						end),
					}
				else
					return ButtonText {
						Text = Computed(function()
							local Name
							if Props.Tool:get() then
								Name = Props.Tool:get().Name
							end
							return Name or "Tool"
						end),
					}
				end
			end, Fusion.cleanup),

			Computed(function()
				if States.ContextMenu.Active:get() and States.ContextMenu.GuiObject:get() == ToolButton then
					return ContextMenu {}
				else
					return {}
				end
			end, Fusion.cleanup),
		},
	}

	if States.DefaultEffectsEnabled:get() then
		Hydrate(ToolButton)({
			BackgroundColor3 = Fusion.Computed(function()
				local PrimarySlot = States.ManagementMode.Swapping.PrimarySlot:get()
				local SecondarySlot = States.ManagementMode.Swapping.SecondarySlot:get()

				local IsPrimarySwapSlot = PrimarySlot and (PrimarySlot == ToolButton)
				local IsSecondarySwapSlot = SecondarySlot and (SecondarySlot == ToolButton)

				if Holding:get() or (IsPrimarySwapSlot or IsSecondarySwapSlot) then
					return Color3.fromRGB(20, 20, 20)
				else
					return Color3.fromRGB(0, 0, 0)
				end
			end),

			[Child "UIStroke"] = {
				Enabled = Props.Equipped,
			},
		})
	end

	table.insert(
		ObserverDisconnects,
		Observer(Holding):onChange(function()
			ToolButton:SetAttribute("Holding", Holding:get())
		end)
	)
	ToolButton:SetAttribute("Holding", Holding:get())
	ToolButton:SetAttribute("Equipped", Props.Equipped:get())
	ToolButton:SetAttribute("SlotNumber", Props.ToolNumber:get())
	New "ObjectValue" {
		Name = "Tool",
		Value = Props.Tool:get(),
		Parent = ToolButton,
	}

	CollectionService:AddTag(ToolButton, "NeoHotbarToolButton")

	return ToolButton
end
]]></ProtectedString>
												<string name="ScriptGuid">{AB657BFF-1ED8-4D34-BBB2-4DF595CC95E1}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ToolButton</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX7CE7657E56D246A8B7CD91D7C94BE2FC">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)

local Hydrate = Fusion.Hydrate
local Child = FusionUtils.Child
local Computed = Fusion.Computed
local Spring = Fusion.Spring

return function()
	local ToolTip = Hydrate(States.InstanceSet:get().ToolTip:Clone())({
		[Child "Text"] = {
			Text = States.ToolTip.Text,
		},
	})

	if States.DefaultEffectsEnabled:get() then
		Hydrate(ToolTip)({
			GroupTransparency = Spring(Computed(function()
				local Visible = States.ToolTip.Enabled:get() and States.ToolTip.Visible:get()
				return (Visible and 0) or 1
			end), 25, 1),

			[Child "Text"] = {
				Font = Enum.Font.Gotham,
			},
		})
	end

	return ToolTip
end
]]></ProtectedString>
												<string name="ScriptGuid">{EAE29228-729C-4BB0-BD33-7DC988999D24}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ToolTip</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXF14ECA8D74954E7A9D43825F56063116">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Hydrate = Fusion.Hydrate
local OnEvent = Fusion.OnEvent
local Value = Fusion.Value
local Computed = Fusion.Computed
local Child = FusionUtils.Child
local Observer = Fusion.Observer
local Cleanup = Fusion.Cleanup

return function(Props: table)
	Props.Action = EnsureProp(Props.Action, "table", {})

	local Hovering = Value(false)
	local ObserverDisconnects = {}

	local ContextActionButton = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
		[OnEvent "Activated"] = function()
			States.ContextMenu.Active:set(false)

			if Props.Action:get() and Props.Action:get().Function then
				Props.Action:get():Function()
			end
		end,
		[OnEvent "MouseEnter"] = function()
			Hovering:set(true)
		end,
		[OnEvent "MouseLeave"] = function()
			Hovering:set(false)
		end,

		[Child "Text"] = {
			Text = Computed(function()
				local Name
				if Props.Action:get() then
					Name = Props.Action:get().Name
				end
				return Name or "Action"
			end),
		},

		[Cleanup] = function()
			for _, Disconnect in ipairs(ObserverDisconnects) do
				Disconnect()
			end
		end
	}

	if States.DefaultEffectsEnabled:get() then
		Hydrate(ContextActionButton) {
			BackgroundTransparency = Computed(function()
				return (Hovering:get() and 0.925) or 1
			end),

			[Child "Text"] = {
				FontFace = Font.fromName("GothamSsm")
			}
		}
	end

	table.insert(ObserverDisconnects, Observer(Hovering):onChange(function()
		ContextActionButton:SetAttribute("Hovering", Hovering:get())
	end))
	ContextActionButton:SetAttribute("Hovering", Hovering:get())

	return ContextActionButton
end
]]></ProtectedString>
												<string name="ScriptGuid">{03C2B86C-B7AC-4258-BC60-8186143A0265}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ContextActionButton</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXC3E14CE3E69147DAB9DF309AD7D284C6">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)
local FusionUtils = require(NeoHotbar.Parent.FusionUtils)
local States = require(NeoHotbar.States)
local EnsureProp = require(NeoHotbar.ExtPackages.EnsureProp)

local Hydrate = Fusion.Hydrate
local Computed = Fusion.Computed
local Child = FusionUtils.Child
local Spring = Fusion.Spring
local Observer = Fusion.Observer
local Cleanup = Fusion.Cleanup

return function(Props: table)
	Props.Keycode = EnsureProp(Props.Keycode, "EnumItem", nil)
  
  local KeycodeImage = Computed(function()
    if typeof(Props.Keycode:get()) == "EnumItem" then
      return UserInputService:GetImageForKeyCode(Props.Keycode:get())
    else
      return ""
    end
  end)
  local Shown = Computed(function()
    return States.GamepadInUse:get() and (string.len(KeycodeImage:get()) >= 1)
  end)
  local ObserverDisconnects = {}

	local ButtonHint = Hydrate(States.InstanceSet:get()[script.Name]:Clone()) {
    [Child "Image"] = {
      Image = KeycodeImage,
    },
    
    [Cleanup] = function()
      for _, Disconnect in ipairs(ObserverDisconnects) do
        Disconnect()
      end
    end
	}

  if States.DefaultEffectsEnabled:get() then
    Hydrate(ButtonHint) {
      GroupTransparency = Spring(Computed(function()
        return (Shown:get() and 0) or 1
      end), 40, 1),
    }
  end

  table.insert(ObserverDisconnects, Observer(Shown):onChange(function()
    ButtonHint:SetAttribute("Shown", Shown:get())
  end))
  ButtonHint:SetAttribute("Shown", Shown:get())

  return ButtonHint
end]]></ProtectedString>
												<string name="ScriptGuid">{E2BE9925-C95E-4472-A5BC-5BE5207781A0}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ButtonHint</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX2230AF898BFF4DD0BD8375335CDCD2FE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ExtPackages</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX96B21D9E6EEF4F6CB76EAEBD9845004E">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local NeoHotbar = script.Parent.Parent

local Fusion = require(NeoHotbar.Parent.Fusion)

local Value = Fusion.Value

return function(Prop: any, Type: string, Default: any)
  if Prop == nil then
    return Value(Default)
  elseif typeof(Prop) == Type then
    return Value(Prop)
  else
    return Prop
  end
end]]></ProtectedString>
												<string name="ScriptGuid">{4C462869-8B1D-4FC4-B438-753AB0D3BFBA}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">EnsureProp</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBXF5E478AF67634CB090174A4E9017660F">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">DefaultInstances</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="TextButton" referent="RBX1958BA3B0B1F4BCE8BECE406B2E410A3">
											<Properties>
												<Font name="FontFace">
													<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
													<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
												</Font>
												<float name="LineHeight">1</float>
												<string name="LocalizationMatchIdentifier"></string>
												<string name="LocalizationMatchedSourceText"></string>
												<int name="MaxVisibleGraphemes">-1</int>
												<string name="OpenTypeFeatures"></string>
												<bool name="RichText">false</bool>
												<string name="Text"></string>
												<Color3 name="TextColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="TextDirection">0</token>
												<bool name="TextScaled">false</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">false</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="AutoButtonColor">false</bool>
												<Ref name="HoverHapticEffect">null</Ref>
												<bool name="Modal">false</bool>
												<Ref name="PressHapticEffect">null</Ref>
												<bool name="Selected">false</bool>
												<token name="Style">0</token>
												<bool name="Active">true</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="BackgroundTransparency">0.300000012</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<bool name="ClipsDescendants">false</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">1</int>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<float name="Rotation">0</float>
												<bool name="Selectable">true</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>60</XO>
													<YS>0</YS>
													<YO>60</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
												<bool name="AutoLocalize">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">CustomButton</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="UICorner" referent="RBX5B0CD3DAEDF546C5915DACB3970A8B36">
												<Properties>
													<UDim name="CornerRadius">
														<S>0</S>
														<O>7</O>
													</UDim>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UICorner</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="UIStroke" referent="RBX91AC3911F00745E490F17885FE198927">
												<Properties>
													<token name="ApplyStrokeMode">1</token>
													<UDim name="BorderOffset">
														<S>0</S>
														<O>0</O>
													</UDim>
													<token name="BorderStrokePosition">0</token>
													<Color3 name="Color">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<bool name="Enabled">true</bool>
													<token name="LineJoinMode">0</token>
													<token name="StrokeSizingMode">0</token>
													<float name="Thickness">2</float>
													<float name="Transparency">0.300000012</float>
													<int name="ZIndex">1</int>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIStroke</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
										<Item class="TextButton" referent="RBX1B7D2081B91C4C189FCBF8647BD2AB87">
											<Properties>
												<Font name="FontFace">
													<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
													<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
												</Font>
												<float name="LineHeight">1</float>
												<string name="LocalizationMatchIdentifier"></string>
												<string name="LocalizationMatchedSourceText"></string>
												<int name="MaxVisibleGraphemes">-1</int>
												<string name="OpenTypeFeatures"></string>
												<bool name="RichText">false</bool>
												<string name="Text"></string>
												<Color3 name="TextColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="TextDirection">0</token>
												<bool name="TextScaled">false</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">false</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="AutoButtonColor">false</bool>
												<Ref name="HoverHapticEffect">null</Ref>
												<bool name="Modal">false</bool>
												<Ref name="PressHapticEffect">null</Ref>
												<bool name="Selected">false</bool>
												<token name="Style">0</token>
												<bool name="Active">true</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="BackgroundTransparency">0.300000012</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<bool name="ClipsDescendants">false</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">2</int>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<float name="Rotation">0</float>
												<bool name="Selectable">true</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>60</XO>
													<YS>0</YS>
													<YO>60</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
												<bool name="AutoLocalize">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ToolButton</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="UICorner" referent="RBXD7B8625CA6404128965D5BF85ACFBF47">
												<Properties>
													<UDim name="CornerRadius">
														<S>0</S>
														<O>7</O>
													</UDim>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UICorner</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="UIStroke" referent="RBX8E9F7EE3AA74434A9F8C8BB678821C15">
												<Properties>
													<token name="ApplyStrokeMode">1</token>
													<UDim name="BorderOffset">
														<S>0</S>
														<O>0</O>
													</UDim>
													<token name="BorderStrokePosition">0</token>
													<Color3 name="Color">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<bool name="Enabled">false</bool>
													<token name="LineJoinMode">0</token>
													<token name="StrokeSizingMode">0</token>
													<float name="Thickness">2</float>
													<float name="Transparency">0.300000012</float>
													<int name="ZIndex">1</int>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIStroke</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="TextLabel" referent="RBX4194A194CFC0404EBEFB2B4883AD6959">
												<Properties>
													<Font name="FontFace">
														<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
														<Weight>400</Weight>
														<Style>Normal</Style>
														<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
													</Font>
													<float name="LineHeight">1</float>
													<string name="LocalizationMatchIdentifier"></string>
													<string name="LocalizationMatchedSourceText"></string>
													<int name="MaxVisibleGraphemes">-1</int>
													<string name="OpenTypeFeatures"></string>
													<bool name="RichText">false</bool>
													<string name="Text">10</string>
													<Color3 name="TextColor3">
														<R>0.666666687</R>
														<G>0.666666687</G>
														<B>0.666666687</B>
													</Color3>
													<token name="TextDirection">0</token>
													<bool name="TextScaled">false</bool>
													<float name="TextSize">13</float>
													<Color3 name="TextStrokeColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="TextStrokeTransparency">1</float>
													<float name="TextTransparency">0</float>
													<token name="TextTruncate">0</token>
													<bool name="TextWrapped">false</bool>
													<token name="TextXAlignment">0</token>
													<token name="TextYAlignment">1</token>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<bool name="ClipsDescendants">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>5</XO>
														<YS>0</YS>
														<YO>3</YO>
													</UDim2>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
													<bool name="AutoLocalize">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ToolNumber</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
										<Item class="TextLabel" referent="RBX04C897969A1F4A58BFADFEBAEEDC358F">
											<Properties>
												<Font name="FontFace">
													<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
													<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
												</Font>
												<float name="LineHeight">1</float>
												<string name="LocalizationMatchIdentifier"></string>
												<string name="LocalizationMatchedSourceText"></string>
												<int name="MaxVisibleGraphemes">-1</int>
												<string name="OpenTypeFeatures"></string>
												<bool name="RichText">false</bool>
												<string name="Text">StarterTool</string>
												<Color3 name="TextColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<token name="TextDirection">0</token>
												<bool name="TextScaled">false</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">true</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<bool name="ClipsDescendants">false</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>1</XS>
													<XO>0</XO>
													<YS>1</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
												<bool name="AutoLocalize">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ButtonText</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="Frame" referent="RBX42BD92EA284144B793884E57D3B57574">
											<Properties>
												<token name="Style">0</token>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<bool name="ClipsDescendants">false</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>1</XS>
													<XO>0</XO>
													<YS>1</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
												<bool name="AutoLocalize">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ButtonImage</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="UIPadding" referent="RBXBEA7201A5F034819A1784DEAC6A8FEFB">
												<Properties>
													<UDim name="PaddingBottom">
														<S>0.140000001</S>
														<O>0</O>
													</UDim>
													<UDim name="PaddingLeft">
														<S>0.140000001</S>
														<O>0</O>
													</UDim>
													<UDim name="PaddingRight">
														<S>0.140000001</S>
														<O>0</O>
													</UDim>
													<UDim name="PaddingTop">
														<S>0.140000001</S>
														<O>0</O>
													</UDim>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIPadding</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ImageLabel" referent="RBX2E9E0B174BBD41DD980A03E3BCD0CFAC">
												<Properties>
													<Content name="Image"><url>rbxassetid://8539764711</url></Content>
													<Color3 name="ImageColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<Vector2 name="ImageRectOffset">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<Vector2 name="ImageRectSize">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<float name="ImageTransparency">0</float>
													<token name="ResampleMode">0</token>
													<token name="ScaleType">0</token>
													<Rect2D name="SliceCenter">
														<min>
															<X>0</X>
															<Y>0</Y>
														</min>
														<max>
															<X>0</X>
															<Y>0</Y>
														</max>
													</Rect2D>
													<float name="SliceScale">1</float>
													<UDim2 name="TileSize">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<bool name="ClipsDescendants">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
													<bool name="AutoLocalize">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Image</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
										<Item class="ScreenGui" referent="RBX77EB959161BA4B0B8F96A6FD5E1CDF05">
											<Properties>
												<bool name="ClipToDeviceSafeArea">true</bool>
												<int name="DisplayOrder">1000</int>
												<token name="SafeAreaCompatibility">1</token>
												<token name="ScreenInsets">2</token>
												<bool name="Enabled">true</bool>
												<bool name="ResetOnSpawn">false</bool>
												<token name="ZIndexBehavior">1</token>
												<bool name="AutoLocalize">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Hotbar</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="Frame" referent="RBXA6994C477446461CA2D5C5AA2F545BBC">
												<Properties>
													<token name="Style">0</token>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0.5</X>
														<Y>1</Y>
													</Vector2>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<bool name="ClipsDescendants">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0.5</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>-8</YO>
													</UDim2>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
													<bool name="AutoLocalize">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Hotbar</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="UIListLayout" referent="RBXC43B683D71E64133BD42CF206FA6C165">
													<Properties>
														<token name="HorizontalFlex">0</token>
														<token name="ItemLineAlignment">0</token>
														<UDim name="Padding">
															<S>0</S>
															<O>8</O>
														</UDim>
														<token name="VerticalFlex">0</token>
														<bool name="Wraps">false</bool>
														<token name="FillDirection">1</token>
														<token name="HorizontalAlignment">0</token>
														<token name="SortOrder">2</token>
														<token name="VerticalAlignment">2</token>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UIListLayout</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="Frame" referent="RBX305ABAC897A14CE7813BAF9BB55A07F4">
													<Properties>
														<token name="Style">0</token>
														<bool name="Active">false</bool>
														<Vector2 name="AnchorPoint">
															<X>0</X>
															<Y>0</Y>
														</Vector2>
														<token name="AutomaticSize">3</token>
														<Color3 name="BackgroundColor3">
															<R>1</R>
															<G>1</G>
															<B>1</B>
														</Color3>
														<float name="BackgroundTransparency">1</float>
														<Color3 name="BorderColor3">
															<R>0.105882362</R>
															<G>0.164705887</G>
															<B>0.207843155</B>
														</Color3>
														<token name="BorderMode">0</token>
														<int name="BorderSizePixel">1</int>
														<bool name="ClipsDescendants">false</bool>
														<bool name="Draggable">false</bool>
														<bool name="Interactable">true</bool>
														<int name="LayoutOrder">2</int>
														<Ref name="NextSelectionDown">null</Ref>
														<Ref name="NextSelectionLeft">null</Ref>
														<Ref name="NextSelectionRight">null</Ref>
														<Ref name="NextSelectionUp">null</Ref>
														<UDim2 name="Position">
															<XS>0</XS>
															<XO>0</XO>
															<YS>0</YS>
															<YO>0</YO>
														</UDim2>
														<float name="Rotation">0</float>
														<bool name="Selectable">false</bool>
														<Ref name="SelectionImageObject">null</Ref>
														<int name="SelectionOrder">0</int>
														<UDim2 name="Size">
															<XS>0</XS>
															<XO>0</XO>
															<YS>0</YS>
															<YO>0</YO>
														</UDim2>
														<token name="SizeConstraint">0</token>
														<bool name="Visible">true</bool>
														<int name="ZIndex">1</int>
														<bool name="AutoLocalize">true</bool>
														<Ref name="RootLocalizationTable">null</Ref>
														<token name="SelectionBehaviorDown">0</token>
														<token name="SelectionBehaviorLeft">0</token>
														<token name="SelectionBehaviorRight">0</token>
														<token name="SelectionBehaviorUp">0</token>
														<bool name="SelectionGroup">false</bool>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Buttons</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
													<Item class="Frame" referent="RBX720FFEE9F4814DD088536154FB3CAE9D">
														<Properties>
															<token name="Style">0</token>
															<bool name="Active">false</bool>
															<Vector2 name="AnchorPoint">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<token name="AutomaticSize">3</token>
															<Color3 name="BackgroundColor3">
																<R>0</R>
																<G>0</G>
																<B>0</B>
															</Color3>
															<float name="BackgroundTransparency">1</float>
															<Color3 name="BorderColor3">
																<R>0.105882362</R>
																<G>0.164705887</G>
																<B>0.207843155</B>
															</Color3>
															<token name="BorderMode">0</token>
															<int name="BorderSizePixel">1</int>
															<bool name="ClipsDescendants">false</bool>
															<bool name="Draggable">false</bool>
															<bool name="Interactable">true</bool>
															<int name="LayoutOrder">3</int>
															<Ref name="NextSelectionDown">null</Ref>
															<Ref name="NextSelectionLeft">null</Ref>
															<Ref name="NextSelectionRight">null</Ref>
															<Ref name="NextSelectionUp">null</Ref>
															<UDim2 name="Position">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<float name="Rotation">0</float>
															<bool name="Selectable">false</bool>
															<Ref name="SelectionImageObject">null</Ref>
															<int name="SelectionOrder">0</int>
															<UDim2 name="Size">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<token name="SizeConstraint">0</token>
															<bool name="Visible">true</bool>
															<int name="ZIndex">1</int>
															<bool name="AutoLocalize">true</bool>
															<Ref name="RootLocalizationTable">null</Ref>
															<token name="SelectionBehaviorDown">0</token>
															<token name="SelectionBehaviorLeft">0</token>
															<token name="SelectionBehaviorRight">0</token>
															<token name="SelectionBehaviorUp">0</token>
															<bool name="SelectionGroup">false</bool>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="DefinesCapabilities">false</bool>
															<string name="Name">ToolSlots</string>
															<int64 name="SourceAssetId">-1</int64>
															<BinaryString name="Tags"></BinaryString>
														</Properties>
														<Item class="UIListLayout" referent="RBXF4806613DF124D4DB984CA8ECC095B87">
															<Properties>
																<token name="HorizontalFlex">0</token>
																<token name="ItemLineAlignment">0</token>
																<UDim name="Padding">
																	<S>0</S>
																	<O>7</O>
																</UDim>
																<token name="VerticalFlex">0</token>
																<bool name="Wraps">false</bool>
																<token name="FillDirection">0</token>
																<token name="HorizontalAlignment">1</token>
																<token name="SortOrder">2</token>
																<token name="VerticalAlignment">2</token>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">UIListLayout</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
														<Item class="UIPadding" referent="RBX2C3262F0E2D648CFB6BA6A4FC3CA8F1D">
															<Properties>
																<UDim name="PaddingBottom">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<UDim name="PaddingLeft">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<UDim name="PaddingRight">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<UDim name="PaddingTop">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">UIPadding</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
														<Item class="UIStroke" referent="RBX81055BEEBE2A47C7A99F8D1A25847461">
															<Properties>
																<token name="ApplyStrokeMode">0</token>
																<UDim name="BorderOffset">
																	<S>0</S>
																	<O>0</O>
																</UDim>
																<token name="BorderStrokePosition">0</token>
																<Color3 name="Color">
																	<R>0</R>
																	<G>0</G>
																	<B>0</B>
																</Color3>
																<bool name="Enabled">false</bool>
																<token name="LineJoinMode">0</token>
																<token name="StrokeSizingMode">0</token>
																<float name="Thickness">3</float>
																<float name="Transparency">0.200000003</float>
																<int name="ZIndex">1</int>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">UIStroke</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
														<Item class="UICorner" referent="RBXC376EF41C39D43D99A416000B465D606">
															<Properties>
																<UDim name="CornerRadius">
																	<S>0</S>
																	<O>7</O>
																</UDim>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">UICorner</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
													</Item>
													<Item class="Frame" referent="RBX05BB59B4685543DABBA0F53D03AF2B07">
														<Properties>
															<token name="Style">0</token>
															<bool name="Active">false</bool>
															<Vector2 name="AnchorPoint">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<token name="AutomaticSize">3</token>
															<Color3 name="BackgroundColor3">
																<R>1</R>
																<G>1</G>
																<B>1</B>
															</Color3>
															<float name="BackgroundTransparency">1</float>
															<Color3 name="BorderColor3">
																<R>0.105882362</R>
																<G>0.164705887</G>
																<B>0.207843155</B>
															</Color3>
															<token name="BorderMode">0</token>
															<int name="BorderSizePixel">1</int>
															<bool name="ClipsDescendants">false</bool>
															<bool name="Draggable">false</bool>
															<bool name="Interactable">true</bool>
															<int name="LayoutOrder">1</int>
															<Ref name="NextSelectionDown">null</Ref>
															<Ref name="NextSelectionLeft">null</Ref>
															<Ref name="NextSelectionRight">null</Ref>
															<Ref name="NextSelectionUp">null</Ref>
															<UDim2 name="Position">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<float name="Rotation">0</float>
															<bool name="Selectable">false</bool>
															<Ref name="SelectionImageObject">null</Ref>
															<int name="SelectionOrder">0</int>
															<UDim2 name="Size">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<token name="SizeConstraint">0</token>
															<bool name="Visible">true</bool>
															<int name="ZIndex">1</int>
															<bool name="AutoLocalize">true</bool>
															<Ref name="RootLocalizationTable">null</Ref>
															<token name="SelectionBehaviorDown">0</token>
															<token name="SelectionBehaviorLeft">0</token>
															<token name="SelectionBehaviorRight">0</token>
															<token name="SelectionBehaviorUp">0</token>
															<bool name="SelectionGroup">false</bool>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="DefinesCapabilities">false</bool>
															<string name="Name">CustomButtons</string>
															<int64 name="SourceAssetId">-1</int64>
															<BinaryString name="Tags"></BinaryString>
														</Properties>
														<Item class="UIListLayout" referent="RBX31E5A154E2C14EBBB5483064F3153511">
															<Properties>
																<token name="HorizontalFlex">0</token>
																<token name="ItemLineAlignment">0</token>
																<UDim name="Padding">
																	<S>0</S>
																	<O>7</O>
																</UDim>
																<token name="VerticalFlex">0</token>
																<bool name="Wraps">false</bool>
																<token name="FillDirection">0</token>
																<token name="HorizontalAlignment">1</token>
																<token name="SortOrder">2</token>
																<token name="VerticalAlignment">2</token>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">UIListLayout</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
													</Item>
													<Item class="UIListLayout" referent="RBX28252108CE6D4760A71EA7B0FCC2B12B">
														<Properties>
															<token name="HorizontalFlex">0</token>
															<token name="ItemLineAlignment">0</token>
															<UDim name="Padding">
																<S>0</S>
																<O>10</O>
															</UDim>
															<token name="VerticalFlex">0</token>
															<bool name="Wraps">false</bool>
															<token name="FillDirection">0</token>
															<token name="HorizontalAlignment">0</token>
															<token name="SortOrder">2</token>
															<token name="VerticalAlignment">0</token>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="DefinesCapabilities">false</bool>
															<string name="Name">UIListLayout</string>
															<int64 name="SourceAssetId">-1</int64>
															<BinaryString name="Tags"></BinaryString>
														</Properties>
													</Item>
												</Item>
											</Item>
										</Item>
										<Item class="CanvasGroup" referent="RBX0B53CCB2A1BE49E3B698F138541F5A97">
											<Properties>
												<Color3 name="GroupColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="GroupTransparency">0</float>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0.5</X>
													<Y>1</Y>
												</Vector2>
												<token name="AutomaticSize">3</token>
												<Color3 name="BackgroundColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="BackgroundTransparency">0.400000006</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<bool name="ClipsDescendants">true</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">1</int>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0.5</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>-7</YO>
												</UDim2>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
												<bool name="AutoLocalize">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ToolTip</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="UICorner" referent="RBXF92C5291D874452F85C0486173EF882A">
												<Properties>
													<UDim name="CornerRadius">
														<S>0</S>
														<O>7</O>
													</UDim>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UICorner</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="TextLabel" referent="RBX05758F5E56064291A385E027C77C75A2">
												<Properties>
													<Font name="FontFace">
														<Family><url>rbxasset://fonts/families/LegacyArial.json</url></Family>
														<Weight>400</Weight>
														<Style>Normal</Style>
														<CachedFaceId><url>rbxasset://fonts/Arimo-Regular.ttf</url></CachedFaceId>
													</Font>
													<float name="LineHeight">1</float>
													<string name="LocalizationMatchIdentifier"></string>
													<string name="LocalizationMatchedSourceText"></string>
													<int name="MaxVisibleGraphemes">-1</int>
													<string name="OpenTypeFeatures"></string>
													<bool name="RichText">true</bool>
													<string name="Text">Tooltip placeholder</string>
													<Color3 name="TextColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<token name="TextDirection">0</token>
													<bool name="TextScaled">false</bool>
													<float name="TextSize">14</float>
													<Color3 name="TextStrokeColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="TextStrokeTransparency">1</float>
													<float name="TextTransparency">0</float>
													<token name="TextTruncate">0</token>
													<bool name="TextWrapped">false</bool>
													<token name="TextXAlignment">0</token>
													<token name="TextYAlignment">1</token>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<bool name="ClipsDescendants">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
													<bool name="AutoLocalize">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Text</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="UIPadding" referent="RBX9B65053ACC384CB0865DFB296AE6183D">
												<Properties>
													<UDim name="PaddingBottom">
														<S>0</S>
														<O>6</O>
													</UDim>
													<UDim name="PaddingLeft">
														<S>0</S>
														<O>11</O>
													</UDim>
													<UDim name="PaddingRight">
														<S>0</S>
														<O>11</O>
													</UDim>
													<UDim name="PaddingTop">
														<S>0</S>
														<O>6</O>
													</UDim>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIPadding</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
										<Item class="Frame" referent="RBX4EB1B6E9A91A4117BC8F4CFFA06BD781">
											<Properties>
												<token name="Style">0</token>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0.5</X>
													<Y>1</Y>
												</Vector2>
												<token name="AutomaticSize">3</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0.105882362</R>
													<G>0.164705887</G>
													<B>0.207843155</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">1</int>
												<bool name="ClipsDescendants">true</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0.5</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>-4</YO>
												</UDim2>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
												<bool name="AutoLocalize">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ContextMenu</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="UIListLayout" referent="RBX609E0902E1C54523A3190FA44935AA3A">
												<Properties>
													<token name="HorizontalFlex">0</token>
													<token name="ItemLineAlignment">0</token>
													<UDim name="Padding">
														<S>0</S>
														<O>0</O>
													</UDim>
													<token name="VerticalFlex">0</token>
													<bool name="Wraps">false</bool>
													<token name="FillDirection">1</token>
													<token name="HorizontalAlignment">0</token>
													<token name="SortOrder">2</token>
													<token name="VerticalAlignment">2</token>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIListLayout</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="Frame" referent="RBXD214187DFDEE4F6380455C131AAA7755">
												<Properties>
													<token name="Style">0</token>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0.105882362</R>
														<G>0.164705887</G>
														<B>0.207843155</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">1</int>
													<bool name="ClipsDescendants">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">2</int>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
													<bool name="AutoLocalize">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ArrowIcon</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ImageLabel" referent="RBX6FE8182362654A8E875BC62D5741B8A6">
													<Properties>
														<Content name="Image"><url>rbxassetid://788089696</url></Content>
														<Color3 name="ImageColor3">
															<R>0</R>
															<G>0</G>
															<B>0</B>
														</Color3>
														<Vector2 name="ImageRectOffset">
															<X>0</X>
															<Y>0</Y>
														</Vector2>
														<Vector2 name="ImageRectSize">
															<X>0</X>
															<Y>0</Y>
														</Vector2>
														<float name="ImageTransparency">0.25</float>
														<token name="ResampleMode">0</token>
														<token name="ScaleType">0</token>
														<Rect2D name="SliceCenter">
															<min>
																<X>0</X>
																<Y>0</Y>
															</min>
															<max>
																<X>0</X>
																<Y>0</Y>
															</max>
														</Rect2D>
														<float name="SliceScale">1</float>
														<UDim2 name="TileSize">
															<XS>1</XS>
															<XO>0</XO>
															<YS>1</YS>
															<YO>0</YO>
														</UDim2>
														<bool name="Active">false</bool>
														<Vector2 name="AnchorPoint">
															<X>0</X>
															<Y>0</Y>
														</Vector2>
														<token name="AutomaticSize">0</token>
														<Color3 name="BackgroundColor3">
															<R>1</R>
															<G>1</G>
															<B>1</B>
														</Color3>
														<float name="BackgroundTransparency">1</float>
														<Color3 name="BorderColor3">
															<R>0.105882362</R>
															<G>0.164705887</G>
															<B>0.207843155</B>
														</Color3>
														<token name="BorderMode">0</token>
														<int name="BorderSizePixel">1</int>
														<bool name="ClipsDescendants">false</bool>
														<bool name="Draggable">false</bool>
														<bool name="Interactable">true</bool>
														<int name="LayoutOrder">0</int>
														<Ref name="NextSelectionDown">null</Ref>
														<Ref name="NextSelectionLeft">null</Ref>
														<Ref name="NextSelectionRight">null</Ref>
														<Ref name="NextSelectionUp">null</Ref>
														<UDim2 name="Position">
															<XS>0</XS>
															<XO>0</XO>
															<YS>0</YS>
															<YO>0</YO>
														</UDim2>
														<float name="Rotation">180</float>
														<bool name="Selectable">false</bool>
														<Ref name="SelectionImageObject">null</Ref>
														<int name="SelectionOrder">0</int>
														<UDim2 name="Size">
															<XS>0</XS>
															<XO>11</XO>
															<YS>0</YS>
															<YO>6</YO>
														</UDim2>
														<token name="SizeConstraint">0</token>
														<bool name="Visible">true</bool>
														<int name="ZIndex">1</int>
														<bool name="AutoLocalize">true</bool>
														<Ref name="RootLocalizationTable">null</Ref>
														<token name="SelectionBehaviorDown">0</token>
														<token name="SelectionBehaviorLeft">0</token>
														<token name="SelectionBehaviorRight">0</token>
														<token name="SelectionBehaviorUp">0</token>
														<bool name="SelectionGroup">false</bool>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">ArrowIcon</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="CanvasGroup" referent="RBXD490126644C74538BAFA3FC3E044ED01">
												<Properties>
													<Color3 name="GroupColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="GroupTransparency">0</float>
													<bool name="Active">true</bool>
													<Vector2 name="AnchorPoint">
														<X>0.5</X>
														<Y>1</Y>
													</Vector2>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="BackgroundTransparency">0.25</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<bool name="ClipsDescendants">true</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">1</int>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0.5</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>-7</YO>
													</UDim2>
													<float name="Rotation">0</float>
													<bool name="Selectable">true</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
													<bool name="AutoLocalize">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Actions</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="UICorner" referent="RBX947CBB92A41D4C4D88B0394F72C5724A">
													<Properties>
														<UDim name="CornerRadius">
															<S>0</S>
															<O>7</O>
														</UDim>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UICorner</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="UIListLayout" referent="RBXB2F05C84BCE34D6883CE28F710065314">
													<Properties>
														<token name="HorizontalFlex">0</token>
														<token name="ItemLineAlignment">0</token>
														<UDim name="Padding">
															<S>0</S>
															<O>0</O>
														</UDim>
														<token name="VerticalFlex">0</token>
														<bool name="Wraps">false</bool>
														<token name="FillDirection">1</token>
														<token name="HorizontalAlignment">0</token>
														<token name="SortOrder">2</token>
														<token name="VerticalAlignment">1</token>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UIListLayout</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
										<Item class="TextButton" referent="RBX42A94CB28A434DC58775BAAAB4496D55">
											<Properties>
												<Font name="FontFace">
													<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
												</Font>
												<float name="LineHeight">1</float>
												<string name="LocalizationMatchIdentifier"></string>
												<string name="LocalizationMatchedSourceText"></string>
												<int name="MaxVisibleGraphemes">-1</int>
												<string name="OpenTypeFeatures"></string>
												<bool name="RichText">false</bool>
												<string name="Text"></string>
												<Color3 name="TextColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="TextDirection">0</token>
												<bool name="TextScaled">false</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">false</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="AutoButtonColor">false</bool>
												<Ref name="HoverHapticEffect">null</Ref>
												<bool name="Modal">false</bool>
												<Ref name="PressHapticEffect">null</Ref>
												<bool name="Selected">false</bool>
												<token name="Style">0</token>
												<bool name="Active">true</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<token name="AutomaticSize">3</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0.105882362</R>
													<G>0.164705887</G>
													<B>0.207843155</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">1</int>
												<bool name="ClipsDescendants">false</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<float name="Rotation">0</float>
												<bool name="Selectable">true</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>1</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
												<bool name="AutoLocalize">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ContextActionButton</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="TextLabel" referent="RBX1C59EA44BDA34EB69ADDE3DA80A82D50">
												<Properties>
													<Font name="FontFace">
														<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
														<Weight>400</Weight>
														<Style>Normal</Style>
													</Font>
													<float name="LineHeight">1</float>
													<string name="LocalizationMatchIdentifier"></string>
													<string name="LocalizationMatchedSourceText"></string>
													<int name="MaxVisibleGraphemes">-1</int>
													<string name="OpenTypeFeatures"></string>
													<bool name="RichText">true</bool>
													<string name="Text">Drop Item</string>
													<Color3 name="TextColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<token name="TextDirection">0</token>
													<bool name="TextScaled">false</bool>
													<float name="TextSize">15</float>
													<Color3 name="TextStrokeColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="TextStrokeTransparency">1</float>
													<float name="TextTransparency">0</float>
													<token name="TextTruncate">0</token>
													<bool name="TextWrapped">false</bool>
													<token name="TextXAlignment">2</token>
													<token name="TextYAlignment">1</token>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<token name="AutomaticSize">3</token>
													<Color3 name="BackgroundColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<bool name="ClipsDescendants">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
													<bool name="AutoLocalize">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Text</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="UIPadding" referent="RBXC387E65BFC774B53A0156960B91BEAD6">
												<Properties>
													<UDim name="PaddingBottom">
														<S>0</S>
														<O>8</O>
													</UDim>
													<UDim name="PaddingLeft">
														<S>0</S>
														<O>10</O>
													</UDim>
													<UDim name="PaddingRight">
														<S>0</S>
														<O>10</O>
													</UDim>
													<UDim name="PaddingTop">
														<S>0</S>
														<O>7</O>
													</UDim>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIPadding</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
										<Item class="CanvasGroup" referent="RBX14A2F456D7284CB18313DFF710A71CE6">
											<Properties>
												<Color3 name="GroupColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="GroupTransparency">0</float>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>1</X>
													<Y>0</Y>
												</Vector2>
												<token name="AutomaticSize">3</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<bool name="ClipsDescendants">true</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>1</XS>
													<XO>10</XO>
													<YS>0</YS>
													<YO>-10</YO>
												</UDim2>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
												<bool name="AutoLocalize">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ButtonHint</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ImageLabel" referent="RBXF8E43E09649849FBA7CDBCE2058E3419">
												<Properties>
													<Content name="Image"><url>rbxasset://textures/ui/Controls/DefaultController/ButtonY@2x.png</url></Content>
													<Color3 name="ImageColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<Vector2 name="ImageRectOffset">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<Vector2 name="ImageRectSize">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<float name="ImageTransparency">0</float>
													<token name="ResampleMode">0</token>
													<token name="ScaleType">0</token>
													<Rect2D name="SliceCenter">
														<min>
															<X>0</X>
															<Y>0</Y>
														</min>
														<max>
															<X>0</X>
															<Y>0</Y>
														</max>
													</Rect2D>
													<float name="SliceScale">1</float>
													<UDim2 name="TileSize">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<float name="BackgroundTransparency">0</float>
													<Color3 name="BorderColor3">
														<R>0</R>
														<G>0</G>
														<B>0</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">0</int>
													<bool name="ClipsDescendants">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<float name="Rotation">0</float>
													<bool name="Selectable">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>25</XO>
														<YS>0</YS>
														<YO>25</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
													<bool name="AutoLocalize">true</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Image</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="UIStroke" referent="RBXA38D8E6D16ED4C1A94C930C51246C569">
													<Properties>
														<token name="ApplyStrokeMode">0</token>
														<UDim name="BorderOffset">
															<S>0</S>
															<O>0</O>
														</UDim>
														<token name="BorderStrokePosition">0</token>
														<Color3 name="Color">
															<R>0</R>
															<G>0</G>
															<B>0</B>
														</Color3>
														<bool name="Enabled">true</bool>
														<token name="LineJoinMode">0</token>
														<token name="StrokeSizingMode">0</token>
														<float name="Thickness">1</float>
														<float name="Transparency">0</float>
														<int name="ZIndex">1</int>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UIStroke</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="UICorner" referent="RBX681E7A19026D465D88FA6101ED98F031">
													<Properties>
														<UDim name="CornerRadius">
															<S>0.5</S>
															<O>0</O>
														</UDim>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UICorner</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="UIPadding" referent="RBX1139EAC98D294394A591991F630E617C">
												<Properties>
													<UDim name="PaddingBottom">
														<S>0</S>
														<O>1</O>
													</UDim>
													<UDim name="PaddingLeft">
														<S>0</S>
														<O>1</O>
													</UDim>
													<UDim name="PaddingRight">
														<S>0</S>
														<O>1</O>
													</UDim>
													<UDim name="PaddingTop">
														<S>0</S>
														<O>1</O>
													</UDim>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UIPadding</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX4BCD2648B17045048BAD6D1DA9726917">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">_Index</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX134D6A4E74EB487A88D095AB617ED8EC">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">hexcede_fusion-utils@0.1.2</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXCC5EA2C56F6F4B97A6358895430929F4">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["elttob_fusion@0.2.0"]["fusion"])
]]></ProtectedString>
												<string name="ScriptGuid">{EBBA434F-9C7A-4421-9773-6720ECA09745}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Fusion</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXD8A86381BEA34B2792DDBBCC6DED9C82">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[return {
	Attribute = require(script.Attribute);
	AttributeOut = require(script.AttributeOut);
	ChildRef = require(script.ChildRef);
	Child = require(script.Child);
	defer = require(script.defer);
	Observe = require(script.Observe);
	ObserveSignal = require(script.ObserveSignal);
	unwrap = require(script.unwrap);
	map = require(script.map);
	With = require(script.With);
	WithItems = require(script.WithItems);
	Without = require(script.Without);
	Bind = require(script.Bind);
}]]></ProtectedString>
												<string name="ScriptGuid">{98B0E1F4-2238-486F-B1B2-8DA9B168BBF8}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">fusion-utils</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBXA0A5010D21EE4B92803197726E87C798">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local Observe = require(script.Parent.Observe)

local Attribute = {
	type = "SpecialKey";
	kind = "Attribute";
	stage = "self";

	apply = function(self, value, applyTo, cleanupTasks)
		local attribute = self.attribute

		if type(value) == "table" and value.get then
			table.insert(cleanupTasks, Observe(value, function(newValue)
				applyTo:SetAttribute(attribute, newValue)
			end))
		else
			applyTo:SetAttribute(attribute, value)
		end
	end;
}
Attribute.__index = Attribute

return function(attribute: string)
	return setmetatable({ attribute = attribute; }, Attribute)
end
]]></ProtectedString>
													<string name="ScriptGuid">{4171CB94-2931-4F7B-9D16-F28C66FEDE76}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Attribute</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX616C84BA97994925A75E5B2FEC0BFAC3">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local defer = require(script.Parent.defer)

local AttributeOut = {
	type = "SpecialKey";
	kind = "AttributeOut";
	stage = "self";

	apply = function(self, value, applyTo, cleanupTasks)
		local attribute = self.attribute
		table.insert(cleanupTasks, applyTo:GetAttributeChangedSignal(attribute):Connect(defer(function()
			value:set(applyTo:GetAttribute(attribute))
		end)))
	end;
}
AttributeOut.__index = AttributeOut

return function(attribute: string)
	return setmetatable({ attribute = attribute; }, AttributeOut)
end
]]></ProtectedString>
													<string name="ScriptGuid">{18DE4F04-B09B-4CAE-B157-ECB8E468B244}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">AttributeOut</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX83179D7B1E23459F97AE092AB8BD703C">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local function Bind(callback, ...)
	local bound = table.pack(...)
	return function(...)
		local extra = table.pack(...)
		return callback(table.unpack(table.move(extra, 1, extra.n, bound.n + 1, table.clone(bound)), 1, bound.n + extra.n))
	end
end

return Bind]]></ProtectedString>
													<string name="ScriptGuid">{95ADE114-015F-4E2E-8AA1-9FCEE99E85B1}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Bind</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX454F67928E724CCEBA91708366E6A0EC">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local Fusion = require(script.Parent.Parent.Fusion)

local Value = Fusion.Value
local Hydrate = Fusion.Hydrate
local Cleanup = Fusion.Cleanup

local ChildRef = require(script.Parent.ChildRef)
local Observe = require(script.Parent.Observe)

local Child = {
	type = "SpecialKey";
	kind = "Child";
	stage = "descendants";

	apply = function(self, value, applyTo, cleanupTasks)
		local childRef = Value()
		Hydrate(applyTo) {
			[ChildRef(self.childName)] = childRef
		}

		local isHydrated = {}
		local result = Observe(childRef, function(child)
			if not child then return end
			if isHydrated[child] then return end
			isHydrated[child] = true

			-- Bind to child
			Hydrate(child)(value)

			-- Bind to cleanup of child
			Hydrate(child) {
				[Cleanup] = function()
					isHydrated[child] = nil
				end;
			}
		end)

		table.insert(cleanupTasks, result)
		table.insert(cleanupTasks, function()
			childRef = nil
		end)
	end;
}
Child.__index = Child

return function(childName: string)
	return setmetatable({ childName = childName; }, Child)
end
]]></ProtectedString>
													<string name="ScriptGuid">{20CD1D0D-C9F6-4973-89F8-340DBEF12E3F}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Child</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXAC2AC80EA399405AA6BEF33C6DB2D1C2">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local ChildRef = {
	type = "SpecialKey";
	kind = "ChildRef";
	stage = "descendants";

	apply = function(self, value, applyTo, cleanupTasks)
		local childName = self.childName

		if not applyTo then return end

		value:set(applyTo:FindFirstChild(childName))
		table.insert(cleanupTasks, applyTo.ChildAdded:Connect(function(newChild)
			if newChild.Name == childName then
				value:set(newChild)
			end
		end))
	end;
}
ChildRef.__index = ChildRef

return function(childName: string)
	return setmetatable({ childName = childName; }, ChildRef)
end
]]></ProtectedString>
													<string name="ScriptGuid">{E45CC202-F698-40FD-A62C-1117EE240033}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ChildRef</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX2B919E4F85284226AE01BF066AFB0FC8">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local Fusion = require(script.Parent.Parent.Fusion)
local Observer = Fusion.Observer

local defer = require(script.Parent.defer)

local function Observe<T, Args...>(stateObject: Fusion.StateObject<T>, callback: (value: T, Args...) -> ...any, ...)
	local extraArguments = table.pack(...)
	local function handleChange()
		callback(stateObject:get(), table.unpack(extraArguments, 1, extraArguments.n))
	end

	return Observer(stateObject):onChange(defer(handleChange))
end

return Observe]]></ProtectedString>
													<string name="ScriptGuid">{6066C679-A8E1-4DCE-BA75-F30F7AE15F0C}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Observe</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX61E39C489CD04F4C841D1A0B43D16076">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local defer = require(script.Parent.defer)

local function ObserveSignal<T>(signal: RBXScriptSignal<T>, callback: (value: T?, ...any) -> ...any, ...)
	local connection = signal:Connect(defer(callback, ...))
	return function()
		connection:Disconnect()
	end
end

return ObserveSignal
]]></ProtectedString>
													<string name="ScriptGuid">{368E3B4C-37CF-42B8-95A8-6186DFC1B337}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ObserveSignal</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX3E7D2851C89749F6935D7B700C5F826B">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local unwrap = require(script.Parent.unwrap)

local function With(source)
	return function(with)
		local destination = table.clone(unwrap(source))
		if type(with) == "table" then
			for index, value in pairs(unwrap(with)) do
				destination[index] = value
			end
		end
		return destination
	end
end

return With]]></ProtectedString>
													<string name="ScriptGuid">{40D7F07F-F6E5-4442-B6CB-21E358A08EFC}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">With</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXA9D0752793454D26BD503F2985654E2A">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local unwrap = require(script.Parent.unwrap)

local function WithItems(source)
	return function(with)
		local destination = table.clone(unwrap(source))
		if type(with) == "table" then
			local withUnwrapped = unwrap(with)
			table.move(withUnwrapped, 1, #withUnwrapped, #destination + 1, destination)
		end
		return destination
	end
end

return WithItems]]></ProtectedString>
													<string name="ScriptGuid">{2410AA11-41DA-4255-8878-9030108D38AE}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">WithItems</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX5AA99AD3F8254496B8D45DD9A6D273E1">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local unwrap = require(script.Parent.unwrap)

local function Without(source)
	return function(with)
		local destination = table.clone(unwrap(source))
		if type(with) == "table" then
			for _, index in ipairs(unwrap(with)) do
				destination[index] = nil
			end
		end
		return destination
	end
end

return Without]]></ProtectedString>
													<string name="ScriptGuid">{55918AB7-8641-4594-A1FB-0BDD0F8392CF}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Without</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXFB07B5B0B4E14610BE8EF0573730DD17">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local function defer(callback, ...)
	task.defer(callback, ...)
	return callback
end

return defer]]></ProtectedString>
													<string name="ScriptGuid">{A232B49B-A6AB-43B1-AD0E-A7BD025D1BDB}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">defer</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX43F185B4C44348C2A8C59953E2760B96">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local Fusion = require(script.Parent.Parent.Fusion)
local Computed = Fusion.Computed

local function map(state, callback)
	if type(state) == "table" and type(state.get) == "function" then
		return Computed(function()
			return callback(state:get())
		end)
	end

	return callback(state)
end

return map]]></ProtectedString>
													<string name="ScriptGuid">{330322A4-4CB9-4909-ACFC-D58AC7192979}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">map</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBXC1302127FE694FF19EAB93289F8DBD5C">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local Fusion = require(script.Parent.Parent.Fusion)

local function unwrap<T>(value: Fusion.CanBeState<T>, default: T?): T
	if type(value) == "table" and type(value.get) == "function" then
		return value:get()
	end
	return if value == nil then default :: T else value :: T
end

return unwrap]]></ProtectedString>
													<string name="ScriptGuid">{7277CDA6-9764-4CB6-B6F0-FD38EB58D68D}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">unwrap</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX58CC8F566F3B47249C9AA2F3B0AEE096">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">elttob_fusion@0.2.0</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX63B04B535D354629BA8001CCF9AE71F0">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[--!strict

--[[
	The entry point for the Fusion library.
]]

local PubTypes = require(script.PubTypes)
local restrictRead = require(script.Utility.restrictRead)

export type StateObject<T> = PubTypes.StateObject<T>
export type CanBeState<T> = PubTypes.CanBeState<T>
export type Symbol = PubTypes.Symbol
export type Value<T> = PubTypes.Value<T>
export type Computed<T> = PubTypes.Computed<T>
export type ForPairs<KO, VO> = PubTypes.ForPairs<KO, VO>
export type ForKeys<KI, KO> = PubTypes.ForKeys<KI, KO>
export type ForValues<VI, VO> = PubTypes.ForKeys<VI, VO>
export type Observer = PubTypes.Observer
export type Tween<T> = PubTypes.Tween<T>
export type Spring<T> = PubTypes.Spring<T>

type Fusion = {
	version: PubTypes.Version,

	New: (className: string) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Hydrate: (target: Instance) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Ref: PubTypes.SpecialKey,
	Cleanup: PubTypes.SpecialKey,
	Children: PubTypes.SpecialKey,
	Out: PubTypes.SpecialKey,
	OnEvent: (eventName: string) -> PubTypes.SpecialKey,
	OnChange: (propertyName: string) -> PubTypes.SpecialKey,

	Value: <T>(initialValue: T) -> Value<T>,
	Computed: <T>(callback: () -> T, destructor: (T) -> ()?) -> Computed<T>,
	ForPairs: <KI, VI, KO, VO, M>(inputTable: CanBeState<{[KI]: VI}>, processor: (KI, VI) -> (KO, VO, M?), destructor: (KO, VO, M?) -> ()?) -> ForPairs<KO, VO>,
	ForKeys: <KI, KO, M>(inputTable: CanBeState<{[KI]: any}>, processor: (KI) -> (KO, M?), destructor: (KO, M?) -> ()?) -> ForKeys<KO, any>,
	ForValues: <VI, VO, M>(inputTable: CanBeState<{[any]: VI}>, processor: (VI) -> (VO, M?), destructor: (VO, M?) -> ()?) -> ForValues<any, VO>,
	Observer: (watchedState: StateObject<any>) -> Observer,

	Tween: <T>(goalState: StateObject<T>, tweenInfo: TweenInfo?) -> Tween<T>,
	Spring: <T>(goalState: StateObject<T>, speed: number?, damping: number?) -> Spring<T>,

	cleanup: (...any) -> (),
	doNothing: (...any) -> ()
}

return restrictRead("Fusion", {
	version = {major = 0, minor = 2, isRelease = true},

	New = require(script.Instances.New),
	Hydrate = require(script.Instances.Hydrate),
	Ref = require(script.Instances.Ref),
	Out = require(script.Instances.Out),
	Cleanup = require(script.Instances.Cleanup),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	Value = require(script.State.Value),
	Computed = require(script.State.Computed),
	ForPairs = require(script.State.ForPairs),
	ForKeys = require(script.State.ForKeys),
	ForValues = require(script.State.ForValues),
	Observer = require(script.State.Observer),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring),

	cleanup = require(script.Utility.cleanup),
	doNothing = require(script.Utility.doNothing)
}) :: Fusion
]]></ProtectedString>
												<string name="ScriptGuid">{BECB3D74-6299-4821-8712-1502BDA89CC5}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">fusion</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX934C097EDEFD48858F0BDE1408C308D3">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores common public-facing type information for Fusion APIs.
]]

type Set<T> = {[T]: any}

--[[
	General use types
]]

-- A unique symbolic value.
export type Symbol = {
	type: string, -- replace with "Symbol" when Luau supports singleton types
	name: string
}

-- Types that can be expressed as vectors of numbers, and so can be animated.
export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

-- A task which can be accepted for cleanup.
export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

-- Script-readable version information.
export type Version = {
	major: number,
	minor: number,
	isRelease: boolean
}
--[[
	Generic reactive graph types
]]

-- A graph object which can have dependents.
export type Dependency = {
	dependentSet: Set<Dependent>
}

-- A graph object which can have dependencies.
export type Dependent = {
	update: (Dependent) -> boolean,
	dependencySet: Set<Dependency>
}

-- An object which stores a piece of reactive state.
export type StateObject<T> = Dependency & {
	type: string, -- replace with "State" when Luau supports singleton types
	kind: string,
	get: (StateObject<T>, asDependency: boolean?) -> T
}

-- Either a constant value of type T, or a state object containing type T.
export type CanBeState<T> = StateObject<T> | T

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type Value<T> = StateObject<T> & {
	-- kind: "State" (add this when Luau supports singleton types)
 	set: (Value<T>, newValue: any, force: boolean?) -> ()
}

-- A state object whose value is derived from other objects using a callback.
export type Computed<T> = StateObject<T> & Dependent & {
	-- kind: "Computed" (add this when Luau supports singleton types)
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs<KO, VO> = StateObject<{ [KO]: VO }> & Dependent & {
	-- kind: "ForPairs" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForKeys<KO, V> = StateObject<{ [KO]: V }> & Dependent & {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForValues<K, VO> = StateObject<{ [K]: VO }> & Dependent & {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using tweens.
export type Tween<T> = StateObject<T> & Dependent & {
	-- kind: "Tween" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using spring simulation.
export type Spring<T> = StateObject<T> & Dependent & {
	-- kind: "Spring" (add this when Luau supports singleton types)
	-- Uncomment when ENABLE_PARAM_SETTERS is enabled
	-- setPosition: (Spring<T>, newValue: Animatable) -> (),
	-- setVelocity: (Spring<T>, newValue: Animatable) -> (),
	-- addVelocity: (Spring<T>, deltaValue: Animatable) -> ()
}

-- An object which can listen for updates on another state object.
export type Observer = Dependent & {
	-- kind: "Observer" (add this when Luau supports singleton types)
  	onChange: (Observer, callback: () -> ()) -> (() -> ())
}

--[[
	Instance related types
]]

-- Denotes children instances in an instance or component's property table.
export type SpecialKey = {
	type: string, -- replace with "SpecialKey" when Luau supports singleton types
	kind: string,
	stage: string, -- replace with "self" | "descendants" | "ancestor" | "observer" when Luau supports singleton types
	apply: (SpecialKey, value: any, applyTo: Instance, cleanupTasks: {Task}) -> ()
}

-- A collection of instances that may be parented to another instance.
export type Children = Instance | StateObject<Children> | {[any]: Children}

-- A table that defines an instance's properties, handlers and children.
export type PropertyTable = {[string | SpecialKey]: any}

return nil]]></ProtectedString>
													<string name="ScriptGuid">{7B91CF4E-7566-44EC-8A91-E9E3F45044C5}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">PubTypes</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX8CE509625FE24A2681B224E484FA44B9">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores common type information used internally.

	These types may be used internally so Fusion code can type-check, but
	should never be exposed to public users, as these definitions are fair game
	for breaking changes.
]]

local Package = script.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}

--[[
	General use types
]]

-- A symbol that represents the absence of a value.
export type None = PubTypes.Symbol & {
	-- name: "None" (add this when Luau supports singleton types)
}

-- Stores useful information about Luau errors.
export type Error = {
	type: string, -- replace with "Error" when Luau supports singleton types
	raw: string,
	message: string,
	trace: string
}

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type State<T> = PubTypes.Value<T> & {
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type Computed<T> = PubTypes.Computed<T> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_callback: () -> T,
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs<KI, VI, KO, VO, M> = PubTypes.ForPairs<KO, VO> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (KI, VI) -> (KO, VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [KI]: VI }>,
	_oldInputTable: { [KI]: VI },
	_outputTable: { [KO]: VO },
	_oldOutputTable: { [KO]: VO },
	_keyIOMap: { [KI]: KO },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForKeys<KI, KO, M> = PubTypes.ForKeys<KO, any> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (KI) -> (KO),
	_destructor: (KO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [KI]: KO }>,
	_oldInputTable: { [KI]: KO },
	_outputTable: { [KO]: any },
	_keyOIMap: { [KO]: KI },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForValues<VI, VO, M> = PubTypes.ForValues<any, VO> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (VI) -> (VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [VI]: VO }>,
	_outputTable: { [any]: VI },
	_valueCache: { [VO]: any },
	_oldValueCache: { [VO]: any },
	_meta: { [VO]: M? },
	_valueData: {
		[VI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object which follows another state object using tweens.
export type Tween<T> = PubTypes.Tween<T> & {
	_goalState: State<T>,
	_tweenInfo: TweenInfo,
	_prevValue: T,
	_nextValue: T,
	_currentValue: T,
	_currentTweenInfo: TweenInfo,
	_currentTweenDuration: number,
	_currentTweenStartTime: number,
	_currentlyAnimating: boolean
}

-- A state object which follows another state object using spring simulation.
export type Spring<T> = PubTypes.Spring<T> & {
	_speed: PubTypes.CanBeState<number>,
	_speedIsState: boolean,
	_lastSpeed: number,
	_damping: PubTypes.CanBeState<number>,
	_dampingIsState: boolean,
	_lastDamping: number,
	_goalState: State<T>,
	_goalValue: T,
	_currentType: string,
	_currentValue: T,
	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

-- An object which can listen for updates on another state object.
export type Observer = PubTypes.Observer & {
	_changeListeners: Set<() -> ()>,
	_numChangeListeners: number
}

return nil]]></ProtectedString>
													<string name="ScriptGuid">{28F9A0FD-77DA-4602-BCF0-023C08923407}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Types</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="Folder" referent="RBX6B9B86F561DB43F69D6C9109207DBEFA">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Animation</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX321051199C4248CEBAE90E3D4F9D3F1A">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local xtypeof = require(Package.Utility.xtypeof)
local unwrap = require(Package.State.unwrap)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Sets the position of the internal springs, meaning the value of this
	Spring will jump to the given value. This doesn't affect velocity.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setPosition(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springPositions = unpackType(newValue, newType)
	self._currentValue = newValue
	SpringScheduler.add(self)
	updateAll(self)
end

--[[
	Sets the velocity of the internal springs, overwriting the existing velocity
	of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setVelocity(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springVelocities = unpackType(newValue, newType)
	SpringScheduler.add(self)
end

--[[
	Adds to the velocity of the internal springs, on top of the existing
	velocity of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:addVelocity(deltaValue: PubTypes.Animatable)
	local deltaType = typeof(deltaValue)
	if deltaType ~= self._currentType then
		logError("springTypeMismatch", nil, deltaType, self._currentType)
	end

	local springDeltas = unpackType(deltaValue, deltaType)
	for index, delta in ipairs(springDeltas) do
		self._springVelocities[index] += delta
	end
	SpringScheduler.add(self)
end

--[[
	Called when the goal state changes value, or when the speed or damping has
	changed.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- figure out if this was a goal change or a speed/damping change
	if goalValue == self._goalValue then
		-- speed/damping change
		local damping = unwrap(self._damping)
		if typeof(damping) ~= "number" then
			logErrorNonFatal("mistypedSpringDamping", nil, typeof(damping))
		elseif damping < 0 then
			logErrorNonFatal("invalidSpringDamping", nil, damping)
		else
			self._currentDamping = damping
		end

		local speed = unwrap(self._speed)
		if typeof(speed) ~= "number" then
			logErrorNonFatal("mistypedSpringSpeed", nil, typeof(speed))
		elseif speed < 0 then
			logErrorNonFatal("invalidSpringSpeed", nil, speed)
		else
			self._currentSpeed = speed
		end

		return false
	else
		-- goal change - reconfigure spring to target new goal
		self._goalValue = goalValue

		local oldType = self._currentType
		local newType = typeof(goalValue)
		self._currentType = newType

		local springGoals = unpackType(goalValue, newType)
		local numSprings = #springGoals
		self._springGoals = springGoals

		if newType ~= oldType then
			-- if the type changed, snap to the new value and rebuild the
			-- position and velocity tables
			self._currentValue = self._goalValue

			local springPositions = table.create(numSprings, 0)
			local springVelocities = table.create(numSprings, 0)
			for index, springGoal in ipairs(springGoals) do
				springPositions[index] = springGoal
			end
			self._springPositions = springPositions
			self._springVelocities = springVelocities

			-- the spring may have been animating before, so stop that
			SpringScheduler.remove(self)
			return true

			-- otherwise, the type hasn't changed, just the goal...
		elseif numSprings == 0 then
			-- if the type isn't animatable, snap to the new value
			self._currentValue = self._goalValue
			return true

		else
			-- if it's animatable, let it animate to the goal
			SpringScheduler.add(self)
			return false
		end
	end
end

local function Spring<T>(
	goalState: PubTypes.Value<T>,
	speed: PubTypes.CanBeState<number>?,
	damping: PubTypes.CanBeState<number>?
): Types.Spring<T>
	-- apply defaults for speed and damping
	if speed == nil then
		speed = 10
	end
	if damping == nil then
		damping = 1
	end

	local dependencySet = {[goalState] = true}
	if xtypeof(speed) == "State" then
		dependencySet[speed] = true
	end
	if xtypeof(damping) == "State" then
		dependencySet[damping] = true
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,
		_currentSpeed = unwrap(speed),
		_currentDamping = unwrap(damping),

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring]]></ProtectedString>
														<string name="ScriptGuid">{6DACC79C-2CE5-4DA9-9535-4B163B562CF9}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Spring</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX7B06BC27C95F487293697A3B857ACBA9">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

type Set<T> = {[T]: any}
type Spring = Types.Spring<any>

local SpringScheduler = {}

local EPSILON = 0.0001
local activeSprings: Set<Spring> = {}
local lastUpdateTime = os.clock()

function SpringScheduler.add(spring: Spring)
	-- we don't necessarily want to use the most accurate time - here we snap to
	-- the last update time so that springs started within the same frame have
	-- identical time steps
	spring._lastSchedule = lastUpdateTime
	spring._startDisplacements = {}
	spring._startVelocities = {}
	for index, goal in ipairs(spring._springGoals) do
		spring._startDisplacements[index] = spring._springPositions[index] - goal
		spring._startVelocities[index] = spring._springVelocities[index]
	end

	activeSprings[spring] = true
end

function SpringScheduler.remove(spring: Spring)
	activeSprings[spring] = nil
end


local function updateAllSprings()
	local springsToSleep: Set<Spring> = {}
	lastUpdateTime = os.clock()

	for spring in pairs(activeSprings) do
		local posPos, posVel, velPos, velVel = springCoefficients(lastUpdateTime - spring._lastSchedule, spring._currentDamping, spring._currentSpeed)

		local positions = spring._springPositions
		local velocities = spring._springVelocities
		local startDisplacements = spring._startDisplacements
		local startVelocities = spring._startVelocities
		local isMoving = false

		for index, goal in ipairs(spring._springGoals) do
			local oldDisplacement = startDisplacements[index]
			local oldVelocity = startVelocities[index]
			local newDisplacement = oldDisplacement * posPos + oldVelocity * posVel
			local newVelocity = oldDisplacement * velPos + oldVelocity * velVel

			if math.abs(newDisplacement) > EPSILON or math.abs(newVelocity) > EPSILON then
				isMoving = true
			end

			positions[index] = newDisplacement + goal
			velocities[index] = newVelocity
		end

		if not isMoving then
			springsToSleep[spring] = true
		end
	end

	for spring in pairs(activeSprings) do
		spring._currentValue = packType(spring._springPositions, spring._currentType)
		updateAll(spring)
	end

	for spring in pairs(springsToSleep) do
		activeSprings[spring] = nil
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler]]></ProtectedString>
														<string name="ScriptGuid">{D9AF55B0-B97C-49EA-85DC-22C1083D4828}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">SpringScheduler</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXA0DD19BA5A024509A254BC348B7AEC3D">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local xtypeof = require(Package.Utility.xtypeof)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- if the goal hasn't changed, then this is a TweenInfo change.
	-- in that case, if we're not currently animating, we can skip everything
	if goalValue == self._nextValue and not self._currentlyAnimating then
		return false
	end

	local tweenInfo = self._tweenInfo
	if self._tweenInfoIsState then
		tweenInfo = tweenInfo:get()
	end

	-- if we receive a bad TweenInfo, then error and stop the update
	if typeof(tweenInfo) ~= "TweenInfo" then
		logErrorNonFatal("mistypedTweenInfo", nil, typeof(tweenInfo))
		return false
	end

	self._prevValue = self._currentValue
	self._nextValue = goalValue

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = tweenInfo

	local tweenDuration = tweenInfo.DelayTime + tweenInfo.Time
	if tweenInfo.Reverses then
		tweenDuration += tweenInfo.Time
	end
	tweenDuration *= tweenInfo.RepeatCount + 1
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)

	return false
end

local function Tween<T>(
	goalState: PubTypes.StateObject<PubTypes.Animatable>,
	tweenInfo: PubTypes.CanBeState<TweenInfo>?
): Types.Tween<T>
	local currentValue = goalState:get(false)

	-- apply defaults for tween info
	if tweenInfo == nil then
		tweenInfo = TweenInfo.new()
	end

	local dependencySet = {[goalState] = true}
	local tweenInfoIsState = xtypeof(tweenInfo) == "State"

	if tweenInfoIsState then
		dependencySet[tweenInfo] = true
	end

	local startingTweenInfo = tweenInfo
	if tweenInfoIsState then
		startingTweenInfo = startingTweenInfo:get()
	end

	-- If we start with a bad TweenInfo, then we don't want to construct a Tween
	if typeof(startingTweenInfo) ~= "TweenInfo" then
		logError("mistypedTweenInfo", nil, typeof(startingTweenInfo))
	end

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo,
		_tweenInfoIsState = tweenInfoIsState,

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0,
		_currentlyAnimating = false
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween]]></ProtectedString>
														<string name="ScriptGuid">{56262F3D-85AD-4D49-97F3-CF51BD8219F1}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Tween</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX7E673986C343429396F0226485AB8F62">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Set<T> = {[T]: any}
type Tween = Types.Tween<any>

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Set<Tween> = {}
setmetatable(allTweens, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	-- FIXME: Typed Luau doesn't understand this loop yet
	for tween: Tween in pairs(allTweens :: any) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			tween._currentlyAnimating = false
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			tween._currentlyAnimating = true
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler]]></ProtectedString>
														<string name="ScriptGuid">{059D5B45-6967-47AB-935A-0BC53F101015}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">TweenScheduler</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXBB0DCB4E796045D3BF66CC39CFA2F30B">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numCycles = 1 + tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numCycles then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime <= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio]]></ProtectedString>
														<string name="ScriptGuid">{02D2BF8D-22E5-4E0F-912B-BC2ED5DAA42B}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">getTweenRatio</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX81591C97580647F0951563B253713466">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: any, to: any, ratio: number): any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			local to, from = to :: number, from :: number
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			local to, from = to :: CFrame, from :: CFrame
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local to, from = to :: Color3, from :: Color3
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local to, from = to :: ColorSequenceKeypoint, from :: ColorSequenceKeypoint
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			local to, from = to :: DateTime, from :: DateTime
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			local to, from = to :: NumberRange, from :: NumberRange
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			local to, from = to :: NumberSequenceKeypoint, from :: NumberSequenceKeypoint
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			local to, from = to :: PhysicalProperties, from :: PhysicalProperties
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			local to, from = to :: Ray, from :: Ray
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio)
			)

		elseif typeString == "Rect" then
			local to, from = to :: Rect, from :: Rect
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			local to, from = to :: Region3, from :: Region3
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			local to, from = to :: Region3int16, from :: Region3int16
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			local to, from = to :: UDim, from :: UDim
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			local to, from = to :: UDim2, from :: UDim2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			local to, from = to :: Vector2, from :: Vector2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			local to, from = to :: Vector2int16, from :: Vector2int16
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			local to, from = to :: Vector3, from :: Vector3
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			local to, from = to :: Vector3int16, from :: Vector3int16
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio < 0.5 then
		return from
	else
		return to
	end
end

return lerpType]]></ProtectedString>
														<string name="ScriptGuid">{79248308-34A8-401B-8661-0DC4584C53E4}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">lerpType</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX164B832B15324869BB7AED174A7DF002">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): PubTypes.Animatable?
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	else
		return nil
	end
end

return packType]]></ProtectedString>
														<string name="ScriptGuid">{CC602E75-C8B4-42E4-8677-9098E61BAC98}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">packType</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXE01C5FC3863A42CFB956BA586FDD493E">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Returns a 2x2 matrix of coefficients for a given time, damping and speed.
	Specifically, this returns four coefficients - posPos, posVel, velPos, and
	velVel - which can be multiplied with position and velocity like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	Special thanks to AxisAngle for helping to improve numerical precision.
]]

local function springCoefficients(time: number, damping: number, speed: number): (number, number, number, number)
	-- if time or speed is 0, then the spring won't move
	if time == 0 or speed == 0 then
		return 1, 0, 0, 1
	end
	local posPos, posVel, velPos, velVel

	if damping > 1 then
		-- overdamped spring
		-- solution to the characteristic equation:
		-- z = -  Sqrt[^2 - 1] 
		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)
		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local scaledTime = time * speed
		local alpha = math.sqrt(damping^2 - 1)
		local scaledInvAlpha = -0.5 / alpha
		local z1 = -alpha - damping
		local z2 = 1 / z1
		local expZ1 = math.exp(scaledTime * z1)
		local expZ2 = math.exp(scaledTime * z2)

		posPos = (expZ2*z1 - expZ1*z2) * scaledInvAlpha
		posVel = (expZ1 - expZ2) * scaledInvAlpha / speed
		velPos = (expZ2 - expZ1) * scaledInvAlpha * speed
		velVel = (expZ1*z1 - expZ2*z2) * scaledInvAlpha

	elseif damping == 1 then
		-- critically damped spring
		-- x[t] -> x0(e^-t)(1+t) + v0(e^-t)t
		-- v[t] -> x0(t ^2)(-e^-t) + v0(1 - t)(e^-t)

		local scaledTime = time * speed
		local expTerm = math.exp(-scaledTime)

		posPos = expTerm * (1 + scaledTime)
		posVel = expTerm * time
		velPos = expTerm * (-scaledTime*speed)
		velVel = expTerm * (1 - scaledTime)

	else
		-- underdamped spring
		-- factored out of the solutions to the characteristic equation:
		--  = Sqrt[1 - ^2]
		-- x[t] -> x0(e^-t)( Cos[t] +  Sin[t])/
		--       + v0(e^-t)(Sin[t])/
		-- v[t] -> x0(-e^-t)(^2 + ^2 ^2)(Sin[t])/
		--       + v0(e^-t)( Cos[t] -  Sin[t])/

		local scaledTime = time * speed
		local alpha = math.sqrt(1 - damping^2)
		local invAlpha = 1 / alpha
		local alphaTime = alpha * scaledTime
		local expTerm = math.exp(-scaledTime*damping)
		local sinTerm = expTerm * math.sin(alphaTime)
		local cosTerm = expTerm * math.cos(alphaTime)
		local sinInvAlpha = sinTerm*invAlpha
		local sinInvAlphaDamp = sinInvAlpha*damping

		posPos = sinInvAlphaDamp + cosTerm
		posVel = sinInvAlpha
		velPos = -(sinInvAlphaDamp*damping + sinTerm*alpha)
		velVel = cosTerm - sinInvAlphaDamp
	end

	return posPos, posVel, velPos, velVel
end

return springCoefficients
]]></ProtectedString>
														<string name="ScriptGuid">{BE309F49-38B8-4318-B6D4-725FCB814F31}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">springCoefficients</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX46C9367F44D14DE09F67DA373F4BECD9">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: any, typeString: string): {number}
	if typeString == "number" then
		local value = value :: number
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType]]></ProtectedString>
														<string name="ScriptGuid">{9DCA8869-2EF8-478E-A925-3D5DCF71763B}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">unpackType</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBX97D91DE69D0947389EC72D4C21FBBA41">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Colour</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX6A38E1F999B347698FF4931519810B39">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

	local lRoot = l ^ (1/3)
	local mRoot = m ^ (1/3)
	local sRoot = s ^ (1/3)

	return Vector3.new(
		lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
		lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
		lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
	local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
	local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

	local l = lRoot ^ 3
	local m = mRoot ^ 3
	local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab
]]></ProtectedString>
														<string name="ScriptGuid">{43A6AEAA-FAC1-449B-B931-38398F49D40D}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Oklab</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBX49064B6FCE1349C3B85672525D623850">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Dependencies</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX6F94DF0817FD4A19BC3E05E36D5249D5">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.

	NOTE: any calls to useDependency() inside the callback (even if inside any
	nested captureDependencies() call) will not be included in the set, to avoid
	self-dependencies.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

type Set<T> = {[T]: any}

local initialisedStack = sharedState.initialisedStack
local initialisedStackCapacity = 0

local function captureDependencies(
	saveToSet: Set<PubTypes.Dependency>,
	callback: (...any) -> any,
	...
): (boolean, any)

	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet
	if initialisedStackSize > initialisedStackCapacity then
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	local data = table.pack(xpcall(callback, parseError, ...))

	sharedState.dependencySet = prevDependencySet
	sharedState.initialisedStackSize -= 1

	return table.unpack(data, 1, data.n)
end

return captureDependencies
]]></ProtectedString>
														<string name="ScriptGuid">{56EFD185-F777-4B35-A4BA-CB49AB848AB0}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">captureDependencies</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXF93CC17B56094CEBA423BE5CA5EBF880">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: PubTypes.Dependency)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency]]></ProtectedString>
														<string name="ScriptGuid">{5CDA5EAB-226F-437F-9F40-FA79F28C2F79}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">initDependency</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX73AD190B53DD4296A36A555399FD405D">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}

-- The set where used dependencies should be saved to.
local dependencySet: Set<PubTypes.Dependency>? = nil

-- A stack of sets where newly created dependencies should be stored.
local initialisedStack: {Set<PubTypes.Dependency>} = {}
local initialisedStackSize = 0

return {
	dependencySet = dependencySet,
	initialisedStack = initialisedStack,
	initialisedStackSize = initialisedStackSize
}]]></ProtectedString>
														<string name="ScriptGuid">{05E99AD0-2482-4803-91FE-93E77B9EE02B}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">sharedState</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXCFEC52C749544A1982D3E691AD6392CE">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}
type Descendant = (PubTypes.Dependent & PubTypes.Dependency) | PubTypes.Dependent

-- Credit: https://blog.elttob.uk/2022/11/07/sets-efficient-topological-search.html
local function updateAll(root: PubTypes.Dependency)
	local counters: {[Descendant]: number} = {}
	local flags: {[Descendant]: boolean} = {}
	local queue: {Descendant} = {}
	local queueSize = 0
	local queuePos = 1

	for object in root.dependentSet do
		queueSize += 1
		queue[queueSize] = object
		flags[object] = true
	end

	-- Pass 1: counting up
	while queuePos <= queueSize do
		local next = queue[queuePos]
		local counter = counters[next]
		counters[next] = if counter == nil then 1 else counter + 1
		if (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				queueSize += 1
				queue[queueSize] = object
			end
		end
		queuePos += 1
	end

	-- Pass 2: counting down + processing
	queuePos = 1
	while queuePos <= queueSize do
		local next = queue[queuePos]
		local counter = counters[next] - 1
		counters[next] = counter
		if counter == 0 and flags[next] and next:update() and (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				flags[object] = true
			end
		end
		queuePos += 1
	end
end

return updateAll]]></ProtectedString>
														<string name="ScriptGuid">{5B73C866-CEEF-458B-BC29-0E1EAF800A6C}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">updateAll</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXBB89923285834C15A6EF8699E22857EB">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: PubTypes.Dependency)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency]]></ProtectedString>
														<string name="ScriptGuid">{1DF36922-4658-4C78-B834-CE4E28C5CB83}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">useDependency</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBXC31C7454ED714277AB787DE35972DDEE">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Instances</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX73051DC7C6614D7D80034A3C4FC49C15">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which parents any given descendants into
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logWarn = require(Package.Logging.logWarn)
local Observer = require(Package.State.Observer)
local xtypeof = require(Package.Utility.xtypeof)

type Set<T> = {[T]: boolean}

-- Experimental flag: name children based on the key used in the [Children] table
local EXPERIMENTAL_AUTO_NAMING = false

local Children = {}
Children.type = "SpecialKey"
Children.kind = "Children"
Children.stage = "descendants"

function Children:apply(propValue: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	local newParented: Set<Instance> = {}
	local oldParented: Set<Instance> = {}

	-- save disconnection functions for state object observers
	local newDisconnects: {[PubTypes.StateObject<any>]: () -> ()} = {}
	local oldDisconnects: {[PubTypes.StateObject<any>]: () -> ()} = {}

	local updateQueued = false
	local queueUpdate: () -> ()

	-- Rescans this key's value to find new instances to parent and state objects
	-- to observe for changes; then unparents instances no longer found and
	-- disconnects observers for state objects no longer present.
	local function updateChildren()
		if not updateQueued then
			return -- this update may have been canceled by destruction, etc.
		end
		updateQueued = false

		oldParented, newParented = newParented, oldParented
		oldDisconnects, newDisconnects = newDisconnects, oldDisconnects
		table.clear(newParented)
		table.clear(newDisconnects)

		local function processChild(child: any, autoName: string?)
			local kind = xtypeof(child)

			if kind == "Instance" then
				-- case 1; single instance

				newParented[child] = true
				if oldParented[child] == nil then
					-- wasn't previously present

					-- TODO: check for ancestry conflicts here
					child.Parent = applyTo
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldParented[child] = nil
				end

				if EXPERIMENTAL_AUTO_NAMING and autoName ~= nil then
					child.Name = autoName
				end

			elseif kind == "State" then
				-- case 2; state object

				local value = child:get(false)
				-- allow nil to represent the absence of a child
				if value ~= nil then
					processChild(value, autoName)
				end

				local disconnect = oldDisconnects[child]
				if disconnect == nil then
					-- wasn't previously present
					disconnect = Observer(child):onChange(queueUpdate)
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldDisconnects[child] = nil
				end

				newDisconnects[child] = disconnect

			elseif kind == "table" then
				-- case 3; table of objects

				for key, subChild in pairs(child) do
					local keyType = typeof(key)
					local subAutoName: string? = nil

					if keyType == "string" then
						subAutoName = key
					elseif keyType == "number" and autoName ~= nil then
						subAutoName = autoName .. "_" .. key
					end

					processChild(subChild, subAutoName)
				end

			else
				logWarn("unrecognisedChildType", kind)
			end
		end

		if propValue ~= nil then
			-- `propValue` is set to nil on cleanup, so we don't process children
			-- in that case
			processChild(propValue)
		end

		-- unparent any children that are no longer present
		for oldInstance in pairs(oldParented) do
			oldInstance.Parent = nil
		end

		-- disconnect observers which weren't reused
		for oldState, disconnect in pairs(oldDisconnects) do
			disconnect()
		end
	end

	queueUpdate = function()
		if not updateQueued then
			updateQueued = true
			task.defer(updateChildren)
		end
	end

	table.insert(cleanupTasks, function()
		propValue = nil
		updateQueued = true
		updateChildren()
	end)

	-- perform initial child parenting
	updateQueued = true
	updateChildren()
end

return Children :: PubTypes.SpecialKey]]></ProtectedString>
														<string name="ScriptGuid">{34C5671B-B878-4956-80A0-1A6B76D3A3B5}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Children</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX20A43AC45C6F441B8A7AACF8DEBEB400">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which adds user-specified tasks to be run
	when the instance is destroyed.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

local Cleanup = {}
Cleanup.type = "SpecialKey"
Cleanup.kind = "Cleanup"
Cleanup.stage = "observer"

function Cleanup:apply(userTask: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	table.insert(cleanupTasks, userTask)
end

return Cleanup]]></ProtectedString>
														<string name="ScriptGuid">{38CE2D15-7377-44B1-B28E-776F78F9C743}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Cleanup</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXD5CB2009DA504C099DC27586D4E5F88A">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Processes and returns an existing instance, with options for setting
	properties, event handlers and other attributes on the instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)

local function Hydrate(target: Instance)
	return function(props: PubTypes.PropertyTable): Instance
		applyInstanceProps(props, target)
		return target
	end
end

return Hydrate]]></ProtectedString>
														<string name="ScriptGuid">{7321CC55-E442-4006-AC55-765CF9BAFC07}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Hydrate</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX0C53070BDD3F4085B355784B90D39AA1">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local defaultProps = require(Package.Instances.defaultProps)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)
local logError= require(Package.Logging.logError)

local function New(className: string)
	return function(props: PubTypes.PropertyTable): Instance
		local ok, instance = pcall(Instance.new, className)

		if not ok then
			logError("cannotCreateClass", nil, className)
		end

		local classDefaults = defaultProps[className]
		if classDefaults ~= nil then
			for defaultProp, defaultValue in pairs(classDefaults) do
				instance[defaultProp] = defaultValue
			end
		end

		applyInstanceProps(props, instance)

		return instance
	end
end

return New]]></ProtectedString>
														<string name="ScriptGuid">{95CFEF91-196D-4292-957F-21E57701566B}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">New</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX7684CF72603C489BB5F0BC17A9927EB1">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs special keys for property tables which connect property change
	listeners to an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function OnChange(propertyName: string): PubTypes.SpecialKey
	local changeKey = {}
	changeKey.type = "SpecialKey"
	changeKey.kind = "OnChange"
	changeKey.stage = "observer"

	function changeKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("cannotConnectChange", nil, applyTo.ClassName, propertyName)
		elseif typeof(callback) ~= "function" then
			logError("invalidChangeHandler", nil, propertyName)
		else
			table.insert(cleanupTasks, event:Connect(function()
				callback((applyTo :: any)[propertyName])
			end))
		end
	end

	return changeKey
end

return OnChange]]></ProtectedString>
														<string name="ScriptGuid">{3AA6AF6A-F0EF-45D2-BB9F-3604CA16C63D}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">OnChange</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXEF47242FF51C41AD8E9BCD0D9336BE1D">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs special keys for property tables which connect event listeners to
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function getProperty_unsafe(instance: Instance, property: string)
	return (instance :: any)[property]
end

local function OnEvent(eventName: string): PubTypes.SpecialKey
	local eventKey = {}
	eventKey.type = "SpecialKey"
	eventKey.kind = "OnEvent"
	eventKey.stage = "observer"

	function eventKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(getProperty_unsafe, applyTo, eventName)
		if not ok or typeof(event) ~= "RBXScriptSignal" then
			logError("cannotConnectEvent", nil, applyTo.ClassName, eventName)
		elseif typeof(callback) ~= "function" then
			logError("invalidEventHandler", nil, eventName)
		else
			table.insert(cleanupTasks, event:Connect(callback))
		end
	end

	return eventKey
end

return OnEvent]]></ProtectedString>
														<string name="ScriptGuid">{C5311178-5E2C-451F-8E17-899393D01EA6}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">OnEvent</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX677D29303E5D4B88B68C004690665045">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which allows users to extract values from
	an instance into an automatically-updated Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local function Out(propertyName: string): PubTypes.SpecialKey
	local outKey = {}
	outKey.type = "SpecialKey"
	outKey.kind = "Out"
	outKey.stage = "observer"

	function outKey:apply(outState: any, applyTo: Instance, cleanupTasks: { PubTypes.Task })
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("invalidOutProperty", nil, applyTo.ClassName, propertyName)
		elseif xtypeof(outState) ~= "State" or outState.kind ~= "Value" then
			logError("invalidOutType")
		else
			outState:set((applyTo :: any)[propertyName])
			table.insert(
				cleanupTasks,
				event:Connect(function()
					outState:set((applyTo :: any)[propertyName])
				end)
			)
			table.insert(cleanupTasks, function()
				outState:set(nil)
			end)
		end
	end

	return outKey
end

return Out
]]></ProtectedString>
														<string name="ScriptGuid">{391C90CF-DF37-41A6-A30A-F406E9A9D31B}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Out</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXD6DB79DE5D86498795520ED55FA80659">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which stores a reference to the instance
	in a user-provided Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local Ref = {}
Ref.type = "SpecialKey"
Ref.kind = "Ref"
Ref.stage = "observer"

function Ref:apply(refState: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	if xtypeof(refState) ~= "State" or refState.kind ~= "Value" then
		logError("invalidRefType")
	else
		refState:set(applyTo)
		table.insert(cleanupTasks, function()
			refState:set(nil)
		end)
	end
end

return Ref]]></ProtectedString>
														<string name="ScriptGuid">{A22DA89F-ADAF-49FD-A8E2-D14F57F28AAA}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Ref</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX99793FC206B946CE801F5E7B4BF3128A">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Applies a table of properties to an instance, including binding to any
	given state objects and applying any special keys.

	No strong reference is kept by default - special keys should take care not
	to accidentally hold strong references to instances forever.

	If a key is used twice, an error will be thrown. This is done to avoid
	double assignments or double bindings. However, some special keys may want
	to enable such assignments - in which case unique keys should be used for
	each occurence.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local cleanup = require(Package.Utility.cleanup)
local xtypeof = require(Package.Utility.xtypeof)
local logError = require(Package.Logging.logError)
local Observer = require(Package.State.Observer)

local function setProperty_unsafe(instance: Instance, property: string, value: any)
	(instance :: any)[property] = value
end

local function testPropertyAssignable(instance: Instance, property: string)
	(instance :: any)[property] = (instance :: any)[property]
end

local function setProperty(instance: Instance, property: string, value: any)
	if not pcall(setProperty_unsafe, instance, property, value) then
		if not pcall(testPropertyAssignable, instance, property) then
			if instance == nil then
				-- reference has been lost
				logError("setPropertyNilRef", nil, property, tostring(value))
			else
				-- property is not assignable
				logError("cannotAssignProperty", nil, instance.ClassName, property)
			end
		else
			-- property is assignable, but this specific assignment failed
			-- this typically implies the wrong type was received
			local givenType = typeof(value)
			local expectedType = typeof((instance :: any)[property])
			logError("invalidPropertyType", nil, instance.ClassName, property, expectedType, givenType)
		end
	end
end

local function bindProperty(instance: Instance, property: string, value: PubTypes.CanBeState<any>, cleanupTasks: {PubTypes.Task})
	if xtypeof(value) == "State" then
		-- value is a state object - assign and observe for changes
		local willUpdate = false
		local function updateLater()
			if not willUpdate then
				willUpdate = true
				task.defer(function()
					willUpdate = false
					setProperty(instance, property, value:get(false))
				end)
			end
		end

		setProperty(instance, property, value:get(false))
		table.insert(cleanupTasks, Observer(value :: any):onChange(updateLater))
	else
		-- value is a constant - assign once only
		setProperty(instance, property, value)
	end
end

local function applyInstanceProps(props: PubTypes.PropertyTable, applyTo: Instance)
	local specialKeys = {
		self = {} :: {[PubTypes.SpecialKey]: any},
		descendants = {} :: {[PubTypes.SpecialKey]: any},
		ancestor = {} :: {[PubTypes.SpecialKey]: any},
		observer = {} :: {[PubTypes.SpecialKey]: any}
	}
	local cleanupTasks = {}

	for key, value in pairs(props) do
		local keyType = xtypeof(key)

		if keyType == "string" then
			if key ~= "Parent" then
				bindProperty(applyTo, key :: string, value, cleanupTasks)
			end
		elseif keyType == "SpecialKey" then
			local stage = (key :: PubTypes.SpecialKey).stage
			local keys = specialKeys[stage]
			if keys == nil then
				logError("unrecognisedPropertyStage", nil, stage)
			else
				keys[key] = value
			end
		else
			-- we don't recognise what this key is supposed to be
			logError("unrecognisedPropertyKey", nil, xtypeof(key))
		end
	end

	for key, value in pairs(specialKeys.self) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.descendants) do
		key:apply(value, applyTo, cleanupTasks)
	end

	if props.Parent ~= nil then
		bindProperty(applyTo, "Parent", props.Parent, cleanupTasks)
	end

	for key, value in pairs(specialKeys.ancestor) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.observer) do
		key:apply(value, applyTo, cleanupTasks)
	end

	applyTo.Destroying:Connect(function()
		cleanup(cleanupTasks)
	end)
end

return applyInstanceProps]]></ProtectedString>
														<string name="ScriptGuid">{74F53C23-3907-40B8-B707-D5B8D19B84E7}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">applyInstanceProps</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX2074C87E4D7A48CDB5A1B3A7311FB477">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

return {
	ScreenGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	BillboardGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	SurfaceGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

		SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
		PixelsPerStud = 50
	},

	Frame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ScrollingFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ScrollBarImageColor3 = Color3.new(0, 0, 0)
	},

	TextLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextBox = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ClearTextOnFocus = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	ImageLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ImageButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false
	},

	ViewportFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	VideoFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},
	
	CanvasGroup = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
}
]]></ProtectedString>
														<string name="ScriptGuid">{D9575B38-CFC7-4E07-864E-3C6C1801BC85}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">defaultProps</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBX49A4A6D9770F42CFB89DB4D5E8DBCBA1">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Logging</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX0AA098CEC7504B9A9579EA0BAA3A4D7F">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific error.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError]]></ProtectedString>
														<string name="ScriptGuid">{C3584DC5-7A35-4249-81D1-9139FA396948}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">logError</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX5667512DC7BA4D879C57434EE905D10A">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal]]></ProtectedString>
														<string name="ScriptGuid">{E4DB4066-5AFB-4ADB-A376-D23FA4B7EB8E}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">logErrorNonFatal</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX5427AC7DFE944BD4AEC9B023F6D2C1EF">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(messageID, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...))
end

return logWarn]]></ProtectedString>
														<string name="ScriptGuid">{505B999D-3C63-4A5F-8208-14271E9795BC}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">logWarn</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX33BC0BE65327448CA9974C5069128CD7">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores templates for different kinds of logging messages.
]]

return {
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	destructorNeededValue = "To save instances into Values, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededComputed = "To return instances from Computeds, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	multiReturnComputed = "Returning multiple values from Computeds is discouraged, as behaviour will change soon - see discussion #189 on GitHub.",
	destructorNeededForKeys = "To return instances from ForKeys, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForValues = "To return instances from ForValues, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForPairs = "To return instances from ForPairs, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	duplicatePropertyKey = "",
	forKeysProcessorError = "ForKeys callback error: ERROR_MESSAGE",
	forKeysKeyCollision = "ForKeys should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previously input key: '%s'; New input key: '%s'",
	forKeysDestructorError = "ForKeys destructor error: ERROR_MESSAGE",
	forPairsDestructorError = "ForPairs destructor error: ERROR_MESSAGE",
	forPairsKeyCollision = "ForPairs should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previous input pair: '[%s] = %s'; New input pair: '[%s] = %s'",
	forPairsProcessorError = "ForPairs callback error: ERROR_MESSAGE",
	forValuesProcessorError = "ForValues callback error: ERROR_MESSAGE",
	forValuesDestructorError = "ForValues destructor error: ERROR_MESSAGE",
	invalidChangeHandler = "The change handler for the '%s' property must be a function.",
	invalidEventHandler = "The handler for the '%s' event must be a function.",
	invalidPropertyType = "'%s.%s' expected a '%s' type, but got a '%s' type.",
	invalidRefType = "Instance refs must be Value objects.",
	invalidOutType = "[Out] properties must be given Value objects.",
	invalidOutProperty = "The %s class doesn't have a property called '%s'.",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	mistypedSpringDamping = "The damping ratio for a spring must be a number. (got a %s)",
	mistypedSpringSpeed = "The speed of a spring must be a number. (got a %s)",
	mistypedTweenInfo = "The tween info of a tween must be a TweenInfo. (got a %s)",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted by `[Children]`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in property tables.",
	unrecognisedPropertyStage = "'%s' isn't a valid stage for a special key to be applied at."
}]]></ProtectedString>
														<string name="ScriptGuid">{B22CE2C6-3E0E-46D9-A493-C8D12C0734C0}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">messages</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXBC6585046F32494797B005324EDB3D60">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.

	TODO: this should have a 'type' field for runtime type checking!
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		type = "Error",
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError]]></ProtectedString>
														<string name="ScriptGuid">{55D995FE-911F-429E-A9E5-07B5E5C5A283}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">parseError</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBXBAFC5DBF18ED4D0497C1B12E4CE1CB02">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">State</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX00045CD3674341758E5A6061288C67B1">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local isSimilar = require(Package.Utility.isSimilar)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update(): boolean
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue, newMetaValue = captureDependencies(self.dependencySet, self._processor)

	if ok then
		if self._destructor == nil and needsDestruction(newValue) then
			logWarn("destructorNeededComputed")
		end

		if newMetaValue ~= nil then
			logWarn("multiReturnComputed")
		end

		local oldValue = self._value
		local similar = isSimilar(oldValue, newValue)
		if self._destructor ~= nil then
			self._destructor(oldValue)
		end
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return not similar
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed<T>(processor: () -> T, destructor: ((T) -> ())?): Types.Computed<T>
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_processor = processor,
		_destructor = destructor,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed]]></ProtectedString>
														<string name="ScriptGuid">{EBF54EEE-252E-4F7F-9E2E-52D7416FA89E}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Computed</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXA72536001FDF4B6BAA01BA7CF08A8E34">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForKeys state object which maps keys of an array using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up
	calculated keys. If omitted, the default cleanup function will be used instead.

	Optionally, a `meta` value can be returned in the processor function as the
	second value to pass data from the processor to the destructor.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForKeys object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end


--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those key pairs, storing information about any
	dependencies used in the processor callback during output key generation,
	and save the new key to the output array with the same value. If it is
	overwriting an older value, that older value will be passed to the
	destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their output keys from the output table and pass them to the destructor.
]]

function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable
	local outputTable = self._outputTable

	local keyOIMap = self._keyOIMap
	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find keys that changed or were not previously present
	for newInKey, value in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end

		-- check if the key is new
		local shouldRecalculate = oldInputTable[newInKey] == nil

		-- check if the key's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output key if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForKeys")
				end

				local oldInKey = keyOIMap[newOutKey]
				local oldOutKey = keyIOMap[newInKey]

				-- check for key collision
				if oldInKey ~= newInKey and newInputTable[oldInKey] ~= nil then
					logError("forKeysKeyCollision", nil, tostring(newOutKey), tostring(oldInKey), tostring(newOutKey))
				end

				-- check for a changed output key
				if oldOutKey ~= newOutKey and keyOIMap[oldOutKey] == newInKey then
					-- clean up the old calculated value
					local oldMetaValue = meta[oldOutKey]

					local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldMetaValue)
					if not destructOK then
						logErrorNonFatal("forKeysDestructorError", err)
					end

					keyOIMap[oldOutKey] = nil
					outputTable[oldOutKey] = nil
					meta[oldOutKey] = nil
				end

				-- update the stored data for this key
				oldInputTable[newInKey] = value
				meta[newOutKey] = newMetaValue
				keyOIMap[newOutKey] = newInKey
				keyIOMap[newInKey] = newOutKey
				outputTable[newOutKey] = value

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forKeysProcessorError", newOutKey)
			end
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find keys that were removed
	for outputKey, inputKey in pairs(keyOIMap) do
		if newInputTable[inputKey] == nil then
			-- clean up the old calculated value
			local oldMetaValue = meta[outputKey]

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, outputKey, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forKeysDestructorError", err)
			end

			-- remove data
			oldInputTable[inputKey] = nil
			meta[outputKey] = nil
			keyOIMap[outputKey] = nil
			keyIOMap[inputKey] = nil
			outputTable[outputKey] = nil
			self._keyData[inputKey] = nil

			-- if we removed a key, then the table/state changed
			didChange = true
		end
	end

	return didChange
end

local function ForKeys<KI, KO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: any }>,
	processor: (KI) -> (KO, M?),
	destructor: (KO, M?) -> ()?
): Types.ForKeys<KI, KO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForKeys",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_keyOIMap = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForKeys]]></ProtectedString>
														<string name="ScriptGuid">{AFEC50D4-AE27-4B52-8CD3-E1A8B1DB8D23}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">ForKeys</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX7615E44D3EF8474588F5BFFEDD29D05D">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForPairs object which maps pairs of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new key/value pair to the output array. If it is overwriting an
	older key/value pair, that older pair will be passed to the destructor
	for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their key/value pairs from the output table and pass them to the destructor.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable

	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- clean out output table
	self._oldOutputTable, self._outputTable = self._outputTable, self._oldOutputTable

	local oldOutputTable = self._oldOutputTable
	local newOutputTable = self._outputTable
	table.clear(newOutputTable)

	-- Step 1: find key/value pairs that changed or were not previously present

	for newInKey, newInValue in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end


		-- check if the pair is new or changed
		local shouldRecalculate = oldInputTable[newInKey] ~= newInValue

		-- check if the pair's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output pair if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newOutValue, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey,
				newInValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForPairs")
				end

				-- if this key was already written to on this run-through, throw a fatal error.
				if newOutputTable[newOutKey] ~= nil then
					-- figure out which key/value pair previously wrote to this key
					local previousNewKey, previousNewValue
					for inKey, outKey in pairs(keyIOMap) do
						if outKey == newOutKey then
							previousNewValue = newInputTable[inKey]
							if previousNewValue ~= nil then
								previousNewKey = inKey
								break
							end
						end
					end

					if previousNewKey ~= nil then
						logError(
							"forPairsKeyCollision",
							nil,
							tostring(newOutKey),
							tostring(previousNewKey),
							tostring(previousNewValue),
							tostring(newInKey),
							tostring(newInValue)
						)
					end
				end

				local oldOutValue = oldOutputTable[newOutKey]

				if oldOutValue ~= newOutValue then
					local oldMetaValue = meta[newOutKey]
					if oldOutValue ~= nil then
						local destructOK, err = xpcall(self._destructor or cleanup, parseError, newOutKey, oldOutValue, oldMetaValue)
						if not destructOK then
							logErrorNonFatal("forPairsDestructorError", err)
						end
					end

					oldOutputTable[newOutKey] = nil
				end

				-- update the stored data for this key/value pair
				oldInputTable[newInKey] = newInValue
				keyIOMap[newInKey] = newOutKey
				meta[newOutKey] = newMetaValue
				newOutputTable[newOutKey] = newOutValue

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forPairsProcessorError", newOutKey)
			end
		else
			local storedOutKey = keyIOMap[newInKey]

			-- check for key collision
			if newOutputTable[storedOutKey] ~= nil then
				-- figure out which key/value pair previously wrote to this key
				local previousNewKey, previousNewValue
				for inKey, outKey in pairs(keyIOMap) do
					if storedOutKey == outKey then
						previousNewValue = newInputTable[inKey]

						if previousNewValue ~= nil then
							previousNewKey = inKey
							break
						end
					end
				end

				if previousNewKey ~= nil then
					logError(
						"forPairsKeyCollision",
						nil,
						tostring(storedOutKey),
						tostring(previousNewKey),
						tostring(previousNewValue),
						tostring(newInKey),
						tostring(newInValue)
					)
				end
			end

			-- copy the stored key/value pair into the new output table
			newOutputTable[storedOutKey] = oldOutputTable[storedOutKey]
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end

	-- STEP 2: find keys that were removed
	for oldOutKey, oldOutValue in pairs(oldOutputTable) do
		-- check if this key/value pair is in the new output table
		if newOutputTable[oldOutKey] ~= oldOutValue then
			-- clean up the old output pair
			local oldMetaValue = meta[oldOutKey]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldOutValue, oldMetaValue)
				if not destructOK then
					logErrorNonFatal("forPairsDestructorError", err)
				end
			end

			-- check if the key was completely removed from the output table
			if newOutputTable[oldOutKey] == nil then
				meta[oldOutKey] = nil
				self._keyData[oldOutKey] = nil
			end

			didChange = true
		end
	end

	for key in pairs(oldInputTable) do
		if newInputTable[key] == nil then
			oldInputTable[key] = nil
			keyIOMap[key] = nil
		end
	end

	return didChange
end

local function ForPairs<KI, VI, KO, VO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: VI }>,
	processor: (KI, VI) -> (KO, VO, M?),
	destructor: (KO, VO, M?) -> ()?
): Types.ForPairs<KI, VI, KO, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForPairs]]></ProtectedString>
														<string name="ScriptGuid">{8E7184B4-C3E0-4EE7-8FDB-ADFE0F0CDE3F}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">ForPairs</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXC2117E87FF614F51B1E8EA21331C2057">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForValues object which maps values of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]
local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForValues object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any values meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those values, storing information about any dependencies
	used in the processor callback during value generation, and save the new value
	to the output array with the same key. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find values that are no longer present, and remove
	their values from the output table and pass them to the destructor. You can re-use
	the same value multiple times and this will function will update them as little as
	possible; reusing the same values where possible.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local inputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local outputValues = {}

	local didChange = false

	-- clean out value cache
	self._oldValueCache, self._valueCache = self._valueCache, self._oldValueCache
	local newValueCache = self._valueCache
	local oldValueCache = self._oldValueCache
	table.clear(newValueCache)

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find values that changed or were not previously present
	for inKey, inValue in pairs(inputTable) do
		-- check if the value is new or changed
		local oldCachedValues = oldValueCache[inValue]
		local shouldRecalculate = oldCachedValues == nil

		-- get a cached value and its dependency/meta data if available
		local value, valueData, meta

		if type(oldCachedValues) == "table" and #oldCachedValues > 0 then
			local valueInfo = table.remove(oldCachedValues, #oldCachedValues)
			value = valueInfo.value
			valueData = valueInfo.valueData
			meta = valueInfo.meta

			if #oldCachedValues <= 0 then
				oldValueCache[inValue] = nil
			end
		elseif oldCachedValues ~= nil then
			oldValueCache[inValue] = nil
			shouldRecalculate = true
		end

		if valueData == nil then
			valueData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
		end

		-- check if the value's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(valueData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- recalculate the output value if necessary
		if shouldRecalculate then
			valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet
			table.clear(valueData.dependencySet)

			local processOK, newOutValue, newMetaValue = captureDependencies(
				valueData.dependencySet,
				self._processor,
				inValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForValues")
				end

				-- pass the old value to the destructor if it exists
				if value ~= nil then
					local destructOK, err = xpcall(self._destructor or cleanup, parseError, value, meta)
					if not destructOK then
						logErrorNonFatal("forValuesDestructorError", err)
					end
				end

				-- store the new value and meta data
				value = newOutValue
				meta = newMetaValue
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet

				logErrorNonFatal("forValuesProcessorError", newOutValue)
			end
		end


		-- store the value and its dependency/meta data
		local newCachedValues = newValueCache[inValue]
		if newCachedValues == nil then
			newCachedValues = {}
			newValueCache[inValue] = newCachedValues
		end

		table.insert(newCachedValues, {
			value = value,
			valueData = valueData,
			meta = meta,
		})

		outputValues[inKey] = value


		-- save dependency values and add to main dependency set
		for dependency in pairs(valueData.dependencySet) do
			valueData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find values that were removed
	-- for tables of data, we just need to check if it's still in the cache
	for _oldInValue, oldCachedValueInfo in pairs(oldValueCache) do
		for _, valueInfo in ipairs(oldCachedValueInfo) do
			local oldValue = valueInfo.value
			local oldMetaValue = valueInfo.meta

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldValue, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forValuesDestructorError", err)
			end

			didChange = true
		end

		table.clear(oldCachedValueInfo)
	end

	self._outputTable = outputValues

	return didChange
end

local function ForValues<VI, VO, M>(
	inputTable: PubTypes.CanBeState<{ [any]: VI }>,
	processor: (VI) -> (VO, M?),
	destructor: (VO, M?) -> ()?
): Types.ForValues<VI, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForValues",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_outputTable = {},
		_valueCache = {},
		_oldValueCache = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForValues]]></ProtectedString>
														<string name="ScriptGuid">{7FB6602D-AB37-46E2-BEF0-307C7BC05F7C}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">ForValues</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX478988AFA91242EA90223DB58BFF00A3">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new state object which can listen for updates on another state
	object.

	FIXME: enabling strict types here causes free types to leak
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local initDependency = require(Package.Dependencies.initDependency)

type Set<T> = {[T]: any}

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Observer objects in memory.
local strongRefs: Set<Types.Observer> = {}

--[[
	Called when the watched state changes value.
]]
function class:update(): boolean
	for _, callback in pairs(self._changeListeners) do
		task.spawn(callback)
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Observer
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ()): () -> ()
	local uniqueIdentifier = {}

	self._numChangeListeners += 1
	self._changeListeners[uniqueIdentifier] = callback

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[uniqueIdentifier] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Observer(watchedState: PubTypes.Value<any>): Types.Observer
	local self = setmetatable({
		type = "State",
		kind = "Observer",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0,
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Observer]]></ProtectedString>
														<string name="ScriptGuid">{7F86C30F-1E8D-4CAF-8562-269B432E5154}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Observer</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX4D1B23BD90D64E8AB4E35C06C9B6472A">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local isSimilar = require(Package.Utility.isSimilar)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	local oldValue = self._value
	if force or not isSimilar(oldValue, newValue) then
		self._value = newValue
		updateAll(self)
	end
end

local function Value<T>(initialValue: T): Types.State<T>
	local self = setmetatable({
		type = "State",
		kind = "Value",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return Value]]></ProtectedString>
														<string name="ScriptGuid">{5F9CAFE2-B98A-4983-97E5-6C4DD17400F1}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Value</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXA8EA3A163BB3406AAAC9B9EF3211A8C6">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A common interface for accessing the values of state objects or constants.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local xtypeof = require(Package.Utility.xtypeof)

local function unwrap<T>(item: PubTypes.CanBeState<T>, useDependency: boolean?): T
	return if xtypeof(item) == "State" then (item :: PubTypes.StateObject<T>):get(useDependency) else (item :: T)
end

return unwrap]]></ProtectedString>
														<string name="ScriptGuid">{55D39244-51BE-4FCE-AB65-D072BE0D47F7}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">unwrap</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="Folder" referent="RBXCCF15373D4EE4D73AC51EC7AD0AC7DA0">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Utility</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX0D2E903B6C224C7ABD743F328972502B">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

return {
	type = "Symbol",
	name = "None"
} :: Types.None]]></ProtectedString>
														<string name="ScriptGuid">{31E1B828-3FAE-4FE3-94C9-E496AE04666F}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">None</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX92F109C1E06048DEAE098F2336DD9C56">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Cleans up the tasks passed in as the arguments.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

local function cleanupOne(task: any)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanupOne(subtask)
			end
		end
	end
end

local function cleanup(...: any)
	for index = 1, select("#", ...) do
		cleanupOne(select(index, ...))
	end
end

return cleanup]]></ProtectedString>
														<string name="ScriptGuid">{BA50F78A-3F71-4E93-BBBD-1F60DF60B098}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">cleanup</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXA48B9C47FE414F539BF0552CE3ACA93D">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	An empty function. Often used as a destructor to indicate no destruction.
]]

local function doNothing(...: any)
end

return doNothing]]></ProtectedString>
														<string name="ScriptGuid">{1062ADD4-7EAF-4CBD-A7FD-31A180479932}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">doNothing</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXE6CFE6009241444BADC375DF33C41F91">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict
--[[
    Returns true if A and B are 'similar' - i.e. any user of A would not need
    to recompute if it changed to B.
]]

local function isSimilar(a: any, b: any): boolean
    -- HACK: because tables are mutable data structures, don't make assumptions
    -- about similarity from equality for now (see issue #44)
    if typeof(a) == "table" then
        return false
    else
        return a == b
    end
end

return isSimilar]]></ProtectedString>
														<string name="ScriptGuid">{2929A341-90D4-4D94-8982-FB0884C05AE5}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">isSimilar</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXEA5DBCD0497F459E8B8947B76CE90772">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
    Returns true if the given value is not automatically memory managed, and
    requires manual cleanup.
]]

local function needsDestruction(x: any): boolean
    return typeof(x) == "Instance"
end

return needsDestruction]]></ProtectedString>
														<string name="ScriptGuid">{19DDB5A2-71EF-4E87-8936-6853B625A848}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">needsDestruction</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBXB70BF4A5DAB24C10902204EE2C792941">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

type table = {[any]: any}

local function restrictRead(tableName: string, strictTable: table): table
	-- FIXME: Typed Luau doesn't recognise this correctly yet
	local metatable = getmetatable(strictTable :: any)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead]]></ProtectedString>
														<string name="ScriptGuid">{CBFE330F-959A-426E-98B6-60435C5F8846}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">restrictRead</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="ModuleScript" referent="RBX87BD3CA46A5D4045A7C197272647B4B7">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Extended typeof, designed for identifying custom objects.
	If given a table with a `type` string, returns that.
	Otherwise, returns `typeof()` the argument.
]]

local function xtypeof(x: any)
	local typeString = typeof(x)

	if typeString == "table" and typeof(x.type) == "string" then
		return x.type
	else
		return typeString
	end
end

return xtypeof]]></ProtectedString>
														<string name="ScriptGuid">{D0832200-805A-47BD-AEB6-900E12E03A6A}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">xtypeof</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXEC8C64153DB242BB92611D20CFBB3878">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "NeoHotbar",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 15617827028,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: ImAvafe (Avafe)"},
		{Text = "Description: NeoHotBar is an advanced roblox inventory library, this library is very usefull when it comes to making a custom inventory system, providing a complex and advanced range of features."},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Advanced scripting knowledge"}
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{3B206766-A0DF-4A98-ACE4-B000FA5708FC}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX5C71F3804E3A499BB848D1EFBF07B20B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">MuchachoHitbox</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXF87721546D914A90AC3F9716DE46FB67">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict

--[[


   _____            __    _ __  ___           __           
  / ___/__  _______/ /_  (_)  |/  /___ ______/ /____  _____
  \__ \/ / / / ___/ __ \/ / /|_/ / __ `/ ___/ __/ _ \/ ___/
 ___/ / /_/ (__  ) / / / / /  / / /_/ (__  ) /_/  __/ /    
/____/\__,_/____/_/ /_/_/_/  /_/\__,_/____/\__/\___/_/     
                                                           




____________________________________________________________________________________________________________________________________________________________________________
				
	[ UPDATE LOG v1.1 :]
1. New property!!
	Hitbox.Key = "insert anything you want here"
		--- This property will be used for the new function | module:FindHitbox(key)
		
2. New function!!
	Module:FindHitbox(Key)
		--- Returns a hitbox using specified Key, nil otherwise
		
3. New detection mode! | "ConstantDetection"
	Hitbox.DetectionMode = "ConstantDetection"
		--- The same as the default detection mode but no hit pool / debounce
		--- You're free to customize the debounce anyway you want
		
4, Made the scripts cleaner
____________________________________________________________________________________________________________________________________________________________________________
	
	[ UPDATE LOG v1.2 :]
1. Made the code better

____________________________________________________________________________________________________________________________________________________________________________
	
	[ UPDATE LOG v1.3 :]
1. New property
	HitboxObject.AutoDestroy = true (Default)
		---  With the value being false you can keep using Stop() 
		and Start() without the hitbox being destroyed.

2. New metamethod
	HitboxObject:Destroy()
		---  This destroys the hitbox. You only need to use this
			 When having AutoDestroy's value set to false.
			 
3. Minor bug fixes
			 
____________________________________________________________________________________________________________________________________________________________________________

	[ UPDATE LOG v1.4  Experimental:]
1. New event
	HitboxObject.TouchEnded:Connect(instance)
				Description
					--- The event fires once a part stops touching the hitbox
				Arguments
					--- Instance part: Returns the part that the hitbox stopped touching
					
____________________________________________________________________________________________________________________________________________________________________________

		 UPDATE LOG v1.5  Stable:]
1. Reverted touch ended, will add back after the bug is fixed

____________________________________________________________________________________________________________________________________________________________________________

		 UPDATE LOG v1.6  Stable:]
1. Touch ended is back! It has been fixed
2. HitboxObject.Key is now generated automatically
3. Minor changes

____________________________________________________________________________________________________________________________________________________________________________

		 UPDATE LOG v2.0 Experimental:]
1. Added VelocityPrediction and VelocityPredictionTime property
2. You can now set the color and transparency of a hitbox
2. Minor fixes
3. Code now uses type checking
____________________________________________________________________________________________________________________________________________________________________________

	Example code:
		local module = require(game.ServerStorage.MuchachoHitbox)

		local hitbox = module.CreateHitbox()
		hitbox.Size = Vector3.new(10,10,10)
		hitbox.CFrame = workspace.Part
		
		-- IF YOU WANT TO ADD VELOCITY PREDICTION
		hitbox.VelocityPrediction = true
		hitbox.VelocityPredictionTime = .2

		hitbox.Touched:Connect(function(hit, hum)
			print(hit)
			hum:TakeDamage(10)
		end)
		
		hitbox:Start()
	
	
	Alright thats all for the example code, its a pretty simple module, you could make a module similar to this yourself.
	And maybe even make it better.
	
	If you encounter any bugs, please tell me in the comment section, or you could DM me on discord
	sushimaster#7840
	
	 SushiMaster
____________________________________________________________________________________________________________________________________________________________________________
	
	
	[MuchachoHitbox Documentation]

		* local Module = require(MuchachoHitbox)
				--- Require the module


			[ FUNCTIONS ]

		* Module.CreateHitbox()
				Description
					--- Creates a hitbox
					
		* Module:FindHitbox(Key)
				Description
					--- Returns a hitbox with specified Key

		* HitboxObject:Start()
				Description
					--- Starts the hitbox. 
					
		* HitboxObject:Stop()
				Description
					--- Stops the hitbox and resets the debounce.
					
		* HitboxObject:Destroy()
				Description
					--- Destroys the hitbox. Use this when you have
						HitboxObject.AutoDestroy set to false
					
			[ EVENTS ]

		* HitboxObject.Touched:Connect(hit, humanoid)
				Description
					--- If the hitbox touches a humanoid, it'll return information on them
					--- The hitbox can detect parts depending on the detection mode
				Arguments
					--- Instance part: Returns the part that the hitbox hit first
					--- Instance humanoid: Returns the Humanoid object 
					
		* HitboxObject.TouchEnded:Connect(instance)
				Description
					--- The event fires once a part stops touching the hitbox
				Arguments
					--- Instance part: Returns the part that the hitbox stopped touching
					
			[ PROPERTIES ]

		* HitboxObject.OverlapParams: OverlapParams
				Description
					--- Takes in a OverlapParams object

		* HitboxObject.Visualizer: boolean
				Description
					--- Turns on or off the visualizer part

		* HitboxObject.CFrame: CFrame / Instance
				Description
					--- Sets the hitbox CFrame to the CFrame
					--- If its an instance, then the hitbox would follow the instance
					
		* HitboxObject.Shape: Enum.PartType.Block / Enum.PartType.Ball
				Description
					--- Defaults to block
					--- Sets the hitbox shape to the property
					
		* HitboxObject.Size: Vector3 / number 
				Description
					--- Sets the size of the hitbox
					--- It uses Vector3 if the shape is block
					--- It uses number if the shape is ball
					
		* HitboxObject.Offset: CFrame
				Description
					--- Hitbox offset

		* HitboxObject.DetectionMode: string | "Default" , "HitOnce" , "HitParts" , "ConstantDetection"
				Description
					--- Default value set to "Default"
					--- Changes on how the detection works
					
		* HitboxObject.Key: String
				Description
					--- The key property for the find hitbox function
					--- MuchachoHitbox automatically generates a randomized key for you but you can change it. The module will save the hitbox, and can be found using | Module:FindHitbox(Key)
					
		* HitboxObject.AutoDestroy: boolean
				Description
					--- Default value is set to true
					--- When set to true, :Stop() atomatically destroys the hitbox.
					--- Does not destroy the hitbox when set to false. You'll 
						have to use :Destroy() to delete the hitbox.
						
		* HitboxObject.VelocityPrediction: boolean
				Description
					--- Default value is set to false
					--- When set to true, hitbox automatically predicts the velocity of the CFrame property if it is an instance. By "VelocityPredictionTime" amount of time
					
		* HitboxObject.VelocityPredictionTime: number
				Description
					--- Default value is set to 0.1
					--- When "VelocityPrediction" is set to true, this property determines how far in the future the hitbox will check for parts.

		* HitboxObject.VisualizerColor: Color3
				Description
					--- Sets the color of the visualizer part
					
		* HitboxObject.VisualizerTransparency: number
				Description
					--- Sets the transparency of the visualizer part

			[ DETECTION MODES ]

		* Default
				Description
					--- Checks if a humanoid exists when this hitbox touches a part. The hitbox will not return humanoids it has already hit for the duration
					--- the hitbox has been active.

		* HitParts
				Description
					--- OnHit will return every hit part, regardless if it's ascendant has a humanoid or not.
					--- OnHit will no longer return a humanoid so you will have to check it. The hitbox will not return parts it has already hit for the
					--- duration the hitbox has been active.

		* HitOnce
				Description
					--- Hitbox will stop as soon as it detects a humanoid
					
		* ConstantDetection
				Description
					--- The default detection mode but no hitlist / debounce
					
____________________________________________________________________________________________________________________________________________________________________________

]]
local rs = game:GetService("RunService")
local hs = game:GetService("HttpService")

local GoodSignal = require(script.GoodSignal)
local DictDiff = require(script.DictDiff)
local Types = require(script.Types)

local muchacho_hitbox = {}
muchacho_hitbox.__index = muchacho_hitbox

local adornment_form = {
	["Proportion"] = {
		[Enum.PartType.Ball] = "Radius",
		[Enum.PartType.Block] = "Size",
	},

	["Shape"] = {
		[Enum.PartType.Ball] = "SphereHandleAdornment",
		[Enum.PartType.Block] = "BoxHandleAdornment",
	},
}

local get_CFrame = {
	["Instance"] = function(point)
		return point.CFrame
	end,

	["CFrame"] = function(point)
		return point
	end,
}


local hitboxes = {}

-- public functions
function muchacho_hitbox.CreateHitbox()
	local self = setmetatable({}, muchacho_hitbox) :: Types.Hitbox
	self.DetectionMode = "Default"
	self.AutoDestroy = true
	
	self.Visualizer = true
	self.VisualizerColor = Color3.fromRGB(255,0,0)
	self.VisualizerTransparency = .8

	self.VelocityPrediction = false
	self.VelocityPredictionTime = 0.1
	
	self.OverlapParams = OverlapParams.new()
	
	self.Size = Vector3.new(0,0,0)
	self.Shape = Enum.PartType.Block
	self.CFrame = CFrame.new(0,0,0)
	self.Offset = CFrame.new(0,0,0)
	
	self.Key = hs:GenerateGUID(false)

	self.HitList = {}
	self.TouchingParts = {}
	
	self.Touched = GoodSignal.new()
	self.TouchEnded = GoodSignal.new()

	return self
end

function muchacho_hitbox:FindHitbox(key) -- deprecated
	if hitboxes[key] then
		return hitboxes[key]
	else
		return nil
	end
end

-- public methods
function muchacho_hitbox.Start(self: Types.Hitbox)
	if hitboxes[self.Key] then
		error("A hitbox with this Key has already been started. Change the key if you want to start this hitbox.")
	end

	hitboxes[self.Key] = self

	-- looping the hitbox
	task.spawn(function()	
		self._Connection = rs.Heartbeat:Connect(function()
			self:_visualize()
			self:_cast()
		end)
	end)
end

function muchacho_hitbox.Stop(self: Types.Hitbox)
	local hitbox = muchacho_hitbox:FindHitbox(self.Key)

	if not hitbox then
		error("Hitbox has already been stopped")
	end

	-- clear hitbox
	self:_clear()

	if not self.AutoDestroy then return end

	-- terminate hitbox
	self.Touched:DisconnectAll()
	self.TouchEnded:DisconnectAll()
	--setmetatable(self, nil)
end

function muchacho_hitbox:Destroy()
	local hitbox: Types.Hitbox = muchacho_hitbox:FindHitbox(self.Key)

	if not hitbox then
		error("Hitbox has already been destroyed")
	end

	-- clear hitbox
	self:_clear()

	-- terminate hitbox
	self.Touched:DisconnectAll()
	self.TouchEnded:DisconnectAll()
	--setmetatable(self, nil)
end


-- private methods
function muchacho_hitbox._CastSpatialQuery(self: Types.Hitbox) : {BasePart}?
	local point_type: CFrame | string = typeof(self.CFrame)
	local point_cframe: CFrame = self:_PredictVelocity() or get_CFrame[point_type](self.CFrame)

	local parts
	local hitboxCFrame: CFrame = point_cframe * self.Offset
	
	if self.Shape == Enum.PartType.Block then
		parts = workspace:GetPartBoundsInBox(hitboxCFrame, self.Size, self.OverlapParams)
	elseif self.Shape == Enum.PartType.Ball then
		parts = workspace:GetPartBoundsInRadius(hitboxCFrame.Position, self.Size, self.OverlapParams)
	else
		error("Part type: " .. self.Shape .. " isn't compatible with muchachoHitbox")
	end

	return parts
end

function muchacho_hitbox._cast(self: Types.Hitbox, part: BasePart)
	local mode = self.DetectionMode
	local parts = self:_CastSpatialQuery()

	self:_FindTouchEnded(parts)

	for _, hit in pairs(parts) do
		local character: Model = hit:FindFirstAncestorOfClass("Model") or hit.Parent
		local humanoid: Humanoid? = character:FindFirstChildOfClass("Humanoid")

		-- detection mode
		if mode == "Default" then
			if humanoid and not table.find(self.HitList, humanoid) then
				table.insert(self.HitList, humanoid)
				
				self:_InsertTouchingParts(hit)

				self.Touched:Fire(hit, humanoid)
			end

		elseif mode == "ConstantDetection" then

			if humanoid then
				self:_InsertTouchingParts(hit)

				self.Touched:Fire(hit, humanoid)
			end

		elseif mode == "HitOnce" then

			if humanoid then
				self:_InsertTouchingParts(hit)

				self.Touched:Fire(hit, humanoid)
				self.TouchEnded:Fire(hit)

				self:Destroy()
				break
			end

		elseif mode == "HitParts" then
			self:_InsertTouchingParts(hit)

			self.Touched:Fire(hit, nil)

		end
	end
end

function muchacho_hitbox._visualize(self: Types.Hitbox)
	if not self.Visualizer then return end

	local predictedCFrame = self:_PredictVelocity()
	
	local point_type: string = typeof(self.CFrame)
	local point_cframe: CFrame = predictedCFrame or get_CFrame[point_type](self.CFrame)

	local proportion = adornment_form.Proportion[self.Shape]

	if not self._Box then
		local newBox = Instance.new(adornment_form.Shape[self.Shape])
		newBox.Name = "Visualizer"
		newBox.Adornee = workspace.Terrain
		newBox[proportion] = self.Size
		newBox.CFrame = point_cframe * self.Offset
		newBox.Color3 = self.VisualizerColor
		newBox.Transparency = self.VisualizerTransparency
		newBox.Parent = workspace.Terrain
		self._Box = newBox
	else
		self._Box.CFrame = point_cframe * self.Offset
	end
end

function muchacho_hitbox._PredictVelocity(self: Types.Hitbox): CFrame | nil
	if self.VelocityPrediction then
		local PredictionTime: number = self.VelocityPredictionTime
		local part: BasePart = self.CFrame
		local constant: number = 1/PredictionTime

		if PredictionTime > 0 and typeof(part) == "Instance" then
			--local velocityVector =  part.CFrame:VectorToObjectSpace(part.AssemblyLinearVelocity) / constant
			--local predictedCFrame = part.CFrame * CFrame.new(velocityVector)
			local Velocity = part.AssemblyLinearVelocity --// Normally this would be their ping
			local PredictedPosition = part.Position + Velocity * PredictionTime
			local PredictedCFrame = CFrame.new(PredictedPosition) * (part.CFrame - part.Position)

			
			return PredictedCFrame
		end
	end
	
	return nil
end

function muchacho_hitbox:_clear()
	self.HitList = {}

	if self._Connection then
		self._Connection:Disconnect()
	end

	if self.Key then
		hitboxes[self.Key] = nil
	end

	if self._Box then
		self._Box:Destroy()
		self.Box = nil
	end
end

function muchacho_hitbox._InsertTouchingParts(self: Types.Hitbox, part)
	if table.find(self.TouchingParts, part) then return end

	table.insert(self.TouchingParts, part)
end

function muchacho_hitbox._FindTouchEnded(self: Types.Hitbox, parts: {BasePart}?)
	if #self.TouchingParts == 0 then return end

	local mode = self.DetectionMode
	local differences = DictDiff.difference(self.TouchingParts, parts)

	if differences then
		for _, diff in ipairs(differences) do
			self.TouchEnded:Fire(diff)
			table.remove(self.TouchingParts, table.find(self.TouchingParts, diff))
		end
	end
end



return muchacho_hitbox
]]></ProtectedString>
							<string name="ScriptGuid">{80D99C78-EC60-4076-B3ED-5837177C6609}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MuchachoHitbox</string>
							<int64 name="SourceAssetId">9645263113</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX68987A9C2C524863A8B3CBA74717823B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local module = {}

local function find(a, tbl)
	for _, a_ in ipairs(tbl) do 
		if a_==a then return true end 
	end
end

function module.difference(a, b)
	local ret = {}
	for _, v in ipairs(a) do
		if not find(v,b) then table.insert(ret, v) end
	end
	
	return ret
end


return module

]]></ProtectedString>
								<string name="ScriptGuid">{F65C6871-C63B-42B7-BF98-3AF7F7701382}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">DictDiff</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX006A8DF251DD46DBA208E243E8F1D031">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	A Signal is a data structure that allows events to be dispatched
	and observed.

	This implementation is a direct copy of the de facto standard, [GoodSignal](https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063),
	with some added methods and typings.

	For example:
	```lua
	local signal = Signal.new()

	-- Subscribe to a signal:
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	-- Dispatch an event:
	signal:Fire("Hello world!")
	```
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
		_yieldedThreads = nil,
	}, Signal)

	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)

	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)

	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	```
]=]
function Signal:Connect(fn)
	local connection = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_next = false,
	}, Connection)

	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	return connection
end

--[=[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]=]
function Signal:Once(fn)
	local connection
	local done = false

	connection = self:Connect(function(...)
		if done then
			return
		end

		done = true
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

function Signal:GetConnections()
	local items = {}

	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end

	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	local yieldedThreads = rawget(self, "_yieldedThreads")
	if yieldedThreads then
		for thread in yieldedThreads do
			if coroutine.status(thread) == "suspended" then
				warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
				task.cancel(thread)
			end
		end
		table.clear(self._yieldedThreads)
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		local conn = item
		task.defer(function(...)
			if conn.Connected then
				conn._fn(...)
			end
		end, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]=]
function Signal:Wait()
	local yieldedThreads = rawget(self, "_yieldedThreads")
	if not yieldedThreads then
		yieldedThreads = {}
		rawset(self, "_yieldedThreads", yieldedThreads)
	end

	local thread = coroutine.running()
	yieldedThreads[thread] = true

	self:Once(function(...)
		yieldedThreads[thread] = nil
		task.spawn(thread, ...)
	end)

	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]=]
function Signal:Destroy()
	self:DisconnectAll()

	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return table.freeze({
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
})
]]></ProtectedString>
								<string name="ScriptGuid">{13FF9849-B2C3-453A-83C5-837F694D882D}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GoodSignal</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX976B7F46ED4C4A3481C834EE329D1DA4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local Goodsignal = require(script.Parent.GoodSignal)

local types = {}

export type HitboxProperties = {
	Visualizer: boolean,
	DetectionMode: ("Default" | "ConstantDetection" | "HitOnce" | "HitParts"),
	AutoDestroy: boolean,	
	Key: string,

	OverlapParams: OverlapParams,

	Size: Vector3,
	Shape: Enum.PartType,
	CFrame: CFrame,
	Offset: CFrame,

	VelocityPredictionTime: number?,
	VelocityPrediction: boolean?,
	
	Touched: Goodsignal.Signal<BasePart, Humanoid?>,
	TouchEnded: Goodsignal.Signal<BasePart, Humanoid?>,
} & any

export type Hitbox = {
	-- properties
	Visualizer: boolean,
	VisualizerColor: Color3?,
	VisualizerTransparency: number,
	
	DetectionMode: ("Default" | "ConstantDetection" | "HitOnce" | "HitParts"),
	AutoDestroy: boolean,	
	Key: string,

	OverlapParams: OverlapParams,

	Size: Vector3,
	Shape: Enum.PartType,
	CFrame: CFrame,
	Offset: CFrame,
	
	VelocityPredictionTime: number?,
	VelocityPrediction: boolean?,
	
	-- events
	Touched: Goodsignal.Signal<BasePart, Humanoid?>,
	TouchEnded: Goodsignal.Signal<BasePart, Humanoid?>,
	
	-- methods
	Start: (self: Hitbox) -> (),
	Stop: (self: Hitbox) -> (),
	Destroy: (self: Hitbox) -> (boolean),

	-- dev
	HitList: {Model}?,
	TouchingParts: {BasePart}?,
	Connection: RBXScriptConnection?,
	Box: BoxHandleAdornment? | SphereHandleAdornment?,
} & any

return types]]></ProtectedString>
								<string name="ScriptGuid">{DFDAE8F6-ED8D-4411-AB31-571DE3902542}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Types</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX101104B4CE1B4ABAA7A6ECE80E79E046">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "MuchachoHitbox",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Sushimaster"},
		{Text = "Description: A powerful hitbox library, usefull for any game, easy to use and understand."},
		{Text = "Version: 2.0 (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Basic scripting knowledge"}
	}
}
]]></ProtectedString>
							<string name="ScriptGuid">{C153A9F2-E273-472C-9017-FF9BBD68EF19}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX0818052EBD3245F181F483B1C946CA57">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CustomPack</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX46630586EB1340B1AD210B7BC0A93966">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "CustomPack",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 91433402964621,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: Berge99075"},
		{Text = "Description: A Powerful backpack library."},
		{Text = "Version: Unknown (latest)"},

		{Separator = "Requirements"},
		{Text = " Roblox Studio"},
		{Text = " Above-basic scripting knowledge"}
	}
}
]]></ProtectedString>
							<string name="ScriptGuid">{6B68AD52-8EDE-4531-B4A2-324C3ECAA631}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Model" referent="RBX22474DC04E2944258FC25E41B912B6EA">
						<Properties>
							<token name="LevelOfDetail">0</token>
							<CoordinateFrame name="ModelMeshCFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<Vector3 name="ModelMeshSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="ModelStreamingMode">0</token>
							<bool name="NeedsPivotMigration">false</bool>
							<Ref name="PrimaryPart">null</Ref>
							<float name="ScaleFactor">1</float>
							<SharedString name="SlimHash">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<OptionalCoordinateFrame name="WorldPivotData">
								<CFrame>
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CFrame>
							</OptionalCoordinateFrame>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CustomPack</string>
							<int64 name="SourceAssetId">91433402964621</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="LocalScript" referent="RBX4AA34C55AC5942E08FEB1D68E9D8633D">
							<Properties>
								<ProtectedString name="Source"><![CDATA[--[[
                                                                                                                                     
                                                                                                                                  
                                                                                                                                  
                                                                                                                                  
              ################                                                                                                    
             ###             ##                                                                                                   
             ###             ##                                                                                                   
             ##################                                                                                                   
     ##################################                                                                                           
    ###                             ####     ########## #####   #####  ######### #############  ##########   ######   ######   
    ####################################    ########### #####   ##### ##########  ###########  ############  ####### #######   
    ####################################   #####        #####   ##### ########       #####     ####    ####  ###############    
    ###                             ####   #####        #####   #####  ##########    #####     ####    ####  ###############    
    ####################################    #####       #####   #####       #####    #####     ####    ####  #### ##### ####    
    ####################################    ###########  ###########  ###########    #####     ############  ####  ###  ####   
    ####################################      #########   #########    #########     #####      #########    ####       ####      
    ####################################                                                                                          
    ####################################                                                                                          
    ####################################    #################################################################################     
    ####################################    #################################################################################     
    ####################################                                                                                          
    ####################################                     #######       ####         #####    ###     ####                     
    ####################################                    ###########   ######     ########### ####  ######                     
    ####################################                    ##### ###### #######    ######   ### ##########                       
    ####################################                    ##### ###############  #####         ########                         
    ###                             ####                    ########### #### ##### #####         ########                         
    ####################################                    #####      ###########  #####        #########                        
    ####################################                    #####     #############  ########### ####  #####                      
    ####                           #####                    #####     ####      ####   ########  ####    #####                    
    ####################################                                                                                          
    ####################################                                                                                          
     ##################################                                                                                           
                                                                                                                                  
                                                                                                                                                                                                              
	Settings is in the "Main" ModuleScript under the "Attributes" section.


--]]


-- Initialize the script
require(script.Main)]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{0C4A8E1E-69DE-4CC8-9F19-BE76FA4B1A1C}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Loader</string>
								<int64 name="SourceAssetId">91433402964621</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXE99D9E9A9BC241978E0ABA07147C9A23">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[
                                                                                                                                     
                                                                                                                                  
                                                                                                                                  
                                                                                                                                  
              ################                                                                                                    
             ###             ##                                                                                                   
             ###             ##                                                                                                   
             ##################                                                                                                   
     ##################################                                                                                           
    ###                             ####     ########## #####   #####  ######### #############  ##########   ######   ######   
    ####################################    ########### #####   ##### ##########  ###########  ############  ####### #######   
    ####################################   #####        #####   ##### ########       #####     ####    ####  ###############    
    ###                             ####   #####        #####   #####  ##########    #####     ####    ####  ###############    
    ####################################    #####       #####   #####       #####    #####     ####    ####  #### ##### ####    
    ####################################    ###########  ###########  ###########    #####     ############  ####  ###  ####   
    ####################################      #########   #########    #########     #####      #########    ####       ####      
    ####################################                                                                                          
    ####################################                                                                                          
    ####################################    #################################################################################     
    ####################################    #################################################################################     
    ####################################                                                                                          
    ####################################                     #######       ####         #####    ###     ####                     
    ####################################                    ###########   ######     ########### ####  ######                     
    ####################################                    ##### ###### #######    ######   ### ##########                       
    ####################################                    ##### ###############  #####         ########                         
    ###                             ####                    ########### #### ##### #####         ########                         
    ####################################                    #####      ###########  #####        #########                        
    ####################################                    #####     #############  ########### ####  #####                      
    ####                           #####                    #####     ####      ####   ########  ####    #####                    
    ####################################                                                                                          
    ####################################                                                                                          
     ##################################                                                                                           
                                                                                                                                  
                                                                                                                                                                                                              
	CustomPack Main Module
	Experienced Scripters only beyond this point.


--]]


print("This game uses CustomPack v1.5.2\nCustomPack is made by Berge99075\nGrab a copy at https://devforum.roblox.com/t/custompack-customizable-backpacks-made-simple/3255258/")

local BackpackScript = {}
BackpackScript.Version = "1.5.2"
BackpackScript.OpenClose = nil -- Function to toggle open/close
BackpackScript.IsOpen = false
BackpackScript.StateChanged = Instance.new("BindableEvent") -- Fires after any open/close, passes IsNowOpen
BackpackScript.SelectedSlotChanged = Instance.new("BindableEvent") -- Fires after any slot is selected

BackpackScript.ModuleName = "Backpack"
BackpackScript.KeepVRTopbarOpen = true
BackpackScript.VRIsExclusive = true
BackpackScript.VRClosesNonExclusive = true

local ICON_SIZE = 60
local FONT_SIZE = script:GetAttribute("TextSize")
local ICON_BUFFER = 5

local BACKGROUND_FADE = script:GetAttribute("BackgroundTransparency")
local BACKGROUND_COLOR = script:GetAttribute("BackgroundColor")

local VR_FADE_TIME = 1
local VR_PANEL_RESOLUTION = 100

local SLOT_DRAGGABLE_COLOR = script:GetAttribute("DraggableColor")
local SLOT_EQUIP_COLOR = script:GetAttribute("EquippedColor")
local SLOT_EQUIP_THICKNESS = 3 -- Relative
local SLOT_FADE_LOCKED = script:GetAttribute("SlotLockedTransparency") -- Locked means undraggable
local SLOT_BORDER_COLOR = script:GetAttribute("BorderColor") -- Appears when dragging

local TOOLTIP_BUFFER = 24
local TOOLTIP_HEIGHT = 24
local TOOLTIP_OFFSET = -28 -- From top

local SLOT_EQUIP_SOUND = Instance.new("Sound")
local SLOT_UNEQUIP_SOUND = Instance.new("Sound")

local ARROW_IMAGE_OPEN = 'rbxasset://textures/ui/TopBar/inventoryOn.png'
local ARROW_IMAGE_CLOSE = 'rbxasset://textures/ui/TopBar/inventoryOff.png'
local ARROW_HOTKEY = {Enum.KeyCode.Backquote, Enum.KeyCode.DPadUp} --TODO: Hookup '~' too?

local HOTBAR_SLOTS_FULL = script:GetAttribute("FullSlots")
local HOTBAR_SLOTS_VR = script:GetAttribute("EmptySlots")
local HOTBAR_SLOTS_MINI = 3
local HOTBAR_SLOTS_WIDTH_CUTOFF = 1024 -- Anything smaller is MINI
local HOTBAR_OFFSET_FROMBOTTOM = -30 -- Offset to make room for the Health GUI

local INVENTORY_ROWS_FULL = 4
local INVENTORY_ROWS_VR = 3
local INVENTORY_ROWS_MINI = 2
local INVENTORY_HEADER_SIZE = 40
local INVENTORY_ARROWS_BUFFER_VR = 40

local SEARCH_BUFFER = 5
local SEARCH_WIDTH = 200
local SEARCH_TEXT = "Search"

local SEARCH_TEXT_OFFSET_FROMLEFT = 0
local SEARCH_BACKGROUND_COLOR = script:GetAttribute("SearchBoxColor")
local SEARCH_TEXT_COLOR = script:GetAttribute("SearchTextColor")
local SEARCH_BACKGROUND_FADE = script:GetAttribute("SearchBoxTransparency")

local DOUBLE_CLICK_TIME = 0.5


local activeSlot = nil

local GetScreenResolution = function ()
	local I = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
	local Frame = Instance.new("Frame", I)
	Frame.BackgroundTransparency = 1
	Frame.Size = UDim2.new(1,0,1,0)
	local AbsoluteSize = Frame.AbsoluteSize
	I:Destroy()
	return AbsoluteSize
end
local ZERO_KEY_VALUE = Enum.KeyCode.Zero.Value
local DROP_HOTKEY_VALUE = Enum.KeyCode.Backspace.Value
	local ICON_MODULE = script:WaitForChild("Icon")
local GAMEPAD_INPUT_TYPES =
	{
		[Enum.UserInputType.Gamepad1] = true;
		[Enum.UserInputType.Gamepad2] = true;
		[Enum.UserInputType.Gamepad3] = true;
		[Enum.UserInputType.Gamepad4] = true;
		[Enum.UserInputType.Gamepad5] = true;
		[Enum.UserInputType.Gamepad6] = true;
		[Enum.UserInputType.Gamepad7] = true;
		[Enum.UserInputType.Gamepad8] = true;
	}

local UserInputService = game:GetService('UserInputService')
local PlayersService = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local StarterGui = game:GetService('StarterGui')
local GuiService = game:GetService('GuiService')
local CoreGui = PlayersService.LocalPlayer.PlayerGui

local TopbarPlusReference = ReplicatedStorage:FindFirstChild("TopbarPlusReference")
local BackpackEnabled = true

if TopbarPlusReference then
	ICON_MODULE = TopbarPlusReference.Value
end

local RobloxGui = Instance.new("ScreenGui", CoreGui)
RobloxGui.DisplayOrder = 120
RobloxGui.IgnoreGuiInset = true
RobloxGui.ResetOnSpawn = false
RobloxGui.Name = "BackpackGui"

local ContextActionService = game:GetService("ContextActionService")
local RunService = game:GetService('RunService')
local VRService = game:GetService('VRService')
local Utility = require(script.Utility)
local GameTranslator = require(script.GameTranslator)
local Themes = require(ICON_MODULE.Themes)
local Icon = require(ICON_MODULE)

local FFlagBackpackScriptUseFormatByKey = true
local FFlagCoreScriptTranslateGameText2 = true
local FFlagRobloxGuiSiblingZindexs = true
local IsTenFootInterface = GuiService:IsTenFootInterface()

if IsTenFootInterface then
	ICON_SIZE = 100
	FONT_SIZE = 24
end

local GamepadActionsBound = false

local IS_PHONE = UserInputService.TouchEnabled and GetScreenResolution().X < HOTBAR_SLOTS_WIDTH_CUTOFF

local Player = PlayersService.LocalPlayer

local MainFrame = nil
local HotbarFrame = nil
local InventoryFrame = nil
local VRInventorySelector = nil
local ScrollingFrame = nil
local UIGridFrame = nil
local UIGridLayout = nil
local ScrollUpInventoryButton = nil
local ScrollDownInventoryButton = nil

local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")
local Backpack = Player:WaitForChild("Backpack")

local InventoryIcon = Icon.new()
InventoryIcon:setImage(ARROW_IMAGE_CLOSE, "deselected")
InventoryIcon:setImage(ARROW_IMAGE_OPEN, "selected")
InventoryIcon:bindToggleKey(ARROW_HOTKEY[1], ARROW_HOTKEY[2])
InventoryIcon:setName("InventoryIcon")
InventoryIcon:setImageScale(1.12)
InventoryIcon:setOrder(-5)
InventoryIcon:setCaption("Toggle the backpack.")
InventoryIcon.deselectWhenOtherIconSelected = false

local Slots = {} -- List of all Slots by index
local LowestEmptySlot = nil
local SlotsByTool = {} -- Map of Tools to their assigned Slots
local HotkeyFns = {} -- Map of KeyCode values to their assigned behaviors
local Dragging = {} -- Only used to check if anything is being dragged, to disable other input
local FullHotbarSlots = 0 -- Now being used to also determine whether or not LB and RB on the gamepad are enabled.
local StarterToolFound = false -- Special handling is required for the gear currently equipped on the site
local WholeThingEnabled = false
local TextBoxFocused = false -- ANY TextBox, not just the search box
local ViewingSearchResults = false -- If the results of a search are currently being viewed
local HotkeyStrings = {} -- Used for eating/releasing hotkeys
local CharConns = {} -- Holds character Connections to be cleared later
local GamepadEnabled = false -- determines if our gui needs to be gamepad friendly
local TimeOfLastToolChange = 0

local IsVR = VRService.VREnabled -- Are we currently using a VR device?
local NumberOfHotbarSlots = IsVR and HOTBAR_SLOTS_VR or (IS_PHONE and HOTBAR_SLOTS_MINI or HOTBAR_SLOTS_FULL) -- Number of slots shown at the bottom
local NumberOfInventoryRows = IsVR and INVENTORY_ROWS_VR or (IS_PHONE and INVENTORY_ROWS_MINI or INVENTORY_ROWS_FULL) -- How many rows in the popped-up inventory
local BackpackPanel = nil
local lastEquippedSlot = nil

local function EvaluateBackpackPanelVisibility(enabled)
	return enabled and InventoryIcon.enabled and BackpackEnabled and VRService.VREnabled
end

local function ShowVRBackpackPopup()
	if BackpackPanel and EvaluateBackpackPanelVisibility(true) then
		BackpackPanel:ForceShowForSeconds(2)
	end
end

local function NewGui(className, objectName)
	local newGui = Instance.new(className)
	newGui.Name = objectName
	newGui.BackgroundColor3 = Color3.new(0, 0, 0)
	newGui.BackgroundTransparency = 1
	newGui.BorderColor3 = Color3.new(0, 0, 0)
	newGui.BorderSizePixel = 0
	newGui.Size = UDim2.new(1, 0, 1, 0)
	if className:match('Text') then
		newGui.TextColor3 = Color3.new(1, 1, 1)
		newGui.Text = ''
		newGui.FontFace = script:GetAttribute("LabelFont")
		newGui.TextSize = FONT_SIZE
		newGui.TextWrapped = true
		if className == 'TextButton' then
			newGui.FontFace = script:GetAttribute("SlotFont")
		end
	end
	return newGui
end

local function FindLowestEmpty()
	for i = 1, NumberOfHotbarSlots do
		local slot = Slots[i]
		if not slot.Tool then
			return slot
		end
	end
	return nil
end

local function isInventoryEmpty()
	for i = NumberOfHotbarSlots + 1, #Slots do
		local slot = Slots[i]
		if slot and slot.Tool then
			return false
		end
	end
	return true
end

local function UseGazeSelection()
	return UserInputService.VREnabled
end

local function AdjustHotbarFrames()
	local inventoryOpen = InventoryFrame.Visible -- (Show all)
	local visualTotal = (inventoryOpen) and NumberOfHotbarSlots or FullHotbarSlots
	local visualIndex = 0
	local hotbarIsVisible = (visualTotal >= 1)

	for i = 1, NumberOfHotbarSlots do
		local slot = Slots[i]
		if slot.Tool or inventoryOpen then
			visualIndex = visualIndex + 1
			slot:Readjust(visualIndex, visualTotal)
			slot.Frame.Visible = true
		else
			slot.Frame.Visible = false
		end
	end
end

local function UpdateScrollingFrameCanvasSize()
	local countX = math.floor(ScrollingFrame.AbsoluteSize.X/(ICON_SIZE + ICON_BUFFER))
	local maxRow = math.ceil((#UIGridFrame:GetChildren() - 1)/countX)
	local canvasSizeY = maxRow*(ICON_SIZE + ICON_BUFFER) + ICON_BUFFER
	ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, canvasSizeY)
end

local function AdjustInventoryFrames()
	for i = NumberOfHotbarSlots + 1, #Slots do
		local slot = Slots[i]
		slot.Frame.LayoutOrder = slot.Index
		slot.Frame.Visible = (slot.Tool ~= nil)
	end
	UpdateScrollingFrameCanvasSize()
end

local function UpdateBackpackLayout()
	HotbarFrame.Size = UDim2.new(0, ICON_BUFFER + (NumberOfHotbarSlots * (ICON_SIZE + ICON_BUFFER)), 0, ICON_BUFFER + ICON_SIZE + ICON_BUFFER)
	HotbarFrame.Position = UDim2.new(0.5, -HotbarFrame.Size.X.Offset / 2, 1, -HotbarFrame.Size.Y.Offset)
	InventoryFrame.Size = UDim2.new(0, HotbarFrame.Size.X.Offset, 0, (HotbarFrame.Size.Y.Offset * NumberOfInventoryRows) + INVENTORY_HEADER_SIZE + (IsVR and 2*INVENTORY_ARROWS_BUFFER_VR or 0))
	InventoryFrame.Position = UDim2.new(0.5, -InventoryFrame.Size.X.Offset / 2, 1, HotbarFrame.Position.Y.Offset - InventoryFrame.Size.Y.Offset)

	ScrollingFrame.Size = UDim2.new(1, ScrollingFrame.ScrollBarThickness + 1, 1, -INVENTORY_HEADER_SIZE - (IsVR and 2*INVENTORY_ARROWS_BUFFER_VR or 0))
	ScrollingFrame.Position = UDim2.new(0, 0, 0, INVENTORY_HEADER_SIZE + (IsVR and INVENTORY_ARROWS_BUFFER_VR or 0))
	AdjustHotbarFrames()
	AdjustInventoryFrames()
end

local function Clamp(low, high, num)
	return math.min(high, math.max(low, num))
end

local function CheckBounds(guiObject, x, y)
	local pos = guiObject.AbsolutePosition
	local size = guiObject.AbsoluteSize
	return (x > pos.X and x <= pos.X + size.X and y > pos.Y and y <= pos.Y + size.Y)
end

local function GetOffset(guiObject, point)
	local centerPoint = guiObject.AbsolutePosition + (guiObject.AbsoluteSize / 2)
	return (centerPoint - point).magnitude
end

local function UnequipAllTools() --NOTE: HopperBin
	if Humanoid then
		Humanoid:UnequipTools()
	end
end


local function EquipNewTool(tool) --NOTE: HopperBin
	UnequipAllTools()
	--Humanoid:EquipTool(tool) --NOTE: This would also unequip current Tool
	tool.Parent = Character --TODO: Switch back to above line after EquipTool is fixed!
end

local function IsEquipped(tool)
	return tool and tool.Parent == Character --NOTE: HopperBin
end

local function MakeSlot(parent, index)
	index = index or (#Slots + 1)

	-- Slot Definition --

	local slot = {}
	slot.Tool = nil
	slot.Index = index
	slot.Frame = nil

	local LocalizedName = nil --remove with FFlagCoreScriptTranslateGameText2
	local LocalizedToolTip = nil --remove with FFlagCoreScriptTranslateGameText2

	local SlotFrameParent = nil
	local SlotFrame = nil
	local FakeSlotFrame = nil
	local ToolIcon = nil
	local ToolName = nil
	local ToolChangeConn = nil
	local HighlightFrame = nil
	local SelectionObj = nil

	--NOTE: The following are only defined for Hotbar Slots
	local ToolTip = nil
	local SlotNumber = nil

	-- Slot Functions --

	local function UpdateSlotFading()
		if VRService.VREnabled and BackpackPanel then
			local panelTransparency = BackpackPanel.transparency
			local slotTransparency = SLOT_FADE_LOCKED

			-- This equation multiplies the two transparencies together.
			local finalTransparency = panelTransparency + slotTransparency - panelTransparency * slotTransparency

			SlotFrame.BackgroundTransparency = finalTransparency
			SlotFrame.TextTransparency = finalTransparency
			if ToolIcon then
				ToolIcon.ImageTransparency = InventoryFrame.Visible and 0 or panelTransparency
			end
			if HighlightFrame then
				for _, child in pairs(HighlightFrame:GetChildren()) do
					child.BackgroundTransparency = finalTransparency
				end
			end

			SlotFrame.SelectionImageObject = SelectionObj
		else
			SlotFrame.SelectionImageObject = nil
			SlotFrame.BackgroundTransparency = (SlotFrame.Draggable) and 0 or SLOT_FADE_LOCKED
		end
		SlotFrame.BackgroundColor3 = (SlotFrame.Draggable) and SLOT_DRAGGABLE_COLOR or BACKGROUND_COLOR
	end

	function slot:Readjust(visualIndex, visualTotal) --NOTE: Only used for Hotbar slots
		local centered = HotbarFrame.Size.X.Offset / 2
		local sizePlus = ICON_BUFFER + ICON_SIZE
		local midpointish = (visualTotal / 2) + 0.5
		local factor = visualIndex - midpointish
		SlotFrame.Position = UDim2.new(0, centered - (ICON_SIZE / 2) + (sizePlus * factor), 0, ICON_BUFFER)
	end

	function slot:Fill(tool)
		if not tool then
			return self:Clear()
		end

		self.Tool = tool

		local function assignToolData()
			if FFlagCoreScriptTranslateGameText2 then
				local icon = tool.TextureId
				ToolIcon.Image = icon

				if icon ~= "" then
					ToolName.Visible = false
				end

				ToolName.Text = tool.Name


				if ToolTip and tool:IsA('Tool') then --NOTE: HopperBin
					ToolTip.Text = tool.ToolTip
					local width = ToolTip.TextBounds.X + TOOLTIP_BUFFER
					ToolTip.Size = UDim2.new(0, width, 0, TOOLTIP_HEIGHT)
					ToolTip.Position = UDim2.new(0.5, -width / 2, 0, TOOLTIP_OFFSET)
				end
			else
				LocalizedName = tool.Name
				LocalizedToolTip = nil

				local icon = tool.TextureId
				ToolIcon.Image = icon
				if icon ~= '' then
					ToolName.Text = LocalizedName
				else
					ToolName.Text = ""
				end -- (Only show name if no icon)
				if ToolTip and tool:IsA('Tool') then --NOTE: HopperBin
					LocalizedToolTip = GameTranslator:TranslateGameText(tool, tool.ToolTip)
					ToolTip.Text = tool.ToolTip
					local width = ToolTip.TextBounds.X + TOOLTIP_BUFFER
					ToolTip.Size = UDim2.new(0, width, 0, TOOLTIP_HEIGHT)
					ToolTip.Position = UDim2.new(0.5, -width / 2, 0, TOOLTIP_OFFSET)
				end
			end
		end
		assignToolData()

		if ToolChangeConn then
			ToolChangeConn:disconnect()
			ToolChangeConn = nil
		end

		ToolChangeConn = tool.Changed:connect(function(property)
			if property == 'TextureId' or property == 'Name' or property == 'ToolTip' then
				assignToolData()
			end
		end)

		local hotbarSlot = (self.Index <= NumberOfHotbarSlots)
		local inventoryOpen = InventoryFrame.Visible

		if (not hotbarSlot or inventoryOpen) and not UserInputService.VREnabled then
			SlotFrame.Draggable = true
		end

		self:UpdateEquipView()

		if hotbarSlot then
			FullHotbarSlots = FullHotbarSlots + 1
			-- If using a controller, determine whether or not we can enable BindCoreAction("RBXHotbarEquip", etc)
			if WholeThingEnabled then
				if FullHotbarSlots >= 1 and not GamepadActionsBound then
					-- Player added first item to a hotbar slot, enable BindCoreAction
					GamepadActionsBound = true
					ContextActionService:BindAction("RBXHotbarEquip", changeToolFunc, false, Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonR1)
				end
			end
		end

		SlotsByTool[tool] = self
		LowestEmptySlot = FindLowestEmpty()
	end

	function slot:Clear()
		if not self.Tool then return end

		if ToolChangeConn then
			ToolChangeConn:disconnect()
			ToolChangeConn = nil
		end

		ToolIcon.Image = ''
		ToolName.Text = ''
		if ToolTip then
			ToolTip.Text = ''
			ToolTip.Visible = false
		end
		SlotFrame.Draggable = false

		self:UpdateEquipView(true) -- Show as unequipped

		if self.Index <= NumberOfHotbarSlots then
			FullHotbarSlots = FullHotbarSlots - 1
			if FullHotbarSlots < 1 then
				-- Player removed last item from hotbar; UnbindCoreAction("RBXHotbarEquip"), allowing the developer to use LB and RB.
				GamepadActionsBound = false
				ContextActionService:UnbindAction("RBXHotbarEquip")
			end
		end

		SlotsByTool[self.Tool] = nil
		self.Tool = nil
		LowestEmptySlot = FindLowestEmpty()
	end

	function slot:UpdateEquipView(unequippedOverride)
		if not unequippedOverride and IsEquipped(self.Tool) then -- Equipped
			lastEquippedSlot = slot
			if not HighlightFrame then
				HighlightFrame = NewGui('Frame', 'Equipped')
				HighlightFrame.ZIndex = SlotFrame.ZIndex
				local edgecorner = Instance.new("UICorner")
				edgecorner.CornerRadius = script:GetAttribute("CornerRadius")
				edgecorner.Parent = HighlightFrame
				local t = SLOT_EQUIP_THICKNESS

				local edgeFrame = Instance.new("UIStroke")
				edgeFrame.Color = SLOT_EQUIP_COLOR
				
				edgeFrame.Thickness = t
				edgeFrame.Parent = HighlightFrame
			end
			HighlightFrame.Parent = SlotFrame
		else -- In the Backpack
			if HighlightFrame then
				HighlightFrame.Parent = nil
			end
		end
		UpdateSlotFading()
	end

	function slot:IsEquipped()
		return IsEquipped(self.Tool)
	end

	function slot:Delete()
		SlotFrame:Destroy() --NOTE: Also clears connections
		table.remove(Slots, self.Index)
		local newSize = #Slots

		-- Now adjust the rest (both visually and representationally)
		for i = self.Index, newSize do
			Slots[i]:SlideBack()
		end

		UpdateScrollingFrameCanvasSize()
	end

	function slot:Swap(targetSlot) --NOTE: This slot (self) must not be empty!
		local myTool, otherTool = self.Tool, targetSlot.Tool
		self:Clear()
		if otherTool then -- (Target slot might be empty)
			targetSlot:Clear()
			self:Fill(otherTool)
		end
		if myTool then
			targetSlot:Fill(myTool)
		else
			targetSlot:Clear()
		end
	end

	function slot:SlideBack() -- For inventory slot shifting
		self.Index = self.Index - 1
		SlotFrame.Name = self.Index
		SlotFrame.LayoutOrder = self.Index
	end

	function slot:TurnNumber(on)
		if SlotNumber then
			SlotNumber.Visible = on
		end
	end

	function slot:SetClickability(on) -- (Happens on open/close arrow)
		if self.Tool then
			if UserInputService.VREnabled then
				SlotFrame.Draggable = false
			else
				SlotFrame.Draggable = not on
			end
			UpdateSlotFading()
		end
	end

	function slot:CheckTerms(terms)
		local hits = 0
		local function checkEm(str, term)
			local _, n = str:lower():gsub(term, '')
			hits = hits + n
		end
		local tool = self.Tool
		if tool then
			for term in pairs(terms) do
				if FFlagCoreScriptTranslateGameText2 then
					checkEm(ToolName.Text, term)
					if tool:IsA('Tool') then --NOTE: HopperBin
						local toolTipText = ToolTip and ToolTip.Text or ""
						checkEm(toolTipText, term)
					end
				else
					checkEm(LocalizedName, term)
					if tool:IsA('Tool') then --NOTE: HopperBin
						checkEm(LocalizedToolTip, term)
					end
				end
			end
		end
		return hits
	end

	-- Slot select logic, activated by clicking or pressing hotkey
	function slot:Select()
		local tool = slot.Tool
		if tool then
			if IsEquipped(tool) then --NOTE: HopperBin
				UnequipAllTools()
				SLOT_UNEQUIP_SOUND:Play()
				activeSlot = nil
			elseif tool.Parent == Backpack then
				SLOT_EQUIP_SOUND:Play()
				EquipNewTool(tool)
				activeSlot = slot
			end
			if activeSlot then
				BackpackScript.SelectedSlotChanged:Fire({
					["SlotNumber"] = activeSlot.Index,
					["Tool"] = activeSlot.Tool,
					["IsEquipped"] = activeSlot:IsEquipped(),
				})
			else
				BackpackScript.SelectedSlotChanged:Fire(nil)
			end
		end
	end

	-- Slot Init Logic --

	SlotFrame = NewGui('TextButton', index)
	local newStroke = Instance.new("UIStroke")
	newStroke.Parent = SlotFrame
	local newRadius = Instance.new("UICorner")
	newRadius.CornerRadius = script:GetAttribute("CornerRadius")
	newRadius.Parent = SlotFrame
	newStroke.Thickness = 0
	SlotFrame.BackgroundColor3 = BACKGROUND_COLOR
	newStroke.Color = SLOT_BORDER_COLOR
	
	SlotFrame.Text = ""
	SlotFrame.AutoButtonColor = false
	SlotFrame.BorderSizePixel = 0
	SlotFrame.Size = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)
	SlotFrame.Active = true
	SlotFrame.Draggable = false
	SlotFrame.BackgroundTransparency = SLOT_FADE_LOCKED
	SlotFrame.MouseButton1Click:connect(function() changeSlot(slot) end)
	slot.Frame = SlotFrame

	do
		local selectionObjectClipper = NewGui('Frame', 'SelectionObjectClipper')
		selectionObjectClipper.Visible = false
		selectionObjectClipper.Parent = SlotFrame

		SelectionObj = NewGui('ImageLabel', 'Selector')
		SelectionObj.Size = UDim2.new(1, 0, 1, 0)
		SelectionObj.Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png"
		SelectionObj.ScaleType = Enum.ScaleType.Slice
		SelectionObj.SliceCenter = Rect.new(12,12,52,52)
		SelectionObj.Parent = selectionObjectClipper
	end


	ToolIcon = NewGui('ImageLabel', 'Icon')
	ToolIcon.Size = UDim2.new(0.8, 0, 0.8, 0)
	ToolIcon.Position = UDim2.new(0.1, 0, 0.1, 0)
	ToolIcon.Parent = SlotFrame

	ToolName = NewGui('TextLabel', 'ToolName')
	ToolName.Size = UDim2.new(1, -2, 1, -2)
	ToolName.Position = UDim2.new(0, 1, 0, 1)
	ToolName.Parent = SlotFrame

	slot.Frame.LayoutOrder = slot.Index

	if index <= NumberOfHotbarSlots then -- Hotbar-Specific Slot Stuff
		-- ToolTip stuff
		ToolTip = NewGui('TextLabel', 'ToolTip')
		ToolTip.ZIndex = 2
		ToolTip.FontFace = script:GetAttribute("ToolTipFont")
		ToolTip.TextWrapped = false
		ToolTip.TextYAlignment = Enum.TextYAlignment.Center
		ToolTip.BackgroundColor3 = Color3.new(0.4, 0.4, 0.4)
		ToolTip.BackgroundTransparency = 0
		ToolTip.Visible = false
		ToolTip.Parent = SlotFrame
		local ToolTipStroke = Instance.new("UICorner")
		ToolTipStroke.CornerRadius = script:GetAttribute("CornerRadius")
		ToolTipStroke.Parent = ToolTip
		SlotFrame.MouseEnter:connect(function()
			if ToolTip.Text ~= '' then
				ToolTip.Visible = true
			end
		end)
		SlotFrame.MouseLeave:connect(function() ToolTip.Visible = false end)

		function slot:MoveToInventory()
			if slot.Index <= NumberOfHotbarSlots then -- From a Hotbar slot
				local tool = slot.Tool
				self:Clear() --NOTE: Order matters here
				local newSlot = MakeSlot(UIGridFrame)
				newSlot:Fill(tool)
				if IsEquipped(tool) then -- Also unequip it --NOTE: HopperBin
					UnequipAllTools()
				end
				-- Also hide the inventory slot if we're showing results right now
				if ViewingSearchResults then
					newSlot.Frame.Visible = false
					newSlot.Parent = InventoryFrame
				end
			end
		end

		-- Show label and assign hotkeys for 1-9 and 0 (zero is always last slot when > 10 total)
		if index < 10 or index == NumberOfHotbarSlots then -- NOTE: Hardcoded on purpose!
			local slotNum = (index < 10) and index or 0
			SlotNumber = NewGui('TextLabel', 'Number')
			SlotNumber.Text = slotNum
			SlotNumber.Size = UDim2.new(0, 15, 0, 15)
			SlotNumber.Visible = false
			SlotNumber.Parent = SlotFrame
			HotkeyFns[ZERO_KEY_VALUE + slotNum] = slot.Select
		end
	end

	do -- Dragging Logic
		local startPoint = SlotFrame.Position
		local lastUpTime = 0
		local startParent = nil

		SlotFrame.DragBegin:connect(function(dragPoint)
			Dragging[SlotFrame] = true
			startPoint = dragPoint

			newStroke.Thickness = 2
			InventoryIcon:lock()

			-- Raise above other slots
			SlotFrame.ZIndex = 2
			ToolIcon.ZIndex = 2
			ToolName.ZIndex = 2
			if FFlagRobloxGuiSiblingZindexs then
				SlotFrame.Parent.ZIndex = 2
			end
			if SlotNumber then
				SlotNumber.ZIndex = 2
			end
			if HighlightFrame then
				HighlightFrame.ZIndex = 2
				for _, child in pairs(HighlightFrame:GetChildren()) do
					if not child:IsA("UICorner") and not child:IsA("UIStroke") then
						child.ZIndex = 2
					end
				end
			end

			-- Circumvent the ScrollingFrame's ClipsDescendants property
			startParent = SlotFrame.Parent
			if startParent == UIGridFrame then
				local oldAbsolutPos = SlotFrame.AbsolutePosition
				local newPosition = UDim2.new(0, SlotFrame.AbsolutePosition.X - InventoryFrame.AbsolutePosition.X, 0, SlotFrame.AbsolutePosition.Y - InventoryFrame.AbsolutePosition.Y)
				SlotFrame.Parent = InventoryFrame
				SlotFrame.Position = newPosition

				FakeSlotFrame = NewGui('Frame', 'FakeSlot')
				FakeSlotFrame.LayoutOrder = SlotFrame.LayoutOrder
				FakeSlotFrame.Size = SlotFrame.Size
				FakeSlotFrame.BackgroundTransparency = 1
				FakeSlotFrame.Parent = UIGridFrame
			end
		end)

		SlotFrame.DragStopped:connect(function(x, y)
			if FakeSlotFrame then
				FakeSlotFrame:Destroy()
			end

			local now = tick()
			SlotFrame.Position = startPoint
			SlotFrame.Parent = startParent

			newStroke.Thickness = 0
			InventoryIcon:unlock()

			-- Restore height
			SlotFrame.ZIndex = 1
			ToolIcon.ZIndex = 1
			ToolName.ZIndex = 1
			if FFlagRobloxGuiSiblingZindexs then
				startParent.ZIndex = 1
			end
			if SlotNumber then
				SlotNumber.ZIndex = 1
			end
			if HighlightFrame then
				HighlightFrame.ZIndex = 1
				for _, child in pairs(HighlightFrame:GetChildren()) do
					if not child:IsA("UICorner") and not child:IsA("UIStroke") then
						child.ZIndex = 1
					end
				end
			end

			Dragging[SlotFrame] = nil

			-- Make sure the tool wasn't dropped
			if not slot.Tool then
				return
			end

			-- Check where we were dropped
			if CheckBounds(InventoryFrame, x, y) then
				if slot.Index <= NumberOfHotbarSlots then
					slot:MoveToInventory()
				end
				-- Check for double clicking on an inventory slot, to move into empty hotbar slot
				if slot.Index > NumberOfHotbarSlots and now - lastUpTime < DOUBLE_CLICK_TIME then
					if LowestEmptySlot then
						local myTool = slot.Tool
						slot:Clear()
						LowestEmptySlot:Fill(myTool)
						slot:Delete()
					end
					now = 0 -- Resets the timer
				end
			elseif CheckBounds(HotbarFrame, x, y) then
				local closest = {math.huge, nil}
				for i = 1, NumberOfHotbarSlots do
					local otherSlot = Slots[i]
					local offset = GetOffset(otherSlot.Frame, Vector2.new(x, y))
					if offset < closest[1] then
						closest = {offset, otherSlot}
					end
				end
				local closestSlot = closest[2]
				if closestSlot ~= slot then
					slot:Swap(closestSlot)
					if slot.Index > NumberOfHotbarSlots then
						local tool = slot.Tool
						if not tool then -- Clean up after ourselves if we're an inventory slot that's now empty
							slot:Delete()
						else -- Moved inventory slot to hotbar slot, and gained a tool that needs to be unequipped
							if IsEquipped(tool) then --NOTE: HopperBin
								UnequipAllTools()
							end
							-- Also hide the inventory slot if we're showing results right now
							if ViewingSearchResults then
								slot.Frame.Visible = false
								slot.Frame.Parent = InventoryFrame
							end
						end
					end
				end
			else
				-- local tool = slot.Tool
				-- if tool.CanBeDropped then --TODO: HopperBins
				-- tool.Parent = workspace
				-- --TODO: Move away from character
				-- end
				if slot.Index <= NumberOfHotbarSlots then
					slot:MoveToInventory() --NOTE: Temporary
				end
			end

			lastUpTime = now
		end)
	end

	-- All ready!
	SlotFrame.Parent = parent
	Slots[index] = slot

	if index > NumberOfHotbarSlots then
		UpdateScrollingFrameCanvasSize()
		-- Scroll to new inventory slot, if we're open and not viewing search results
		if InventoryFrame.Visible and not ViewingSearchResults then
			local offset = ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteSize.Y
			ScrollingFrame.CanvasPosition = Vector2.new(0, math.max(0, offset))
		end
	end

	return slot
end

local function OnChildAdded(child) -- To Character or Backpack
	if not child:IsA('Tool') then --NOTE: HopperBin
		if child:IsA('Humanoid') and child.Parent == Character then
			Humanoid = child
		end
		return
	end
	local tool = child

	if tool.Parent == Character then
		ShowVRBackpackPopup()
		TimeOfLastToolChange = tick()
	end

	--TODO: Optimize / refactor / do something else
	if not StarterToolFound and tool.Parent == Character and not SlotsByTool[tool] then
		local starterGear = Player:FindFirstChild('StarterGear')
		if starterGear then
			if starterGear:FindFirstChild(tool.Name) then
				StarterToolFound = true
				local slot = LowestEmptySlot or MakeSlot(UIGridFrame)
				for i = slot.Index, 1, -1 do
					local curr = Slots[i] -- An empty slot, because above
					local pIndex = i - 1
					if pIndex > 0 then
						local prev = Slots[pIndex] -- Guaranteed to be full, because above
						prev:Swap(curr)
					else
						curr:Fill(tool)
					end
				end
				-- Have to manually unequip a possibly equipped tool
				for _, child in pairs(Character:GetChildren()) do
					if child:IsA('Tool') and child ~= tool then
						child.Parent = Backpack
					end
				end
				AdjustHotbarFrames()
				return -- We're done here
			end
		end
	end

	-- The tool is either moving or new
	local slot = SlotsByTool[tool]
	if slot then
		slot:UpdateEquipView()
	else -- New! Put into lowest hotbar slot or new inventory slot
		slot = LowestEmptySlot or MakeSlot(UIGridFrame)
		slot:Fill(tool)
		if slot.Index <= NumberOfHotbarSlots and not InventoryFrame.Visible then
			AdjustHotbarFrames()
		end
	end
end

local function OnChildRemoved(child) -- From Character or Backpack
	if not child:IsA('Tool') then --NOTE: HopperBin
		return
	end
	local tool = child

	ShowVRBackpackPopup()
	TimeOfLastToolChange = tick()

	-- Ignore this event if we're just moving between the two
	local newParent = tool.Parent
	if newParent == Character or newParent == Backpack then
		return
	end

	local slot = SlotsByTool[tool]
	if slot then
		slot:Clear()
		if slot.Index > NumberOfHotbarSlots then -- Inventory slot
			slot:Delete()
		elseif not InventoryFrame.Visible then
			AdjustHotbarFrames()
		end
	end
end

local function OnCharacterAdded(character)
	-- First, clean up any old slots
	for i = #Slots, 1, -1 do
		local slot = Slots[i]
		if slot.Tool then
			slot:Clear()
		end
		if i > NumberOfHotbarSlots then
			slot:Delete()
		end
	end

	-- And any old Connections
	for _, conn in pairs(CharConns) do
		conn:Disconnect()
	end
	CharConns = {}

	-- Hook up the new character
	Character = character
	table.insert(CharConns, character.ChildRemoved:Connect(OnChildRemoved))
	table.insert(CharConns, character.ChildAdded:Connect(OnChildAdded))
	for _, child in pairs(character:GetChildren()) do
		OnChildAdded(child)
	end
	--NOTE: Humanoid is set inside OnChildAdded

	-- And the new backpack, when it gets here
	Backpack = Player:WaitForChild('Backpack')
	table.insert(CharConns, Backpack.ChildRemoved:Connect(OnChildRemoved))
	table.insert(CharConns, Backpack.ChildAdded:Connect(OnChildAdded))
	for _, child in pairs(Backpack:GetChildren()) do
		OnChildAdded(child)
	end
	
	AdjustHotbarFrames()
end

local function OnInputBegan(input, isProcessed)
	-- Pass through keyboard hotkeys when not typing into a TextBox and not disabled (except for the Drop key)
	if input.UserInputType == Enum.UserInputType.Keyboard and not TextBoxFocused and (WholeThingEnabled or input.KeyCode.Value == DROP_HOTKEY_VALUE) then
		local hotkeyBehavior = HotkeyFns[input.KeyCode.Value]
		if hotkeyBehavior then
			hotkeyBehavior(isProcessed)
		end
	end

	local inputType = input.UserInputType
	if not isProcessed then
		if inputType == Enum.UserInputType.MouseButton1 or inputType == Enum.UserInputType.Touch then
			if InventoryFrame.Visible then
				InventoryIcon:deselect()
			end
		end
	end
end

local function OnUISChanged(property)
	if property == 'KeyboardEnabled' or property == "VREnabled" then
		local on = UserInputService.KeyboardEnabled and not UserInputService.VREnabled
		for i = 1, NumberOfHotbarSlots do
			Slots[i]:TurnNumber(on)
		end
	end
end

local lastChangeToolInputObject = nil
local lastChangeToolInputTime = nil
local maxEquipDeltaTime = 0.06
local noOpFunc = function() end
local selectDirection = Vector2.new(0,0)
local hotbarVisible = false

function unbindAllGamepadEquipActions()
	ContextActionService:UnbindAction("RBXBackpackHasGamepadFocus")
	ContextActionService:UnbindAction("RBXCloseInventory")
end

local function setHotbarVisibility(visible, isInventoryScreen)
	for i = 1, NumberOfHotbarSlots do
		local hotbarSlot = Slots[i]
		if hotbarSlot and hotbarSlot.Frame and (isInventoryScreen or hotbarSlot.Tool) then
			hotbarSlot.Frame.Visible = visible
		end
	end
end

local function getInputDirection(inputObject)
	local buttonModifier = 1
	if inputObject.UserInputState == Enum.UserInputState.End then
		buttonModifier = -1
	end

	if inputObject.KeyCode == Enum.KeyCode.Thumbstick1 then

		local magnitude = inputObject.Position.magnitude

		if magnitude > 0.98 then
			local normalizedVector = Vector2.new(inputObject.Position.x / magnitude, -inputObject.Position.y / magnitude)
			selectDirection =  normalizedVector
		else
			selectDirection = Vector2.new(0,0)
		end
	elseif inputObject.KeyCode == Enum.KeyCode.DPadLeft then
		selectDirection = Vector2.new(selectDirection.x - 1 * buttonModifier, selectDirection.y)
	elseif inputObject.KeyCode == Enum.KeyCode.DPadRight then
		selectDirection = Vector2.new(selectDirection.x + 1 * buttonModifier, selectDirection.y)
	elseif inputObject.KeyCode == Enum.KeyCode.DPadUp then
		selectDirection = Vector2.new(selectDirection.x, selectDirection.y - 1 * buttonModifier)
	elseif inputObject.KeyCode == Enum.KeyCode.DPadDown then
		selectDirection = Vector2.new(selectDirection.x, selectDirection.y + 1 * buttonModifier)
	else
		selectDirection = Vector2.new(0,0)
	end

	return selectDirection
end

local selectToolExperiment = function(actionName, inputState, inputObject)
	local inputDirection = getInputDirection(inputObject)

	if inputDirection == Vector2.new(0,0) then
		return
	end

	local angle = math.atan2(inputDirection.y, inputDirection.x) - math.atan2(-1, 0)
	if angle < 0 then
		angle = angle + (math.pi * 2)
	end

	local quarterPi = (math.pi * 0.25)

	local index = (angle/quarterPi) + 1
	index = math.floor(index + 0.5) -- round index to whole number
	if index > NumberOfHotbarSlots then
		index = 1
	end

	if index > 0 then
		local selectedSlot = Slots[index]
		if selectedSlot and selectedSlot.Tool and not selectedSlot:IsEquipped() then
			selectedSlot:Select()
		end
	else
		UnequipAllTools()
	end
end

changeToolFunc = function(actionName, inputState, inputObject)
	if inputState ~= Enum.UserInputState.Begin then return end

	if lastChangeToolInputObject then
		if (lastChangeToolInputObject.KeyCode == Enum.KeyCode.ButtonR1 and
			inputObject.KeyCode == Enum.KeyCode.ButtonL1) or
			(lastChangeToolInputObject.KeyCode == Enum.KeyCode.ButtonL1 and
				inputObject.KeyCode == Enum.KeyCode.ButtonR1) then
			if (tick() - lastChangeToolInputTime) <= maxEquipDeltaTime then
				UnequipAllTools()
				lastChangeToolInputObject = inputObject
				lastChangeToolInputTime = tick()
				return
			end
		end
	end

	lastChangeToolInputObject = inputObject
	lastChangeToolInputTime = tick()

	delay(maxEquipDeltaTime, function()
		if lastChangeToolInputObject ~= inputObject then return end

		local moveDirection = 0
		if (inputObject.KeyCode == Enum.KeyCode.ButtonL1) then
			moveDirection = -1
		else
			moveDirection = 1
		end

		for i = 1, NumberOfHotbarSlots do
			local hotbarSlot = Slots[i]
			if hotbarSlot:IsEquipped() then

				local newSlotPosition = moveDirection + i
				local hitEdge = false
				if newSlotPosition > NumberOfHotbarSlots then
					newSlotPosition = 1
					hitEdge = true
				elseif newSlotPosition < 1 then
					newSlotPosition = NumberOfHotbarSlots
					hitEdge = true
				end

				local origNewSlotPos = newSlotPosition
				while not Slots[newSlotPosition].Tool do
					newSlotPosition = newSlotPosition + moveDirection
					if newSlotPosition == origNewSlotPos then return end

					if newSlotPosition > NumberOfHotbarSlots then
						newSlotPosition = 1
						hitEdge = true
					elseif newSlotPosition < 1 then
						newSlotPosition = NumberOfHotbarSlots
						hitEdge = true
					end
				end

				if hitEdge then
					UnequipAllTools()
					lastEquippedSlot = nil
				else
					Slots[newSlotPosition]:Select()
				end
				return
			end
		end

		if lastEquippedSlot and lastEquippedSlot.Tool then
			lastEquippedSlot:Select()
			return
		end

		local startIndex = moveDirection == -1 and NumberOfHotbarSlots or 1
		local endIndex = moveDirection == -1 and 1 or NumberOfHotbarSlots
		for i = startIndex, endIndex, moveDirection do
			if Slots[i].Tool then
				Slots[i]:Select()
				return
			end
		end
	end)
end

function getGamepadSwapSlot()
	for i = 1, #Slots do
		if Slots[i].Frame:WaitForChild("UIStroke").Thickness > 0 then
			return Slots[i]
		end
	end
end

function changeSlot(slot)
	local swapInVr = not VRService.VREnabled or InventoryFrame.Visible

	if slot.Frame == GuiService.SelectedObject and swapInVr then
		local currentlySelectedSlot = getGamepadSwapSlot()

		if currentlySelectedSlot then
			currentlySelectedSlot.Frame:WaitForChild("UIStroke").Thickness = 0
			if currentlySelectedSlot ~= slot then
				slot:Swap(currentlySelectedSlot)
				VRInventorySelector.SelectionImageObject.Visible = false

				if slot.Index > NumberOfHotbarSlots and not slot.Tool then
					if GuiService.SelectedObject == slot.Frame then
						GuiService.SelectedObject = currentlySelectedSlot.Frame
					end
					slot:Delete()
				end

				if currentlySelectedSlot.Index > NumberOfHotbarSlots and not currentlySelectedSlot.Tool then
					if GuiService.SelectedObject == currentlySelectedSlot.Frame then
						GuiService.SelectedObject = slot.Frame
					end
					currentlySelectedSlot:Delete()
				end
			end
		else
			local startSize = slot.Frame.Size
			local startPosition = slot.Frame.Position
			slot.Frame:TweenSizeAndPosition(startSize + UDim2.new(0, 10, 0, 10), startPosition - UDim2.new(0, 5, 0, 5), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, .1, true, function() slot.Frame:TweenSizeAndPosition(startSize, startPosition, Enum.EasingDirection.In, Enum.EasingStyle.Quad, .1, true) end)
			slot.Frame:WaitForChild("UIStroke").Thickness = 3
			VRInventorySelector.SelectionImageObject.Visible = true
		end
	else
		slot:Select()
		VRInventorySelector.SelectionImageObject.Visible = false
	end
end

function vrMoveSlotToInventory()
	if not VRService.VREnabled then
		return
	end

	local currentlySelectedSlot = getGamepadSwapSlot()
	if currentlySelectedSlot and currentlySelectedSlot.Tool then
		currentlySelectedSlot:WaitForChild("UIStroke").Thickness = 0
		currentlySelectedSlot:MoveToInventory()
		VRInventorySelector.SelectionImageObject.Visible = false
	end
end

function enableGamepadInventoryControl()
	local goBackOneLevel = function(actionName, inputState, inputObject)
		if inputState ~= Enum.UserInputState.Begin then return end

		local selectedSlot = getGamepadSwapSlot()
		if selectedSlot then
			local selectedSlot = getGamepadSwapSlot()
			if selectedSlot then
				selectedSlot:WaitForChild("UIStroke").Thickness = 0
				return
			end
		elseif InventoryFrame.Visible then
			InventoryIcon:deselect()
		end
	end

	ContextActionService:BindAction("RBXBackpackHasGamepadFocus", noOpFunc, false, Enum.UserInputType.Gamepad1)
	ContextActionService:BindAction("RBXCloseInventory", goBackOneLevel, false, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonStart)

	-- Gaze select will automatically select the object for us!
	if not UseGazeSelection() then
		GuiService.SelectedObject = HotbarFrame:FindFirstChild("1")
	end
end


function disableGamepadInventoryControl()
	unbindAllGamepadEquipActions()

	for i = 1, NumberOfHotbarSlots do
		local hotbarSlot = Slots[i]
		if hotbarSlot and hotbarSlot.Frame then
			hotbarSlot.Frame:WaitForChild("UIStroke").Thickness = 0
		end
	end

	if GuiService.SelectedObject and GuiService.SelectedObject:IsDescendantOf(MainFrame) then
		GuiService.SelectedObject = nil
	end
end


local function bindBackpackHotbarAction()
	if WholeThingEnabled and not GamepadActionsBound then
		GamepadActionsBound = true
		ContextActionService:BindAction("RBXHotbarEquip", changeToolFunc, false, Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonR1)
	end
end

local function unbindBackpackHotbarAction()
	disableGamepadInventoryControl()
	GamepadActionsBound = false
	ContextActionService:UnbindAction("RBXHotbarEquip")
end

function gamepadDisconnected()
	GamepadEnabled = false
	disableGamepadInventoryControl()
end

function gamepadConnected()
	GamepadEnabled = true

	if FullHotbarSlots >= 1 then
		bindBackpackHotbarAction()
	end

	if InventoryFrame.Visible then
		enableGamepadInventoryControl()
	end
end

local function OnIconChanged(enabled)
	-- Check for enabling/disabling the whole thing
	enabled = enabled and StarterGui:GetCore("TopbarEnabled")
	InventoryIcon:setEnabled(enabled and not GuiService.MenuIsOpen)
	WholeThingEnabled = enabled
	MainFrame.Visible = enabled

	-- Eat/Release hotkeys (Doesn't affect UserInputService)
	for _, keyString in pairs(HotkeyStrings) do
		if enabled then
			--GuiService:AddKey(keyString)
		else
			--GuiService:RemoveKey(keyString)
		end
	end

	if enabled then
		if FullHotbarSlots >=1 then
			bindBackpackHotbarAction()
		end
	else
		unbindBackpackHotbarAction()
	end
end


local function MakeVRRoundButton(name, image)
	local newButton = NewGui('ImageButton', name)
	newButton.Size = UDim2.new(0, 40, 0, 40)
	newButton.Image = "rbxasset://textures/ui/Keyboard/close_button_background.png";

	local buttonIcon = NewGui('ImageLabel', 'Icon')
	buttonIcon.Size = UDim2.new(0.5,0,0.5,0);
	buttonIcon.Position = UDim2.new(0.25,0,0.25,0);
	buttonIcon.Image = image;
	buttonIcon.Parent = newButton;

	local buttonSelectionObject = NewGui('ImageLabel', 'Selection')
	buttonSelectionObject.Size = UDim2.new(0.9,0,0.9,0);
	buttonSelectionObject.Position = UDim2.new(0.05,0,0.05,0);
	buttonSelectionObject.Image = "rbxasset://textures/ui/Keyboard/close_button_selection.png";
	newButton.SelectionImageObject = buttonSelectionObject

	return newButton, buttonIcon, buttonSelectionObject
end


-- Make the main frame, which (mostly) covers the screen
MainFrame = NewGui('Frame', 'Backpack')
MainFrame.Visible = false
MainFrame.Parent = RobloxGui

-- Make the HotbarFrame, which holds only the Hotbar Slots
HotbarFrame = NewGui('Frame', 'Hotbar')
HotbarFrame.Parent = MainFrame

-- Make all the Hotbar Slots
for i = 1, NumberOfHotbarSlots do
	local slot = MakeSlot(HotbarFrame, i)
	slot.Frame.Visible = false

	if not LowestEmptySlot then
		LowestEmptySlot = slot
	end
end

InventoryIcon.selected:Connect(function()
	if not GuiService.MenuIsOpen then
		BackpackScript.OpenClose()
	end
end)
InventoryIcon.deselected:Connect(function()
	if InventoryFrame.Visible then
		BackpackScript.OpenClose()
	end
end)

LeftBumperButton = NewGui('ImageLabel', 'LeftBumper')
LeftBumperButton.Size = UDim2.new(0, 40, 0, 40)
LeftBumperButton.Position = UDim2.new(0, -LeftBumperButton.Size.X.Offset, 0.5, -LeftBumperButton.Size.Y.Offset/2)

RightBumperButton = NewGui('ImageLabel', 'RightBumper')
RightBumperButton.Size = UDim2.new(0, 40, 0, 40)
RightBumperButton.Position = UDim2.new(1, 0, 0.5, -RightBumperButton.Size.Y.Offset/2)

-- Make the Inventory, which holds the ScrollingFrame, the header, and the search box
InventoryFrame = NewGui('Frame', 'Inventory')
local newIRadius = Instance.new("UICorner")
newIRadius.CornerRadius = script:GetAttribute("CornerRadius")
newIRadius.Parent = InventoryFrame
InventoryFrame.BackgroundTransparency = BACKGROUND_FADE
InventoryFrame.BackgroundColor3 = BACKGROUND_COLOR
InventoryFrame.Active = true
InventoryFrame.Visible = false
InventoryFrame.Parent = MainFrame

VRInventorySelector = NewGui('TextButton', 'VRInventorySelector')
VRInventorySelector.Position = UDim2.new(0, 0, 0, 0)
VRInventorySelector.Size = UDim2.new(1, 0, 1, 0)
VRInventorySelector.BackgroundTransparency = 1
VRInventorySelector.Text = ""
VRInventorySelector.Parent = InventoryFrame

local GroupTitle = NewGui('TextLabel', 'GroupTitle')

GroupTitle.Size = UDim2.new(0, 100, 0, INVENTORY_HEADER_SIZE - 20)
GroupTitle.Position = UDim2.new(0, 8, 0, 8)
GroupTitle.Text = "All Items"
GroupTitle.TextXAlignment = Enum.TextXAlignment.Left
GroupTitle.FontFace = script:GetAttribute("LabelFont")
GroupTitle.TextSize = 18
GroupTitle.TextColor3 = script:GetAttribute("TextColor")
GroupTitle.BackgroundTransparency = 1
GroupTitle.ZIndex = 2
GroupTitle.Parent = InventoryFrame

local selectorImage = NewGui('ImageLabel', 'Selector')
selectorImage.Size = UDim2.new(1, 0, 1, 0)
selectorImage.Image = "rbxasset://textures/ui/Keyboard/key_selection_9slice.png"
selectorImage.ScaleType = Enum.ScaleType.Slice
selectorImage.SliceCenter = Rect.new(12,12,52,52)
selectorImage.Visible = false
VRInventorySelector.SelectionImageObject = selectorImage

VRInventorySelector.MouseButton1Click:Connect(function()
	vrMoveSlotToInventory()
end)

-- Make the ScrollingFrame, which holds the rest of the Slots (however many)
ScrollingFrame = NewGui('ScrollingFrame', 'ScrollingFrame')
ScrollingFrame.Selectable = false
ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
ScrollingFrame.Parent = InventoryFrame

UIGridFrame = NewGui('Frame', 'UIGridFrame')
UIGridFrame.Selectable = false
UIGridFrame.Size = UDim2.new(1, -(ICON_BUFFER*2), 1, 0)
UIGridFrame.Position = UDim2.new(0, ICON_BUFFER, 0, 0)
UIGridFrame.Parent = ScrollingFrame

UIGridLayout = Instance.new("UIGridLayout")
UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIGridLayout.CellSize = UDim2.new(0, ICON_SIZE, 0, ICON_SIZE)
UIGridLayout.CellPadding = UDim2.new(0, ICON_BUFFER, 0, ICON_BUFFER)
UIGridLayout.Parent = UIGridFrame

ScrollUpInventoryButton = MakeVRRoundButton('ScrollUpButton', 'rbxasset://textures/ui/Backpack/ScrollUpArrow.png')
ScrollUpInventoryButton.Size = UDim2.new(0, 34, 0, 34)
ScrollUpInventoryButton.Position = UDim2.new(0.5, -ScrollUpInventoryButton.Size.X.Offset/2, 0, INVENTORY_HEADER_SIZE + 3)
ScrollUpInventoryButton.Icon.Position = ScrollUpInventoryButton.Icon.Position - UDim2.new(0,0,0,2)
ScrollUpInventoryButton.MouseButton1Click:Connect(function()
	ScrollingFrame.CanvasPosition = Vector2.new(
		ScrollingFrame.CanvasPosition.X,
		Clamp(0, ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteWindowSize.Y, ScrollingFrame.CanvasPosition.Y - (ICON_BUFFER + ICON_SIZE)))
end)

ScrollDownInventoryButton = MakeVRRoundButton('ScrollDownButton', 'rbxasset://textures/ui/Backpack/ScrollUpArrow.png')
ScrollDownInventoryButton.Rotation = 180
ScrollDownInventoryButton.Icon.Position = ScrollDownInventoryButton.Icon.Position - UDim2.new(0,0,0,2)
ScrollDownInventoryButton.Size = UDim2.new(0, 34, 0, 34)
ScrollDownInventoryButton.Position = UDim2.new(0.5, -ScrollDownInventoryButton.Size.X.Offset/2, 1, -ScrollDownInventoryButton.Size.Y.Offset - 3)
ScrollDownInventoryButton.MouseButton1Click:Connect(function()
	ScrollingFrame.CanvasPosition = Vector2.new(
		ScrollingFrame.CanvasPosition.X,
		Clamp(0, ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteWindowSize.Y, ScrollingFrame.CanvasPosition.Y + (ICON_BUFFER + ICON_SIZE)))
end)

ScrollingFrame.Changed:Connect(function(prop)
	if prop == 'AbsoluteWindowSize' or prop == 'CanvasPosition' or prop == 'CanvasSize' then
		local canScrollUp = ScrollingFrame.CanvasPosition.Y ~= 0
		local canScrollDown = ScrollingFrame.CanvasPosition.Y < ScrollingFrame.CanvasSize.Y.Offset - ScrollingFrame.AbsoluteWindowSize.Y

		ScrollUpInventoryButton.Visible = canScrollUp
		ScrollDownInventoryButton.Visible = canScrollDown
	end
end)

-- Position the frames and sizes for the Backpack GUI elements
UpdateBackpackLayout()

--Make the gamepad hint frame
local gamepadHintsFrame = Utility:Create'Frame'
{
	Name = "GamepadHintsFrame",
	Size = UDim2.new(0, HotbarFrame.Size.X.Offset, 0, (IsTenFootInterface and 95 or 60)),
	BackgroundTransparency = 1,
	Visible = false,
	Parent = MainFrame
}

local function addGamepadHint(hintImage, hintImageLarge, hintText)
	local hintFrame = Utility:Create'Frame'
	{
		Name = "HintFrame",
		Size = UDim2.new(1, 0, 1, -5),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundTransparency = 1,
		Parent = gamepadHintsFrame
	}

	local hintImage = Utility:Create'ImageLabel'
	{
		Name = "HintImage",
		Size = (IsTenFootInterface and UDim2.new(0,90,0,90) or UDim2.new(0,60,0,60)),
		BackgroundTransparency = 1,
		Image = (IsTenFootInterface and hintImageLarge or hintImage),
		Parent = hintFrame
	}

	local hintText = Utility:Create'TextLabel'
	{
		Name = "HintText",
		Position = UDim2.new(0, (IsTenFootInterface and 100 or 70), 0, 0),
		Size = UDim2.new(1, -(IsTenFootInterface and 100 or 70), 1, 0),
		Font = Enum.Font.SourceSansBold,
		FontSize = (IsTenFootInterface and Enum.FontSize.Size36 or Enum.FontSize.Size24),
		BackgroundTransparency = 1,
		Text = hintText,
		TextColor3 = Color3.new(1,1,1),
		TextXAlignment = Enum.TextXAlignment.Left,
		TextWrapped = true,
		Parent = hintFrame
	}
	local textSizeConstraint = Instance.new("UITextSizeConstraint", hintText)
	textSizeConstraint.MaxTextSize = hintText.TextSize
end

local function resizeGamepadHintsFrame()
	gamepadHintsFrame.Size = UDim2.new(HotbarFrame.Size.X.Scale, HotbarFrame.Size.X.Offset, 0, (IsTenFootInterface and 95 or 60))
	gamepadHintsFrame.Position = UDim2.new(HotbarFrame.Position.X.Scale, HotbarFrame.Position.X.Offset, InventoryFrame.Position.Y.Scale, InventoryFrame.Position.Y.Offset - gamepadHintsFrame.Size.Y.Offset)

	local spaceTaken = 0

	local gamepadHints = gamepadHintsFrame:GetChildren()
	--First get the total space taken by all the hints
	for i = 1, #gamepadHints do
		gamepadHints[i].Size = UDim2.new(1, 0, 1, -5)
		gamepadHints[i].Position = UDim2.new(0, 0, 0, 0)
		spaceTaken = spaceTaken + (gamepadHints[i].HintText.Position.X.Offset + gamepadHints[i].HintText.TextBounds.X)
	end

	--The space between all the frames should be equal
	local spaceBetweenElements = (gamepadHintsFrame.AbsoluteSize.X - spaceTaken)/(#gamepadHints - 1)
	for i = 1, #gamepadHints do
		gamepadHints[i].Position = (i == 1 and UDim2.new(0, 0, 0, 0) or UDim2.new(0, gamepadHints[i-1].Position.X.Offset + gamepadHints[i-1].Size.X.Offset + spaceBetweenElements, 0, 0))
		gamepadHints[i].Size = UDim2.new(0, (gamepadHints[i].HintText.Position.X.Offset + gamepadHints[i].HintText.TextBounds.X), 1, -5)
	end
end

addGamepadHint("rbxasset://textures/ui/Settings/Help/XButtonDark.png", "rbxasset://textures/ui/Settings/Help/XButtonDark@2x.png", "Remove From Hotbar")
addGamepadHint("rbxasset://textures/ui/Settings/Help/AButtonDark.png", "rbxasset://textures/ui/Settings/Help/AButtonDark@2x.png", "Select/Swap")
addGamepadHint("rbxasset://textures/ui/Settings/Help/BButtonDark.png", "rbxasset://textures/ui/Settings/Help/BButtonDark@2x.png", "Close Backpack")

do -- Search stuff
	local searchFrame = NewGui('Frame', 'Search')
	local newRadius = Instance.new("UICorner")
	newRadius.CornerRadius = UDim.new(0,4)
	newRadius.Parent = searchFrame
	searchFrame.BackgroundColor3 = SEARCH_BACKGROUND_COLOR
	searchFrame.BackgroundTransparency = SEARCH_BACKGROUND_FADE
	searchFrame.Size = UDim2.new(0, SEARCH_WIDTH - (SEARCH_BUFFER * 2), 0, INVENTORY_HEADER_SIZE - (SEARCH_BUFFER * 2))
	searchFrame.Position = UDim2.new(1, -searchFrame.Size.X.Offset - SEARCH_BUFFER, 0, SEARCH_BUFFER)
	searchFrame.Parent = InventoryFrame
	local stroke = Instance.new("UIStroke")
	stroke.Color = Color3.fromRGB(73, 77, 90)
	stroke.Thickness = 2
	stroke.Parent = searchFrame

	local searchBox = NewGui('TextBox', 'TextBox')
	searchBox.PlaceholderText = SEARCH_TEXT
	searchBox.TextColor3 = SEARCH_TEXT_COLOR
	searchBox.ClearTextOnFocus = false
	searchBox.FontSize = Enum.FontSize.Size24
	searchBox.TextXAlignment = Enum.TextXAlignment.Left
	searchBox.PlaceholderColor3 = script:GetAttribute("SearchPlaceholderColor")

	local searchImage = Instance.new("ImageLabel")
	searchImage.Parent = searchFrame
	searchImage.BackgroundTransparency = 1
	searchImage.Size = UDim2.fromScale(1,1)
	searchImage.SizeConstraint = Enum.SizeConstraint.RelativeYY
	searchImage.Parent = searchFrame
	searchImage.Image = "rbxassetid://16884179038"
	searchImage.ImageRectSize = Vector2.new(108, 108)
	searchImage.ImageRectOffset = Vector2.new(798, 660)
	local uipadding = Instance.new("UIPadding")
	uipadding.Parent = searchBox
	uipadding.PaddingLeft = UDim.new(0, 8)
	searchBox.Size = searchFrame.Size - UDim2.fromOffset(34, SEARCH_TEXT_OFFSET_FROMLEFT)
	searchBox.Position = UDim2.new(0, SEARCH_TEXT_OFFSET_FROMLEFT + (searchImage.AbsoluteSize.X + 30), 0, 0)
	searchBox.Parent = searchFrame
	local xButton = NewGui('TextButton', 'X')
	local newRadius2 = Instance.new("UICorner")
	newRadius2.CornerRadius = script:GetAttribute("CornerRadius")
	newRadius2.Parent = xButton
	xButton.Font = Enum.Font.Arial
	xButton.Text = 'x'
	xButton.ZIndex = 10
	xButton.TextColor3 = SLOT_EQUIP_COLOR
	xButton.FontSize = Enum.FontSize.Size24
	xButton.TextYAlignment = Enum.TextYAlignment.Bottom
	xButton.BackgroundColor3 = SEARCH_BACKGROUND_COLOR
	xButton.BackgroundTransparency = 0
	xButton.Size = UDim2.new(0, searchFrame.Size.Y.Offset - (SEARCH_BUFFER * 2), 0, searchFrame.Size.Y.Offset - (SEARCH_BUFFER * 2))
	xButton.Position = UDim2.new(1, -xButton.Size.X.Offset - (SEARCH_BUFFER * 2), 0.5, -xButton.Size.Y.Offset / 2)
	xButton.Visible = false
	xButton.BorderSizePixel = 0
	xButton.Parent = searchFrame

	local function search()
		local terms = {}
		for word in searchBox.Text:gmatch('%S+') do
			terms[word:lower()] = true
		end

		local hitTable = {}
		for i = NumberOfHotbarSlots + 1, #Slots do -- Only search inventory slots
			local slot = Slots[i]
			local hits = slot:CheckTerms(terms)
			table.insert(hitTable, {slot, hits})
			slot.Frame.Visible = false
			slot.Frame.Parent = InventoryFrame
		end

		table.sort(hitTable, function(left, right)
			return left[2] > right[2]
		end)
		ViewingSearchResults = true

		local hitCount = 0
		for i, data in ipairs(hitTable) do
			local slot, hits = data[1], data[2]
			if hits > 0 then
				slot.Frame.Visible = true
				slot.Frame.Parent = UIGridFrame
				slot.Frame.LayoutOrder = NumberOfHotbarSlots + hitCount
				hitCount = hitCount + 1
			end
		end

		ScrollingFrame.CanvasPosition = Vector2.new(0, 0)
		UpdateScrollingFrameCanvasSize()

		xButton.ZIndex = 3
	end

	local function clearResults()
		if xButton.ZIndex > 0 then
			ViewingSearchResults = false
			for i = NumberOfHotbarSlots + 1, #Slots do
				local slot = Slots[i]
				slot.Frame.LayoutOrder = slot.Index
				slot.Frame.Parent = UIGridFrame
				slot.Frame.Visible = true
			end
			xButton.ZIndex = 0
		end
		UpdateScrollingFrameCanvasSize()
	end

	local function reset()
		clearResults()
		searchBox.Text = ''
	end

	local function onChanged(property)
		if property == 'Text' then
			local text = searchBox.Text
			if text == '' then
				clearResults()
			elseif text ~= SEARCH_TEXT then
				search()
			end
			xButton.Visible = false
		end
	end

	local function focusLost(enterPressed)
		if enterPressed then
			--TODO: Could optimize
			search()
		end
	end

	xButton.MouseButton1Click:Connect(reset)
	searchBox.Changed:Connect(onChanged)
	searchBox.FocusLost:Connect(focusLost)

	BackpackScript.StateChanged.Event:Connect(function(isNowOpen)

		if not isNowOpen then
			reset()
			if not InventoryFrame.Visible then
				InventoryIcon:deselect()
			end
		end
	end)
	
	HotkeyFns[Enum.KeyCode.Escape.Value] = function(isProcessed)
		if isProcessed then -- Pressed from within a TextBox
			reset()
		elseif InventoryFrame.Visible then
			InventoryIcon:deselect()
		end
	end

	local function detectGamepad(lastInputType)
		if lastInputType == Enum.UserInputType.Gamepad1 and not UserInputService.VREnabled then
			searchFrame.Visible = false
		else
			searchFrame.Visible = true
		end
	end
	UserInputService.LastInputTypeChanged:Connect(detectGamepad)
end

GuiService.MenuOpened:Connect(function()
	if InventoryFrame.Visible then
		InventoryIcon:deselect()
	end
end)


do -- Make the Inventory expand/collapse arrow (unless TopBar)
	local removeHotBarSlot = function(name, state, input)
		if state ~= Enum.UserInputState.Begin then return end
		if not GuiService.SelectedObject then return end

		for i = 1, NumberOfHotbarSlots do
			if Slots[i].Frame == GuiService.SelectedObject and Slots[i].Tool then
				Slots[i]:MoveToInventory()
				return
			end
		end
	end

	local function openClose()
		if not next(Dragging) then -- Only continue if nothing is being dragged
			InventoryFrame.Visible = not InventoryFrame.Visible
			local nowOpen = InventoryFrame.Visible
			AdjustHotbarFrames()
			HotbarFrame.Active = not HotbarFrame.Active
			for i = 1, NumberOfHotbarSlots do
				Slots[i]:SetClickability(not nowOpen)
			end
		end

		if InventoryFrame.Visible then
			if GamepadEnabled then
				if GAMEPAD_INPUT_TYPES[UserInputService:GetLastInputType()] then
					resizeGamepadHintsFrame()
					gamepadHintsFrame.Visible = not UserInputService.VREnabled
				end
				enableGamepadInventoryControl()
			end
			if BackpackPanel and VRService.VREnabled then
				BackpackPanel:SetVisible(true)
				BackpackPanel:RequestPositionUpdate()
			end
		else
			if GamepadEnabled then
				gamepadHintsFrame.Visible = false
			end
			disableGamepadInventoryControl()
		end

		if InventoryFrame.Visible then
			ContextActionService:BindAction("RBXRemoveSlot", removeHotBarSlot, false, Enum.KeyCode.ButtonX)
		else
			ContextActionService:UnbindAction("RBXRemoveSlot")
		end

		BackpackScript.IsOpen = InventoryFrame.Visible
		BackpackScript.StateChanged:Fire(InventoryFrame.Visible)
	end

	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
	BackpackScript.OpenClose = openClose -- Exposed
end

-- Now that we're done building the GUI, we Connect to all the major events

-- Wait for the player if LocalPlayer wasn't ready earlier
while not Player do
	wait()
	Player = PlayersService.LocalPlayer
end

-- Listen to current and all future characters of our player
Player.CharacterAdded:Connect(OnCharacterAdded)
if Player.Character then
	OnCharacterAdded(Player.Character)
end

do -- Hotkey stuff
	
	-- Listen to key down
	UserInputService.InputBegan:Connect(OnInputBegan)

	-- Listen to ANY TextBox gaining or losing focus, for disabling all hotkeys
	UserInputService.TextBoxFocused:Connect(function() TextBoxFocused = true end)
	UserInputService.TextBoxFocusReleased:Connect(function() TextBoxFocused = false end)

	-- Manual unequip for HopperBins on drop button pressed
	HotkeyFns[DROP_HOTKEY_VALUE] = function() --NOTE: HopperBin
		UnequipAllTools()
	end

	-- Listen to keyboard status, for showing/hiding hotkey labels
	UserInputService.Changed:Connect(OnUISChanged)
	OnUISChanged('KeyboardEnabled')

	-- Listen to gamepad status, for allowing gamepad style selection/equip
	if UserInputService:GetGamepadConnected(Enum.UserInputType.Gamepad1) then
		gamepadConnected()
	end
	UserInputService.GamepadConnected:Connect(function(gamepadEnum)
		if gamepadEnum == Enum.UserInputType.Gamepad1 then
			gamepadConnected()
		end
	end)
	UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
		if gamepadEnum == Enum.UserInputType.Gamepad1 then
			gamepadDisconnected()
		end
	end)
end

function BackpackScript:SetBackpackEnabled(Enabled)
	BackpackEnabled = Enabled
end

function BackpackScript:IsOpened()
	return BackpackScript.IsOpen
end

function BackpackScript:GetBackpackEnabled()
	return BackpackEnabled
end

function BackpackScript:GetStateChangedEvent()
	return BackpackScript.StateChanged
end

RunService.Heartbeat:Connect(function()
	OnIconChanged(BackpackEnabled)
end)
-- Table to store group assignments: [tool] = groupName
local ToolGroups = {}
-- Table to store group contents: [groupName] = {tool1, tool2, ...}
local Groups = {}

-- Group Icon Mapping: [groupName] = iconAssetId
local GroupIcons = {}


-- UI: Group Button Bar
local GroupButtonBar = nil
local GroupButtons = {}
local SelectedGroup = nil


-- Table to store group assignments: [tool] = groupName
local ToolGroups = {}
-- Table to store group contents: [groupName] = {tool1, tool2, ...}
local Groups = {}

-- Group Icon Mapping: [groupName] = iconAssetId
local GroupIcons = {}

-- UI: Group Button Bar
local GroupButtonBar = nil
local GroupButtons = {}
local SelectedGroup = nil

-- Implement group assignment logic
function BackpackScript:SetToolGroup(tool, groupName)
	-- Remove from previous group if exists
	local oldGroup = ToolGroups[tool]
	if oldGroup then
		local groupTable = Groups[oldGroup]
		if groupTable then
			for i, t in groupTable do
				if t == tool then
					table.remove(groupTable, i)
					break
				end
			end
		end
	end
	-- Assign to new group
	ToolGroups[tool] = groupName
	if not Groups[groupName] then
		Groups[groupName] = {}
	end
	table.insert(Groups[groupName], tool)
	if RefreshGroupButtons then RefreshGroupButtons() end
end

function BackpackScript:RemoveToolGroup(tool)
	local groupName = ToolGroups[tool]
	if groupName then
		local groupTable = Groups[groupName]
		if groupTable then
			for i, t in groupTable do
				if t == tool then
					table.remove(groupTable, i)
					break
				end
			end
		end
		ToolGroups[tool] = nil
	end
	if RefreshGroupButtons then RefreshGroupButtons() end
end

function BackpackScript:ClearAllGroups()
	ToolGroups = {}
	Groups = {}
	if RefreshGroupButtons then RefreshGroupButtons() end
end

-- Get the group name for a tool
function BackpackScript:GetToolGroup(tool)
	return ToolGroups[tool]
end

-- Get all group names
function BackpackScript:GetAllGroups()
	local groupList = {}
	for groupName, _ in Groups do
		table.insert(groupList, groupName)
	end
	return groupList
end

-- Get all tools in a group
function BackpackScript:GetToolsInGroup(groupName)
	return Groups[groupName] or {}
end

-- Function to filter inventory slots by group
local function FilterInventoryByGroup(groupName)
	SelectedGroup = groupName
	for i = NumberOfHotbarSlots + 1, #Slots do
		local slot = Slots[i]
		local tool = slot.Tool
		local show = false
		if not groupName then
			show = true
		elseif tool and BackpackScript:GetToolGroup(tool) == groupName then
			show = true
		end
		slot.Frame.Visible = show
	end
	UpdateScrollingFrameCanvasSize()
end

-- Function to refresh group buttons
function RefreshGroupButtons()
	
	if not GroupButtonBar then return end
	-- Clear old buttons
	for _, btn in GroupButtons do
		btn:Destroy()
	end
	GroupButtons = {}

	local groups = BackpackScript:GetAllGroups()
	if #groups == 0 then
		GroupTitle.Visible = false
		return
	else
		GroupTitle.Visible = true
	end
	table.sort(groups, function(a, b) return tostring(a) < tostring(b) end)
	
	local y = 0
	local BUTTON_SIZE = 48
	local BUTTON_PADDING = 8

	-- Add "All" button
	local allBtn = Instance.new("ImageButton")
	allBtn.Name = "AllGroups"
	allBtn.Size = UDim2.new(0, BUTTON_SIZE, 0, BUTTON_SIZE)
	allBtn.Position = UDim2.new(0, 0, 0, y)
	allBtn.BackgroundTransparency = BACKGROUND_FADE
	allBtn.Image = "rbxassetid://12988755627" -- generic grid icon
	allBtn.Parent = GroupButtonBar
	allBtn.BackgroundColor3 = BACKGROUND_COLOR
	allBtn.MouseButton1Click:Connect(function()
		FilterInventoryByGroup(nil)
		GroupTitle.Text = "All Items"
	end)
	local allBtnRadius = Instance.new("UICorner")
	allBtnRadius.CornerRadius = script:GetAttribute("CornerRadius")
	allBtnRadius.Parent = allBtn
	table.insert(GroupButtons, allBtn)
	y = y + BUTTON_SIZE + BUTTON_PADDING

	-- Add a button for each group
	for _, groupName in groups do
		local btn = Instance.new("ImageButton")
		btn.Name = "Group_" .. tostring(groupName)
		btn.Size = UDim2.new(0, BUTTON_SIZE, 0, BUTTON_SIZE)
		btn.Position = UDim2.new(0, 0, 0, y)
		btn.BackgroundTransparency = BACKGROUND_FADE
		btn.BackgroundColor3 = BACKGROUND_COLOR
		btn.Image = GroupIcons[groupName] or "" -- default folder icon
		btn.Parent = GroupButtonBar
		local btnPadding = Instance.new("UIPadding")
		btnPadding.PaddingLeft = UDim.new(0, 8)
		btnPadding.PaddingRight = UDim.new(0, 8)
		btnPadding.PaddingTop = UDim.new(0, 8)
		btnPadding.PaddingBottom = UDim.new(0, 8)
		btnPadding.Parent = btn
		btn.MouseButton1Click:Connect(function()
			FilterInventoryByGroup(groupName)
			GroupTitle.Text = groupName
		end)
		local btnRadius = Instance.new("UICorner")
		btnRadius.CornerRadius = script:GetAttribute("CornerRadius")
		btnRadius.Parent = btn
		if not GroupIcons[groupName] then
			local text = Instance.new("TextLabel")
			text.Parent = btn
			text.Size = UDim2.new(1, 0, 1, 0)
			text.BackgroundTransparency = 1
			text.Text = groupName
			text.TextColor3 = script:GetAttribute("TextColor")
			text.TextSize = 18
			text.FontFace = script:GetAttribute("LabelFont")
			text.TextXAlignment = Enum.TextXAlignment.Center
			text.TextYAlignment = Enum.TextYAlignment.Center
			text.TextTruncate = Enum.TextTruncate.AtEnd
			text.TextWrapped = true
		end
		table.insert(GroupButtons, btn)
		y = y + BUTTON_SIZE + BUTTON_PADDING
	end
end

-- Function to set group icon
function BackpackScript:SetGroupIcon(groupName, iconAssetId)
	GroupIcons[groupName] = iconAssetId
	if RefreshGroupButtons then
		RefreshGroupButtons()
	end
end

-- Function to get group icon
function BackpackScript:GetGroupIcon(groupName)
	return GroupIcons[groupName]
end

-- Create the GroupButtonBar UI and insert into InventoryFrame
do
	
	GroupButtonBar = Instance.new("ScrollingFrame")
	GroupButtonBar.Name = "GroupButtonBar"
	GroupButtonBar.CanvasSize = UDim2.new(0, 0, 0, 0)
	GroupButtonBar.AutomaticSize = Enum.AutomaticSize.Y
	GroupButtonBar.Size = UDim2.new(0, 56, 1, 0)
	GroupButtonBar.Position = UDim2.new(0, -56, 0, 0)
	GroupButtonBar.BackgroundTransparency = 1
	GroupButtonBar.Parent = InventoryFrame
	RefreshGroupButtons()
end


local APIRemote = Instance.new("BindableFunction")
APIRemote.Parent = game.ReplicatedStorage
APIRemote.Name = "CustomPackAPI"
local apifunctions = {
	SetBackpackEnabled = function(enabled :boolean)
		BackpackScript:SetBackpackEnabled(enabled)
	end,
	SetInventoryOpen = function(enabled :boolean)
		BackpackScript.IsOpen = enabled
	end,
	ToggleInventoryOpen = function()
		BackpackScript.OpenClose()
	end,
	IsInventoryOpen = function()
		return BackpackScript:IsInventoryOpen()
	end,
	GetBackpackEnabled = function()
		return BackpackEnabled
	end,
	GetStateChangedEvent = function()
		return BackpackScript:GetStateChangedEvent()
	end,
	GetSelectedSlotChangedEvent = function()
		return BackpackScript.SelectedSlotChanged
	end,
	GetVersion = function()
		return BackpackScript.Version
	end,
	SetGroupIcon = function(groupName, iconAssetId)
		BackpackScript:SetGroupIcon(groupName, iconAssetId)
	end,
	GetEquipSound = function()
		return SLOT_EQUIP_SOUND
	end,
	GetUnequipSound = function()
		return SLOT_UNEQUIP_SOUND
	end,
	GetSlot = function(slotnumber :number)
		local slot = Slots[slotnumber]
		return {
			["SlotNumber"] = slot.Index,
			["Tool"] = slot.Tool,
			["IsEquipped"] = slot:IsEquipped(),
		}
	end,
	GetAllSlots = function()
		local finalslots = {}
		for i, v in pairs(Slots) do
			table.insert(finalslots, {
				["SlotNumber"] = v.Index,
				["Tool"] = v.Tool,
				["IsEquipped"] = v:IsEquipped(),
			})
		end
		return finalslots
	end,
	GetEquippedSlot = function()
		if activeSlot then
			return {
				["SlotNumber"] = activeSlot.Index,
				["Tool"] = activeSlot.Tool,
				["IsEquipped"] = activeSlot:IsEquipped(),
			}
		end
		return nil
	end,
	
	IsSlotEquipped = function(slotnumber :number)
		return Slots[slotnumber]:IsEquipped()
	end,
	GetGroupIcon = function(groupName)
		return BackpackScript:GetGroupIcon(groupName)
	end,
	GetToolsInGroup = function(groupName)
		return BackpackScript:GetToolsInGroup(groupName)
	end,
	GetAllGroups = function()
		return BackpackScript:GetAllGroups()
	end,
	GetToolGroup = function(tool)
		return BackpackScript:GetToolGroup(tool)
	end,
	RemoveToolGroup = function(tool)
		BackpackScript:RemoveToolGroup(tool)
	end,
	SetToolGroup = function(tool, groupName)
		BackpackScript:SetToolGroup(tool, groupName)
	end,
}
APIRemote.OnInvoke = function (name, data)
	assert(apifunctions[name], ("API Function \"%s\" doesn't exist."):format(tostring(name)))
	if apifunctions[name] then
		return apifunctions[name](table.unpack(data or {}))
	end
end

return BackpackScript

]]></ProtectedString>
									<string name="ScriptGuid">{0EDCFB95-6289-40CD-BD39-21B425A02366}</string>
									<BinaryString name="AttributesSerialize"><![CDATA[EwAAAA8AAABCYWNrZ3JvdW5kQ29sb3IPgYAAPomICD6dnBw+FgAAAEJhY2tncm91bmRUcmFu
c3BhcmVuY3kGAAAAAAAA0D8LAAAAQm9yZGVyQ29sb3IPAACAPwAAgD8AAIA/DAAAAENvcm5l
clJhZGl1cwkAAAAACAAAAA4AAABEcmFnZ2FibGVDb2xvcg/y8PA98vDwPY2MDD4NAAAARXF1
aXBwZWRDb2xvcg9qvLQ+jZcOP+f7aT8JAAAARnVsbFNsb3RzBgAAAAAAACRACQAAAExhYmVs
Rm9udCGQAQAYAAAAcmJ4YXNzZXRpZDovLzE2NjU4MjIxNDI4AAAAAAkAAABNaW5pU2xvdHMG
AAAAAAAACEAOAAAAU2VhcmNoQm94Q29sb3IPkZCQPZGQkD2pqKg9FQAAAFNlYXJjaEJveFRy
YW5zcGFyZW5jeQYAAAAAAADgPxYAAABTZWFyY2hQbGFjZWhvbGRlckNvbG9yD7OyMj+zsjI/
s7IyPw8AAABTZWFyY2hUZXh0Q29sb3IPAACAPwAAgD8AAIA/GAAAAFNsb3RFcXVpcFN0cm9r
ZVRoaWNrbmVzcwYAAAAAAAAIQAgAAABTbG90Rm9udCFYAgAYAAAAcmJ4YXNzZXRpZDovLzE2
NjU4MjIxNDI4AAAAABYAAABTbG90TG9ja2VkVHJhbnNwYXJlbmN5BgAAAAAAANA/CQAAAFRl
eHRDb2xvcg8AAIA/AACAPwAAgD8IAAAAVGV4dFNpemUGAAAAAAAALEALAAAAVG9vbFRpcEZv
bnQhvAIAGAAAAHJieGFzc2V0aWQ6Ly8xNjY1ODIyMTQyOAAAAAA=]]></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Main</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXB0DC29BA3F7D4FA6AF7A6AEA60EB77B6">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[--[[
		Filename: Utility.lua
		Written by: jeditkacheff
		Version 1.0
		Description: Utility module for CoreScripts
--]]

------------------ CONSTANTS --------------------
local SELECTED_COLOR = Color3.fromRGB(0,162,255)
local NON_SELECTED_COLOR = Color3.fromRGB(78,84,96)

local ARROW_COLOR = Color3.fromRGB(204, 204, 204)
local ARROW_COLOR_HOVER = Color3.fromRGB(255, 255, 255)
local ARROW_COLOR_TOUCH = ARROW_COLOR_HOVER
local ARROW_COLOR_INACTIVE = Color3.fromRGB(150, 150, 150)

local SELECTED_LEFT_IMAGE = "rbxasset://textures/ui/Settings/Slider/SelectedBarLeft.png"
local NON_SELECTED_LEFT_IMAGE = "rbxasset://textures/ui/Settings/Slider/BarLeft.png"
local SELECTED_RIGHT_IMAGE = "rbxasset://textures/ui/Settings/Slider/SelectedBarRight.png"
local NON_SELECTED_RIGHT_IMAGE= "rbxasset://textures/ui/Settings/Slider/BarRight.png"

local CONTROLLER_SCROLL_DELTA = 0.2
local CONTROLLER_THUMBSTICK_DEADZONE = 0.8

local DROPDOWN_BG_TRANSPARENCY = 0.2

------------- SERVICES ----------------
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local CoreGui = game.Players.LocalPlayer.PlayerGui
local RobloxGui = CoreGui:WaitForChild("BackpackGui")
local ContextActionService = game:GetService("ContextActionService")
local VRService = game:GetService("VRService")

--------------- FLAGS ----------------

local success, result = pcall(function() return false end)
local FFlagUseNotificationsLocalization = success and result

------------------ VARIABLES --------------------
local tenFootInterfaceEnabled = false

----------- UTILITIES --------------
local Util = {}
do
	function Util.Create(instanceType)
		return function(data)
			local obj = Instance.new(instanceType)
			local parent = nil
			for k, v in pairs(data) do
				if type(k) == 'number' then
					v.Parent = obj
				elseif k == 'Parent' then
					parent = v
				else
					obj[k] = v
				end
			end
			if parent then
				obj.Parent = parent
			end
			return obj
		end
	end
end

local onResizedCallbacks = {}
setmetatable(onResizedCallbacks, { __mode = 'k' })

-- used by several guis to show no selection adorn
local noSelectionObject = Util.Create'ImageLabel'
{
	Image = "",
	BackgroundTransparency = 1
};


-- MATH --
function clamp(low, high, input)
	return math.max(low, math.min(high, input))
end

function ClampVector2(low, high, input)
	return Vector2.new(clamp(low.x, high.x, input.x), clamp(low.y, high.y, input.y))
end

---- TWEENZ ----
local function Linear(t, b, c, d)
	if t >= d then
		return b + c
	end

	return c*t/d + b
end

local function EaseOutQuad(t, b, c, d)
	if t >= d then
		return b + c
	end

	t = t/d
	return b - c*t*(t - 2)
end

local function EaseInOutQuad(t, b, c, d)
	if t >= d then
		return b + c
	end

	t = t/d
	if t < 1/2 then
		return 2*c*t*t + b
	end
	return b + c*(2*(2 - t)*t - 1)
end

function PropertyTweener(instance, prop, start, final, duration, easingFunc, cbFunc)
	local this = {}
	this.StartTime = tick()
	this.EndTime = this.StartTime + duration
	this.Cancelled = false

	local finished = false
	local percentComplete = 0

	local function finalize()
		if instance then
			instance[prop] = easingFunc(1, start, final - start, 1)
		end
		finished = true
		percentComplete = 1
		if cbFunc then
			cbFunc()
		end
	end

	-- Initial set
	instance[prop] = easingFunc(0, start, final - start, duration)
	coroutine.wrap(function()
		local now = tick()
		while now < this.EndTime and instance do
			if this.Cancelled then
				return
			end
			instance[prop] = easingFunc(now - this.StartTime, start, final - start, duration)
			percentComplete = clamp(0, 1, (now - this.StartTime) / duration)
			RunService.RenderStepped:wait()
			now = tick()
		end
		if this.Cancelled == false and instance then
			finalize()
		end
	end)()

	function this:GetFinal()
		return final
	end

	function this:GetPercentComplete()
		return percentComplete
	end

	function this:IsFinished()
		return finished
	end

	function this:Finish()
		if not finished then
			self:Cancel()
			finalize()
		end
	end

	function this:Cancel()
		this.Cancelled = true
	end

	return this
end

----------- CLASS DECLARATION --------------

local function CreateSignal()
	local sig = {}

	local mSignaler = Instance.new('BindableEvent')

	local mArgData = nil
	local mArgDataCount = nil

	function sig:fire(...)
		mArgData = {...}
		mArgDataCount = select('#', ...)
		mSignaler:Fire()
	end

	function sig:connect(f)
		if not f then error("connect(nil)", 2) end
		return mSignaler.Event:Connect(function()
			f(unpack(mArgData, 1, mArgDataCount))
		end)
	end

	function sig:wait()
		mSignaler.Event:wait()
		if not mArgData then
			error("Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
		end
		return unpack(mArgData, 1, mArgDataCount)
	end

	return sig
end

local function getViewportSize()
	while not workspace.CurrentCamera do
		workspace.Changed:wait()
	end

	-- ViewportSize is initally set to 1, 1 in Camera.cpp constructor.
	-- Also check against 0, 0 incase this is changed in the future.
	while workspace.CurrentCamera.ViewportSize == Vector2.new(0,0) or
		workspace.CurrentCamera.ViewportSize == Vector2.new(1,1) do
		workspace.CurrentCamera.Changed:wait()
	end

	return workspace.CurrentCamera.ViewportSize
end

local function isSmallTouchScreen()
	local viewportSize = getViewportSize()
	return UserInputService.TouchEnabled and (viewportSize.Y < 500 or viewportSize.X < 700)
end

local function isPortrait()
	local viewport = getViewportSize()
	return viewport.Y > viewport.X
end

local function isTenFootInterface()
	return tenFootInterfaceEnabled
end

local function usesSelectedObject()
	--VR does not use selected objects (in the same way as gamepad)
	if VRService.VREnabled then return false end
	--Touch does not use selected objects unless there's also a gamepad
	if UserInputService.TouchEnabled and not UserInputService.GamepadEnabled then return false end
	--PC with gamepad, console... does use selected objects
	return true
end

local function isPosOverGui(pos, gui, debug) -- does not account for rotation
	local ax, ay = gui.AbsolutePosition.x, gui.AbsolutePosition.y
	local sx, sy = gui.AbsoluteSize.x, gui.AbsoluteSize.y
	local bx, by = ax+sx, ay+sy

	return pos.x > ax and pos.x < bx and pos.y > ay and pos.y < by
end

local function isPosOverGuiWithClipping(pos, gui) -- isPosOverGui, accounts for clipping and visibility, does not account for rotation
	if not isPosOverGui(pos, gui) then
		return false
	end

	local clipping = false
	local check = gui
	while true do
		if check == nil or (not check:IsA'GuiObject' and not check:IsA'LayerCollector') then
			clipping = true
			if check and check:IsA'CoreGui' then
				clipping = false
			end
			break
		end

		if check:IsA'GuiObject' and not check.Visible then
			clipping = true
			break
		end
		if check:IsA'LayerCollector' or check.ClipsDescendants then
			if not isPosOverGui(pos, check) then
				clipping = true
				break
			end
		end

		check = check.Parent
	end

	return not clipping
end

local function areGuisIntersecting(a, b) -- does not account for rotation
	local aax, aay = a.AbsolutePosition.x, a.AbsolutePosition.y
	local asx, asy = a.AbsoluteSize.x, a.AbsoluteSize.y
	local abx, aby = aax+asx, aay+asy
	local bax, bay = b.AbsolutePosition.x, b.AbsolutePosition.y
	local bsx, bsy = b.AbsoluteSize.x, b.AbsoluteSize.y
	local bbx, bby = bax+bsx, bay+bsy

	local intersectingX = aax < bbx and abx > bax
	local intersectingY = aay < bby and aby > bay
	local intersecting = intersectingX and intersectingY

	return intersecting
end

local function isGuiVisible(gui, debug) -- true if any part of the gui is visible on the screen, considers clipping, does not account for rotation
	local clipping = false
	local check = gui
	while true do
		if check == nil or not check:IsA'GuiObject' and not check:IsA'LayerCollector' then
			clipping = true
			if check and check:IsA'CoreGui' then
				clipping = false
			end
			break
		end

		if check:IsA'GuiObject' and not check.Visible then
			clipping = true
			break
		end
		if check:IsA'LayerCollector' or check.ClipsDescendants then
			if not areGuisIntersecting(check, gui) then
				clipping = true
				break
			end
		end

		check = check.Parent
	end

	return not clipping
end

local function addHoverState(button, instance, onNormalButtonState, onHoverButtonState)
	local function onNormalButtonStateCallback()
        if button.Active then
            onNormalButtonState(instance)
        end
	end
	local function onHoverButtonStateCallback()
        if button.Active then
            onHoverButtonState(instance)
        end
	end

	button.MouseEnter:Connect(onHoverButtonStateCallback)
	button.SelectionGained:Connect(onHoverButtonStateCallback)
	button.MouseLeave:Connect(onNormalButtonStateCallback)
	button.SelectionLost:Connect(onNormalButtonStateCallback)

	onNormalButtonState(instance)
end

local function addOnResizedCallback(key, callback)
	onResizedCallbacks[key] = callback
	callback(getViewportSize(), isPortrait())
end

local gamepadSet = {
	[Enum.UserInputType.Gamepad1] = true;
	[Enum.UserInputType.Gamepad2] = true;
	[Enum.UserInputType.Gamepad3] = true;
	[Enum.UserInputType.Gamepad4] = true;
	[Enum.UserInputType.Gamepad5] = true;
	[Enum.UserInputType.Gamepad6] = true;
	[Enum.UserInputType.Gamepad7] = true;
	[Enum.UserInputType.Gamepad8] = true;
}

local function MakeDefaultButton(name, size, clickFunc, pageRef, hubRef)
	local SelectionOverrideObject = Util.Create'ImageLabel'
	{
		Image = "",
		BackgroundTransparency = 1,
	};

	local button = Util.Create'ImageButton'
	{
		Name = name .. "Button",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		AutoButtonColor = false,
		BackgroundTransparency = 1,
		Size = size,
		ZIndex = 2,
		SelectionImageObject = SelectionOverrideObject
	};

	local enabled = Util.Create'BoolValue'
	{
		Name = 'Enabled',
		Parent = button,
		Value = true
	}

	if clickFunc then
		button.MouseButton1Click:Connect(function()
			clickFunc(gamepadSet[UserInputService:GetLastInputType()] or false)
		end)
	end

	local function isPointerInput(inputObject)
		return inputObject.UserInputType == Enum.UserInputType.MouseMovement or inputObject.UserInputType == Enum.UserInputType.Touch
	end

	local rowRef = nil
	local function setRowRef(ref)
		rowRef = ref
	end

	local function selectButton()
		local hub = hubRef
		if hub == nil then
			if pageRef then
				hub = pageRef.HubRef
			end
		end

		if (hub and hub.Active) or hub == nil then
			button.Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButtonSelected.png"

			local scrollTo = button
			if rowRef then
				scrollTo = rowRef
			end
			if hub then
				hub:ScrollToFrame(scrollTo)
			end
		end
	end

	local function deselectButton()
		button.Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png"
	end

	button.InputBegan:Connect(function(inputObject)
		if button.Selectable and isPointerInput(inputObject) then
			selectButton()
		end
	end)
	button.InputEnded:Connect(function(inputObject)
		if button.Selectable and GuiService.SelectedCoreObject ~= button and isPointerInput(inputObject) then
			deselectButton()
		end
	end)


	button.SelectionGained:Connect(function()
		selectButton()
	end)
	button.SelectionLost:Connect(function()
		deselectButton()
	end)

	local guiServiceCon = GuiService.Changed:Connect(function(prop)
		if prop ~= "SelectedCoreObject" then return end
		if not usesSelectedObject() then return end

		if GuiService.SelectedCoreObject == nil or GuiService.SelectedCoreObject ~= button then
			deselectButton()
			return
		end

		if button.Selectable then
			selectButton()
		end
	end)

	return button, setRowRef
end

local function MakeButton(name, text, size, clickFunc, pageRef, hubRef)
	local button, setRowRef = MakeDefaultButton(name, size, clickFunc, pageRef, hubRef)

	local textLabel = Util.Create'TextLabel'
	{
		Name = name .. "TextLabel",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, -8),
		Position = UDim2.new(0,0,0,0),
		TextColor3 = Color3.fromRGB(255,255,255),
		TextYAlignment = Enum.TextYAlignment.Center,
		Font = Enum.Font.SourceSansBold,
		TextSize = 24,
		Text = text,
		TextScaled = true,
		TextWrapped = true,
		ZIndex = 2,
		Parent = button
	};
	local constraint = Instance.new("UITextSizeConstraint",textLabel)

	if isSmallTouchScreen() then
		textLabel.TextSize = 18
	elseif isTenFootInterface() then
		textLabel.TextSize = 36
	end
	constraint.MaxTextSize = textLabel.TextSize

	return button, textLabel, setRowRef
end

local function MakeImageButton(name, image, size, imageSize, clickFunc, pageRef, hubRef)
	local button, setRowRef = MakeDefaultButton(name, size, clickFunc, pageRef, hubRef)

	local imageLabel = Util.Create'ImageLabel'
	{
		Name = name .. "ImageLabel",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = imageSize,
		Position = UDim2.new(0.5, 0, 0.5, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		Image = image,
		ZIndex = 2,
		Parent = button
	};

	return button, imageLabel, setRowRef
end

local function AddButtonRow(pageToAddTo, name, text, size, clickFunc, hubRef)
	local button, textLabel, setRowRef = MakeButton(name, text, size, clickFunc, pageToAddTo, hubRef)
	local row = Util.Create'Frame'
	{
		Name = name .. "Row",
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, size.Y.Scale, size.Y.Offset),
		Parent = pageToAddTo.Page
	}
	button.Parent = row
	button.AnchorPoint = Vector2.new(1, 0)
	button.Position = UDim2.new(1, -20, 0, 0)
	return row, button, textLabel, setRowRef
end

local function CreateDropDown(dropDownStringTable, startPosition, settingsHub)
	-------------------- CONSTANTS ------------------------
	local DEFAULT_DROPDOWN_TEXT = "Choose One"
	local SCROLLING_FRAME_PIXEL_OFFSET = 25
	local SELECTION_TEXT_COLOR_NORMAL = Color3.fromRGB(178,178,178)
	local SELECTION_TEXT_COLOR_NORMAL_VR = Color3.fromRGB(229,229,229)
	local SELECTION_TEXT_COLOR_HIGHLIGHTED = Color3.fromRGB(255,255,255)

	-------------------- VARIABLES ------------------------
	local lastSelectedCoreObject = nil

	-------------------- SETUP ------------------------
	local this = {}
	this.CurrentIndex = nil

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	if type(dropDownStringTable) ~= "table" then
		error("CreateDropDown dropDownStringTable (first arg) is not a table", 2)
		return this
	end

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	local interactable = true
	local guid = HttpService:GenerateGUID(false)
	local dropDownButtonEnabled
	local lastStringTable = dropDownStringTable

	----------------- GUI SETUP ------------------------
	local DropDownFullscreenFrame = Util.Create'ImageButton'
	{
		Name = "DropDownFullscreenFrame",
		BackgroundTransparency = DROPDOWN_BG_TRANSPARENCY,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = Color3.fromRGB(0,0,0),
		ZIndex = 10,
		Active = true,
		Visible = false,
		Selectable = false,
		AutoButtonColor = false,
		Parent = CoreGui.RobloxGui
	};

	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			DropDownFullscreenFrame.Parent = Panel3D.Get("SettingsMenu"):GetGUI()
			DropDownFullscreenFrame.BackgroundTransparency = 1
		else
			DropDownFullscreenFrame.Parent = CoreGui.RobloxGui
			DropDownFullscreenFrame.BackgroundTransparency = DROPDOWN_BG_TRANSPARENCY
		end

		--Force the gui to update, but only if onVREnabled is fired later on
		if this.UpdateDropDownList then
			this:UpdateDropDownList(lastStringTable)
		end
	end
	VRService.Changed:Connect(onVREnabled)
	onVREnabled("VREnabled")

	local DropDownSelectionFrame = Util.Create'ImageLabel'
	{
		Name = "DropDownSelectionFrame",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		BackgroundTransparency = 1,
		Size = UDim2.new(0.6, 0, 0.9, 0),
		Position = UDim2.new(0.5, 0, 0.5, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		ZIndex = 10,
		Parent = DropDownFullscreenFrame
	};

	local DropDownScrollingFrame = Util.Create'ScrollingFrame'
	{
		Name = "DropDownScrollingFrame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, -20, 1, -SCROLLING_FRAME_PIXEL_OFFSET),
		Position = UDim2.new(0, 10, 0, 10),
		ZIndex = 10,
		Parent = DropDownSelectionFrame
	};

	local guiServiceChangeCon = nil
	local active = false
	local hideDropDownSelection = function(name, inputState)
		if name ~= nil and inputState ~= Enum.UserInputState.Begin then return end
		this.DropDownFrame.Selectable = interactable

		--Make sure to set the hub to Active again so selecting the
		--dropdown button will highlight it
		settingsHub:SetActive(true)

		if DropDownFullscreenFrame.Visible and usesSelectedObject() then
			GuiService.SelectedCoreObject = lastSelectedCoreObject
		end
		DropDownFullscreenFrame.Visible = false
		if guiServiceChangeCon then guiServiceChangeCon:Disconnect() end
		ContextActionService:UnbindAction(guid .. "Action")
		ContextActionService:UnbindAction(guid .. "FreezeAction")

		dropDownButtonEnabled.Value = interactable
		active = false

		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(DropDownFullscreenFrame, 0)
		end
	end
	local noOpFunc = function() end

	local DropDownFrameClicked = function()
		if not interactable then return end

		this.DropDownFrame.Selectable = false
		active = true

		DropDownFullscreenFrame.Visible = true
		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(DropDownFullscreenFrame, 0.5)
		end

		lastSelectedCoreObject = this.DropDownFrame
		if this.CurrentIndex and this.CurrentIndex > 0 then
			GuiService.SelectedCoreObject = this.Selections[this.CurrentIndex]
		end

		guiServiceChangeCon = GuiService:GetPropertyChangedSignal("SelectedCoreObject"):Connect(function()
			for i = 1, #this.Selections do
				if GuiService.SelectedCoreObject == this.Selections[i] then
					this.Selections[i].TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
				else
					this.Selections[i].TextColor3 = VRService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL
				end
			end
		end)

		ContextActionService:BindActionAtPriority(guid .. "FreezeAction", noOpFunc, false, Enum.ContextActionPriority.High.Value, Enum.UserInputType.Keyboard, Enum.UserInputType.Gamepad1)
		ContextActionService:BindActionAtPriority(guid .. "Action", hideDropDownSelection, false, Enum.ContextActionPriority.High.Value, Enum.KeyCode.ButtonB, Enum.KeyCode.Escape)

		settingsHub:SetActive(false)

		dropDownButtonEnabled.Value = false
	end

	local dropDownFrameSize = UDim2.new(0.6, 0, 0, 50)
	this.DropDownFrame = MakeButton("DropDownFrame", DEFAULT_DROPDOWN_TEXT, dropDownFrameSize, DropDownFrameClicked, nil, settingsHub)
	this.DropDownFrame.Position = UDim2.new(1, 0, 0.5, 0)
	this.DropDownFrame.AnchorPoint = Vector2.new(1, 0.5)

	dropDownButtonEnabled = this.DropDownFrame.Enabled
	local selectedTextLabel = this.DropDownFrame.DropDownFrameTextLabel
	selectedTextLabel.Position = UDim2.new(0, 15, 0, 0)
	selectedTextLabel.Size = UDim2.new(1, -50, 1, -8)
	selectedTextLabel.ClipsDescendants = true
	selectedTextLabel.TextXAlignment = Enum.TextXAlignment.Left
	local dropDownImage = Util.Create'ImageLabel'
	{
		Name = "DropDownImage",
		Image = "rbxasset://textures/ui/Settings/DropDown/DropDown.png",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(1, 0.5),
		Size = UDim2.new(0,15,0,10),
		Position = UDim2.new(1,-12,0.5,0),
		ZIndex = 2,
		Parent = this.DropDownFrame
	};
	this.DropDownImage = dropDownImage


	---------------------- FUNCTIONS -----------------------------------
	local function setSelection(index)
		local shouldFireChanged = false
		for i, selectionLabel in pairs(this.Selections) do
			if i == index then
				selectedTextLabel.Text = selectionLabel.Text
				this.CurrentIndex = i

				shouldFireChanged = true
			end
		end

		if shouldFireChanged then
			indexChangedEvent:Fire(index)
		end
	end

	local function setSelectionByValue(value)
		local shouldFireChanged = false
		for i, selectionLabel in pairs(this.Selections) do
			if selectionLabel.Text == value then
				selectedTextLabel.Text = selectionLabel.Text
				this.CurrentIndex = i

				shouldFireChanged = true
			end
		end

		if shouldFireChanged then
			indexChangedEvent:Fire(this.CurrentIndex)
		end
		return shouldFireChanged
	end

	local enterIsDown = false
	local function processInput(input)
		if input.UserInputState == Enum.UserInputState.Begin then
			if input.KeyCode == Enum.KeyCode.Return then
				if GuiService.SelectedCoreObject == this.DropDownFrame or this.SelectionInfo and this.SelectionInfo[GuiService.SelectedCoreObject] then
					enterIsDown = true
				end
			end
		elseif input.UserInputState == Enum.UserInputState.End then
			if input.KeyCode == Enum.KeyCode.Return and enterIsDown then
				enterIsDown = false
				if GuiService.SelectedCoreObject == this.DropDownFrame then
					DropDownFrameClicked()
				elseif this.SelectionInfo and this.SelectionInfo[GuiService.SelectedCoreObject] then
					local info = this.SelectionInfo[GuiService.SelectedCoreObject]
					info.Clicked()
				end
			end
		end
	end

	local function setIsFaded(isFaded)
		if isFaded then
			this.DropDownFrame.DropDownFrameTextLabel.TextTransparency = 0.5
			this.DropDownFrame.ImageTransparency = 0.5
			this.DropDownImage.ImageTransparency = 0.5
		else
			this.DropDownFrame.DropDownFrameTextLabel.TextTransparency = 0
			this.DropDownFrame.ImageTransparency = 0
			this.DropDownImage.ImageTransparency = 0
		end
	end


	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.IndexChanged = indexChangedEvent.Event

	function this:SetSelectionIndex(newIndex)
		setSelection(newIndex)
	end

	function this:SetSelectionByValue(value)
		return setSelectionByValue(value)
	end

	function this:ResetSelectionIndex()
		this.CurrentIndex = nil
		selectedTextLabel.Text = DEFAULT_DROPDOWN_TEXT
		hideDropDownSelection()
	end

	function this:GetSelectedIndex()
		return this.CurrentIndex
	end

	function this:SetZIndex(newZIndex)
		this.DropDownFrame.ZIndex = newZIndex
		dropDownImage.ZIndex = newZIndex
		selectedTextLabel.ZIndex = newZIndex
	end

	function this:SetInteractable(value)
		interactable = value
		this.DropDownFrame.Selectable = interactable

		if not interactable then
			hideDropDownSelection()
			setIsFaded(VRService.VREnabled)
			if not VRService.VREnabled then
				this:SetZIndex(1)
			end
		else
			setIsFaded(false)
			if not VRService.VREnabled then
				this:SetZIndex(2)
			end
		end

		dropDownButtonEnabled.Value = value and not active
	end


	function this:UpdateDropDownList(dropDownStringTable)
		lastStringTable = dropDownStringTable

		if this.Selections then
			for i = 1, #this.Selections do
				this.Selections[i]:Destroy()
			end
		end

		this.Selections = {}
		this.SelectionInfo = {}

		local vrEnabled = VRService.VREnabled
		local font = vrEnabled and Enum.Font.SourceSansBold or Enum.Font.SourceSans
		local textSize = vrEnabled and 36 or 24

		local itemHeight = vrEnabled and 70 or 50
		local itemSpacing = itemHeight + 1

		local dropDownWidth = vrEnabled and 600 or 400

		for i,v in pairs(dropDownStringTable) do
			local SelectionOverrideObject =	Util.Create'Frame'
			{
				BackgroundTransparency = 0.7,
				BorderSizePixel = 0,
				Size = UDim2.new(1, 0, 1, 0)
			};

			local nextSelection = Util.Create'TextButton'
			{
				Name = "Selection" .. tostring(i),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				AutoButtonColor = false,
				Size = UDim2.new(1, -28, 0, itemHeight),
				Position = UDim2.new(0,14,0, (i - 1) * itemSpacing),
				TextColor3 = VRService.VREnabled and SELECTION_TEXT_COLOR_NORMAL_VR or SELECTION_TEXT_COLOR_NORMAL,
				Font = font,
				TextSize = textSize,
				Text = v,
				ZIndex = 10,
				SelectionImageObject = SelectionOverrideObject,
				Parent = DropDownScrollingFrame
			};

			if i == startPosition then
				this.CurrentIndex = i
				selectedTextLabel.Text = v
				nextSelection.TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
			elseif not startPosition and i == 1 then
				nextSelection.TextColor3 = SELECTION_TEXT_COLOR_HIGHLIGHTED
			end

			local clicked = function()
				selectedTextLabel.Text = nextSelection.Text
				hideDropDownSelection()
				this.CurrentIndex = i
				indexChangedEvent:Fire(i)
			end

			nextSelection.MouseButton1Click:Connect(clicked)

			nextSelection.MouseEnter:Connect(function()
				if usesSelectedObject() then
					GuiService.SelectedCoreObject = nextSelection
				end
			end)

			this.Selections[i] = nextSelection
			this.SelectionInfo[nextSelection] = {Clicked = clicked}
		end

		GuiService:RemoveSelectionGroup(guid)
		GuiService:AddSelectionTuple(guid, unpack(this.Selections))

		DropDownScrollingFrame.CanvasSize = UDim2.new(1,-20,0,#dropDownStringTable * itemSpacing)

		local function updateDropDownSize()
			if DropDownScrollingFrame.CanvasSize.Y.Offset < (DropDownFullscreenFrame.AbsoluteSize.Y - 10) then
				DropDownSelectionFrame.Size = UDim2.new(0, dropDownWidth,
														0,DropDownScrollingFrame.CanvasSize.Y.Offset + SCROLLING_FRAME_PIXEL_OFFSET)
			else
				DropDownSelectionFrame.Size = UDim2.new(0, dropDownWidth, 0.9, 0)
			end
		end

		DropDownFullscreenFrame.Changed:Connect(function(prop)
			if prop ~= "AbsoluteSize" then return end
			updateDropDownSize()
		end)

		updateDropDownSize()
	end

	----------------------- CONNECTIONS/SETUP --------------------------------
	this:UpdateDropDownList(dropDownStringTable)

	DropDownFullscreenFrame.MouseButton1Click:Connect(hideDropDownSelection)

	settingsHub.PoppedMenu:Connect(function(poppedMenu)
		if poppedMenu == DropDownFullscreenFrame then
			hideDropDownSelection()
		end
	end)

	return this
end


local function CreateSelector(selectionStringTable, startPosition)

	-------------------- VARIABLES ------------------------
	local lastInputDirection = 0
	local TweenTime = 0.15

	-------------------- SETUP ------------------------
	local this = {}
	this.HubRef = nil

	if type(selectionStringTable) ~= "table" then
		error("CreateSelector selectionStringTable (first arg) is not a table", 2)
		return this
	end

	local indexChangedEvent = Instance.new("BindableEvent")
	indexChangedEvent.Name = "IndexChanged"

	local interactable = true

	this.CurrentIndex = 0

	----------------- GUI SETUP ------------------------
	this.SelectorFrame = Util.Create'ImageButton'
	{
		Name = "Selector",
		Image = "",
		AutoButtonColor = false,
		NextSelectionLeft = this.SelectorFrame,
		NextSelectionRight = this.SelectorFrame,
		BackgroundTransparency = 1,
		Size = UDim2.new(0.6,0,0,50),
		Position = UDim2.new(1, 0, 0.5, 0),
		AnchorPoint = Vector2.new(1, 0.5),
		ZIndex = 2,
		SelectionImageObject = noSelectionObject
	};

	local leftButton = Util.Create'ImageButton'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0, 0.5),
		Position = UDim2.new(0,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = this.SelectorFrame
	};
	local rightButton = Util.Create'ImageButton'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(1, 0.5),
		Position = UDim2.new(1,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = this.SelectorFrame
	};

	local leftButtonImage = Util.Create'ImageLabel'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Left.png",
		ImageColor3 = ARROW_COLOR,
		ZIndex = 4,
		Parent = leftButton
	};
	local rightButtonImage = Util.Create'ImageLabel'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,18,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Right.png",
		ImageColor3 = ARROW_COLOR,
		ZIndex = 4,
		Parent = rightButton
	};
	if not UserInputService.TouchEnabled then
		local applyNormal, applyHover =
			function(instance) instance.ImageColor3 = ARROW_COLOR end,
			function(instance) instance.ImageColor3 = ARROW_COLOR_HOVER end
		addHoverState(leftButton, leftButtonImage, applyNormal, applyHover)
		addHoverState(rightButton, rightButtonImage, applyNormal, applyHover)
	end


	this.Selections = {}
	local isSelectionLabelVisible = {}
	local isAutoSelectButton = {}

	local autoSelectButton = Util.Create'ImageButton'{
		Name = 'AutoSelectButton',
		BackgroundTransparency = 1,
		Image = '',
		Position = UDim2.new(0, leftButton.Size.X.Offset, 0, 0),
		Size = UDim2.new(1, leftButton.Size.X.Offset * -2, 1, 0),
		Parent = this.SelectorFrame,
		ZIndex = 2,
		SelectionImageObject = noSelectionObject
	}
	autoSelectButton.MouseButton1Click:Connect(function()
		if not interactable then return end
		if #this.Selections <= 1 then return end
		local newIndex = this.CurrentIndex + 1
		if newIndex > #this.Selections then
			newIndex = 1
		end
		this:SetSelectionIndex(newIndex)
		if usesSelectedObject() then
			GuiService.SelectedCoreObject = this.SelectorFrame
		end
	end)
	isAutoSelectButton[autoSelectButton] = true

	---------------------- FUNCTIONS -----------------------------------
	local function setSelection(index, direction)
		for i, selectionLabel in pairs(this.Selections) do
			local isSelected = (i == index)

			local leftButtonUDim = UDim2.new(0,leftButton.Size.X.Offset,0,0)
			local tweenPos = UDim2.new(0,leftButton.Size.X.Offset * direction * 3,0,0)

			if isSelectionLabelVisible[selectionLabel] then
				tweenPos = UDim2.new(0,leftButton.Size.X.Offset * -direction * 3,0,0)
			end

			if tweenPos.X.Offset < 0 then
				tweenPos = UDim2.new(0,tweenPos.X.Offset + (selectionLabel.AbsoluteSize.X/4),0,0)
			end

			if isSelected then
				isSelectionLabelVisible[selectionLabel] = true
				selectionLabel.Position = tweenPos
				selectionLabel.Visible = true
				PropertyTweener(selectionLabel, "TextTransparency", 1, 0, TweenTime * 1.1, EaseOutQuad)
				if selectionLabel:IsDescendantOf(game) then
					selectionLabel:TweenPosition(leftButtonUDim, Enum.EasingDirection.In, Enum.EasingStyle.Quad, TweenTime, true)
				else
					selectionLabel.Position = leftButtonUDim
				end
				this.CurrentIndex = i
				indexChangedEvent:Fire(index)
			elseif isSelectionLabelVisible[selectionLabel] then
				isSelectionLabelVisible[selectionLabel] = false
				PropertyTweener(selectionLabel, "TextTransparency", 0, 1, TweenTime * 1.1, EaseOutQuad)
				if selectionLabel:IsDescendantOf(game) then
					selectionLabel:TweenPosition(tweenPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, TweenTime * 0.9, true)
				else
					selectionLabel.Position = UDim2.new(tweenPos)
				end
			end
		end
	end

	local function stepFunc(inputObject, step)
		if not interactable then return end

		if inputObject ~= nil and inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 and
			inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Gamepad2 and
			inputObject.UserInputType ~= Enum.UserInputType.Gamepad3 and inputObject.UserInputType ~= Enum.UserInputType.Gamepad4 and
			inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end

		if usesSelectedObject() then
			GuiService.SelectedCoreObject = this.SelectorFrame
		end

		local newIndex = step + this.CurrentIndex

		local direction = 0
		if newIndex > this.CurrentIndex then
			direction = 1
		else
			direction = -1
		end

		if newIndex > #this.Selections then
			newIndex = 1
		elseif newIndex < 1 then
			newIndex = #this.Selections
		end

		setSelection(newIndex, direction)
	end

	local guiServiceCon = nil
	local function connectToGuiService()
		guiServiceCon = GuiService:GetPropertyChangedSignal("SelectedCoreObject"):Connect(function()
			if #this.Selections <= 0 then
				return
			end

			if GuiService.SelectedCoreObject == this.SelectorFrame then
				this.Selections[this.CurrentIndex].TextTransparency = 0
			else
				if GuiService.SelectedCoreObject ~= nil and isAutoSelectButton[GuiService.SelectedCoreObject] then
					if VRService.VREnabled then
						this.Selections[this.CurrentIndex].TextTransparency = 0
					else
						GuiService.SelectedCoreObject = this.SelectorFrame
					end
				else
					this.Selections[this.CurrentIndex].TextTransparency = 0.5
				end
			end
		end)
	end

	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.IndexChanged = indexChangedEvent.Event

	function this:SetSelectionIndex(newIndex)
		setSelection(newIndex, 1)
	end

	function this:GetSelectedIndex()
		return this.CurrentIndex
	end

	function this:SetZIndex(newZIndex)
		leftButton.ZIndex = newZIndex
		rightButton.ZIndex = newZIndex
		leftButtonImage.ZIndex = newZIndex
		rightButtonImage.ZIndex = newZIndex

		for i = 1, #this.Selections do
			this.Selections[i].ZIndex = newZIndex
		end
	end

	function this:SetInteractable(value)
		interactable = value
		this.SelectorFrame.Selectable = interactable

		leftButton.Active = interactable
		rightButton.Active = interactable

		if not interactable then
			for i, selectionLabel in pairs(this.Selections) do
				selectionLabel.TextColor3 = Color3.fromRGB(49, 49, 49)
			end
			leftButtonImage.ImageColor3 = ARROW_COLOR_INACTIVE
            rightButtonImage.ImageColor3 = ARROW_COLOR_INACTIVE
		else
			for i, selectionLabel in pairs(this.Selections) do
				selectionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			end
			leftButtonImage.ImageColor3 = ARROW_COLOR
            rightButtonImage.ImageColor3 = ARROW_COLOR
		end
	end

	function this:UpdateOptions(selectionStringTable)
		for i,v in pairs(this.Selections) do
			v:Destroy()
		end

		isSelectionLabelVisible = {}
		this.Selections = {}

		for i,v in pairs(selectionStringTable) do
			local nextSelection = Util.Create'TextLabel'
			{
				Name = "Selection" .. tostring(i),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Size = UDim2.new(1,leftButton.Size.X.Offset * -2, 1, 0),
				Position = UDim2.new(1,0,0,0),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextYAlignment = Enum.TextYAlignment.Center,
				TextTransparency = 0.5,
				Font = Enum.Font.SourceSans,
				TextSize = 24,
				Text = v,
				ZIndex = 2,
				Visible = false,
				Parent = this.SelectorFrame
			};
			if isTenFootInterface() then
				nextSelection.TextSize = 36
			end

			if i == startPosition then
				this.CurrentIndex = i
				nextSelection.Position = UDim2.new(0,leftButton.Size.X.Offset,0,0)
				nextSelection.Visible = true

				isSelectionLabelVisible[nextSelection] = true
			else
				isSelectionLabelVisible[nextSelection] = false
			end

			this.Selections[i] = nextSelection
		end

		local hasMoreThanOneSelection = #this.Selections > 1
		leftButton.Visible = hasMoreThanOneSelection
		rightButton.Visible = hasMoreThanOneSelection
	end

	--------------------- SETUP -----------------------
	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		local vrEnabled = VRService.VREnabled
		leftButton.Selectable = vrEnabled
		rightButton.Selectable = vrEnabled
		autoSelectButton.Selectable = vrEnabled
	end
	VRService.Changed:Connect(onVREnabled)
	onVREnabled("VREnabled")

	leftButton.InputBegan:Connect(function(inputObject)
		if inputObject.UserInputType == Enum.UserInputType.Touch then
			stepFunc(nil, -1)
		end
	end)
	leftButton.MouseButton1Click:Connect(function()
		if not UserInputService.TouchEnabled then
			stepFunc(nil, -1)
		end
	end)
	rightButton.InputBegan:Connect(function(inputObject)
		if inputObject.UserInputType == Enum.UserInputType.Touch then
			stepFunc(nil, 1)
		end
	end)
	rightButton.MouseButton1Click:Connect(function()
		if not UserInputService.TouchEnabled then
			stepFunc(nil, 1)
		end
	end)

	local isInTree = true
	this:UpdateOptions(selectionStringTable)

	UserInputService.InputBegan:Connect(function(inputObject)
		if not interactable then return end
		if not isInTree then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		if GuiService.SelectedCoreObject ~= this.SelectorFrame then return end

		if inputObject.KeyCode == Enum.KeyCode.DPadLeft or inputObject.KeyCode == Enum.KeyCode.Left or inputObject.KeyCode == Enum.KeyCode.A then
			stepFunc(inputObject, -1)
		elseif inputObject.KeyCode == Enum.KeyCode.DPadRight or inputObject.KeyCode == Enum.KeyCode.Right or inputObject.KeyCode == Enum.KeyCode.D then
			stepFunc(inputObject, 1)
		end
	end)

	UserInputService.InputChanged:Connect(function(inputObject)
		if not interactable then return end
		if not isInTree then lastInputDirection = 0 return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 then return end

		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SelectorFrame.Parent) then return end

		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end


		if inputObject.Position.X > CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X > 0 and lastInputDirection ~= 1 then
			lastInputDirection = 1
			stepFunc(inputObject, lastInputDirection)
		elseif inputObject.Position.X < -CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X < 0 and lastInputDirection ~= -1 then
			lastInputDirection = -1
			stepFunc(inputObject, lastInputDirection)
		elseif math.abs(inputObject.Position.X) < CONTROLLER_THUMBSTICK_DEADZONE then
			lastInputDirection = 0
		end
	end)

	this.SelectorFrame.AncestryChanged:Connect(function(child, parent)
		isInTree = parent
		if not isInTree then
			if guiServiceCon then guiServiceCon:Disconnect() end
		else
			connectToGuiService()
		end
	end)

	local function onResized(viewportSize, portrait)
		local textSize = 0
		if portrait then
			textSize = 16
		else
			textSize = isTenFootInterface() and 36 or 24
		end

		for i, selection in pairs(this.Selections) do
			selection.TextSize = textSize
		end
	end
	addOnResizedCallback(this.SelectorFrame, onResized)

	connectToGuiService()

	return this
end

local function ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
	local parent = CoreGui.RobloxGui
	if parent:FindFirstChild("AlertViewFullScreen") then return end

	--Declare AlertViewBacking so onVREnabled can take it as an upvalue
	local AlertViewBacking = nil

	--Handle VR toggle while alert is open
	--Future consideration: maybe rebuild gui when VR toggles mid-game; right now only subpaneling is handled rather than visual style
	local function onVREnabled(prop)
		if prop ~= "VREnabled" then return end
		local Panel3D, settingsPanel = nil, nil
		if VRService.VREnabled then
			Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			settingsPanel = Panel3D.Get("SettingsMenu")
			parent = settingsPanel:GetGUI()
		else
			parent = CoreGui.RobloxGui
		end
		if AlertViewBacking and AlertViewBacking.Parent ~= nil then
			AlertViewBacking.Parent = parent
			if VRService.VREnabled then
				settingsPanel:SetSubpanelDepth(AlertViewBacking, 0.5)
			end
		end
	end
	local vrEnabledConn = VRService.Changed:Connect(onVREnabled)

	local NON_SELECTED_TEXT_COLOR = Color3.fromRGB(59, 166, 241)
	local SELECTED_TEXT_COLOR = Color3.fromRGB(255, 255, 255)

	AlertViewBacking = Util.Create'ImageLabel'
	{
		Name = "AlertViewBacking",
		Image = "rbxasset://textures/ui/Settings/MenuBarAssets/MenuButton.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(8,6,46,44),
		BackgroundTransparency = 1,

		ImageTransparency = 1,
		Size = UDim2.new(0, 400, 0, 350),
		Position = UDim2.new(0.5, -200, 0.5, -175),
		ZIndex = 9,
		Parent = parent
	};
	onVREnabled("VREnabled")
	if hasBackground or VRService.VREnabled then
		AlertViewBacking.ImageTransparency = 0
	else
		AlertViewBacking.Size = UDim2.new(0.8, 0, 0, 350)
		AlertViewBacking.Position = UDim2.new(0.1, 0, 0.1, 0)
	end

	if CoreGui.RobloxGui.AbsoluteSize.Y <= AlertViewBacking.Size.Y.Offset then
		AlertViewBacking.Size = UDim2.new(AlertViewBacking.Size.X.Scale, AlertViewBacking.Size.X.Offset,
											AlertViewBacking.Size.Y.Scale, CoreGui.RobloxGui.AbsoluteSize.Y)
		AlertViewBacking.Position = UDim2.new(AlertViewBacking.Position.X.Scale, -AlertViewBacking.Size.X.Offset/2, 0.5, -AlertViewBacking.Size.Y.Offset/2)
	end

	local AlertViewText = Util.Create'TextLabel'
	{
		Name = "AlertViewText",
		BackgroundTransparency = 1,
		Size = UDim2.new(0.95, 0, 0.6, 0),
		Position = UDim2.new(0.025, 0, 0.05, 0),
		Font = Enum.Font.SourceSansBold,
		TextSize = 36,
		Text = alertMessage,
		TextWrapped = true,
		TextColor3 = Color3.fromRGB(255, 255, 255),
		TextXAlignment = Enum.TextXAlignment.Center,
		TextYAlignment = Enum.TextYAlignment.Center,
		ZIndex = 10,
		Parent = AlertViewBacking
	};

	local SelectionOverrideObject = Util.Create'ImageLabel'
	{
		Image = "",
		BackgroundTransparency = 1
	};

	local removeId = HttpService:GenerateGUID(false)

	local destroyAlert = function(actionName, inputState)
		if VRService.VREnabled and (inputState == Enum.UserInputState.Begin or inputState == Enum.UserInputState.Cancel) then
			return
		end
		if not AlertViewBacking then
			return
		end
		if VRService.VREnabled then
			local Panel3D = require(CoreGui.RobloxGui.Modules.VR.Panel3D)
			Panel3D.Get("SettingsMenu"):SetSubpanelDepth(AlertViewBacking, 0)
		end
		AlertViewBacking:Destroy()
		AlertViewBacking = nil
		if okPressedFunc then
			okPressedFunc()
		end
		ContextActionService:UnbindAction(removeId)
		GuiService.SelectedCoreObject = nil
		if settingsHub then
			settingsHub:ShowBar()
		end
		if vrEnabledConn then
			vrEnabledConn:Disconnect()
		end
	end

	local AlertViewButtonSize = UDim2.new(1, -20, 0, 60)
	local AlertViewButtonPosition = UDim2.new(0, 10, 0.65, 0)
	if not hasBackground then
		AlertViewButtonSize = UDim2.new(0, 200, 0, 50)
		AlertViewButtonPosition = UDim2.new(0.5, -100, 0.65, 0)
	end

	local AlertViewButton, AlertViewText = MakeButton("AlertViewButton", okButtonText, AlertViewButtonSize, destroyAlert)
	AlertViewButton.Position = AlertViewButtonPosition
	AlertViewButton.NextSelectionLeft = AlertViewButton
	AlertViewButton.NextSelectionRight = AlertViewButton
	AlertViewButton.NextSelectionUp = AlertViewButton
	AlertViewButton.NextSelectionDown = AlertViewButton
	AlertViewButton.ZIndex = 9
	AlertViewText.ZIndex = AlertViewButton.ZIndex
	AlertViewButton.Parent = AlertViewBacking

	if usesSelectedObject() then
		GuiService.SelectedCoreObject = AlertViewButton
	end

	GuiService.SelectedCoreObject = AlertViewButton

	ContextActionService:BindActionAtPriority(removeId, destroyAlert, false, Enum.ContextActionPriority.High.Value, Enum.KeyCode.Escape, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonA)

	if settingsHub and not VRService.VREnabled then
		settingsHub:HideBar()
		settingsHub.Pages.CurrentPage:Hide(1, 1)
	end
end

local function CreateNewSlider(numOfSteps, startStep, minStep)
	-------------------- SETUP ------------------------
	local this = {}

	local spacing = 4
	local initialSpacing = 8
	local steps = tonumber(numOfSteps)
	local currentStep = startStep

	local lastInputDirection = 0
	local timeAtLastInput = nil

	local interactable = true

	local renderStepBindName = HttpService:GenerateGUID(false)

	-- this is done to prevent using these values below (trying to keep the variables consistent)
	numOfSteps = ""
	startStep = ""

	if steps <= 0 then
		error("CreateNewSlider failed because numOfSteps (first arg) is 0 or negative, please supply a positive integer", 2)
		return
	end

	local valueChangedEvent = Instance.new("BindableEvent")
	valueChangedEvent.Name = "ValueChanged"

	----------------- GUI SETUP ------------------------
	this.SliderFrame = Util.Create'ImageButton'
	{
		Name = "Slider",
		Image = "",
		AutoButtonColor = false,
		NextSelectionLeft = this.SliderFrame,
		NextSelectionRight = this.SliderFrame,
		BackgroundTransparency = 1,
		Size = UDim2.new(0.6, 0, 0, 50),
		Position = UDim2.new(1, 0, 0.5, 0),
		AnchorPoint = Vector2.new(1, 0.5),
		SelectionImageObject = noSelectionObject,
		ZIndex = 2
	};

	this.StepsContainer = Util.Create "Frame"
	{
		Name = "StepsContainer",
		Position = UDim2.new(0.5, 0, 0.5, 0),
		Size = UDim2.new(1, -100, 1, 0),
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		Parent = this.SliderFrame,
	}

	local leftButton = Util.Create'ImageButton'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0, 0.5),
		Position = UDim2.new(0,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Active = true,
		Parent = this.SliderFrame
	};
	local rightButton = Util.Create'ImageButton'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(1, 0.5),
		Position = UDim2.new(1,0,0.5,0),
		Size =  UDim2.new(0,50,0,50),
		Image =  "",
		ZIndex = 3,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Active = true,
		Parent = this.SliderFrame
	};

	local leftButtonImage = Util.Create'ImageLabel'
	{
		Name = "LeftButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,30,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/Less.png",
		ZIndex = 4,
		Parent = leftButton,
		ImageColor3 = UserInputService.TouchEnabled and ARROW_COLOR_TOUCH or ARROW_COLOR
	};
	local rightButtonImage = Util.Create'ImageLabel'
	{
		Name = "RightButton",
		BackgroundTransparency = 1,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.new(0.5,0,0.5,0),
		Size =  UDim2.new(0,30,0,30),
		Image =  "rbxasset://textures/ui/Settings/Slider/More.png",
		ZIndex = 4,
		Parent = rightButton,
		ImageColor3 = UserInputService.TouchEnabled and ARROW_COLOR_TOUCH or ARROW_COLOR
	};
	if not UserInputService.TouchEnabled then
		local onNormalButtonState, onHoverButtonState =
			function(instance) instance.ImageColor3 = ARROW_COLOR end,
			function(instance) instance.ImageColor3 = ARROW_COLOR_HOVER end

		addHoverState(leftButton, leftButtonImage, onNormalButtonState, onHoverButtonState)
		addHoverState(rightButton, rightButtonImage, onNormalButtonState, onHoverButtonState)
	end

	this.Steps = {}
	local stepXSize = 35
	if isSmallTouchScreen() then
		stepXSize = 25
	end

	local stepXScale = 1 / steps
	stepXSize = 0

	for i = 1, steps do
		local nextStep = Util.Create'ImageButton'
		{
			Name = "Step" .. tostring(i),
			BackgroundColor3 = SELECTED_COLOR,
			BackgroundTransparency = 0.36,
			BorderSizePixel = 0,
			AutoButtonColor = false,
			Active = false,
			AnchorPoint = Vector2.new(0, 0.5),
			Position = UDim2.new((i - 1) * stepXScale, spacing / 2, 0.5, 0),
			Size =  UDim2.new(stepXScale,-spacing, 24 / 50, 0),
			Image =  "",
			ZIndex = 3,
			Selectable = false,
			ImageTransparency = 0.36,
			Parent = this.StepsContainer,
			SelectionImageObject = noSelectionObject
		};

		if i > currentStep then
			nextStep.BackgroundColor3 = NON_SELECTED_COLOR
		end

		if i == 1 or i == steps then
			nextStep.BackgroundTransparency = 1
			nextStep.ScaleType = Enum.ScaleType.Slice
			nextStep.SliceCenter = Rect.new(3,3,32,21)

			if i <= currentStep then
				if i == 1 then
					nextStep.Image = SELECTED_LEFT_IMAGE
				else
					nextStep.Image = SELECTED_RIGHT_IMAGE
				end
			else
				if i == 1 then
					nextStep.Image = NON_SELECTED_LEFT_IMAGE
				else
					nextStep.Image = NON_SELECTED_RIGHT_IMAGE
				end
			end
		end

		this.Steps[#this.Steps + 1] = nextStep
	end


	------------------- FUNCTIONS ---------------------
	local function hideSelection()
		for i = 1, steps do
			this.Steps[i].BackgroundColor3 = NON_SELECTED_COLOR
			if i == 1 then
				this.Steps[i].Image = NON_SELECTED_LEFT_IMAGE
			elseif i == steps then
				this.Steps[i].Image = NON_SELECTED_RIGHT_IMAGE
			end
		end
	end
	local function showSelection()
		for i = 1, steps do
			if i > currentStep then break end
			this.Steps[i].BackgroundColor3 = SELECTED_COLOR
			if i == 1 then
				this.Steps[i].Image = SELECTED_LEFT_IMAGE
			elseif i == steps then
				this.Steps[i].Image = SELECTED_RIGHT_IMAGE
			end
		end
	end
	local function modifySelection(alpha)
		for i = 1, steps do
			if i == 1 or i == steps then
				this.Steps[i].ImageTransparency = alpha
			else
				this.Steps[i].BackgroundTransparency = alpha
			end
		end
	end

	local function setCurrentStep(newStepPosition)
		if not minStep then minStep = 0 end

		leftButton.Visible = true
		rightButton.Visible = true

		if newStepPosition <= minStep then
			newStepPosition = minStep
			leftButton.Visible = false
		end
		if newStepPosition >= steps then
			newStepPosition = steps
			rightButton.Visible = false
		end

		if currentStep == newStepPosition then return end

		currentStep = newStepPosition

		hideSelection()
		showSelection()

		timeAtLastInput = tick()
		valueChangedEvent:Fire(currentStep)
	end

	local function isActivateEvent(inputObject)
		if not inputObject then return false end
		return inputObject.UserInputType == Enum.UserInputType.MouseButton1 or inputObject.UserInputType == Enum.UserInputType.Touch or (inputObject.UserInputType == Enum.UserInputType.Gamepad1 and inputObject.KeyCode == Enum.KeyCode.ButtonA)
	end
	local function mouseDownFunc(inputObject, newStepPos, repeatAction)
		if not interactable then return end

		if inputObject == nil then return end

		if not isActivateEvent(inputObject) then return end

		if usesSelectedObject() and not VRService.VREnabled then
			GuiService.SelectedCoreObject = this.SliderFrame
		end

		if not VRService.VREnabled then
			if repeatAction then
				lastInputDirection = newStepPos - currentStep
			else
				lastInputDirection = 0

				local mouseInputMovedCon = nil
				local mouseInputEndedCon = nil

				mouseInputMovedCon = UserInputService.InputChanged:Connect(function(inputObject)
					if inputObject.UserInputType ~= Enum.UserInputType.MouseMovement then return end

					local mousePos = inputObject.Position.X
					for i = 1, steps do
						local stepPosition = this.Steps[i].AbsolutePosition.X
						local stepSize = this.Steps[i].AbsoluteSize.X
						if mousePos >= stepPosition and mousePos <= stepPosition + stepSize then
							setCurrentStep(i)
							break
						elseif i == 1 and mousePos < stepPosition then
							setCurrentStep(0)
							break
						elseif i == steps and mousePos >= stepPosition then
							setCurrentStep(i)
							break
						end
					end
				end)
				mouseInputEndedCon = UserInputService.InputEnded:Connect(function(inputObject)
					if not isActivateEvent(inputObject) then return end

					lastInputDirection = 0
					mouseInputEndedCon:Disconnect()
					mouseInputMovedCon:Disconnect()
				end)
			end
		else
			lastInputDirection = 0
		end

		setCurrentStep(newStepPos)
	end

	local function mouseUpFunc(inputObject)
		if not interactable then return end
		if not isActivateEvent(inputObject) then return end

		lastInputDirection = 0
	end

	local function touchClickFunc(inputObject, newStepPos, repeatAction)
		mouseDownFunc(inputObject, newStepPos, repeatAction)
	end

	--------------------- PUBLIC FACING FUNCTIONS -----------------------
	this.ValueChanged = valueChangedEvent.Event

	function this:SetValue(newValue)
		setCurrentStep(newValue)
	end

	function this:GetValue()
		return currentStep
	end

	function this:SetInteractable(value)
		lastInputDirection = 0
		interactable = value
		this.SliderFrame.Selectable = value
		if not interactable then
			hideSelection()
		else
			showSelection()
		end
	end

	function this:SetZIndex(newZIndex)
		leftButton.ZIndex = newZIndex
		rightButton.ZIndex = newZIndex
		leftButtonImage.ZIndex = newZIndex
		rightButtonImage.ZIndex = newZIndex

		for i = 1, #this.Steps do
			this.Steps[i].ZIndex = newZIndex
		end
	end

	function this:SetMinStep(newMinStep)
		if newMinStep >= 0 and newMinStep <= steps then
			minStep = newMinStep
		end

		if currentStep <= minStep then
			currentStep = minStep
			leftButton.Visible = false
		end
		if currentStep >= steps then
			currentStep = steps
			rightButton.Visible = false
		end
	end

	--------------------- SETUP -----------------------

	leftButton.InputBegan:Connect(function(inputObject) mouseDownFunc(inputObject, currentStep - 1, true) end)
	leftButton.InputEnded:Connect(function(inputObject) mouseUpFunc(inputObject) end)
	rightButton.InputBegan:Connect(function(inputObject) mouseDownFunc(inputObject, currentStep + 1, true) end)
	rightButton.InputEnded:Connect(function(inputObject) mouseUpFunc(inputObject) end)

	local function onVREnabled(prop)
		if prop ~= "VREnabled" then
			return
		end
		if VRService.VREnabled then
			leftButton.Selectable = interactable
			rightButton.Selectable = interactable
			this.SliderFrame.Selectable = interactable

			for i = 1, steps do
				this.Steps[i].Selectable = interactable
				this.Steps[i].Active = interactable
			end
		else
			leftButton.Selectable = false
			rightButton.Selectable = false
			this.SliderFrame.Selectable = interactable
			for i = 1, steps do
				this.Steps[i].Selectable = false
				this.Steps[i].Active = false
			end
		end
	end
	VRService.Changed:Connect(onVREnabled)
	onVREnabled("VREnabled")

	for i = 1, steps do
		this.Steps[i].InputBegan:Connect(function(inputObject)
			mouseDownFunc(inputObject, i)
		end)
		this.Steps[i].InputEnded:Connect(function(inputObject)
		 mouseUpFunc(inputObject) end)
	end

	this.SliderFrame.InputBegan:Connect(function(inputObject)
		if VRService.VREnabled then
			local selected = GuiService.SelectedCoreObject
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end
		end
		mouseDownFunc(inputObject, currentStep)
	end)
	this.SliderFrame.InputEnded:Connect(function(inputObject)
		if VRService.VREnabled then
			local selected = GuiService.SelectedCoreObject
			if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end
		end
		mouseUpFunc(inputObject)
	end)


	local stepSliderFunc = function()
		if timeAtLastInput == nil then return end

		local currentTime = tick()
		local timeSinceLastInput = currentTime - timeAtLastInput
		if timeSinceLastInput >= CONTROLLER_SCROLL_DELTA then
			setCurrentStep(currentStep + lastInputDirection)
		end
	end

	local isInTree = true

	local navigateLeft = -1 --these are just for differentiation, the actual value isn't important as long as they coerce to boolean true (all numbers do in Lua)
	local navigateRight = 1
	local navigationKeyCodes = {
		[Enum.KeyCode.Thumbstick1] = true, --thumbstick can be either direction
		[Enum.KeyCode.DPadLeft] = navigateLeft,
		[Enum.KeyCode.DPadRight] = navigateRight,
		[Enum.KeyCode.Left] = navigateLeft,
		[Enum.KeyCode.Right] = navigateRight,
		[Enum.KeyCode.A] = navigateLeft,
		[Enum.KeyCode.D] = navigateRight,
		[Enum.KeyCode.ButtonA] = true --buttonA can be either direction
	}
	UserInputService.InputBegan:Connect(function(inputObject)
		if not interactable then return end
		if not isInTree then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end

		if navigationKeyCodes[inputObject.KeyCode] == navigateLeft then
			lastInputDirection = -1
			setCurrentStep(currentStep - 1)
		elseif navigationKeyCodes[inputObject.KeyCode] == navigateRight then
			lastInputDirection = 1
			setCurrentStep(currentStep + 1)
		end
	end)

	UserInputService.InputEnded:Connect(function(inputObject)
		if not interactable then return end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 and inputObject.UserInputType ~= Enum.UserInputType.Keyboard then return end
		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end

		if navigationKeyCodes[inputObject.KeyCode] then --detect any keycode considered a navigation key
			lastInputDirection = 0
		end
	end)

	UserInputService.InputChanged:Connect(function(inputObject)
		if not interactable then
			lastInputDirection = 0
			return
		end
		if not isInTree then
			lastInputDirection = 0
			return
		end

		if inputObject.UserInputType ~= Enum.UserInputType.Gamepad1 then return end
		local selected = GuiService.SelectedCoreObject
		if not selected or not selected:IsDescendantOf(this.SliderFrame.Parent) then return end
		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end

		if inputObject.Position.X > CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X > 0 and lastInputDirection ~= 1 then
			lastInputDirection = 1
			setCurrentStep(currentStep + 1)
		elseif inputObject.Position.X < -CONTROLLER_THUMBSTICK_DEADZONE and inputObject.Delta.X < 0 and lastInputDirection ~= -1 then
			lastInputDirection = -1
			setCurrentStep(currentStep - 1)
		elseif math.abs(inputObject.Position.X) < CONTROLLER_THUMBSTICK_DEADZONE then
			lastInputDirection = 0
		end
	end)

	local isBound = false
	GuiService.Changed:Connect(function(prop)
		if prop ~= "SelectedCoreObject" then return end

		local selected = GuiService.SelectedCoreObject
		local isThisSelected = selected and selected:IsDescendantOf(this.SliderFrame.Parent)
		if isThisSelected then
			modifySelection(0)
			if not isBound then
				isBound = true
				timeAtLastInput = tick()
				RunService:BindToRenderStep(renderStepBindName, Enum.RenderPriority.Input.Value + 1, stepSliderFunc)
			end
		else
			modifySelection(0.36)
			if isBound then
				isBound = false
				RunService:UnbindFromRenderStep(renderStepBindName)
			end
		end
	end)

	this.SliderFrame.AncestryChanged:Connect(function(child, parent)
		isInTree = parent
	end)

	setCurrentStep(currentStep)

	return this
end

local ROW_HEIGHT = 50
if isTenFootInterface() then ROW_HEIGHT = 90 end

local nextPosTable = {}
local function AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
	local nextRowPositionY = 0
	local isARealRow = selectionType ~= 'TextBox' -- Textboxes are constructed in this function - they don't have an associated class.

	if nextPosTable[pageToAddTo] then
		nextRowPositionY = nextPosTable[pageToAddTo]
	end

	local RowFrame = nil
	RowFrame = Util.Create'ImageButton'
	{
		Name = rowDisplayName .. "Frame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(2, 2, 18, 18),
		ImageTransparency = 1,
		Active = false,
		AutoButtonColor = false,
		Size = UDim2.new(1,0,0,ROW_HEIGHT),
		Position = UDim2.new(0,0,0,nextRowPositionY),
		ZIndex = 2,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = pageToAddTo.Page
	};
	RowFrame.ImageColor3 = RowFrame.BackgroundColor3

	if RowFrame and extraSpacing then
		RowFrame.Position = UDim2.new(RowFrame.Position.X.Scale,RowFrame.Position.X.Offset,
			RowFrame.Position.Y.Scale,RowFrame.Position.Y.Offset + extraSpacing)
	end

	local RowLabel = nil
	RowLabel = Util.Create'TextLabel'
	{
		Name = rowDisplayName .. "Label",
		Text = rowDisplayName,
		Font = Enum.Font.SourceSansBold,
		TextSize = 16,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,200,1,0),
		Position = UDim2.new(0,10,0,0),
		ZIndex = 2,
		Parent = RowFrame
	};

	local RowLabelTextSizeConstraint = Instance.new("UITextSizeConstraint")
	if FFlagUseNotificationsLocalization then
		RowLabel.Size = UDim2.new(0.35,0,1,0)
		RowLabel.TextScaled = true
		RowLabel.TextWrapped = true
		RowLabelTextSizeConstraint.Parent = RowLabel
		RowLabelTextSizeConstraint.MaxTextSize = 16
	end

	if not isARealRow then
		RowLabel.Text = ''
	end

	local function onResized(viewportSize, portrait)
		if portrait then
			RowLabel.TextSize = 16
		else
			RowLabel.TextSize = isTenFootInterface() and 36 or 24
		end
		RowLabelTextSizeConstraint.MaxTextSize = RowLabel.TextSize
	end
	onResized(getViewportSize(), isPortrait())
	addOnResizedCallback(RowFrame, onResized)

	local ValueChangerSelection = nil
	local ValueChangerInstance = nil
	if selectionType == "Slider" then
		ValueChangerInstance = CreateNewSlider(rowValues, rowDefault)
		ValueChangerInstance.SliderFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.SliderFrame
	elseif selectionType == "Selector" then
		ValueChangerInstance = CreateSelector(rowValues, rowDefault)
		ValueChangerInstance.SelectorFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.SelectorFrame
	elseif selectionType == "DropDown" then
		ValueChangerInstance = CreateDropDown(rowValues, rowDefault, pageToAddTo.HubRef)
		ValueChangerInstance.DropDownFrame.Parent = RowFrame
		ValueChangerSelection = ValueChangerInstance.DropDownFrame
	elseif selectionType == "TextBox" then
		local isMouseOverRow = false
		local forceReturnSelectionOnFocusLost = false
		local SelectionOverrideObject = Util.Create'ImageLabel'
		{
			Image = "",
			BackgroundTransparency = 1,
		};

		ValueChangerInstance = {}
		ValueChangerInstance.HubRef = nil

		local box = Util.Create'TextBox'
		{
			AnchorPoint = Vector2.new(1, 0.5),
			Size = UDim2.new(0.6,0,1,0),
			Position = UDim2.new(1,0,0.5,0),
			Text = rowDisplayName,
			TextColor3 = Color3.fromRGB(49, 49, 49),
			BackgroundTransparency = 0.5,
			BorderSizePixel = 0,
			TextYAlignment = Enum.TextYAlignment.Top,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextWrapped = true,
			Font = Enum.Font.SourceSans,
			TextSize = 24,
			ZIndex = 2,
			SelectionImageObject = SelectionOverrideObject,
			ClearTextOnFocus = false,
			Parent = RowFrame
		};
		ValueChangerSelection = box

		box.Focused:Connect(function()
			if usesSelectedObject() then
				GuiService.SelectedCoreObject = box
			end

			if box.Text == rowDisplayName then
				box.Text = ""
			end
		end)
		box.FocusLost:Connect(function(enterPressed, inputObject)
			forceReturnSelectionOnFocusLost = false
		end)
		if extraSpacing then
			box.Position = UDim2.new(box.Position.X.Scale,box.Position.X.Offset,
				box.Position.Y.Scale,box.Position.Y.Offset + extraSpacing)
		end

		ValueChangerSelection.SelectionGained:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.1

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(ValueChangerSelection)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.5
			end
		end)

		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerSelection

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
				isMouseOverRow = true
			end
		end
		local function processInput(input)
			if input.UserInputState == Enum.UserInputState.Begin then
				if input.KeyCode == Enum.KeyCode.Return then
					if GuiService.SelectedCoreObject == ValueChangerSelection then
						forceReturnSelectionOnFocusLost = true
						box:CaptureFocus()
					end
				end
			end
		end
		box.MouseEnter:Connect(setRowSelection)

		UserInputService.InputBegan:Connect(processInput)

	elseif selectionType == "TextEntry" then
		local isMouseOverRow = false
		local forceReturnSelectionOnFocusLost = false
		local SelectionOverrideObject = Util.Create'ImageLabel'
		{
			Image = "",
			BackgroundTransparency = 1,
		};

		ValueChangerInstance = {}
		ValueChangerInstance.HubRef = nil

		local box = Util.Create'TextBox'
		{
			AnchorPoint = Vector2.new(1, 0.5),
			Size = UDim2.new(0.4,-10,0,40),
			Position = UDim2.new(1,0,0.5,0),
			Text = rowDisplayName,
			TextColor3 = Color3.fromRGB(178, 178, 178),
			BackgroundTransparency = 1.0,
			BorderSizePixel = 0,
			TextYAlignment = Enum.TextYAlignment.Center,
			TextXAlignment = Enum.TextXAlignment.Center,
			TextWrapped = false,
			Font = Enum.Font.SourceSans,
			TextSize = 24,
			ZIndex = 2,
			SelectionImageObject = SelectionOverrideObject,
			ClearTextOnFocus = false,
			Parent = RowFrame
		};
		ValueChangerSelection = box

		box.Focused:Connect(function()
			if usesSelectedObject() then
				GuiService.SelectedCoreObject = box
			end

			if box.Text == rowDisplayName then
				box.Text = ""
			end
		end)
		box.FocusLost:Connect(function(enterPressed, inputObject)
			forceReturnSelectionOnFocusLost = false
		end)
		if extraSpacing then
			box.Position = UDim2.new(box.Position.X.Scale,box.Position.X.Offset,
										box.Position.Y.Scale,box.Position.Y.Offset + extraSpacing)
		end

		ValueChangerSelection.SelectionGained:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 0.8

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(ValueChangerSelection)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:Connect(function()
			if usesSelectedObject() then
				box.BackgroundTransparency = 1.0
			end
		end)

		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerSelection

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
				isMouseOverRow = true
			end
		end
		local function processInput(input)
			if input.UserInputState == Enum.UserInputState.Begin then
				if input.KeyCode == Enum.KeyCode.Return then
					if GuiService.SelectedCoreObject == ValueChangerSelection then
						forceReturnSelectionOnFocusLost = true
						box:CaptureFocus()
					end
				end
			end
		end
		RowFrame.MouseEnter:Connect(setRowSelection)

		function ValueChangerInstance:SetZIndex(newZIndex)
			box.ZIndex = newZIndex
		end

		function ValueChangerInstance:SetInteractable(interactable)
			box.Selectable = interactable
			if not interactable then
				box.TextColor3 = Color3.fromRGB(49,49,49)
				box.ZIndex = 1
			else
				box.TextColor3 = Color3.fromRGB(178,178,178)
				box.ZIndex = 2
			end
		end

		function ValueChangerInstance:SetValue(value) -- should this do more?
			box.Text = value
		end

		local valueChangedEvent = Instance.new("BindableEvent")
		valueChangedEvent.Name = "ValueChanged"

		box.FocusLost:Connect(function()
			valueChangedEvent:Fire(box.Text)
		end)

		ValueChangerInstance.ValueChanged = valueChangedEvent.Event

		UserInputService.InputBegan:Connect(processInput)
	end

	ValueChangerInstance.Name = rowDisplayName .. "ValueChanger"

	nextRowPositionY = nextRowPositionY + ROW_HEIGHT
	if extraSpacing then
		nextRowPositionY = nextRowPositionY + extraSpacing
	end

	nextPosTable[pageToAddTo] = nextRowPositionY

	if isARealRow then
		local setRowSelection = function()
			local fullscreenDropDown = CoreGui.RobloxGui:FindFirstChild("DropDownFullscreenFrame")
			if fullscreenDropDown and fullscreenDropDown.Visible then return end

			local valueFrame = ValueChangerInstance.SliderFrame
			if not valueFrame then
				valueFrame = ValueChangerInstance.SliderFrame
			end
			if not valueFrame then
				valueFrame = ValueChangerInstance.DropDownFrame
			end
			if not valueFrame then
				valueFrame = ValueChangerInstance.SelectorFrame
			end

			if valueFrame and valueFrame.Visible and valueFrame.ZIndex > 1 and usesSelectedObject() and pageToAddTo.Active then
				GuiService.SelectedCoreObject = valueFrame
			end
		end
		RowFrame.MouseEnter:Connect(setRowSelection)

		--Could this be cleaned up even more?
		local function onVREnabled(prop)
			if prop == "VREnabled" then
				if VRService.VREnabled then
					RowFrame.Selectable = true
					RowFrame.Active = true
					ValueChangerSelection.Active = true
					GuiService.Changed:Connect(function(prop)
						if prop == "SelectedCoreObject" then
							local selected = GuiService.SelectedCoreObject
							if selected and (selected == RowFrame or selected:IsDescendantOf(RowFrame)) then
								RowFrame.ImageTransparency = 0.5
								RowFrame.BackgroundTransparency = 1
							else
								RowFrame.ImageTransparency = 1
								RowFrame.BackgroundTransparency = 1
							end
						end
					end)
				else
					RowFrame.Selectable = false
					RowFrame.Active = false
				end
			end
		end
		VRService.Changed:Connect(onVREnabled)
		onVREnabled("VREnabled")

		ValueChangerSelection.SelectionGained:Connect(function()
			if usesSelectedObject() then
				if VRService.VREnabled then
					RowFrame.ImageTransparency = 0.5
					RowFrame.BackgroundTransparency = 1
				else
					RowFrame.ImageTransparency = 1
					RowFrame.BackgroundTransparency = 0.5
				end

				if ValueChangerInstance.HubRef then
					ValueChangerInstance.HubRef:ScrollToFrame(RowFrame)
				end
			end
		end)
		ValueChangerSelection.SelectionLost:Connect(function()
			if usesSelectedObject() then
				RowFrame.ImageTransparency = 1
				RowFrame.BackgroundTransparency = 1
			end
		end)
	end

	pageToAddTo:AddRow(RowFrame, RowLabel, ValueChangerInstance, extraSpacing, false)

	ValueChangerInstance.Selection = ValueChangerSelection

	return RowFrame, RowLabel, ValueChangerInstance
end

local function AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
	local nextRowPositionY = 0

	if nextPosTable[pageToAddTo] then
		nextRowPositionY = nextPosTable[pageToAddTo]
	end

	local RowFrame = Util.Create'ImageButton'
	{
		Name = rowDisplayName .. "Frame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Image = "rbxasset://textures/ui/VR/rectBackgroundWhite.png",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(10,10,10,10),
		ImageTransparency = 1,
		Active = false,
		AutoButtonColor = false,
		Size = UDim2.new(1,0,0,ROW_HEIGHT),
		Position = UDim2.new(0,0,0,nextRowPositionY),
		ZIndex = 2,
		Selectable = false,
		SelectionImageObject = noSelectionObject,
		Parent = pageToAddTo.Page
	};
	RowFrame.ImageColor3 = RowFrame.BackgroundColor3
	RowFrame.SelectionGained:Connect(function()
		RowFrame.BackgroundTransparency = 0.5
	end)
	RowFrame.SelectionLost:Connect(function()
		RowFrame.BackgroundTransparency = 1
	end)

	local RowLabel = Util.Create'TextLabel'
	{
		Name = rowDisplayName .. "Label",
		Text = rowDisplayName,
		Font = Enum.Font.SourceSansBold,
		TextSize = 16,
		TextColor3 = Color3.fromRGB(255,255,255),
		TextXAlignment = Enum.TextXAlignment.Left,
		BackgroundTransparency = 1,
		Size = UDim2.new(0,200,1,0),
		Position = UDim2.new(0,10,0,0),
		ZIndex = 2,
		Parent = RowFrame
	};
	local function onResized(viewportSize, portrait)
		if portrait then
			RowLabel.TextSize = 16
		else
			RowLabel.TextSize = isTenFootInterface() and 36 or 24
		end
	end
	addOnResizedCallback(RowFrame, onResized)

	if extraSpacing then
		RowFrame.Position = UDim2.new(RowFrame.Position.X.Scale,RowFrame.Position.X.Offset,
			RowFrame.Position.Y.Scale,RowFrame.Position.Y.Offset + extraSpacing)
	end

	nextRowPositionY = nextRowPositionY + ROW_HEIGHT
	if extraSpacing then
		nextRowPositionY = nextRowPositionY + extraSpacing
	end

	nextPosTable[pageToAddTo] = nextRowPositionY

	local setRowSelection = function()
		if RowFrame.Visible then
			GuiService.SelectedCoreObject = RowFrame
		end
	end
	RowFrame.MouseEnter:Connect(setRowSelection)

	rowObject.SelectionImageObject = noSelectionObject

	rowObject.SelectionGained:Connect(function()
		if VRService.VREnabled then
			RowFrame.ImageTransparency = 0.5
			RowFrame.BackgroundTransparency = 1
		else
			RowFrame.ImageTransparency = 1
			RowFrame.BackgroundTransparency = 0.5
		end
	end)
	rowObject.SelectionLost:Connect(function()
		RowFrame.ImageTransparency = 1
		RowFrame.BackgroundTransparency = 1
	end)

	rowObject.Parent = RowFrame

	pageToAddTo:AddRow(RowFrame, RowLabel, rowObject, extraSpacing, true)
	return RowFrame
end

-------- public facing API ----------------
local moduleApiTable = {}

function moduleApiTable:Create(instanceType)
	return function(data)
		local obj = Instance.new(instanceType)
		local parent = nil
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			elseif k == 'Parent' then
				parent = v
			else
				obj[k] = v
			end
		end
		if parent then
			obj.Parent = parent
		end
		return obj
	end
end

-- RayPlaneIntersection (shortened)
-- http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
function moduleApiTable:RayPlaneIntersection(ray, planeNormal, pointOnPlane)
	planeNormal = planeNormal.unit
	ray = ray.Unit

	local Vd = planeNormal:Dot(ray.Direction)
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	return ray.Origin + ray.Direction * t
end

function moduleApiTable:GetEaseLinear()
	return Linear
end
function moduleApiTable:GetEaseOutQuad()
	return EaseOutQuad
end
function moduleApiTable:GetEaseInOutQuad()
	return EaseInOutQuad
end

function moduleApiTable:CreateNewSlider(numOfSteps, startStep, minStep)
	return CreateNewSlider(numOfSteps, startStep, minStep)
end

function moduleApiTable:CreateNewSelector(selectionStringTable, startPosition)
	return CreateSelector(selectionStringTable, startPosition)
end

function moduleApiTable:CreateNewDropDown(dropDownStringTable, startPosition)
	return CreateDropDown(dropDownStringTable, startPosition, nil)
end

function moduleApiTable:AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
	return AddNewRow(pageToAddTo, rowDisplayName, selectionType, rowValues, rowDefault, extraSpacing)
end

function moduleApiTable:AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
	return AddNewRowObject(pageToAddTo, rowDisplayName, rowObject, extraSpacing)
end

function moduleApiTable:ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
	ShowAlert(alertMessage, okButtonText, settingsHub, okPressedFunc, hasBackground)
end

function moduleApiTable:IsSmallTouchScreen()
	return isSmallTouchScreen()
end

function moduleApiTable:IsPortrait()
	return isPortrait()
end

function moduleApiTable:MakeStyledButton(name, text, size, clickFunc, pageRef, hubRef)
	return MakeButton(name, text, size, clickFunc, pageRef, hubRef)
end

function moduleApiTable:MakeStyledImageButton(name, image, size, imageSize, clickFunc, pageRef, hubRef)
	return MakeImageButton(name, image, size, imageSize, clickFunc, pageRef, hubRef)
end

function moduleApiTable:AddButtonRow(pageToAddTo, name, text, size, clickFunc, hubRef)
	return AddButtonRow(pageToAddTo, name, text, size, clickFunc, hubRef)
end

function moduleApiTable:CreateSignal()
	return CreateSignal()
end

function  moduleApiTable:UsesSelectedObject()
	return usesSelectedObject()
end

function moduleApiTable:TweenProperty(instance, prop, start, final, duration, easingFunc, cbFunc)
	return PropertyTweener(instance, prop, start, final, duration, easingFunc, cbFunc)
end

function moduleApiTable:OnResized(key, callback)
	return addOnResizedCallback(key, callback)
end

function moduleApiTable:FireOnResized()
	local newSize = getViewportSize()
	local portrait = moduleApiTable:IsPortrait()

	for key, callback in pairs(onResizedCallbacks) do
		callback(newSize, portrait)
	end
end

-- Returns an interpolation between position0 and position1.
--	Returns position0 when t = 0, and position1 when t = 1.
function moduleApiTable:Lerp(t, position0, position1)
	return (1 - t) * position0 + t * position1
end

-- Returns a rounded number
function moduleApiTable:Round(n)
	return n % 1 >= 0.5 and math.ceil(n) or math.floor(n)
end


return moduleApiTable
]]></ProtectedString>
										<string name="ScriptGuid">{1359BBAA-8D6F-41B7-A690-93FE93D50465}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Utility</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXDB3E26DE1F9347E58DA479CCCAEAC8C9">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local LocalizationService = game:GetService("LocalizationService")
local Players = game:GetService("Players")
local CoreGui = game.Players.LocalPlayer.PlayerGui
local RobloxGui = CoreGui:WaitForChild("BackpackGui")

local CoreScriptTranslateGameText = false

local playerTranslator = nil
local player = nil
local localeId = nil
local localeIdConnection = nil
local localeChangedEvent = Instance.new("BindableEvent")

local function handlePlayerOrLocaleChanged()
    if player and player.LocaleId ~= localeId then
        localeId = player.LocaleId
        localeChangedEvent:Fire(localeId)
    end
end

local function reset()
    playerTranslator = nil
    player = nil

    if localeIdConnection then
        localeIdConnection:Disconnect()
        localeIdConnection = nil
    end
end

local function getTranslator()
    if not playerTranslator then
        player = Players.LocalPlayer
        if player then
            playerTranslator = LocalizationService:GetTranslatorForPlayer(player)

            handlePlayerOrLocaleChanged()
            localeIdConnection = player:GetPropertyChangedSignal("LocaleId"):Connect(handlePlayerOrLocaleChanged)
        end
    end
    return playerTranslator
end

local registryInfoMap = {}

local function unregisterGui(element)
    registryInfoMap[element].connection:Disconnect()
    registryInfoMap[element] = nil
end

local function makeAncestryChangedHandler(element, info)
    return function(child, parent)
        if not game:IsAncestorOf(element) then
            if info.hasBeenAdded then
                unregisterGui(element)
            end
        else
            info.hasBeenAdded = true
        end
    end
end

local function updateRegistryInfo(info, context, text)
    info.context = context
    info.text = text
end

local function makeRegistryInfo(element, context, text)
    local info = { hasBeenAdded = game:IsAncestorOf(element) }
    updateRegistryInfo(info, context, text)
    info.connection = element.AncestryChanged:Connect(
        makeAncestryChangedHandler(element, info))
    return info
end

local function registerGui(element, context, text)
    if registryInfoMap[element] == nil then
        registryInfoMap[element] = makeRegistryInfo(element, context, text)
    else
        updateRegistryInfo(registryInfoMap[element], context, text)
    end
end

if CoreScriptTranslateGameText then
    Players:GetPropertyChangedSignal("LocalPlayer"):Connect(function()
        reset()
        getTranslator()
    end)
end

local GameTranslator = {}

GameTranslator.LocaleChanged = localeChangedEvent.Event

-- This is meant for translating user game text that appears under CoreGui.
-- It uses Player.LocaleId and the LocalizationTables under LocalizationService.
-- This includes team names, score names, tool names, and notification toasts.
-- DO NOT USE THIS TO TRANSLATE ROBLOX TEXT IN ROBLOX GUIS!!!
-- Text from Roblox in Roblox guis should use LocalizationService.RobloxLocaleId
-- and the CoreScriptLocalization table, NOT user tables with the game locale ID.

function GameTranslator:TranslateGameText(context, text)
    if CoreScriptTranslateGameText then
        local translator = getTranslator()
        if translator then
            return translator:RobloxOnlyTranslate(context, text)
        else
            return text
        end
    else
        return text
    end
end

local function retranslateAll()
    for element, info in pairs(registryInfoMap) do
        element.Text = GameTranslator:TranslateGameText(info.context, info.text)
    end
end

if CoreScriptTranslateGameText then
    LocalizationService.AutoTranslateWillRun:Connect(retranslateAll)
end

function GameTranslator:TranslateAndRegister(element, context, text)
    if CoreScriptTranslateGameText then
        element.Text = self:TranslateGameText(context, text)
        registerGui(element, context, text)
    end

    return text
end

return GameTranslator
]]></ProtectedString>
										<string name="ScriptGuid">{CA21C7ED-AB31-43BC-94FC-2CBBB889181E}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">GameTranslator</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXA1A4A87FC6ED4F70A99D01C93DB63353">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local LocalizationService = game:GetService("LocalizationService")
local CoreGui = game.Players.LocalPlayer.PlayerGui
local RobloxGui = CoreGui:WaitForChild("BackpackGui")
local Players = game:GetService("Players")
local FFlagCoreScriptEnableRobloxTranslatorFallback = false

local FALLBACK_ENGLISH_TRANSLATOR
if FFlagCoreScriptEnableRobloxTranslatorFallback then
    FALLBACK_ENGLISH_TRANSLATOR = false
end

-- Waiting for the player ensures that the RobloxLocaleId has been set.
if Players.LocalPlayer == nil then
    Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
end

local coreScriptTableTranslator
local function getTranslator()
    if coreScriptTableTranslator == nil then
        coreScriptTableTranslator = CoreGui.CoreScriptLocalization:GetTranslator(
            LocalizationService.RobloxLocaleId)
    end
    return coreScriptTableTranslator
end

local translatorsCache = {}

local function getTranslatorForLocale(locale)
    local translator = translatorsCache[locale]
    if translator then
        return translator
    end

    translator = CoreGui.CoreScriptLocalization:GetTranslator(locale)
    translatorsCache[locale] = translator

    return translator
end

local function formatByKeyWithFallback(key, args, translator)
    local success, result = pcall(function()
        return translator:FormatByKey(key, args)
    end)

    if success then
        return result
    else
        return FALLBACK_ENGLISH_TRANSLATOR:FormatByKey(key, args)
    end
end

local RobloxTranslator = {}

function RobloxTranslator:FormatByKey(key, args)
    if FFlagCoreScriptEnableRobloxTranslatorFallback then
        return formatByKeyWithFallback(key, args, getTranslator())
    else
        return getTranslator():FormatByKey(key, args)
    end
end

function RobloxTranslator:FormatByKeyForLocale(key, locale, args)
    if FFlagCoreScriptEnableRobloxTranslatorFallback then
        return formatByKeyWithFallback(key, args, getTranslatorForLocale(locale))
    else
        return getTranslatorForLocale(locale):FormatByKey(key, args)
    end
end

return RobloxTranslator
]]></ProtectedString>
										<string name="ScriptGuid">{903C44F8-F0F7-4396-877E-5792B66E1784}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">RobloxTranslator</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXF5C0B98B79164CFF9383BB1DD8F02946">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[--[[
	
	The majority of this code is an interface designed to make it easy for you to
	work with TopbarPlus (most methods for instance reference :modifyTheme()).
	The processing overhead mainly consists of applying themes and calculating 
	appearance (such as size and width of labels) which is handled in about
	200 lines of code here and the Widget UI module. This has been achieved
	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
	features like UIListLayouts.


	v3 provides inbuilt support for controllers (simply press DPadUp),
	touch devices (phones, tablets , etc), localization (automatic resizing
	of widgets, autolocalize for relevant labels), backwards compatability
	with the old topbar, and more.


	My primary goals for the v3 re-write have been to:
		
	1. Improve code readability and organisation (reduced lines of code within
	   Icon+IconController from 3200 to ~950, separated UI elements, etc)
		
	2. Improve ease-of-use (themes now actually make sense and can account
	   for any modifications you want, converted to a package for
	   quick installation and easy-comparisons of new updates, etc)
	
	3. Provide support for all key features of the new Roblox topbar
	   while improving performance of the module (deferring and collecting
	   changes then calling as a singular, utilizing inbuilt Roblox features
	   such as UILIstLayouts, etc)

--]]



-- SERVICES
local LocalizationService = game:GetService("LocalizationService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TextService = game:GetService("TextService")
local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")



-- REFERENCE HANDLER
-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
-- therefore this ensures that the first required package becomes the dominant and only functioning module
local iconModule = script
local Reference = require(iconModule.Reference)
local referenceObject = Reference.getObject()
local leadPackage = referenceObject and referenceObject.Value
if leadPackage and leadPackage ~= iconModule then
	return require(leadPackage)
end
if not referenceObject then
	Reference.addToReplicatedStorage()
end



-- MODULES
local Signal = require(iconModule.Packages.GoodSignal)
local Janitor = require(iconModule.Packages.Janitor)
local Utility = require(iconModule.Utility)
local Attribute = require(iconModule.Attribute)
local Themes = require(iconModule.Features.Themes)
local Gamepad = require(iconModule.Features.Gamepad)
local Overflow = require(iconModule.Features.Overflow)
local Icon = {}
Icon.__index = Icon



--- LOCAL
local localPlayer = Players.LocalPlayer
local themes = iconModule.Features.Themes
local playerGui = localPlayer:WaitForChild("PlayerGui")
local iconsDict = {}
local anyIconSelected = Signal.new()
local elements = iconModule.Elements
local totalCreatedIcons = 0



-- PRESETUP
-- This is only used to determine if we need to apply the old topbar theme
-- I'll be removing this and associated functions once all games have
-- fully transitioned over to the new topbar
if GuiService.TopbarInset.Height == 0 then
	GuiService:GetPropertyChangedSignal("TopbarInset"):Wait()
end



-- PUBLIC VARIABLES
Icon.baseDisplayOrderChanged = Signal.new()
Icon.baseDisplayOrder = 10
Icon.baseTheme = require(themes.Default)
Icon.isOldTopbar = GuiService.TopbarInset.Height == 36
Icon.iconsDictionary = iconsDict
Icon.container = require(elements.Container)(Icon)
Icon.topbarEnabled = true
Icon.iconAdded = Signal.new()
Icon.iconRemoved = Signal.new()
Icon.iconChanged = Signal.new()



-- PUBLIC FUNCTIONS
function Icon.getIcons()
	return Icon.iconsDictionary
end

function Icon.getIconByUID(UID)
	local match = Icon.iconsDictionary[UID]
	if match then
		return match
	end
end

function Icon.getIcon(nameOrUID)
	local match = Icon.getIconByUID(nameOrUID)
	if match then
		return match
	end
	for _, icon in pairs(iconsDict) do
		if icon.name == nameOrUID then
			return icon
		end
	end
end

function Icon.setTopbarEnabled(bool, isInternal)
	if typeof(bool) ~= "boolean" then
		bool = Icon.topbarEnabled
	end
	if not isInternal then
		Icon.topbarEnabled = bool
	end
	for _, screenGui in pairs(Icon.container) do
		screenGui.Enabled = bool
	end
end

function Icon.modifyBaseTheme(modifications)
	modifications = Themes.getModifications(modifications)
	for _, modification in pairs(modifications) do
		for _, detail in pairs(Icon.baseTheme) do
			Themes.merge(detail, modification)
		end
	end
	for _, icon in pairs(iconsDict) do
		icon:setTheme(Icon.baseTheme)
	end
end

function Icon.setDisplayOrder(int)
	Icon.baseDisplayOrder = int
	Icon.baseDisplayOrderChanged:Fire(int)
end



-- SETUP
task.defer(Gamepad.start, Icon)
task.defer(Overflow.start, Icon)
for _, screenGui in pairs(Icon.container) do
	screenGui.Parent = playerGui
end
if Icon.isOldTopbar then
	Icon.modifyBaseTheme(require(themes.Classic))
end



-- CONSTRUCTOR
function Icon.new()
	local self = {}
	setmetatable(self, Icon)

	--- Janitors (for cleanup)
	local janitor = Janitor.new()
	self.janitor = janitor
	self.themesJanitor = janitor:add(Janitor.new())
	self.singleClickJanitor = janitor:add(Janitor.new())
	self.captionJanitor = janitor:add(Janitor.new())
	self.joinJanitor = janitor:add(Janitor.new())
	self.menuJanitor = janitor:add(Janitor.new())
	self.dropdownJanitor = janitor:add(Janitor.new())

	-- Register
	local iconUID = Utility.generateUID()
	iconsDict[iconUID] = self
	janitor:add(function()
		iconsDict[iconUID] = nil
	end)

	-- Signals (events)
	self.selected = janitor:add(Signal.new())
	self.deselected = janitor:add(Signal.new())
	self.toggled = janitor:add(Signal.new())
	self.viewingStarted = janitor:add(Signal.new())
	self.viewingEnded = janitor:add(Signal.new())
	self.stateChanged = janitor:add(Signal.new())
	self.notified = janitor:add(Signal.new())
	self.noticeStarted = janitor:add(Signal.new())
	self.noticeChanged = janitor:add(Signal.new())
	self.endNotices = janitor:add(Signal.new())
	self.toggleKeyAdded = janitor:add(Signal.new())
	self.fakeToggleKeyChanged = janitor:add(Signal.new())
	self.alignmentChanged = janitor:add(Signal.new())
	self.updateSize = janitor:add(Signal.new())
	self.resizingComplete = janitor:add(Signal.new())
	self.joinedParent = janitor:add(Signal.new())
	self.menuSet = janitor:add(Signal.new())
	self.dropdownSet = janitor:add(Signal.new())
	self.updateMenu = janitor:add(Signal.new())
	self.startMenuUpdate = janitor:add(Signal.new())
	self.childThemeModified = janitor:add(Signal.new())
	self.indicatorSet = janitor:add(Signal.new())
	self.dropdownChildAdded = janitor:add(Signal.new())
	self.menuChildAdded = janitor:add(Signal.new())

	-- Properties
	self.iconModule = iconModule
	self.UID = iconUID
	self.isEnabled = true
	self.isSelected = false
	self.isViewing = false
	self.joinedFrame = false
	self.parentIconUID = false
	self.deselectWhenOtherIconSelected = true
	self.totalNotices = 0
	self.activeState = "Deselected"
	self.alignment = ""
	self.originalAlignment = ""
	self.appliedTheme = {}
	self.appearance = {}
	self.cachedInstances = {}
	self.cachedNamesToInstances = {}
	self.cachedCollectives = {}
	self.bindedToggleKeys = {}
	self.customBehaviours = {}
	self.toggleItems = {}
	self.bindedEvents = {}
	self.notices = {}
	self.menuIcons = {}
	self.dropdownIcons = {}
	self.childIconsDict = {}
	self.isOldTopbar = Icon.isOldTopbar
	self.creationTime = os.clock()

	-- Widget is the new name for an icon
	local widget = janitor:add(require(elements.Widget)(self, Icon))
	self.widget = widget
	self:setAlignment()
	
	-- It's important we set an order otherwise icons will not align
	-- correctly within menus
	totalCreatedIcons += 1
	local ourOrder = totalCreatedIcons
	self:setOrder(ourOrder)

	-- This applies the default them
	self:setTheme(Icon.baseTheme)

	-- Button Clicked (for states "Selected" and "Deselected")
	local clickRegion = self:getInstance("ClickRegion")
	local function handleToggle()
		if self.locked then
			return
		end
		if self.isSelected then
			self:deselect("User", self)
		else
			self:select("User", self)
		end
	end
	local isTouchTapping = false
	local isClicking = false
	clickRegion.MouseButton1Click:Connect(function()
		if isTouchTapping then
			return
		end
		isClicking = true
		task.delay(0.01, function()
			isClicking = false
		end)
		handleToggle()
	end)
	clickRegion.TouchTap:Connect(function()
		-- This resolves the bug report by @28Pixels:
		-- https://devforum.roblox.com/t/topbarplus/1017485/1104
		if isClicking then
			return
		end
		isTouchTapping = true
		task.delay(0.01, function()
			isTouchTapping = false
		end)
		handleToggle()
	end)

	-- Keys can be bound to toggle between Selected and Deselected
	janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
		if self.locked then
			return
		end
		if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
			handleToggle()
		end
	end))

	-- Button Hovering (for state "Viewing")
	-- Hovering is a state only for devices with keyboards
	-- and controllers (not touchpads)
	local function viewingStarted(dontSetState)
		if self.locked then
			return
		end
		self.isViewing = true
		self.viewingStarted:Fire(true)
		if not dontSetState then
			self:setState("Viewing", "User", self)
		end
	end
	local function viewingEnded()
		if self.locked then
			return
		end
		self.isViewing = false
		self.viewingEnded:Fire(true)
		self:setState(nil, "User", self)
	end
	self.joinedParent:Connect(function()
		if self.isViewing then
			viewingEnded()
		end
	end)
	clickRegion.MouseEnter:Connect(function()
		local dontSetState = not UserInputService.KeyboardEnabled
		viewingStarted(dontSetState)
	end)
	local touchCount = 0
	janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
	clickRegion.MouseLeave:Connect(viewingEnded)
	clickRegion.SelectionGained:Connect(viewingStarted)
	clickRegion.SelectionLost:Connect(viewingEnded)
	clickRegion.MouseButton1Down:Connect(function()
		if not self.locked and UserInputService.TouchEnabled then
			touchCount += 1
			local myTouchCount = touchCount
			task.delay(0.2, function()
				if myTouchCount == touchCount then
					viewingStarted()
				end
			end)
		end
	end)
	clickRegion.MouseButton1Up:Connect(function()
		touchCount += 1
	end)

	-- Handle overlay on viewing
	local iconOverlay = self:getInstance("IconOverlay")
	self.viewingStarted:Connect(function()
		iconOverlay.Visible = not self.overlayDisabled
	end)
	self.viewingEnded:Connect(function()
		iconOverlay.Visible = false
	end)

	-- Deselect when another icon is selected
	janitor:add(anyIconSelected:Connect(function(incomingIcon)
		if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
			self:deselect("AutoDeselect", incomingIcon)
		end
	end))

	-- This checks if the script calling this module is a descendant of a ScreenGui
	-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
	-- client respawns. This solves one of the most asked about questions on the post
	-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
	-- the LocalScript rests within
	local source =  debug.info(2, "s")
	local sourcePath = string.split(source, ".")
	local origin = game
	local originsScreenGui
	for i, sourceName in pairs(sourcePath) do
		origin = origin:FindFirstChild(sourceName)
		if not origin then
			break
		end
		if origin:IsA("ScreenGui") then
			originsScreenGui = origin
		end
	end
	if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
		Utility.localPlayerRespawned(function()
			self:destroy()
		end)
	end

	-- Additional children behaviour when toggled (mostly notices)
	local noticeLabel = self:getInstance("NoticeLabel")
	self.toggled:Connect(function(isSelected)
		self.noticeChanged:Fire(self.totalNotices)
		for childIconUID, _ in pairs(self.childIconsDict) do
			local childIcon = Icon.getIconByUID(childIconUID)
			childIcon.noticeChanged:Fire(childIcon.totalNotices)
			if not isSelected and childIcon.isSelected then
				-- If an icon within a menu or dropdown is also
				-- a dropdown or menu, then close it
				for _, _ in pairs(childIcon.childIconsDict) do
					childIcon:deselect("HideParentFeature", self)
				end
			end
		end
	end)
	
	-- This closes/reopens the chat or playerlist if the icon is a dropdown
	-- In the future I'd prefer to use the position+size of the chat
	-- to determine whether to close dropdown (instead of non-right-set)
	-- but for reasons mentioned here it's unreliable at the time of
	-- writing this: https://devforum.roblox.com/t/here/2794915
	-- I could also make this better by accounting for multiple
	-- dropdowns being open (not just this one) but this will work
	-- fine for almost every use case for now.
	self.selected:Connect(function()
		local isDropdown = #self.dropdownIcons > 0
		if isDropdown then
			if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
				self.chatWasPreviouslyActive = true
				StarterGui:SetCore("ChatActive", false)
			end
			if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
				self.playerlistWasPreviouslyActive = true
				StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
			end
		end
	end)
	self.deselected:Connect(function()
		if self.chatWasPreviouslyActive then
			self.chatWasPreviouslyActive = nil
			StarterGui:SetCore("ChatActive", true)
		end
		if self.playerlistWasPreviouslyActive then
			self.playerlistWasPreviouslyActive = nil
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
		end
	end)
	
	-- There's a rare occassion where the appearance is not
	-- fully set to deselected so this ensures the icons
	-- appearance is fully as it should be
	--print("self.activeState =", self.activeState)
	task.delay(0.1, function()
		if self.activeState == "Deselected" then
			self.stateChanged:Fire("Deselected")
			self:refresh()
		end
	end)
	
	-- Call icon added
	Icon.iconAdded:Fire(self)

	return self
end



-- METHODS
function Icon:setName(name)
	self.widget.Name = name
	self.name = name
	return self
end

function Icon:setState(incomingStateName, fromSource, sourceIcon)
	-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
	-- a users mouse enters the widget), then informing other systems of this state change to then act upon
	-- (such as the theme handler applying the theme which corresponds to that state).
	if not incomingStateName then
		incomingStateName = (self.isSelected and "Selected") or "Deselected"
	end
	local stateName = Utility.formatStateName(incomingStateName)
	local previousStateName = self.activeState
	if previousStateName == stateName then
		return
	end
	local currentIsSelected = self.isSelected
	self.activeState = stateName
	if stateName == "Deselected" then
		self.isSelected = false
		if currentIsSelected then
			self.toggled:Fire(false, fromSource, sourceIcon)
			self.deselected:Fire(fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(false, fromSource, sourceIcon)
	elseif stateName == "Selected" then
		self.isSelected = true
		if not currentIsSelected then
			self.toggled:Fire(true, fromSource, sourceIcon)
			self.selected:Fire(fromSource, sourceIcon)
			anyIconSelected:Fire(self, fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(true, fromSource, sourceIcon)
	end
	self.stateChanged:Fire(stateName, fromSource, sourceIcon)
end

function Icon:getInstance(name)
	-- This enables us to easily retrieve instances located within the icon simply by passing its name.
	-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
	-- We cache the result for more performant retrieval in the future.
	local instance = self.cachedNamesToInstances[name]
	if instance then
		return instance
	end
	local function cacheInstance(childName, child)
		local currentCache = self.cachedInstances[child]
		if not currentCache then
			local collectiveName = child:GetAttribute("Collective")
			local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
			if cachedCollective then
				table.insert(cachedCollective, child)
			end
			self.cachedNamesToInstances[childName] = child
			self.cachedInstances[child] = true
			child.Destroying:Once(function()
				self.cachedNamesToInstances[childName] = nil
				self.cachedInstances[child] = nil
			end)
		end
	end
	local widget = self.widget
	cacheInstance("Widget", widget)
	if name == "Widget" then
		return widget
	end

	local returnChild
	local function scanChildren(parentInstance)
		for _, child in pairs(parentInstance:GetChildren()) do
			local widgetUID = child:GetAttribute("WidgetUID")
			if widgetUID and widgetUID ~= self.UID then
				-- This prevents instances within other icons from being recorded
				-- (for instance when other icons are added to this icons menu)
				continue
			end
			-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
			-- then its important we scan the real original instance instead of this clone
			local previousChild = child
			local realChild = Themes.getRealInstance(child)
			if realChild then
				child = realChild
			end
			-- Finally scan its children
			scanChildren(child)
			if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
				local childName = child.Name
				cacheInstance(childName, child)
				if childName == name then
					returnChild = child
				end
			end
		end
	end
	scanChildren(widget)
	return returnChild
end

function Icon:getCollective(name)
	-- A collective is an array of instances within the Widget that have been
	-- grouped together based on a given name. This just makes it easy
	-- to act on multiple instances at once which share similar behaviours.
	-- For instance, if we want to change the icons corner size, all corner instances
	-- with the attribute "Collective" and value "WidgetCorner" could be updated
	-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
	local collective = self.cachedCollectives[name]
	if collective then
		return collective
	end
	collective = {}
	for instance, _ in pairs(self.cachedInstances) do
		if instance:GetAttribute("Collective") == name then
			table.insert(collective, instance)
		end
	end
	self.cachedCollectives[name] = collective
	return collective
end

function Icon:getInstanceOrCollective(collectiveOrInstanceName)
	-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
	-- an array of instances instead of a single instance
	local instances = {}
	local instance = self:getInstance(collectiveOrInstanceName)
	if instance then
		table.insert(instances, instance)
	end
	if #instances == 0 then
		instances = self:getCollective(collectiveOrInstanceName)
	end
	return instances
end

function Icon:getStateGroup(iconState)
	local chosenState = iconState or self.activeState
	local stateGroup = self.appearance[chosenState]
	if not stateGroup then
		stateGroup = {}
		self.appearance[chosenState] = stateGroup
	end
	return stateGroup
end

function Icon:refreshAppearance(instance, specificProperty)
	Themes.refresh(self, instance, specificProperty)
	return self
end

function Icon:refresh()
	self:refreshAppearance(self.widget)
	self.updateSize:Fire()
	return self
end

function Icon:updateParent()
	local parentIcon = Icon.getIconByUID(self.parentIconUID)
	if parentIcon then
		parentIcon.updateSize:Fire()
	end
end

function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
	-- You can specify your own custom callback to handle custom logic just before
	-- an instances property is changed by using :setBehaviour()
	local key = collectiveOrInstanceName.."-"..property
	self.customBehaviours[key] = callback
	if refreshAppearance then
		local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
		for _, instance in pairs(instances) do
			self:refreshAppearance(instance, property)
		end
	end
end

function Icon:modifyTheme(modifications, modificationUID)
	local modificationUID = Themes.modify(self, modifications, modificationUID)
	return self, modificationUID
end

function Icon:modifyChildTheme(modifications, modificationUID)
	-- Same as modifyTheme except for its children (i.e. icons
	-- within its dropdown or menu)
	self.childModifications = modifications
	self.childModificationsUID = modificationUID
	for childIconUID, _ in pairs(self.childIconsDict) do
		local childIcon = Icon.getIconByUID(childIconUID)
		childIcon:modifyTheme(modifications, modificationUID)
	end
	self.childThemeModified:Fire()
	return self
end

function Icon:removeModification(modificationUID)
	Themes.remove(self, modificationUID)
	return self
end

function Icon:removeModificationWith(instanceName, property, state)
	Themes.removeWith(self, instanceName, property, state)
	return self
end

function Icon:setTheme(theme)
	Themes.set(self, theme)
	return self
end

function Icon:setEnabled(bool)
	self.isEnabled = bool
	self.widget.Visible = bool
	self:updateParent()
	return self
end

function Icon:select(fromSource, sourceIcon)
	self:setState("Selected", fromSource, sourceIcon)
	return self
end

function Icon:deselect(fromSource, sourceIcon)
	self:setState("Deselected", fromSource, sourceIcon)
	return self
end

function Icon:notify(customClearSignal, noticeId)
	-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
	-- users of changes/updates within your UI such as a Catalog
	-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
	-- Roblox event (e.g. Instance.new("BindableEvent").Event)
	local notice = self.notice
	if not notice then
		notice = require(elements.Notice)(self, Icon)
		self.notice = notice
	end
	self.noticeStarted:Fire(customClearSignal, noticeId)
	return self
end

function Icon:clearNotices()
	self.endNotices:Fire()
	return self
end

function Icon:disableOverlay(bool)
	self.overlayDisabled = bool
	return self
end
Icon.disableStateOverlay = Icon.disableOverlay

function Icon:setImage(imageId, iconState)
	self:modifyTheme({"IconImage", "Image", imageId, iconState})
	return self
end

function Icon:setLabel(text, iconState)
	self:modifyTheme({"IconLabel", "Text", text, iconState})
	return self
end

function Icon:setOrder(int, iconState)
	self:modifyTheme({"Widget", "LayoutOrder", int, iconState})
	return self
end

function Icon:setCornerRadius(udim, iconState)
	self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
	return self
end

function Icon:align(leftCenterOrRight, isFromParentIcon)
	-- Determines the side of the screen the icon will be ordered
	local direction = tostring(leftCenterOrRight):lower()
	if direction == "mid" or direction == "centre" then
		direction = "center"
	end
	if direction ~= "left" and direction ~= "center" and direction ~= "right" then
		direction = "left"
	end
	local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
	local holders = screenGui.Holders
	local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
	if not isFromParentIcon then
		self.originalAlignment = finalDirection
	end
	local joinedFrame = self.joinedFrame
	local alignmentHolder = holders[finalDirection]
	self.screenGui = screenGui
	self.alignmentHolder = alignmentHolder
	if not self.isDestroyed then
		self.widget.Parent = joinedFrame or alignmentHolder
	end
	self.alignment = finalDirection
	self.alignmentChanged:Fire(finalDirection)
	Icon.iconChanged:Fire(self)
	return self
end
Icon.setAlignment = Icon.align

function Icon:setLeft()
	self:setAlignment("Left")
	return self
end

function Icon:setMid()
	self:setAlignment("Center")
	return self
end

function Icon:setRight()
	self:setAlignment("Right")
	return self
end

function Icon:setWidth(offsetMinimum, iconState)
	-- This sets a minimum X offset size for the widget, useful
	-- for example if you're constantly changing the label
	-- but don't want the icon to resize every time
	local newSize = UDim2.fromOffset(offsetMinimum, self.widget.Size.Y.Offset)
	self:modifyTheme({"Widget", "Size", newSize, iconState})
	self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
	return self
end

function Icon:setImageScale(number, iconState)
	self:modifyTheme({"IconImageScale", "Value", number, iconState})
	return self
end

function Icon:setImageRatio(number, iconState)
	self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
	return self
end

function Icon:setTextSize(number, iconState)
	self:modifyTheme({"IconLabel", "TextSize", number, iconState})
	return self
end

function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
	fontWeight = fontWeight or Enum.FontWeight.Regular
	fontStyle = fontStyle or Enum.FontStyle.Normal
	local fontFace
	local fontType = typeof(font)
	if fontType == "number" then
		fontFace = Font.fromId(font, fontWeight, fontStyle)
	elseif fontType == "EnumItem" then
		fontFace = Font.fromEnum(font)
	elseif fontType == "string" then
		if not font:match("rbxasset") then
			fontFace = Font.fromName(font, fontWeight, fontStyle)
		end
	end
	if not fontFace then
		fontFace = Font.new(font, fontWeight, fontStyle)
	end
	self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
	return self
end

function Icon:bindToggleItem(guiObjectOrLayerCollector)
	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
		error("Toggle item must be a GuiObject or LayerCollector!")
	end
	self.toggleItems[guiObjectOrLayerCollector] = true
	self:_updateSelectionInstances()
	return self
end

function Icon:unbindToggleItem(guiObjectOrLayerCollector)
	self.toggleItems[guiObjectOrLayerCollector] = nil
	self:_updateSelectionInstances()
	return self
end

function Icon:_updateSelectionInstances()
	-- This is to assist with controller navigation and selection
	-- It converts the value true to an array
	for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
		local buttonInstancesArray = {}
		for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
			if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
				table.insert(buttonInstancesArray, instance)
			end
		end
		self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
	end
end

function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
	for toggleItem, _ in pairs(self.toggleItems) do
		if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
			local property = "Visible"
			if toggleItem:IsA("LayerCollector") then
				property = "Enabled"
			end
			toggleItem[property] = bool
		end
	end
end

function Icon:bindEvent(iconEventName, eventFunction)
	local event = self[iconEventName]
	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
	self.bindedEvents[iconEventName] = event:Connect(function(...)
		eventFunction(self, ...)
	end)
	return self
end

function Icon:unbindEvent(iconEventName)
	local eventConnection = self.bindedEvents[iconEventName]
	if eventConnection then
		eventConnection:Disconnect()
		self.bindedEvents[iconEventName] = nil
	end
	return self
end

function Icon:bindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = true
	self.toggleKeyAdded:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:unbindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = nil
	return self
end

function Icon:call(callback, ...)
	local packedArgs = table.pack(...)
	task.spawn(function()
		callback(self, table.unpack(packedArgs))
	end)
	return self
end

function Icon:addToJanitor(callback)
	self.janitor:add(callback)
	return self
end

function Icon:lock()
	-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = false
	self.locked = true
	return self
end

function Icon:unlock()
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = true
	self.locked = false
	return self
end

function Icon:debounce(seconds)
	self:lock()
	task.wait(seconds)
	self:unlock()
	return self
end

function Icon:autoDeselect(bool)
	-- When set to true the icon will deselect itself automatically whenever
	-- another icon is selected
	if bool == nil then
		bool = true
	end
	self.deselectWhenOtherIconSelected = bool
	return self
end

function Icon:oneClick(bool)
	-- When set to true the icon will automatically deselect when selected, this creates
	-- the effect of a single click button
	local singleClickJanitor = self.singleClickJanitor
	singleClickJanitor:clean()
	if bool or bool == nil then
		singleClickJanitor:add(self.selected:Connect(function()
			self:deselect("OneClick", self)
		end))
	end
	self.oneClickEnabled = true
	return self
end

function Icon:setCaption(text)
	if text == "_hotkey_" and (self.captionText) then
		return self
	end
	local captionJanitor = self.captionJanitor
	self.captionJanitor:clean()
	if not text or text == "" then
		self.caption = nil
		self.captionText = nil
		return self
	end
	local caption = captionJanitor:add(require(elements.Caption)(self))
	caption:SetAttribute("CaptionText", text)
	self.caption = caption
	self.captionText = text
	return self
end

function Icon:setCaptionHint(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.fakeToggleKey = keyCodeEnum
	self.fakeToggleKeyChanged:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:leave()
	local joinJanitor = self.joinJanitor
	joinJanitor:clean()
	return self
end

function Icon:joinMenu(parentIcon)
	Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
	parentIcon.menuChildAdded:Fire(self)
	return self
end

function Icon:setMenu(arrayOfIcons)
	self.menuSet:Fire(arrayOfIcons)
	return self
end

function Icon:setFrozenMenu(arrayOfIcons)
	self:freezeMenu(arrayOfIcons)
	self:setMenu(arrayOfIcons)
end

function Icon:freezeMenu()
	-- A frozen menu is a menu which is permanently locked in the
	-- the selected state (with its toggle hidden)
	self:select("FrozenMenu", self)
	self:bindEvent("deselected", function(icon)
		icon:select("FrozenMenu", self)
	end)
	self:modifyTheme({"IconSpot", "Visible", false})
end

function Icon:joinDropdown(parentIcon)
	parentIcon:getDropdown()
	Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
	parentIcon.dropdownChildAdded:Fire(self)
	return self
end

function Icon:getDropdown()
	local dropdown = self.dropdown
	if not dropdown then
		dropdown = require(elements.Dropdown)(self)
		self.dropdown = dropdown
		self:clipOutside(dropdown)
	end
	return dropdown
end

function Icon:setDropdown(arrayOfIcons)
	self:getDropdown()
	self.dropdownSet:Fire(arrayOfIcons)
	return self
end

function Icon:clipOutside(instance)
	-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
	-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
	-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
	-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
	-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
	local instanceClone = Utility.clipOutside(self, instance)
	self:refreshAppearance(instance)
	return self, instanceClone
end

function Icon:setIndicator(keyCode)
	-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
	-- with controllers to show the user what button to press to highlight the topbar. You don't need
	-- to set an indicator for controllers as this is handled internally within the Gamepad module
	local indicator = self.indicator
	if not indicator then
		indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
		self.indicator = indicator
	end
	self.indicatorSet:Fire(keyCode)
end



-- DESTROY/CLEANUP
function Icon:destroy()
	if self.isDestroyed then
		return
	end
	self:clearNotices()
	if self.parentIconUID then
		self:leave()
	end
	self.isDestroyed = true
	self.janitor:clean()
	Icon.iconRemoved:Fire(self)
end
Icon.Destroy = Icon.destroy



return Icon]]></ProtectedString>
										<string name="ScriptGuid">{AF7308D7-DEB7-4BBF-A54F-8E4AD4A08103}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Icon</string>
										<int64 name="SourceAssetId">16049574146</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX3DB0A51F45C54461B0333F9494B25C40">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[-- v3 alone has taken 250+ hours so please consider keeping this
-- required attribute and linking to TopbarPlus within your games
-- description or devforum post. An in-game readable version also
-- makes it easier for me to debug and compare differences betewen
-- live places. Thanks! ~Ben

local RunService = game:GetService("RunService")
local GroupService = game:GetService("GroupService")
local Players = game:GetService("Players")
if not RunService:IsStudio() then
	print(` Running TopbarPlus {require(script.Parent.VERSION)} by ForeverHD`)
end

return {}]]></ProtectedString>
											<string name="ScriptGuid">{921C1913-94ED-429B-B0B1-49AEA1BEBC95}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Attribute</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX65D9373F50FE461BBB2511DB014275DD">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[-- This module enables you to place Icon wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
-- cause icons to overlap with each other

local replicatedStorage = game:GetService("ReplicatedStorage")
local Reference = {}
Reference.objectName = "TopbarPlusReference"

function Reference.addToReplicatedStorage()
	local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
	objectValue.Name = Reference.objectName
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    return objectValue
end

function Reference.getObject()
	local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
    if objectValue then
        return objectValue
    end
    return false
end

return Reference]]></ProtectedString>
											<string name="ScriptGuid">{C034798A-6302-450A-88FE-F4B64B7E1CBE}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Reference</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXC3B8DE70340B4734AA20A7F4315AC869">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source">return &quot;v3.0.2&quot;</ProtectedString>
											<string name="ScriptGuid">{829F4B00-2CCA-4F6A-A15C-C6CD116E4FA5}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">VERSION</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX9E90D398CAA742CF93AFF02CDFA0ABAF">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[-- Just generic utility functions which I use and repeat across all my projects



-- LOCAL
local Utility = {}
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer



-- FUNCTIONS
function Utility.createStagger(delayTime, callback, delayInitially)
	-- This creates and returns a function which when called
	-- acts identically to callback, however will only be called
	-- for a maximum of once per delayTime. If the returned function
	-- is called more than once during the delayTime, then it will
	-- wait until the expiryTime then perform another recall.
	-- This is useful for visual interfaces and effects which may be
	-- triggered multiple times within a frame or short period, but which
	-- we don't necessary need to (for performance reasons).
	local staggerActive = false
	local multipleCalls = false
	if not delayTime or delayTime == 0 then
		-- We make 0.01 instead of 0 because devices can now run at
		-- different frame rates
		delayTime = 0.01
	end
	local function staggeredCallback(...)
		if staggerActive then
			multipleCalls = true
			return
		end
		local packedArgs = table.pack(...)
		staggerActive = true
		multipleCalls = false
		task.spawn(function()
			if delayInitially then
				task.wait(delayTime)
			end
			callback(table.unpack(packedArgs))
		end)
		task.delay(delayTime, function()
			staggerActive = false
			if multipleCalls then
				-- This means it has been called at least once during
				-- the stagger period, so call again
				staggeredCallback(table.unpack(packedArgs))
			end
		end)
	end
	return staggeredCallback
end

function Utility.round(n)
	-- Credit to Darkmist101 for this
	return math.floor(n + 0.5)
end

function Utility.reverseTable(t)
	for i = 1, math.floor(#t/2) do
		local j = #t - i + 1
		t[i], t[j] = t[j], t[i]
	end
end

function Utility.copyTable(t)
	-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = Utility.copyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end

local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
function Utility.generateUID(length)
	length = length or 8
	local UID = ""
	local list = validCharacters
	local total = #list
	for i = 1, length do
		local randomCharacter = list[math.random(1, total)]
		UID = UID..randomCharacter
	end
	return UID
end

local instanceTrackers = {}
function Utility.setVisible(instance, bool, sourceUID)
	-- This effectively works like a buff object but
	-- incredibly simplified. It stacks false values
	-- so that if there is more than more than, the 
	-- instance remains hidden even if set visible true
	local tracker = instanceTrackers[instance]
	if not tracker then
		tracker = {}
		instanceTrackers[instance] = tracker
		instance.Destroying:Once(function()
			instanceTrackers[instance] = nil
		end)
	end
	if not bool then
		tracker[sourceUID] = true
	else
		tracker[sourceUID] = nil
	end
	local isVisible = bool
	if bool then
		for sourceUID, _ in pairs(tracker) do
			isVisible = false
			break
		end
	end
	instance.Visible = isVisible
end

function Utility.formatStateName(incomingStateName)
	return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
end

function Utility.localPlayerRespawned(callback)
	-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
	-- In these scenarios, traditional methods like CharacterAdded won't be called by the
	-- time the localscript has been destroyed, therefore we listen for removing instead
	-- If humanoid and health == 0, then reset/died normally, else was
	-- forcefully reset via a method such as LoadCharacter
	-- We wrap this behaviour in case any additional quirks need to be accounted for
	localPlayer.CharacterRemoving:Connect(callback)
end

function Utility.getClippedContainer(screenGui)
	-- We always want clipped items to display in front hence
	-- why we have this
	local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
	if not clippedContainer then
		clippedContainer = Instance.new("Folder")
		clippedContainer.Name = "ClippedContainer"
		clippedContainer.Parent = screenGui
	end
	return clippedContainer
end

local Janitor = require(script.Parent.Packages.Janitor)
local GuiService = game:GetService("GuiService")
function Utility.clipOutside(icon, instance)
	local cloneJanitor = icon.janitor:add(Janitor.new())
	instance.Destroying:Once(function()
		cloneJanitor:Destroy()
	end)
	icon.janitor:add(instance)

	local originalParent = instance.Parent
	local clone = cloneJanitor:add(Instance.new("Frame"))
	clone:SetAttribute("IsAClippedClone", true)
	clone.Name = instance.Name
	clone.AnchorPoint = instance.AnchorPoint
	clone.Size = instance.Size
	clone.Position = instance.Position
	clone.BackgroundTransparency = 1
	clone.LayoutOrder = instance.LayoutOrder
	clone.Parent = originalParent

	local valueInstance = Instance.new("ObjectValue")
	valueInstance.Name = "OriginalInstance"
	valueInstance.Value = instance
	valueInstance.Parent = clone

	local valueInstanceCopy = valueInstance:Clone()
	instance:SetAttribute("HasAClippedClone", true)
	valueInstanceCopy.Name = "ClippedClone"
	valueInstanceCopy.Value = clone
	valueInstanceCopy.Parent = instance

	local screenGui
	local function updateScreenGui()
		local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
		screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else originalScreenGui.Parent[originalScreenGui.Name.."Clipped"]
		instance.AnchorPoint = Vector2.new(0, 0)
		instance.Parent = Utility.getClippedContainer(screenGui)
	end
	cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
	updateScreenGui()

	-- Lets copy over children that modify size
	for _, child in pairs(instance:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			child:Clone().Parent = clone
		end
	end

	-- If the icon is hidden, its important we are too (as
	-- setting a parent to visible = false no longer makes
	-- this hidden)
	local widget = icon.widget
	local isOutsideParent = false
	local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
	local function updateVisibility()
		if ignoreVisibilityUpdater then
			return
		end
		local isVisible = widget.Visible
		
		if isOutsideParent then
			isVisible = false
		end
		Utility.setVisible(instance, isVisible, "ClipHandler")
	end
	cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))

	local previousScroller
	local Icon = require(icon.iconModule)
	local function checkIfOutsideParentXBounds()
		-- Defer so that roblox's properties reflect their true values
		task.defer(function()
			-- If the instance is within a parent item (such as a dropdown or menu)
			-- then we hide it if it exceeds the bounds of that parent
			local parentInstance
			local ourUID = icon.UID
			local nextIconUID = ourUID
			local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
			if shouldClipToParent then
				for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
					local nextIcon = Icon.getIconByUID(nextIconUID)
					if not nextIcon then
						break
					end
					local nextParentInstance = nextIcon.joinedFrame
					nextIconUID = nextIcon.parentIconUID
					if not nextParentInstance then
						break
					end
					parentInstance = nextParentInstance
				end
			end
			if not parentInstance then
				isOutsideParent = false
				updateVisibility()
				return
			end
			local pos = instance.AbsolutePosition
			local halfSize = instance.AbsoluteSize/2
			local parentPos = parentInstance.AbsolutePosition
			local parentSize = parentInstance.AbsoluteSize
			local posHalf = (pos + halfSize)
			local exceededLeft = posHalf.X < parentPos.X
			local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
			local exceededTop = posHalf.Y < parentPos.Y
			local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
			local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
			if hasExceeded ~= isOutsideParent then
				isOutsideParent = hasExceeded
				updateVisibility()
			end
			if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
				previousScroller = parentInstance
				local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
					checkIfOutsideParentXBounds()
				end)
				cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
			end
		end)
	end

	local camera = workspace.CurrentCamera
	local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
	local function trackProperty(property)
		local absoluteProperty = "Absolute"..property
		local function updateProperty()
			local cloneValue = clone[absoluteProperty]
			local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
			if property == "Position" then

				-- This binds the instances within the bounds of the screen
				local SIDE_PADDING = 4
				local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
				local inputX = absoluteValue.X.Offset
				if inputX < SIDE_PADDING then
					inputX = SIDE_PADDING
				elseif inputX > limitX then
					inputX = limitX
				end
				absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)

				-- AbsolutePosition does not perfectly match with TopbarInsets enabled
				-- This corrects this
				local topbarInset = GuiService.TopbarInset
				local viewportWidth = workspace.CurrentCamera.ViewportSize.X
				local guiWidth = screenGui.AbsoluteSize.X
				local guiOffset = screenGui.AbsolutePosition.X
				local widthDifference = guiOffset - topbarInset.Min.X
				local oldTopbarCenterOffset = 0--widthDifference/30 -- I have no idea why this works, it just does
				local offsetX = if icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset
				
				-- Also add additionalOffset
				offsetX -= additionalOffsetX
				absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)

				-- Finally check if within its direct parents bounds
				checkIfOutsideParentXBounds()

			end
			instance[property] = absoluteValue
		end
		
		-- This defer is essential as the listener may be in a different screenGui to the actor
		local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))
		
		-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
		-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
		-- within this type of screenGui DO NOT accurately update to match their new
		-- real world position; instead they jump around almost randomly for a few frames.
		-- I have spent way too many hours trying to solve this bug, I think the only way
		-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
		-- have time to redesign the entire system around that at the moment.
		-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
		local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))
		
	end
	task.delay(0.1, checkIfOutsideParentXBounds)
	checkIfOutsideParentXBounds()
	updateVisibility()
	trackProperty("Position")
	
	-- Track visiblity changes
	cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
		--print("Visiblity changed:", instance, clone, instance.Visible)
		--clone.Visible = instance.Visible
	end))

	-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
	local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
	if shouldTrackCloneSize then
		trackProperty("Size")
	else
		cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			local absolute = instance.AbsoluteSize
			clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end))
	end

	return clone
end

function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)

	-- This is resonsible for moving the icon under a feature like a dropdown
	local joinJanitor = originalIcon.joinJanitor
	joinJanitor:clean()
	if not scrollingFrameOrFrame then
		originalIcon:leave()
		return
	end
	originalIcon.parentIconUID = parentIcon.UID
	originalIcon.joinedFrame = scrollingFrameOrFrame
	local function updateAlignent()
		local parentAlignment = parentIcon.alignment
		if parentAlignment == "Center" then
			parentAlignment = "Left"
		end
		originalIcon:setAlignment(parentAlignment, true)
	end
	joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
	updateAlignent()
	originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
	originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
	if parentIcon.childModifications then
		-- We defer so that the default values (such as dropdown
		-- minimum width can be applied before any custom
		-- child modifications from the user)
		task.defer(function()
			originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
		end)
	end
	--
	local clickRegion = originalIcon:getInstance("ClickRegion")
	local function makeSelectable()
		clickRegion.Selectable = parentIcon.isSelected
	end
	joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
	task.defer(makeSelectable)
	joinJanitor:add(function()
		clickRegion.Selectable = true
	end)
	--

	-- We track icons in arrays and dictionaries using their UID instead of the icon
	-- itself to prevent heavy cyclical tables when printing the icons
	local originalIconUID = originalIcon.UID
	table.insert(iconsArray, originalIconUID)
	parentIcon:autoDeselect(false)
	parentIcon.childIconsDict[originalIconUID] = true
	if not parentIcon.isEnabled then
		parentIcon:setEnabled(true)
	end
	originalIcon.joinedParent:Fire(parentIcon)

	-- This is responsible for removing it from that feature and updating
	-- their parent icon so its informed of the icon leaving it
	joinJanitor:add(function()
		local joinedFrame = originalIcon.joinedFrame
		if not joinedFrame then
			return
		end
		for i, iconUID in pairs(iconsArray) do
			if iconUID == originalIconUID then
				table.remove(iconsArray, i)
				break
			end
		end
		local Icon = require(originalIcon.iconModule)
		local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
		if not parentIcon then
			return
		end
		originalIcon:setAlignment(originalIcon.originalAlignment)
		originalIcon.parentIconUID = false
		originalIcon.joinedFrame = false
		originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
		originalIcon:removeModification("JoinModification")
		
		local parentHasNoChildren = true
		local parentChildIcons = parentIcon.childIconsDict
		parentChildIcons[originalIconUID] = nil
		for childIconUID, _ in pairs(parentChildIcons) do
			parentHasNoChildren = false
			break
		end
		if parentHasNoChildren and not parentIcon.isAnOverflow then
			parentIcon:setEnabled(false)
		end
		updateAlignent()

	end)

end



return Utility]]></ProtectedString>
											<string name="ScriptGuid">{3A75CFAF-424B-44AD-8955-6E5B7584B4A5}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Utility</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX65E4D34323164F17835AE276F2C754E7">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
											<string name="ScriptGuid">{17C3B1B3-99F4-43A8-A698-7E43921E4714}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Themes</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX8138E94343B843DFB6A6723058544993">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
												<string name="ScriptGuid">{61055A5A-3EEE-48B8-AB2D-B81A36F31D9D}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Classic</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXAE5D781685EA420D95CD268239B09B72">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
	{"IconButton", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.3, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Medium, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.925, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
	{"Dropdown", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.3, "Deselected"},
	{"Dropdown", "MaxIcons", 4, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
												<string name="ScriptGuid">{A642E8FD-1E4D-4414-BBA4-4E3463F8F9D7}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Default</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="PackageLink" referent="RBX99299AA8986048D99B8B1592AD935408">
										<Properties>
											<bool name="AutoUpdate">false</bool>
											<string name="DefaultName"></string>
											<int name="ModifiedState">1</int>
											<Content name="PackageIdSerialize"><url>rbxassetid://16049574146</url></Content>
											<BinaryString name="SerializedDefaultAttributes"></BinaryString>
											<int64 name="VersionIdSerialize">20</int64>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">PackageLink</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Folder" referent="RBX3BF4D7074C4A412B999BE33CB5A0B24B">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Elements</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX1244ECA78FCB40A68E3039168F01BBD1">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[return function(icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local clickRegion = icon:getInstance("ClickRegion")
	local caption = Instance.new("CanvasGroup")
	caption.Name = "Caption"
	caption.AnchorPoint = Vector2.new(0.5, 0)
	caption.BackgroundTransparency = 1
	caption.BorderSizePixel = 0
	caption.GroupTransparency = 1
	caption.Position = UDim2.fromOffset(0, 0)
	caption.Visible = true
	caption.ZIndex = 30
	caption.Parent = clickRegion

	local box = Instance.new("Frame")
	box.Name = "Box"
	box.AutomaticSize = Enum.AutomaticSize.XY
	box.BackgroundColor3 = Color3.fromRGB(101, 102, 104)
	box.Position = UDim2.fromOffset(4, 7)
	box.ZIndex = 12
	box.Parent = caption

	local header = Instance.new("TextLabel")
	header.Name = "Header"
	header.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	header.Text = "Caption"
	header.TextColor3 = Color3.fromRGB(255, 255, 255)
	header.TextSize = 14
	header.TextTruncate = Enum.TextTruncate.None
	header.TextWrapped = false
	header.TextXAlignment = Enum.TextXAlignment.Left
	header.AutomaticSize = Enum.AutomaticSize.X
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Size = UDim2.fromOffset(0, 16)
	header.ZIndex = 18
	header.Parent = box

	local layout = Instance.new("UIListLayout")
	layout.Name = "Layout"
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = box

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "CaptionCorner"
	UICorner.Parent = box

	local padding = Instance.new("UIPadding")
	padding.Name = "Padding"
	padding.PaddingBottom = UDim.new(0, 12)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingTop = UDim.new(0, 12)
	padding.Parent = box

	local hotkeys = Instance.new("Frame")
	hotkeys.Name = "Hotkeys"
	hotkeys.AutomaticSize = Enum.AutomaticSize.Y
	hotkeys.BackgroundTransparency = 1
	hotkeys.LayoutOrder = 3
	hotkeys.Size = UDim2.fromScale(1, 0)
	hotkeys.Visible = false
	hotkeys.Parent = box

	local layout1 = Instance.new("UIListLayout")
	layout1.Name = "Layout1"
	layout1.Padding = UDim.new(0, 6)
	layout1.FillDirection = Enum.FillDirection.Vertical
	layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout1.HorizontalFlex = Enum.UIFlexAlignment.None
	layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
	layout1.VerticalFlex = Enum.UIFlexAlignment.None
	layout1.SortOrder = Enum.SortOrder.LayoutOrder
	layout1.Parent = hotkeys

	local keyTag1 = Instance.new("ImageLabel")
	keyTag1.Name = "Key1"
	keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
	keyTag1.ImageTransparency = 0.7
	keyTag1.ScaleType = Enum.ScaleType.Slice
	keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
	keyTag1.AutomaticSize = Enum.AutomaticSize.X
	keyTag1.BackgroundTransparency = 1
	keyTag1.LayoutOrder = 1
	keyTag1.Size = UDim2.fromOffset(0, 30)
	keyTag1.ZIndex = 15
	keyTag1.Parent = hotkeys

	local inset = Instance.new("UIPadding")
	inset.Name = "Inset"
	inset.PaddingLeft = UDim.new(0, 8)
	inset.PaddingRight = UDim.new(0, 8)
	inset.Parent = keyTag1

	local labelContent = Instance.new("TextLabel")
	labelContent.AutoLocalize = false
	labelContent.Name = "LabelContent"
	labelContent.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	labelContent.Text = ""
	labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
	labelContent.TextSize = 14
	labelContent.AutomaticSize = Enum.AutomaticSize.X
	labelContent.BackgroundTransparency = 1
	labelContent.Position = UDim2.fromOffset(0, -1)
	labelContent.Size = UDim2.fromScale(1, 1)
	labelContent.ZIndex = 16
	labelContent.Parent = keyTag1
	
	local caret = Instance.new("ImageLabel")
	caret.Name = "Caret"
	caret.Image = "rbxasset://LuaPackages/Packages/_Index/UIBlox/UIBlox/AppImageAtlas/img_set_1x_1.png"
	caret.ImageColor3 = Color3.fromRGB(101, 102, 104)
	caret.ImageRectOffset = Vector2.new(260, 440)
	caret.ImageRectSize = Vector2.new(16, 8)
	caret.AnchorPoint = Vector2.new(0, 0.5)
	caret.BackgroundTransparency = 1
	caret.Position = UDim2.new(0, 0, 0, 4)
	caret.Rotation = 180
	caret.Size = UDim2.fromOffset(16, 8)
	caret.ZIndex = 12
	caret.Parent = caption

	local dropShadow = Instance.new("ImageLabel")
	dropShadow.Name = "DropShadow"
	dropShadow.Image = "rbxasset://LuaPackages/Packages/_Index/UIBlox/UIBlox/AppImageAtlas/img_set_1x_1.png"
	dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	dropShadow.ImageRectOffset = Vector2.new(217, 486)
	dropShadow.ImageRectSize = Vector2.new(25, 25)
	dropShadow.ImageTransparency = 0.45
	dropShadow.ScaleType = Enum.ScaleType.Slice
	dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
	dropShadow.BackgroundTransparency = 1
	dropShadow.Position = UDim2.fromOffset(0, 5)
	dropShadow.Size = UDim2.new(1, 0, 0, 48)
	dropShadow.Parent = caption
	box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
	end)
	
	-- It's important we match the sizes as this is not
	-- handles within clipOutside (as it assumes the sizes
	-- are already the same)
	local captionJanitor = icon.captionJanitor
	local _, captionClone = icon:clipOutside(caption)
	captionClone.AutomaticSize = Enum.AutomaticSize.None
	local function matchSize()
		local absolute = caption.AbsoluteSize
		captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
	end
	captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
	matchSize()
	
	
	
	local isCompletelyEnabled = false
	-- This handles the appearing/disappearing/positioning of the caption
	local captionHeader = caption.Box.Header
	local UserInputService = game:GetService("UserInputService")
	local function updateHotkey(keyCodeEnum)
		local hasKeyboard = UserInputService.KeyboardEnabled
		local text = caption:GetAttribute("CaptionText") or ""
		local hideHeader = text == "_hotkey_"
		if not hasKeyboard and hideHeader then
			icon:setCaption()
			return
		end
		captionHeader.Text = text
		captionHeader.Visible = not hideHeader
		if keyCodeEnum then
			labelContent.Text = keyCodeEnum.Name
			hotkeys.Visible = true
		end
		if not hasKeyboard then
			hotkeys.Visible = false
		end
	end
	caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)

	local EASING_STYLE = Enum.EasingStyle.Quad
	local TWEEN_SPEED = 0.2
	local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
	local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local function getCaptionPosition(customEnabled)
		local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
		local yOut = 2
		local yIn = yOut + 8
		local yOffset = if enabled then yIn else yOut
		return UDim2.new(0.5, 0, 1, yOffset)
	end
	local function updatePosition(forcedEnabled)
		
		-- Ignore changes if not enabled to reduce redundant calls
		if not isCompletelyEnabled then
			return
		end
		
		-- Currently the one thing which isn't accounted for are the bounds of the screen
		-- This would be an issue if someone sets a long caption text for the left or
		-- right most icon
		local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
		local startPosition = getCaptionPosition(not enabled)
		local endPosition = getCaptionPosition(enabled)
		
		-- It's essential we reset the carets position to prevent the x sizing bounds
		-- of the caption from infinitely scaling up
		if enabled then
			local caretY = caret.Position.Y.Offset
			caret.Position = UDim2.fromOffset(0, caretY)
			caption.AutomaticSize = Enum.AutomaticSize.XY
			caption.Size = UDim2.fromOffset(32, 53)
		else
			local absolute = caption.AbsoluteSize
			caption.AutomaticSize = Enum.AutomaticSize.Y
			caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end
		
		-- We initially default to the opposite state
		local previousCaretX
		local function updateCaret()
			local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
			local caretY = caret.Position.Y.Offset
			local newCaretPosition = UDim2.fromOffset(caretX, caretY)
			if previousCaretX ~= caretX then
				-- Again, it's essential we reset the caret if
				-- a difference in X position is detected otherwise
				-- a slight quirk with AutomaticCanvas can cause
				-- the caption to infinitely scale
				previousCaretX = caretX
				caret.Position = UDim2.fromOffset(0, caretY)
				task.wait()
			end
			caret.Position = newCaretPosition
		end
		captionClone.Position = startPosition
		updateCaret()
		
		-- Now we tween into the new state
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
		local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
		tween:Play()
		tween.Completed:Once(function()
			updateCaretConnection:Disconnect()
		end)
		
	end
	captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updatePosition()
	end))
	updatePosition(false)
	
	captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
	for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
		updateHotkey(keyCodeEnum)
		break
	end
	captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
	local fakeToggleKey = icon.fakeToggleKey
	if fakeToggleKey then
		updateHotkey(fakeToggleKey)
	end

	local function setCaptionEnabled(enabled)
		if isCompletelyEnabled == enabled then
			return
		end
		local joinedFrame = icon.joinedFrame
		if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
			enabled = false
		end
		isCompletelyEnabled = enabled
		local newTransparency = (enabled and 0) or 1
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tweenTransparency = TweenService:Create(caption, tweenInfo, {
			GroupTransparency = newTransparency
		})
		tweenTransparency:Play()
		updatePosition()
		updateHotkey()
	end
	
	local WAIT_DURATION = 0.5
	local RECOVER_PERIOD = 0.3
	local Icon = require(icon.iconModule)
	captionJanitor:add(icon.stateChanged:Connect(function(stateName)
		if stateName == "Viewing" then
			local lastClock = Icon.captionLastClosedClock
			local clockDifference = (lastClock and os.clock() - lastClock) or 999
			local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
			task.delay(waitDuration, function()
				if icon.activeState == "Viewing" then
					setCaptionEnabled(true)
				end
			end)
		else
			Icon.captionLastClosedClock = os.clock()
			setCaptionEnabled(false)
		end
	end))
	
	return caption
end]]></ProtectedString>
												<string name="ScriptGuid">{0BCA3AFF-CD66-43CB-A4C5-D311B4ACCAD3}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Caption</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX0F314647101A49A9877A5727CBD6C2EA">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[return function(Icon)
	
	local GuiService = game:GetService("GuiService")
	local isOldTopbar = Icon.isOldTopbar
	local container = {}
	local guiInset = GuiService:GetGuiInset()
	local isConsoleScreen = GuiService:IsTenFootInterface()
	local startInset = if isOldTopbar then 12 else guiInset.Y - (44 + 2)
	if isConsoleScreen then
		startInset = 10
	end
	local screenGui = Instance.new("ScreenGui")
	screenGui:SetAttribute("StartInset", startInset)
	screenGui.Name = "TopbarStandard"
	screenGui.Enabled = true
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true
	screenGui.ResetOnSpawn = false
	screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
	container[screenGui.Name] = screenGui
	screenGui.DisplayOrder = Icon.baseDisplayOrder
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGui.DisplayOrder = Icon.baseDisplayOrder
	end)

	local holders = Instance.new("Frame")
	local yDownOffset = if isOldTopbar then 2 else 0
	local ySizeOffset = -2
	if isConsoleScreen then
		yDownOffset += 13
		ySizeOffset = 50
	end
	holders.Name = "Holders"
	holders.BackgroundTransparency = 1
	holders.Position = UDim2.new(0, 0, 0, yDownOffset)
	holders.Size = UDim2.new(1, 0, 1, ySizeOffset)
	holders.Visible = true
	holders.ZIndex = 1
	holders.Parent = screenGui
	
	local screenGuiCenter = screenGui:Clone()
	local holdersCenter = screenGuiCenter.Holders
	local GuiService = game:GetService("GuiService")
	local function updateCenteredHoldersHeight()
		holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
	end
	screenGuiCenter.Name = "TopbarCentered"
	screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	end)
	container[screenGuiCenter.Name] = screenGuiCenter
	GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(updateCenteredHoldersHeight)
	updateCenteredHoldersHeight()
	
	local screenGuiClipped = screenGui:Clone()
	screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
	screenGuiClipped.DisplayOrder += 1
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiClipped.DisplayOrder = Icon.baseDisplayOrder + 1
	end)
	container[screenGuiClipped.Name] = screenGuiClipped
	
	local screenGuiCenterClipped = screenGuiCenter:Clone()
	screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
	screenGuiCenterClipped.DisplayOrder += 1
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenterClipped.DisplayOrder = Icon.baseDisplayOrder + 1
	end)
	container[screenGuiCenterClipped.Name] = screenGuiCenterClipped
	
	if isOldTopbar then
		task.defer(function()
			local function decideToHideTopbar()
				if GuiService.MenuIsOpen then
					Icon.setTopbarEnabled(false, true)
				else
					Icon.setTopbarEnabled()
				end
			end
			GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
			decideToHideTopbar()
		end)
	end
	
	local holderReduction = -24
	local left = Instance.new("ScrollingFrame")
	left:SetAttribute("IsAHolder", true)
	left.Name = "Left"
	left.Position = UDim2.fromOffset(startInset, 0)
	left.Size = UDim2.new(1, holderReduction, 1, 0)
	left.BackgroundTransparency = 1
	left.Visible = true
	left.ZIndex = 1
	left.Active = false
	left.ClipsDescendants = true
	left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
	left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	left.AutomaticCanvasSize = Enum.AutomaticSize.X
	left.ScrollingDirection = Enum.ScrollingDirection.X
	left.ScrollBarThickness = 0
	left.BorderSizePixel = 0
	left.Selectable = false
	left.ScrollingEnabled = false--true
	left.ElasticBehavior = Enum.ElasticBehavior.Never
	left.Parent = holders
	
	local UIListLayout = Instance.new("UIListLayout")
	UIListLayout.Padding = UDim.new(0, startInset)
	UIListLayout.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	UIListLayout.Parent = left
	
	local center = left:Clone()
	center.ScrollingEnabled = false
	center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	center.Name = "Center"
	center.Parent = holdersCenter
	
	local right = left:Clone()
	right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	right.Name = "Right"
	right.AnchorPoint = Vector2.new(1, 0)
	right.Position = UDim2.new(1, -12, 0, 0)
	right.Parent = holders

	return container
end]]></ProtectedString>
												<string name="ScriptGuid">{C9E4BB7D-B02C-4FC3-AFA9-10A365E7D7EA}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Container</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXD28051BD5BD34DFCA93ECBDD92171E6F">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[return function(icon)
	
	local dropdown = Instance.new("Frame")
	dropdown.Name = "Dropdown"
	dropdown.AutomaticSize = Enum.AutomaticSize.XY
	dropdown.BackgroundTransparency = 1
	dropdown.BorderSizePixel = 0
	dropdown.AnchorPoint = Vector2.new(0.5, 0)
	dropdown.Position = UDim2.new(0.5, 0, 1, 10)
	dropdown.ZIndex = -2
	dropdown.ClipsDescendants = true
	dropdown.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "DropdownCorner"
	UICorner.CornerRadius = UDim.new(0, 10)
	UICorner.Parent = dropdown

	local dropdownScroller = Instance.new("ScrollingFrame")
	dropdownScroller.Name = "DropdownScroller"
	dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
	dropdownScroller.BackgroundTransparency = 1
	dropdownScroller.BorderSizePixel = 0
	dropdownScroller.AnchorPoint = Vector2.new(0, 0)
	dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
	dropdownScroller.ZIndex = -1
	dropdownScroller.ClipsDescendants = true
	dropdownScroller.Visible = true
	dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
	dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
	dropdownScroller.Active = false
	dropdownScroller.ScrollingEnabled = true
	dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
	dropdownScroller.ScrollBarThickness = 5
	dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	dropdownScroller.ScrollBarImageTransparency = 0.8
	dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	dropdownScroller.Selectable = false
	dropdownScroller.Active = true
	dropdownScroller.Parent = dropdown
	
	local dropdownPadding = Instance.new("UIPadding")
	dropdownPadding.Name = "DropdownPadding"
	dropdownPadding.PaddingTop = UDim.new(0, 8)
	dropdownPadding.PaddingBottom = UDim.new(0, 8)
	dropdownPadding.Parent = dropdownScroller

	local dropdownList = Instance.new("UIListLayout")
	dropdownList.Name = "DropdownList"
	dropdownList.FillDirection = Enum.FillDirection.Vertical
	dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
	dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
	dropdownList.Parent = dropdownScroller
	
	local dropdownJanitor = icon.dropdownJanitor
	local Icon = require(icon.iconModule)
	icon.dropdownChildAdded:Connect(function(childIcon)
		-- Modify appearance of child when joined
		local _, modificationUID = childIcon:modifyTheme({
			{"Widget", "BorderSize", 0},
			{"IconCorners", "CornerRadius", UDim.new(0, 4)},
			{"Widget", "MinimumWidth", 190},
			{"Widget", "MinimumHeight", 56},
			{"IconLabel", "TextSize", 19},
			{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
			{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
			{"Selection", "Size", UDim2.new(1, -8, 1, -8)},
			{"Selection", "Position", UDim2.new(0, 4, 0, 4)},
		})
		task.defer(function()
			childIcon.joinJanitor:add(function()
				childIcon:removeModification(modificationUID)
			end)
		end)
	end)
	icon.dropdownSet:Connect(function(arrayOfIcons)
		-- Destroy any previous icons
		for i, otherIconUID in pairs(icon.dropdownIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Add new icons
		local totalNewIcons = #arrayOfIcons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinDropdown(icon)
			end
		end
	end)

	-- Update visibiliy of dropdown
	local Utility = require(script.Parent.Parent.Utility)
	local function updateVisibility()
		--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
		Utility.setVisible(dropdown, icon.isSelected, "InternalDropdown")
	end
	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
	updateVisibility()
	--task.delay(0.2, updateVisibility)
	
	-- This updates the scrolling frame to only display a scroll
	-- length equal to the distance produced by its MaxIcons
	local updateCount = 0
	local isUpdating = false
	local function updateMaxIcons()
		
		-- This prevents more than 1 update occurring every frame
		updateCount += 1
		if isUpdating then
			return
		end
		local myUpdateCount = updateCount
		isUpdating = true
		task.defer(function()
			isUpdating = false
			if updateCount ~= myUpdateCount then
				updateMaxIcons()
			end
		end)
			
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then
			return
		end
		local orderedInstances = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") then
				table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
			end
		end
		table.sort(orderedInstances, function(groupA, groupB)
			return groupA[2] < groupB[2]
		end)
		local totalHeight = 0
		local hasSetNextSelection = false
		for i = 1, maxIcons do
			local group = orderedInstances[i]
			if not group then
				break
			end
			local child = group[1]
			local height = child.AbsoluteSize.Y
			totalHeight += height
			local iconUID = child:GetAttribute("WidgetUID")
			local childIcon = iconUID and Icon.getIconByUID(iconUID)
			if childIcon then
				local nextSelection = nil
				if not hasSetNextSelection then
					hasSetNextSelection = true
					nextSelection = icon:getInstance("ClickRegion")
				end
				childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
			end
		end
		totalHeight += dropdownPadding.PaddingTop.Offset
		totalHeight += dropdownPadding.PaddingBottom.Offset
		dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)
	end
	dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIcons))
	dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIcons))
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIcons))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIcons))
	dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIcons))
	updateMaxIcons()
	
	return dropdown
end]]></ProtectedString>
												<string name="ScriptGuid">{C5A3128A-4B1A-4982-BF75-2BEE810006EA}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Dropdown</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXD2882430E07F465D84A0153D265BA32F">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local widget = icon.widget
	local contents = icon:getInstance("Contents")
	local indicator = Instance.new("Frame")
	indicator.Name = "Indicator"
	indicator.LayoutOrder = 9999999
	indicator.ZIndex = 6
	indicator.Size = UDim2.new(0, 42, 0, 42)
	indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicator.BackgroundTransparency = 1
	indicator.Position = UDim2.new(1, 0, 0.5, 0)
	indicator.BorderSizePixel = 0
	indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicator.Parent = contents

	local indicatorButton = Instance.new("Frame")
	indicatorButton.Name = "IndicatorButton"
	indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
	indicatorButton.BorderSizePixel = 0
	indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.Parent = indicator
	
	local GuiService = game:GetService("GuiService")
	local GamepadService = game:GetService("GamepadService")
	local ourClickRegion = icon:getInstance("ClickRegion")
	local function selectionChanged()
		local selectedClickRegion = GuiService.SelectedObject
		if selectedClickRegion == ourClickRegion then
			indicatorButton.BackgroundTransparency = 1
			indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
		else
			indicatorButton.BackgroundTransparency = 0.75
			indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1, 1)
		end
	end
	icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
	selectionChanged()

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.LayoutOrder = 2
	imageLabel.ZIndex = 15
	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.Image = "rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png"
	imageLabel.Parent = indicatorButton

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = indicatorButton

	local UserInputService = game:GetService("UserInputService")
	local function setIndicatorVisible(visibility)
		if visibility == nil then
			visibility = indicator.Visible
		end
		if GamepadService.GamepadCursorEnabled then
			visibility = false
		end
		if visibility then
			icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
		elseif indicator.Visible then
			icon:removeModification("IndicatorPadding")
		end
		icon:modifyTheme({"Indicator", "Visible", visibility})
		icon.updateSize:Fire()
	end
	icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
	icon.indicatorSet:Connect(function(keyCode)
		local visibility = false
		if keyCode then
			imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
			visibility = true
		end
		setIndicatorVisible(visibility)
	end)

	local function updateSize()
		local ySize = widget.AbsoluteSize.Y*0.96
		indicator.Size = UDim2.new(0, ySize, 0, ySize)
	end
	widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
	updateSize()

	return indicator
end]]></ProtectedString>
												<string name="ScriptGuid">{16484D2A-383A-4BDE-9C9C-5318509224ED}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Indicator</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX96A6E26527A0477B9373D2076C7D516A">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[return function(icon)

	local menu = Instance.new("ScrollingFrame")
	menu.Name = "Menu"
	menu.BackgroundTransparency = 1
	menu.Visible = true
	menu.ZIndex = 1
	menu.Size = UDim2.fromScale(1, 1)
	menu.ClipsDescendants = true
	menu.TopImage = ""
	menu.BottomImage = ""
	menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
	menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	menu.ScrollingEnabled = true
	menu.ScrollingDirection = Enum.ScrollingDirection.X
	menu.ZIndex = 20
	menu.ScrollBarThickness = 3
	menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	menu.ScrollBarImageTransparency = 0.8
	menu.BorderSizePixel = 0
	menu.Selectable = false
	
	local Icon = require(icon.iconModule)
	local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
	menuUIListLayout.Name = "MenuUIListLayout"
	menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	menuUIListLayout.Parent = menu

	local menuGap = Instance.new("Frame")
	menuGap.Name = "MenuGap"
	menuGap.BackgroundTransparency = 1
	menuGap.Visible = false
	menuGap.AnchorPoint = Vector2.new(0, 0.5)
	menuGap.ZIndex = 5
	menuGap.Parent = menu
	
	local hasStartedMenu = false
	local Themes = require(script.Parent.Parent.Features.Themes)
	local function totalChildrenChanged()
		
		local menuJanitor = icon.menuJanitor
		local totalIcons = #icon.menuIcons
		if hasStartedMenu then
			if totalIcons <= 0 then
				menuJanitor:clean()
				hasStartedMenu = false
			end
			return
		end
		hasStartedMenu = true
		
		-- Listen for changes
		menuJanitor:add(icon.toggled:Connect(function()
			if #icon.menuIcons > 0 then
				icon.updateSize:Fire()
			end
		end))
		
		-- Modify appearance of menu icon when joined
		local _, modificationUID = icon:modifyTheme({
			{"Menu", "Active", true},
		})
		task.defer(function()
			menuJanitor:add(function()
				icon:removeModification(modificationUID)
			end)
		end)
		
		-- For right-aligned icons, this ensures their menus
		-- close button appear instantly when selected (instead
		-- of partially hidden from view)
		local previousCanvasX = menu.AbsoluteCanvasSize.X
		local function rightAlignCanvas()
			if icon.alignment == "Right" then
				local newCanvasX = menu.AbsoluteCanvasSize.X
				local difference = previousCanvasX - newCanvasX
				previousCanvasX = newCanvasX
				menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
			end
		end
		menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
		menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))
		
		-- Apply a close selected image if the user hasn't applied thier own
		local stateGroup = icon:getStateGroup()
		local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
		local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
		if imageDeselected == imageSelected then
			local fontLink = "rbxasset://fonts/families/FredokaOne.json"
			local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
			icon:removeModificationWith("IconLabel", "Text", "Viewing")
			icon:removeModificationWith("IconLabel", "Image", "Viewing")
			icon:modifyTheme({
				{"IconLabel", "FontFace", fontFace, "Selected"},
				{"IconLabel", "Text", "X", "Selected"},
				{"IconLabel", "TextSize", 20, "Selected"},
				{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
				{"IconImage", "Image", "", "Selected"},
			})
		end

		-- Change order of spot when alignment changes
		local iconSpot = icon:getInstance("IconSpot")
		local menuGap = icon:getInstance("MenuGap")
		local function updateAlignent()
			local alignment = icon.alignment
			if alignment == "Right" then
				iconSpot.LayoutOrder = 99999
				menuGap.LayoutOrder = 99998
			else
				iconSpot.LayoutOrder = -99999
				menuGap.LayoutOrder = -99998
			end
		end
		menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
		updateAlignent()
		
		-- This updates the scrolling frame to only display a scroll
		-- length equal to the distance produced by its MaxIcons
		menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
			local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
			local canvasY = menu.CanvasSize.Y
			menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
		end)
		menuJanitor:add(icon.updateMenu:Connect(function()
			local maxIcons = menu:GetAttribute("MaxIcons")
			if not maxIcons then
				return
			end
			local orderedInstances = {}
			for _, child in pairs(menu:GetChildren()) do
				local widgetUID = child:GetAttribute("WidgetUID")
				if widgetUID and child.Visible then
					table.insert(orderedInstances, {child, child.AbsolutePosition.X})
				end
			end
			table.sort(orderedInstances, function(groupA, groupB)
				return groupA[2] < groupB[2]
			end)
			local totalWidth = 0
			for i = 1, maxIcons do
				local group = orderedInstances[i]
				if not group then
					break
				end
				local child = group[1]
				local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
				totalWidth += width
			end
			menu:SetAttribute("MenuWidth", totalWidth)
		end))
		local function startMenuUpdate()
			task.delay(0.1, function()
				icon.startMenuUpdate:Fire()
			end)
		end
		local iconButton = icon:getInstance("IconButton")
		local previousButtonWidth = iconButton.AbsoluteSize.X
		menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
		menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
		startMenuUpdate()
	end
	
	icon.menuChildAdded:Connect(totalChildrenChanged)
	icon.menuSet:Connect(function(arrayOfIcons)
		-- Reset any previous icons
		for i, otherIconUID in pairs(icon.menuIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Apply new icons
		local totalNewIcons = #arrayOfIcons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinMenu(icon)
			end
		end
	end)
	
	return menu
end]]></ProtectedString>
												<string name="ScriptGuid">{AB92C211-8EAF-4815-BFBF-5396BF4778DB}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Menu</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX0DA69EC654B54D049354C6114E2E6ADB">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[return function(Icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local selectionContainer = Instance.new("Frame")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Visible = false
	
	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	selection.BackgroundTransparency = 1
	selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
	selection.BorderSizePixel = 0
	selection.Parent = selectionContainer

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Name = "UIStroke"
	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	UIStroke.Color = Color3.fromRGB(255, 255, 255)
	UIStroke.Thickness = 3
	UIStroke.Parent = selection

	local selectionGradient = Instance.new("UIGradient")
	selectionGradient.Name = "SelectionGradient"
	selectionGradient.Parent = UIStroke

	local UICorner = Instance.new("UICorner")
	UICorner:SetAttribute("Collective", "IconCorners")
	UICorner.Name = "UICorner"
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = selection
	
	local RunService = game:GetService("RunService")
	local GuiService = game:GetService("GuiService")
	local rotationSpeed = 1
	selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
		rotationSpeed = selection:GetAttribute("RotationSpeed")
	end)
	RunService.Heartbeat:Connect(function()
		if not GuiService.SelectedObject then
			return
		end
		selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
	end)

	return selectionContainer
	
end]]></ProtectedString>
												<string name="ScriptGuid">{D21B45B9-1E57-4605-9C95-B7A095EC1743}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Selection</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXE85468D3908645E3B77E8BF16748074A">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
-- the icon (aka Widget) instance.
-- This contains the core components of the icon such as the button, image, label and notice. It's
-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)

return function(icon, Icon)

	local widget = Instance.new("Frame")
	widget:SetAttribute("WidgetUID", icon.UID)
	widget.Name = "Widget"
	widget.BackgroundTransparency = 1
	widget.Visible = true
	widget.ZIndex = 20
	widget.Active = false
	widget.ClipsDescendants = true

	local button = Instance.new("Frame")
	button.Name = "IconButton"
	button.Visible = true
	button.ZIndex = 2
	button.BorderSizePixel = 0
	button.Parent = widget
	button.ClipsDescendants = true
	button.Active = false -- This is essential for mobile scrollers to work when dragging
	icon.deselected:Connect(function()
		button.ClipsDescendants = true
	end)
	icon.selected:Connect(function()
		task.defer(function()
			icon.resizingComplete:Once(function()
				if icon.isSelected then
					button.ClipsDescendants = false
				end
			end)
		end)
	end)

	local iconCorner = Instance.new("UICorner")
	iconCorner:SetAttribute("Collective", "IconCorners")
	iconCorner.Parent = button

	local menu = require(script.Parent.Menu)(icon)
	local menuUIListLayout = menu.MenuUIListLayout
	local menuGap = menu.MenuGap
	menu.Parent = button

	local iconSpot = Instance.new("Frame")
	iconSpot.Name = "IconSpot"
	iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
	iconSpot.BackgroundTransparency = 0.9
	iconSpot.Visible = true
	iconSpot.AnchorPoint = Vector2.new(0, 0.5)
	iconSpot.ZIndex = 5
	iconSpot.Parent = menu

	local iconSpotCorner = iconCorner:Clone()
	iconSpotCorner.Parent = iconSpot

	local overlay = iconSpot:Clone()
	overlay.Name = "IconOverlay"
	overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	overlay.ZIndex = iconSpot.ZIndex + 1
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.AnchorPoint = Vector2.new(0, 0)
	overlay.Visible = false
	overlay.Parent = iconSpot

	local clickRegion = Instance.new("TextButton")
	clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
	clickRegion.Name = "ClickRegion"
	clickRegion.BackgroundTransparency = 1
	clickRegion.Visible = true
	clickRegion.Text = ""
	clickRegion.ZIndex = 20
	clickRegion.Selectable = true
	clickRegion.SelectionGroup = true
	clickRegion.Parent = iconSpot
	
	local Gamepad = require(script.Parent.Parent.Features.Gamepad)
	Gamepad.registerButton(clickRegion)

	local clickRegionCorner = iconCorner:Clone()
	clickRegionCorner.Parent = clickRegion

	local contents = Instance.new("Frame")
	contents.Name = "Contents"
	contents.BackgroundTransparency = 1
	contents.Size = UDim2.fromScale(1, 1)
	contents.Parent = iconSpot

	local contentsList = Instance.new("UIListLayout")
	contentsList.Name = "ContentsList"
	contentsList.FillDirection = Enum.FillDirection.Horizontal
	contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
	contentsList.SortOrder = Enum.SortOrder.LayoutOrder
	contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
	contentsList.Padding = UDim.new(0, 3)
	contentsList.Parent = contents

	local paddingLeft = Instance.new("Frame")
	paddingLeft.Name = "PaddingLeft"
	paddingLeft.LayoutOrder = 1
	paddingLeft.ZIndex = 5
	paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingLeft.BackgroundTransparency = 1
	paddingLeft.BorderSizePixel = 0
	paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingLeft.Parent = contents

	local paddingCenter = Instance.new("Frame")
	paddingCenter.Name = "PaddingCenter"
	paddingCenter.LayoutOrder = 3
	paddingCenter.ZIndex = 5
	paddingCenter.Size = UDim2.new(0, 0, 1, 0)
	paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingCenter.BackgroundTransparency = 1
	paddingCenter.BorderSizePixel = 0
	paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingCenter.Parent = contents

	local paddingRight = Instance.new("Frame")
	paddingRight.Name = "PaddingRight"
	paddingRight.LayoutOrder = 5
	paddingRight.ZIndex = 5
	paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingRight.BackgroundTransparency = 1
	paddingRight.BorderSizePixel = 0
	paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingRight.Parent = contents

	local iconLabelContainer = Instance.new("Frame")
	iconLabelContainer.Name = "IconLabelContainer"
	iconLabelContainer.LayoutOrder = 4
	iconLabelContainer.ZIndex = 3
	iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
	iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
	iconLabelContainer.BackgroundTransparency = 1
	iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	iconLabelContainer.Parent = contents

	local iconLabel = Instance.new("TextLabel")
	local viewportX = workspace.CurrentCamera.ViewportSize.X+200
	iconLabel.Name = "IconLabel"
	iconLabel.LayoutOrder = 4
	iconLabel.ZIndex = 15
	iconLabel.AnchorPoint = Vector2.new(0, 0)
	iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
	iconLabel.ClipsDescendants = false
	iconLabel.BackgroundTransparency = 1
	iconLabel.Position = UDim2.fromScale(0, 0)
	iconLabel.RichText = true
	iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
	iconLabel.Text = ""
	iconLabel.TextWrapped = true
	iconLabel.TextWrap = true
	iconLabel.TextScaled = false
	iconLabel.Active = false
	iconLabel.AutoLocalize = true
	iconLabel.Parent = iconLabelContainer

	local iconImage = Instance.new("ImageLabel")
	iconImage.Name = "IconImage"
	iconImage.LayoutOrder = 2
	iconImage.ZIndex = 15
	iconImage.AnchorPoint = Vector2.new(0, 0.5)
	iconImage.Size = UDim2.new(0, 0, 0.5, 0)
	iconImage.BackgroundTransparency = 1
	iconImage.Position = UDim2.new(0, 11, 0.5, 0)
	iconImage.ScaleType = Enum.ScaleType.Stretch
	iconImage.Active = false
	iconImage.Parent = contents

	local iconImageCorner = iconCorner:Clone()
	iconImageCorner:SetAttribute("Collective", nil)
	iconImageCorner.CornerRadius = UDim.new(0, 0)
	iconImageCorner.Name = "IconImageCorner"
	iconImageCorner.Parent = iconImage

	local TweenService = game:GetService("TweenService")
	local resizingCount = 0
	local repeating = false
	local function handleLabelAndImageChangesUnstaggered(forceUpdateString)

		-- We defer changes by a frame to eliminate all but 1 requests which
		-- could otherwise stack up to 20+ requests in a single frame
		-- We then repeat again once to account for any final changes
		-- Deferring is also essential because properties are set immediately
		-- afterwards (therefore calculations will use the correct values)
		task.defer(function()
			local indicator = icon.indicator
			local usingIndicator = indicator and indicator.Visible
			local usingText = usingIndicator or iconLabel.Text ~= ""
			local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
			local alignment = Enum.HorizontalAlignment.Center
			local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
			local buttonSize = NORMAL_BUTTON_SIZE
			if usingImage and not usingText then
				iconLabelContainer.Visible = false
				iconImage.Visible = true
				paddingLeft.Visible = false
				paddingCenter.Visible = false
				paddingRight.Visible = false
			elseif not usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = false
				paddingLeft.Visible = true
				paddingCenter.Visible = false
				paddingRight.Visible = true
			elseif usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = true
				paddingLeft.Visible = true
				paddingCenter.Visible = not usingIndicator
				paddingRight.Visible = not usingIndicator
				alignment = Enum.HorizontalAlignment.Left
			end
			button.Size = buttonSize

			local function getItemWidth(item)
				local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
				return targetWidth
			end
			local contentsPadding = contentsList.Padding.Offset
			local initialWidgetWidth = contentsPadding --0
			local textWidth = iconLabel.TextBounds.X
			iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
			for _, child in pairs(contents:GetChildren()) do
				if child:IsA("GuiObject") and child.Visible == true then
					local itemWidth = getItemWidth(child)
					initialWidgetWidth += itemWidth + contentsPadding
				end
			end
			local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
			local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
			local widgetBorderSize = widget:GetAttribute("BorderSize")
			local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
			local menuIcons = icon.menuIcons
			local additionalWidth = 0
			local hasMenu = #menuIcons > 0
			local showMenu = hasMenu and icon.isSelected
			if showMenu then
				for _, frame in pairs(menu:GetChildren()) do
					if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
						additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
					end
				end
				if not iconSpot.Visible then
					widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
				end
				additionalWidth -= (widgetBorderSize*0.5)
				widgetWidth += additionalWidth - (widgetBorderSize*0.75)
			end
			menuGap.Visible = showMenu and iconSpot.Visible
			local desiredWidth = widget:GetAttribute("DesiredWidth")
			if desiredWidth and widgetWidth < desiredWidth then
				widgetWidth = desiredWidth
			end

			icon.updateMenu:Fire()
			local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
			local spotWidth = preWidth-(widgetBorderSize*2)
			local menuWidth = menu:GetAttribute("MenuWidth")
			local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
			if totalMenuWidth then
				local maxWidth = menu:GetAttribute("MaxWidth")
				if maxWidth then
					totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
				end
				menu:SetAttribute("MenuCanvasWidth", widgetWidth)
				if totalMenuWidth < widgetWidth then
					widgetWidth = totalMenuWidth
				end
			end

			local style = Enum.EasingStyle.Quint
			local direction = Enum.EasingDirection.Out
			local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
			local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
			local SPEED = 750
			local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
			local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
			TweenService:Create(iconSpot, spotTweenInfo, {
				Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
				Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
			}):Play()
			TweenService:Create(clickRegion, spotTweenInfo, {
				Size = UDim2.new(0, spotWidth, 1, 0),
			}):Play()
			local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
			local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
			if updateInstantly then
				widget.Size = newWidgetSize
			end
			widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
			local movingTween = TweenService:Create(widget, widgetTweenInfo, {
				Size = newWidgetSize,
			})
			movingTween:Play()
			resizingCount += 1
			for i = 1, widgetTweenInfo.Time * 100 do
				task.delay(i/100, function()
					Icon.iconChanged:Fire(icon)
				end)
			end
			task.delay(widgetTweenInfo.Time-0.2, function()
				resizingCount -= 1
				task.defer(function()
					if resizingCount == 0 then
						icon.resizingComplete:Fire()
					end
				end)
			end)
			icon:updateParent()
		end)
	end
	local Utility = require(script.Parent.Parent.Utility)
	local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
	local firstTimeSettingFontFace = true
	icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
	icon:setBehaviour("IconLabel", "FontFace", function(value)
		local previousFontFace = iconLabel.FontFace
		if previousFontFace == value then
			return
		end
		task.spawn(function()
			--[[
			local fontLink = value.Family
			if string.match(fontLink, "rbxassetid://") then
				local ContentProvider = game:GetService("ContentProvider")
				local assets = {fontLink}
				ContentProvider:PreloadAsync(assets)
				print("FONT LOADED!!!")
			end--]]

			-- Afaik there's no way to determine when a Font Family has
			-- loaded (even with ContentProvider), so we just have to try
			-- a few times and hope it loads within the refresh period
			handleLabelAndImageChanges()
			if firstTimeSettingFontFace then
				firstTimeSettingFontFace = false
				for i = 1, 10 do
					task.wait(1)
					handleLabelAndImageChanges()
				end
			end
		end)
	end)
	local function updateBorderSize()
		task.defer(function()
			local borderOffset = widget:GetAttribute("BorderSize")
			local alignment = icon.alignment
			local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
			menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
			menuGap.Size = UDim2.fromOffset(borderOffset, 0)
			menuUIListLayout.Padding = UDim.new(0, 0)
			handleLabelAndImageChanges()
		end)
	end
	icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
	icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
	icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
	icon.updateSize:Connect(handleLabelAndImageChanges)
	icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
	icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
	icon:setBehaviour("IconImage", "Image", function(value)
		local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
		if iconImage.Image ~= textureId then
			handleLabelAndImageChanges()
		end
		return textureId
	end)
	icon.alignmentChanged:Connect(function(newAlignment)
		if newAlignment == "Center" then
			newAlignment = "Left"
		end
		menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
		updateBorderSize()
	end)

	local iconImageScale = Instance.new("NumberValue")
	iconImageScale.Name = "IconImageScale"
	iconImageScale.Parent = iconImage
	iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
		iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
	end)

	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
	UIAspectRatioConstraint.Name = "IconImageRatio"
	UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
	UIAspectRatioConstraint.Parent = iconImage

	local iconGradient = Instance.new("UIGradient")
	iconGradient.Name = "IconGradient"
	iconGradient.Enabled = true
	iconGradient.Parent = button

	local iconSpotGradient = Instance.new("UIGradient")
	iconSpotGradient.Name = "IconSpotGradient"
	iconSpotGradient.Enabled = true
	iconSpotGradient.Parent = iconSpot

	return widget
end]]></ProtectedString>
												<string name="ScriptGuid">{CA51CD9D-7735-48C1-B64D-E84F7872ED95}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Widget</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX10387E4B62864A5E977BB988887604E6">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local notice = Instance.new("Frame")
	notice.Name = "Notice"
	notice.ZIndex = 25
	notice.AutomaticSize = Enum.AutomaticSize.X
	notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
	notice.BorderSizePixel = 0
	notice.BackgroundTransparency = 0.1
	notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	notice.Visible = false
	notice.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = notice

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Parent = notice

	local noticeLabel = Instance.new("TextLabel")
	noticeLabel.Name = "NoticeLabel"
	noticeLabel.ZIndex = 26
	noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	noticeLabel.AutomaticSize = Enum.AutomaticSize.X
	noticeLabel.Size = UDim2.new(1, 0, 1, 0)
	noticeLabel.BackgroundTransparency = 1
	noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
	noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.FontSize = Enum.FontSize.Size14
	noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.Text = "1"
	noticeLabel.TextWrapped = true
	noticeLabel.TextWrap = true
	noticeLabel.Font = Enum.Font.Arial
	noticeLabel.Parent = notice
	
	local iconModule = script.Parent.Parent
	local packages = iconModule.Packages
	local Janitor = require(packages.Janitor)
	local Signal = require(packages.GoodSignal)
	local Utility = require(iconModule.Utility)
	icon.noticeChanged:Connect(function(totalNotices)

		-- Notice amount
		if not totalNotices then
			return
		end
		local exceeded99 = totalNotices > 99
		local noticeDisplay = (exceeded99 and "99+") or totalNotices
		noticeLabel.Text = noticeDisplay
		if exceeded99 then
			noticeLabel.TextSize = 11
		end

		-- Should enable
		local enabled = true
		if totalNotices < 1 then
			enabled = false
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
		if icon.isSelected and dropdownOrMenuActive then
			enabled = false
		elseif parentIcon and not parentIcon.isSelected then
			enabled = false
		end
		Utility.setVisible(notice, enabled, "NoticeHandler")

	end)
	icon.noticeStarted:Connect(function(customClearSignal, noticeId)
	
		if not customClearSignal then
			customClearSignal = icon.deselected
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		if parentIcon then
			parentIcon:notify(customClearSignal)
		end
		
		local noticeJanitor = icon.janitor:add(Janitor.new())
		local noticeComplete = noticeJanitor:add(Signal.new())
		noticeJanitor:add(icon.endNotices:Connect(function()
			noticeComplete:Fire()
		end))
		noticeJanitor:add(customClearSignal:Connect(function()
			noticeComplete:Fire()
		end))
		noticeId = noticeId or Utility.generateUID()
		icon.notices[noticeId] = {
			completeSignal = noticeComplete,
			clearNoticeEvent = customClearSignal,
		}
		local noticeLabel = icon:getInstance("NoticeLabel")
		local function updateNotice()
			icon.noticeChanged:Fire(icon.totalNotices)
		end
		icon.notified:Fire(noticeId)
		icon.totalNotices += 1
		updateNotice()
		noticeComplete:Once(function()
			noticeJanitor:destroy()
			icon.totalNotices -= 1
			icon.notices[noticeId] = nil
			updateNotice()
		end)
	end)
	
	-- Establish the notice
	notice:SetAttribute("ClipToJoinedParent", true)
	icon:clipOutside(notice)
	
	return notice
end]]></ProtectedString>
												<string name="ScriptGuid">{02016B40-A7A0-4C1B-8708-54C78C48C611}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Notice</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX52A350F75ED94CB2A01D614099676C36">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Features</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXB119F8E1555A49F5BC8DC573D54EE135">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[-- As the name suggests, this handles everything related to gamepads
-- (i.e. Xbox or Playstation controllers) and their navigation
-- I created a separate module for gamepads (and not touchpads or
-- keyboards) because gamepads are greatly more unqiue and require
-- additional tailored programming



-- SERVICES
local GamepadService = game:GetService("GamepadService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")



-- LOCAL
local Gamepad = {}
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Gamepad.start(incomingIcon)
	
	-- Public variables
	Icon = incomingIcon
	Icon.highlightKey = Enum.KeyCode.DPadUp -- What controller key to highlight the topbar (or set to false to disable)
	Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most
	
	-- We defer so the developer can make changes before the
	-- gamepad controls are initialized
	task.delay(1, function()
		-- Some local utility
		local iconsDict = Icon.iconsDictionary
		local function getIconFromSelectedObject()
			local clickRegion = GuiService.SelectedObject
			local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
			local icon = iconUID and iconsDict[iconUID]
			return icon
		end
		
		-- This enables users to instantly open up their last selected icon
		local previousHighlightedIcon
		local iconDisplayingHighlightKey
		local usedIndicatorOnce = false
		local usedBOnce = false
		local Utility = require(script.Parent.Parent.Utility)
		local Selection = require(script.Parent.Parent.Elements.Selection)
		local function updateSelectedObject()
			local icon = getIconFromSelectedObject()
			local gamepadEnabled = UserInputService.GamepadEnabled
			if icon then
				if gamepadEnabled then
					local clickRegion = icon:getInstance("ClickRegion")
					local selection = icon.selection
					if not selection then
						selection = icon.janitor:add(Selection(Icon))
						selection:SetAttribute("IgnoreVisibilityUpdater", true)
						selection.Parent = icon.widget
						icon.selection = selection
						icon:refreshAppearance(selection) --icon:clipOutside(selection)
					end
					clickRegion.SelectionImageObject = selection.Selection
				end
				if previousHighlightedIcon and previousHighlightedIcon ~= icon then
					previousHighlightedIcon:setIndicator()
				end
				local newIndicator = if gamepadEnabled and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
				previousHighlightedIcon = icon
				Icon.lastHighlightedIcon = icon
				icon:setIndicator(newIndicator)
			else
				local newIndicator = if gamepadEnabled and not usedIndicatorOnce then Icon.highlightKey else nil
				if not previousHighlightedIcon then
					previousHighlightedIcon = Gamepad.getIconToHighlight()
				end
				if newIndicator == Icon.highlightKey then
					-- We only display the highlightKey once to show
					-- the user how to highlight the topbar icon
					usedIndicatorOnce = true
				else
					--usedBOnce = true
				end
				if previousHighlightedIcon then
					previousHighlightedIcon:setIndicator(newIndicator)
				end
			end
		end
		GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)

		-- This listens for a gamepad being present/added/removed
		local function checkGamepadEnabled()
			local gamepadEnabled = UserInputService.GamepadEnabled
			if not gamepadEnabled then
				usedIndicatorOnce = false
				usedBOnce = false
			end
			updateSelectedObject()
		end
		UserInputService:GetPropertyChangedSignal("GamepadEnabled"):Connect(checkGamepadEnabled)
		checkGamepadEnabled()

		-- This allows for easy highlighting of the topbar when the
		-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
		-- If you'd like to disable, do ``Icon.highlightKey = false``
		UserInputService.InputBegan:Connect(function(input, touchingAnObject)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				-- Sometimes the Roblox gamepad glitches when combined with a cursor
				-- This fixes that by unhighlighting if the cursor is pressed down
				-- (i.e. a mouse click)
				local icon = getIconFromSelectedObject()
				if icon then
					GuiService.SelectedObject = nil
				end
				return
			end
			if input.KeyCode ~= Icon.highlightKey then
				return
			end
			local iconToHighlight = Gamepad.getIconToHighlight()
			if iconToHighlight then
				if GamepadService.GamepadCursorEnabled then
					task.wait(0.2)
					GamepadService:DisableGamepadCursor()
				end
				local clickRegion = iconToHighlight:getInstance("ClickRegion")
				GuiService.SelectedObject = clickRegion
			end
		end)
	end)
end

function Gamepad.getIconToHighlight()
	-- If an icon has already been selected, returns the last selected icon
	-- Else if more than 0 icons, it selects the left-most icon
	local iconsDict = Icon.iconsDictionary
	local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
	if not iconToHighlight then
		local currentX
		for _, icon in pairs(iconsDict) do
			if icon.parentIconUID then
				continue
			end
			local thisX = icon.widget.AbsolutePosition.X
			if not currentX or thisX < currentX then
				iconToHighlight = icon
				currentX = iconToHighlight.widget.AbsolutePosition.X
			end
		end
	end
	return iconToHighlight
end

-- This called when the icon's ClickRegion is created
function Gamepad.registerButton(buttonInstance)
	-- This provides a basic level of support for controllers by making
	-- the icons easy to highlight via the virtual cursor, then
	-- when selected, focuses in on the selected icon and hops
	-- between other nearby icons simply by toggling the joystick
	local inputBegan = false
	buttonInstance.InputBegan:Connect(function(input)
		-- Two wait frames required to ensure inputBegan is detected within
		-- UserInputService.InputBegan. We do this because object.InputBegan
		-- does not return the correct input objects (unlike the service)
		inputBegan = true
		task.wait()
		task.wait()
		inputBegan = false
	end)
	local connection = UserInputService.InputBegan:Connect(function(input)
		task.wait()
		if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
			-- We focus on an icon when selected via the virtual cursor
			task.wait(0.2)
			GamepadService:DisableGamepadCursor()
			GuiService.SelectedObject = buttonInstance
			return
		end
		local isSelected = GuiService.SelectedObject == buttonInstance
		local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
		local keyName = input.KeyCode.Name
		if table.find(unselectKeyCodes, keyName) and isSelected then
			-- We unfocus when back button is pressed, but ignore
			-- if the virtual cursor is disabled otherwise it will be
			-- impossible to select the topbar
			if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
				GuiService.SelectedObject = nil
			end
		end
	end)
	buttonInstance.Destroying:Once(function()
		connection:Disconnect()
	end)
end



return Gamepad]]></ProtectedString>
												<string name="ScriptGuid">{FC5DDBD1-6D79-4F69-BC2C-9F4F1BCE4BEA}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Gamepad</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXC028F1A03BC54B86BB5782F5F06C3439">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[-- When designing your game for many devices and screen sizes, icons may occasionally
-- particularly for smaller devices like phones, overlap with other icons or the bounds
-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring



-- LOCAL
local Overflow = {}
local holders = {}
local orderedAvailableIcons = {}
local iconsDict
local currentCamera = workspace.CurrentCamera
local overflowIcons = {}
local overflowIconUIDs = {}
local Utility = require(script.Parent.Parent.Utility)
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Overflow.start(incomingIcon)
	Icon = incomingIcon
	iconsDict = Icon.iconsDictionary
	local primaryScreenGui
	for _, screenGui in pairs(Icon.container) do
		if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
			primaryScreenGui = screenGui
		end
		for _, holder in pairs(screenGui.Holders:GetChildren()) do
			if holder:GetAttribute("IsAHolder") then
				holders[holder.Name] = holder
			end
		end
	end

	-- We listen for changes in icons (such as them being added, removed,
	-- the setting of a different alignment, the widget size changing, etc)
	local beginOverflow = false
	local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
		if not beginOverflow then
			return
		end
		if not ignoreAvailable then
			Overflow.updateAvailableIcons("Center")
		end
		Overflow.updateBoundary("Left")
		Overflow.updateBoundary("Right")
	end)
	task.delay(1, function()
		-- This is essential to prevent central icons begin added
		-- left or right due to incomplete UIListLayout calculations
		-- within the first few frames
		beginOverflow = true
		updateBoundaries()
	end)
	Icon.iconAdded:Connect(updateBoundaries)
	Icon.iconRemoved:Connect(updateBoundaries)
	Icon.iconChanged:Connect(updateBoundaries)
	currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
		updateBoundaries(true)
	end)
	primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updateBoundaries(true)
	end)
end

function Overflow.getWidth(icon, getMaxWidth)
	local widget = icon.widget
	return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
end

function Overflow.getAvailableIcons(alignment)
	local ourOrderedIcons = orderedAvailableIcons[alignment]
	if not ourOrderedIcons then
		ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	end
	return ourOrderedIcons
end

function Overflow.updateAvailableIcons(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon)
	local ourTotal = 0
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local ourOrderedIcons = {}
	for _, icon in pairs(iconsDict) do
		local parentUID = icon.parentIconUID
		local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
		local isOverflow = overflowIconUIDs[icon.UID]
		if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow then
			table.insert(ourOrderedIcons, icon)
			ourTotal += 1
		end
	end

	-- Ignore if no icons are available
	if ourTotal <= 0 then
		return {}
	end

	-- This sorts these icons by smallest order, or if equal, left-most position
	-- (even for the right alignment because all icons are sorted left-to-right)
	table.sort(ourOrderedIcons, function(iconA, iconB)
		local orderA = iconA.widget.LayoutOrder
		local orderB = iconB.widget.LayoutOrder
		local hasParentA = iconA.parentIconUID
		local hasParentB = iconB.parentIconUID
		if hasParentA == hasParentB then
			if orderA < orderB then
				return true
			end
			if orderA > orderB then
				return false
			end
			return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
		elseif hasParentB then
			return false
		elseif hasParentA then
			return true
		end
	end)

	-- Finish up
	orderedAvailableIcons[alignment] = ourOrderedIcons
	return ourOrderedIcons

end

function Overflow.getRealXPositions(alignment, orderedIcons)
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local isLeft = alignment == "Left"
	local holder = holders[alignment]
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local holderUIList = holder.UIListLayout
	local topbarInset = holderUIList.Padding.Offset
	local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
	local realXPositions = {}
	if isLeft then
		Utility.reverseTable(orderedIcons)
	end
	for i = #orderedIcons, 1, -1 do
		local icon = orderedIcons[i]
		local sizeX = Overflow.getWidth(icon)
		if not isLeft then
			absoluteX -= sizeX
		end
		realXPositions[icon.UID] = absoluteX
		if isLeft then
			absoluteX += sizeX
		end
		absoluteX += (isLeft and topbarInset) or -topbarInset
	end
	return realXPositions
end

function Overflow.updateBoundary(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local topbarInset = holderUIList.Padding.Offset
	local topbarPadding = holderUIList.Padding.Offset
	local BOUNDARY_GAP = topbarInset
	local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	local boundWidth = 0
	local ourTotal = 0
	for _, icon in pairs(ourOrderedIcons) do
		boundWidth += Overflow.getWidth(icon) + topbarPadding
		ourTotal += 1
	end
	if ourTotal <= 0 then
		return
	end
	
	-- These are the icons with menus which icons will be moved into
	-- when overflowing
	local isCentral = alignment == "Central"
	local isLeft = alignment == "Left"
	local isRight = not isLeft
	local overflowIcon = overflowIcons[alignment]
	if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
		local order = (isLeft and -9999999) or 9999999
		overflowIcon = Icon.new()--:setLabel(`{alignment}`)
		overflowIcon:setImage(6069276526, "Deselected")
		overflowIcon:setName("Overflow"..alignment)
		overflowIcon:setOrder(order)
		overflowIcon:setAlignment(alignment)
		overflowIcon:autoDeselect(false)
		overflowIcon.isAnOverflow = true
		--overflowIcon:freezeMenu()
		overflowIcon:select("OverflowStart", overflowIcon)
		overflowIcon:setEnabled(false)
		overflowIcons[alignment] = overflowIcon
		overflowIconUIDs[overflowIcon.UID] = true
	end

	-- The default boundary is the point where both the left-most-right-icon
	-- and left-most-right-icon meet OR the opposite side of the screen
	local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
	local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
	local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
	local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
	local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
	if nearestOppositeIcon then
		local oppositeEndWidget = nearestOppositeIcon.widget
		local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
		local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
		local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
		boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
	end
	
	-- We get the left-most icon (if left alignment) or right-most-icon (if
	-- right alignment) of the central icons group to see if we need to change
	-- the boundary (if the central icon boundary is smaller than the alignment
	-- boundary then we use the central)
	local centerOrderedIcons = Overflow.getAvailableIcons("Center")
	local centerPos = (isLeft and 1) or #centerOrderedIcons
	local nearestCenterIcon = centerOrderedIcons[centerPos]
	local usingNearestCenter = false
	if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
		local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
		local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
		local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
		local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
		local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
		local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
		if isLeft then
			if centerBoundary < removeBoundary then
				nearestCenterIcon:align("Left")
				nearestCenterIcon.hasRelocatedInOverflow = true
			end
		elseif isRight then
			if centerBoundary > removeBoundary then
				nearestCenterIcon:align("Right")
				nearestCenterIcon.hasRelocatedInOverflow = true
			end
		end
	end
	
	--[[
	This updates the maximum size of the overflow menus
	The menu determines its bounds from the smallest of either:
	 	1. The closest center-aligned icon (i.e. the boundary)
	 	2. The edge of the opposite overflow menu UNLESS...
	 	3. ... the edge exceeds more than half the screenGui
	--]]
	if overflowIcon then
		local menuBoundary = boundary
		local menu = overflowIcon:getInstance("Menu")
		local holderXEndPos = holderXPos + holderXSize
		local menuWidth = holderXSize
		if menu and oppositeOverflowIcon then
			local oppositeWidget = oppositeOverflowIcon.widget
			local oppositeXPos = oppositeWidget.AbsolutePosition.X
			local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
			local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
			local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
			local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
			if not usingNearestCenter then
				local halfwayXPos = holderXPos + holderXSize/2
				local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
				menuBoundary = halfwayBoundary
				if isDominant then
					menuBoundary = oppositeBoundary
				end
			end
			menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
		end
		local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
		menuWidth = Utility.round(menuWidth)
		if menu and currentMaxWidth ~= menuWidth then
			menu:SetAttribute("MaxWidth", menuWidth)
		end
	end

	-- Parent ALL icons of that alignment into the overflow if at least on
	-- sibling exceeds the bounds.
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local widgetX = Overflow.getWidth(icon)
		local xPos = realXPositions[icon.UID]
		if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
			joinOverflow = true
		end
	end
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local isOverflow = overflowIconUIDs[icon.UID]
		if not isOverflow then
			if joinOverflow and not icon.parentIconUID then
				icon:joinMenu(overflowIcon)
			elseif not joinOverflow and icon.parentIconUID then
				icon:leave()
			end
		end
	end
	
	-- Hide the overflows when not in use
	if overflowIcon.isEnabled ~= joinOverflow then
		overflowIcon:setEnabled(joinOverflow)
	end
	
	-- Have the menus auto selected
	if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
		overflowIcon.overflowAlreadyOpened = true
		overflowIcon:select()
	end

end



return Overflow]]></ProtectedString>
												<string name="ScriptGuid">{D594FC91-E0DA-49EB-A28F-B259863300EA}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Overflow</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX851435541E0E4CE9A365455F307EA260">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
												<string name="ScriptGuid">{ABB1B5F3-4BA6-425B-91CA-FF36FB5C2809}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Themes</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX6F6E638D4E004574B624913778B8BB35">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
													<string name="ScriptGuid">{5E1C8792-0A29-44DD-8241-314220886423}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Classic</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX7792EBCD259B449BB0E860DEA2F8C7EF">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
	{"IconButton", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.3, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Medium, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.925, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
	{"Dropdown", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.3, "Deselected"},
	{"Dropdown", "MaxIcons", 4, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
													<string name="ScriptGuid">{42ADE2B0-388D-4438-BF7D-02F7F07E62A9}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Default</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
									<Item class="Folder" referent="RBXEB4F63203BAF4E5BBA8E877B6D5EF73B">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Packages</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX206F79D6D8F04EF2B6050B8A358C8DC2">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end
Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end
Signal.Destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal]]></ProtectedString>
												<string name="ScriptGuid">{51EC698B-BB4E-454D-A3CB-0F5C011ED406}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">GoodSignal</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXC1EB8A19B9864ABE9A5034D365A6B306">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------
This package was modified by ForeverHD.

PACKAGE MODIFICATIONS:
	1. Added pascalCase aliases for all methods
	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
	3. Slight change to how promises are tracked
	4. Added isAnInstanceBeingDestroyed check to line 228
	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
	6. Likely some additional changes which weren't record here
-------------------------------------
--]]



-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local function getPromiseReference()
	if RunService:IsRunning() then
		local main = require(game:GetService("ReplicatedStorage").Framework)
		return main.modules.Promise
	end
end

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	IGNORE_MEMORY_DEBUG = true,
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	["Promise"] = "cancel";
	RBXScriptConnection = "Disconnect";
}

--[[**
	Instantiates a new Janitor object.
	@returns [t:Janitor]
**--]]
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

--[[**
	Determines if the passed object is a Janitor.
	@param [t:any] Object The object you are checking.
	@returns [t:boolean] Whether or not the object is a Janitor.
**--]]
function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

--[[**
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.
	@param [t:any] Object The object you want to clean up.
	@param [t:string|true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param [t:any?] Index The index that can be used to clean up the object manually.
	@returns [t:any] The object that was passed.
**--]]
function Janitor.__index:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local objectType = typeof(Object)
	if objectType == "table" and string.match(tostring(Object), "Promise") then
		objectType = "Promise"
		--local status = Object:getStatus()
		--print("status =", status, status == "Rejected")
	end
	MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
	end

	local OriginalTraceback = debug.traceback("")
	self[Object] = {MethodName, OriginalTraceback}
	return Object
end
Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

--[[**
	Adds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.
	@param [t:Promise] PromiseObject The promise you want to add to the janitor.
	@returns [t:Promise]
**--]]
function Janitor.__index:AddPromise(PromiseObject)
	local Promise = getPromiseReference()
	if Promise then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
						PromiseObject:cancel()
					end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	local Promise = getPromiseReference()
	if Promise and Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

--[[**
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.
	@param [t:any] Index The index you want to remove.
	@returns [t:Janitor] The same janitor, for chaining reasons.
**--]]
function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]
	if This then
		local Object = This[Index]

		if Object then
			local ObjectDetail = self[Object]
			local MethodName = ObjectDetail and ObjectDetail[1]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

--[[**
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the job using `__index`.
	@param [t:any] Index The index that the object is stored under.
	@returns [t:any?] This will return the object if it is found, but it won't return anything if it doesn't exist.
**--]]
function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
end

--[[**
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).
	@returns [t:void]
**--]]
function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, ObjectDetail in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			local MethodName = ObjectDetail[1]
			local OriginalTraceback = ObjectDetail[2]
			local function warnUser(warning)
				local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
				local addedLine = OriginalTraceback
				warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
			end
			if MethodName == true then
				local success, warning = pcall(Object)
				if not success then
					warnUser(warning)
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					local success, warning = pcall(ObjectMethod, Object)
					local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
					if not success and not isAnInstanceBeingDestroyed then
						warnUser(warning)
					end
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

--[[**
	Calls `:Cleanup()` and renders the Janitor unusable.
	@returns [t:void]
**--]]
function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

--- Makes the Janitor clean up when the instance is destroyed
-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed
-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)
-- @author Corecii
local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

--[[**
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	@param [t:Instance] Object The instance you want to link the Janitor to.
	@param [t:boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.
	@returns [t:RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.
**--]]
function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

--[[**
	Links several instances to a janitor, which is then returned.
	@param [t:...Instance] ... All the instances you want linked.
	@returns [t:Janitor] A janitor that can be used to manually disconnect all LinkToInstances.
**--]]
function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
												<string name="ScriptGuid">{6ED602A8-04A1-4DC6-B67D-C7738A3C05CF}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Janitor</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Script" referent="RBX4FADC78A03B24591885167F4BA33A4EA">
							<Properties>
								<ProtectedString name="Source"><![CDATA[--[[
                                                                                                                                     
                                                                                                                                  
                                                                                                                                  
                                                                                                                                  
              ################                                                                                                    
             ###             ##                                                                                                   
             ###             ##                                                                                                   
             ##################                                                                                                   
     ##################################                                                                                           
    ###                             ####     ########## #####   #####  ######### #############  ##########   ######   ######   
    ####################################    ########### #####   ##### ##########  ###########  ############  ####### #######   
    ####################################   #####        #####   ##### ########       #####     ####    ####  ###############    
    ###                             ####   #####        #####   #####  ##########    #####     ####    ####  ###############    
    ####################################    #####       #####   #####       #####    #####     ####    ####  #### ##### ####    
    ####################################    ###########  ###########  ###########    #####     ############  ####  ###  ####   
    ####################################      #########   #########    #########     #####      #########    ####       ####      
    ####################################                                                                                          
    ####################################                                                                                          
    ####################################    #################################################################################     
    ####################################    #################################################################################     
    ####################################                                                                                          
    ####################################                     #######       ####         #####    ###     ####                     
    ####################################                    ###########   ######     ########### ####  ######                     
    ####################################                    ##### ###### #######    ######   ### ##########                       
    ####################################                    ##### ###############  #####         ########                         
    ###                             ####                    ########### #### ##### #####         ########                         
    ####################################                    #####      ###########  #####        #########                        
    ####################################                    #####     #############  ########### ####  #####                      
    ####                           #####                    #####     ####      ####   ########  ####    #####                    
    ####################################                                                                                          
    ####################################                                                                                          
     ##################################                                                                                           
                                                                                                                                  
                                                                                                                                                 
	Thank you for using CustomPack. Here's how to get started:

	It's pretty easy to set up, all you gotta do is to put the script into StarterPlayerScripts and customize it to your likings in the Attributes of the Main script.


	-- API DOCUMENTATION --
	
	To use the API, invoke the remote function named "CustomPackAPI".
	
	-+ MAIN +-
	
	SetBackpackEnabled()
		Arguments: enabled (boolean)
		Hides/shows the backpack and the hotbar. Does not affect the inventory.
		Example: CustomPackAPI:Invoke("SetBackpackEnabled", {true})
		
	SetInventoryOpen()
		Arguments: enabled (boolean)
		Opens/closes the inventory. Does not affect the hotbar or the backpack.
		Example: CustomPackAPI:Invoke("SetInventoryOpen", {true})
		
	ToggleInventoryOpen()
		Arguments: None
		Opens the inventory if it's closed, closes if it's open.
		Example: CustomPackAPI:Invoke("ToggleInventoryOpen")
		
	IsInventoryOpen()
		Arguments: None
		Checks if the inventory is open.
		Example: CustomPackAPI:Invoke("IsInventoryOpen")
		
	-+ TOOL GROUPS +-
	
	SetToolGroup()
		Arguments: tool (Tool), group (string)
		Sets the group of a tool.
		Example: CustomPackAPI:Invoke("SetToolGroup", {tool, "Group1"})
		
	GetToolsInGroup()
		Arguments: group (string)
		Gets all tools in a group.
		Example: CustomPackAPI:Invoke("SetToolGroupEnabled", {"Group1"})
	
	GetToolGroup()
		Arguments: tool (Tool)
		Gets the group of a tool.
		Example: CustomPackAPI:Invoke("GetToolGroup", {tool})
		
	GetGroupIcon()
		Arguments: group (string)
		Gets the icon of a tool group.
		Example: CustomPackAPI:Invoke("GetGroupIcon", {"Group1"})
		
	SetGroupIcon()
		Arguments: group (string), icon (string)
		Sets the icon of a tool group.
		Example: CustomPackAPI:Invoke("GetGroupIcon", {"Group1", "rbxassetid://1"})
	
	RemoveToolGroup()
		Arguments: tool (Tool)
		Removes the group of a tool.
		Example: CustomPackAPI:Invoke("RemoveToolGroup", {tool})
	
	GetAllGroups()
		Arguments: None
		Gets all tool groups.
		Example: CustomPackAPI:Invoke("GetAllGroups")
		
	-+ SLOTS +-
	
	GetSelectedSlotChangedEvent()
		Arguments: None
		Gets the event that is fired when the selected slot changes.
		Example: CustomPackAPI:Invoke("GetSelectedSlotChangedEvent")
	
	GetSlot()
		Arguments: index (number)
		Gets the slot at the given index. Returns nil if none is found.
		Example: CustomPackAPI:Invoke("GetSlot", {1})
		
	GetAllSlots()
		Arguments: None
		Gets all slots.
		Example: CustomPackAPI:Invoke("GetAllSlots")
		
	GetEquippedSlot()
		Arguments: None
		Gets the equipped slot. Returns nil if none is found.
		Example: CustomPackAPI:Invoke("GetEquippedSlot")
	
	--- OBJECTS ---
	
	Slot:
		Slot.Tool (Tool)
			The tool in the slot.
			Example: CustomPackAPI:Invoke("GetSlot", {1}).Tool
		
		Slot.Index (number)
			The index of the slot.
			Example: CustomPackAPI:Invoke("GetSlot", {1}).Index
		
		Slot.IsEquipped (boolean)
			If the slot is equipped.
			Example: CustomPackAPI:Invoke("GetSlot", {1}).IsEquipped
	
	
	-+ SOUNDS +-
	
	GetEquipSound()
		Arguments: None
		Gets the sound that is played when equipping a tool.
		Example: CustomPackAPI:Invoke("GetEquipSound")
		
	GetUnequipSound()
		Arguments: None
		Gets the sound that is played when unequipping a tool.
		Example: CustomPackAPI:Invoke("GetUnequipSound")
		
	-+ OTHER +-
	
	GetVersion()
		Arguments: None
		Gets the version of CustomPack.
		Example: CustomPackAPI:Invoke("GetVersion")
]]]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{1D3905EB-968F-4C56-B932-9B6CB810C80B}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">README AND DOCUMENTATION</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXAAB6F9FAFA684BCBBE98A5303CA8DCC9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Text+</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXDE6531E9214242CF8BCF38D4CAB8C5F0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native

--[[

          TTTTTTTTTTTT                                                                              
TTTTTTTTTTTTTTTTTTTTTT                                                                              
TTTTTTTTTTTTTTTTTTTTTT                                                                              
 TT      TTTTT                                                      ttttt                           
         TTTTTT                                            xxx      tttttt                          
         TTTTTT            eeeeeeeeee      xxxxxxx     xxxxxx       tttttt             +++++        
         TTTTTT          eeeeeeeeeeeeee      xxxxxx    xxxxx     ttttttttttttt          +++++       
         TTTTTT         eeeeeee   eeeeee      xxxxxx  xxxxx      ttttttttttttt          +++++       
         TTTTTT        eeeeee       eeeee      xxxxxxxxxxx          tttttt              +++++++++++
         TTTTTT        eeeeeeeeeeeeeeeeee       xxxxxxxxxx          tttttt       +++++++++++++++++++
         TTTTTT       eeeeeeeeeeeeeeeeeee        xxxxxxxxx          tttttt       +++++++++++++++++++
          TTTTTT       eeeee           ee       xxxxxxxxxxx         tttttt        +++   +++++       
          TTTTTT       eeeeee                   xxxxx xxxxxx       tttttt                +++++      
          TTTTTT        eeeeee    eeeeeee      xxxxx   xxxxxxx     tttttt                +++++      
          TTTTTT         eeeeeeeeeeeeeee      xxxxxx     xxxxxx    ttttttttt             +++++      
                           eeeeeeeeee        xxxxxx                 ttttttttt                       
                                                                      ttttttt                       

v1.29.1

An efficient, robust, open-source text-rendering library for
Roblox, featuring custom fonts and advanced text control.


GitHub (repository):
https://github.com/AlexanderLindholt/TextPlus

GitBook (documentation):
https://alexxander.gitbook.io/TextPlus

DevForum (topic):
https://devforum.roblox.com/t/3521684


--------------------------------------------------------------------------------
MIT License

Copyright (c) 2025 Alexander Lindholt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--------------------------------------------------------------------------------

]]--

-- Services.
local CollectionService = game:GetService("CollectionService")
local TextService = game:GetService("TextService")

-- Attempt to find the plugin object.
local plugin = script:FindFirstAncestorOfClass("Plugin")

-- Signal library.
local Signal
if plugin then
	for _, instance in plugin:GetDescendants() do
		if instance:HasTag("Signal") then
			Signal = require(instance)
			if type(Signal) == "table" and Signal.new then Signal = Signal.new end
			break
		end
	end
else
	Signal = CollectionService:GetTagged("Signal")[1]
	if Signal then
		Signal = require(Signal)
		if type(Signal) == "table" and Signal.new then Signal = Signal.new end
	end
end

-- Player viewport.
local camera = workspace.CurrentCamera

-- Character for when a character is missing in a custom font.
local missingCharacter = "rbxassetid://75989824347198"

-- Options list for validation.
local optionsList = require(script.Options)
-- Option defaults.
local defaults = require(script.Defaults)
-- Options corrector.
local correctOptions = require(script.CorrectOptions)

-- Instance recycling.
local textLabelsAmount, textLabels = 0, {}
local imageLabelsAmount, imageLabels = 0, {}
local uiStrokesAmount, uiStrokes = 0, {}
local foldersAmount, folders = 0, {}
local function getTextLabel()
	local instance = textLabels[textLabelsAmount]
	if not instance then
		textLabelsAmount += 1
		return Instance.new("TextLabel")
	end
	textLabels[textLabelsAmount] = nil
	textLabelsAmount -= 1
	return instance
end
local function getImageLabel()
	local instance = imageLabels[imageLabelsAmount]
	if not instance then
		imageLabelsAmount += 1
		return Instance.new("ImageLabel")
	end
	imageLabels[imageLabelsAmount] = nil
	imageLabelsAmount -= 1
	return instance
end
local function getUIStroke()
	local instance = uiStrokes[uiStrokesAmount]
	if not instance then
		uiStrokesAmount += 1
		return Instance.new("UIStroke")
	end
	uiStrokes[uiStrokesAmount] = nil
	uiStrokesAmount -= 1
	return instance
end
local function getFolder()
	local instance = folders[foldersAmount]
	if not instance then
		foldersAmount += 1
		return Instance.new("Folder")
	end
	folders[foldersAmount] = nil
	foldersAmount -= 1
	return instance
end

-- Types.
export type CustomFont = {
	Image: number,
	Size: number,
	Characters: {
		[string]: {}
	}
}
export type Options = {
	Font: Font | CustomFont?,
	
	Size: number?,
	
	ScaleSize:
		"RootX" | "RootY" | "RootXY" |
		"FrameX" | "FrameY" | "FrameXY"?,
	MinimumSize: number?,
	MaximumSize: number?,
	
	Color: Color3?,
	Transparency: number?,
	
	Pixelated: boolean?,
	
	Offset: Vector2?,
	Rotation: number?,
	
	StrokeSize: number?,
	StrokeColor: Color3?,
	StrokeTransparency: number?,
	
	ShadowOffset: Vector2?,
	ShadowColor: number?,
	ShadowTransparency: number?,
	
	LineHeight: number?,
	CharacterSpacing: number?,
	
	Truncate: boolean?,
	
	XAlignment: "Left" | "Center" | "Right" | "Justified"?,
	YAlignment: "Top" | "Center" | "Bottom" | "Justified"?,
	
	WordSorting: boolean?,
	LineSorting: boolean?,
	
	Dynamic: boolean?
}

type Connection = {
	Connected: boolean,
	Disconnect: typeof(
		-- Erases the connection.
		function(connection: Connection) end
	)
}
type Signal<Parameters...> = {
	Connect: typeof(
		-- Connects a function.
		function(signal: Signal<Parameters...>, callback: (Parameters...) -> ()): Connection end
	),
	Once: typeof(
		-- Connects a function, then auto-disconnects after the first call.
		function(signal: Signal<Parameters...>, callback: (Parameters...) -> ()): Connection end
	),
	Wait: typeof(
		-- Yields the calling thread until the next fire.
		function(signal: Signal<Parameters...>): Parameters... end
	),
	
	Fire: typeof(
		-- Runs all connected functions, and resumes all waiting threads.
		function(signal: Signal<Parameters...>, ...: Parameters...) end
	),
	
	DisconnectAll: typeof(
		-- Erases all connections.<br>
		-- <em>Much faster than calling <code>Disconnect</code> on each.</em>
		function(signal: Signal<Parameters...>) end
	),
	Destroy: typeof(
		-- Erases all connections and methods, making the signal unusable.<br>
		-- Remove references to the signal to delete it completely.
		function(signal: Signal<Parameters...>) end
	)
}

-- Frame data tables.
local frameText: {string} = {}
local frameOptions: {Options} = {}
local frameTextBounds: {Vector2} = {}
local frameSizeConnections: {RBXScriptSignal} = {}
local frameUpdateSignals: {Signal} = if Signal then {} else nil

-- Roblox built-in text rendering stuff.
local textBoundsParams = Instance.new("GetTextBoundsParams")
textBoundsParams.Size = 100 -- Size limit for Roblox's built-in text-rendering.

local characterWidthCache = {}

-- Custom fonts.
local userFonts = require(script.Fonts)

-- Module.
local module = {}

--[[
Returns the last rendered text string for a frame.
]]--
module.GetText = function(frame: GuiObject): Options
	-- Get, verify and return text.
	local text = frameText[frame]
	if not text then error("Invalid frame.", 2) end
	return text
end
--[[
Returns the current options for a frame.
]]--
module.GetOptions = function(frame: GuiObject): Options
	-- Get, verify and return options.
	local options = frameOptions[frame]
	if not options then error("Invalid frame.", 2) end
	return frameOptions[frame]
end
--[[
Returns the last rendered text's bounds for a frame.
]]--
module.GetBounds = function(frame: GuiObject): Vector2
	-- Get, verify and return text bounds.
	local textBounds = frameTextBounds[frame]
	if not textBounds then error("Invalid frame.", 2) end
	return textBounds
end

--[[
Returns the update signal for a frame.
]]--
module.GetUpdateSignal = function(frame: GuiObject): Signal
	-- Get, verify and return signal.
	local signal = frameUpdateSignals[frame]
	if not signal then error("Invalid frame.", 2) end
	return signal
end

--[[
Returns a function for iterating through all characters in a frame.

<em>Ignores sorting folders.
Works with any sorting.</em>
]]--
module.GetCharacters = function(frame: GuiObject): {TextLabel | ImageLabel}
	-- Get and verify options.
	local options = frameOptions[frame]
	if not options then error("Invalid frame.", 2) end
	
	-- Create and return iterator.
	return coroutine.wrap(function()
		-- Identify sorting.
		local lineSorting, wordSorting = options.LineSorting, options.WordSorting
		
		if lineSorting and wordSorting then -- Full sorting.
			-- Global character counter.
			local index = 0
			
			-- Loop through lines.
			for _, line in frame:GetChildren() do
				-- Verify instance.
				if line:IsA("Folder") then
					-- Loop through words.
					for _, word in line:GetChildren() do
						-- Loop through characters.
						for _, character in word:GetChildren() do
							-- Increment global character counter.
							index += 1
							-- Pass parameters to loop.
							coroutine.yield(index, character)
						end
					end
				end
			end
		elseif lineSorting or wordSorting then -- One sorting.
			-- Global character counter.
			local index = 0
			
			-- Loop through words/lines.
			for _, folder in frame:GetChildren() do
				-- Verify instance.
				if folder:IsA("Folder") then
					-- Loop through characters.
					for _, character in folder:GetChildren() do
						-- Increment global character counter.
						index += 1
						-- Pass parameters to loop.
						coroutine.yield(index, character)
					end
				end
			end
		else -- No sorting.
			-- Identify character instance class for verification.
			local characterClass = if type(options.Font) == "table" then "TextLabel" else "ImageLabel"
			
			-- Loop through characters.
			for index, character in frame:GetChildren() do
				-- Verify instance.
				if character:IsA(characterClass) then
					-- Pass parameters to loop.
					coroutine.yield(index, character)
				end
			end
		end
	end)
end

local function clear(frame)
	-- Get options.
	local options = frameOptions[frame]
	
	-- Identify character instance class and storage table.
	local characterTable, characterClass = nil
	if type(options.Font) == "table" then
		characterTable = imageLabels
		characterClass = "ImageLabel"
	else
		characterTable = textLabels
		characterClass = "TextLabel"
	end
	
	-- Setup character stashing.
	local function stashCharacter(character)
		-- Remove and store character instance.
		character.Parent = nil
		table.insert(characterTable, character)
		
		-- Remove and store character's stroke if existent.
		local stroke = character:FindFirstChildOfClass("UIStroke")
		if stroke then
			stroke.Parent = nil
			uiStrokes[uiStrokesAmount + 1] = stroke
		end
		
		-- Remove and store the main character if this is a shadow.
		local main = character:FindFirstChildOfClass(characterClass)
		if main then
			-- Remove and store the main character instance.
			main.Parent = nil
			table.insert(characterTable, main)
			
			-- Remove and store the main character's stroke if existent.
			local mainStroke = main:FindFirstChildOfClass("UIStroke")
			if mainStroke then
				mainStroke.Parent = nil
				uiStrokes[uiStrokesAmount + 1] = mainStroke
			end
		end
	end
	
	-- Identify sorting.
	local lineSorting, wordSorting = options.LineSorting, options.WordSorting
	
	if lineSorting and wordSorting then -- Full sorting.
		-- Loop through lines.
		for _, line in frame:GetChildren() do
			-- Verify instance.
			if not line:IsA("Folder") then continue end
			
			-- Remove and store line folder.
			line.Parent = nil
			folders[foldersAmount + 1] = line
			
			-- Loop through words.
			for _, word in line:GetChildren() do
				-- Remove and store word folder.
				word.Parent = nil
				folders[foldersAmount + 1] = word
				
				-- Loop through characters.
				for _, character in word:GetChildren() do
					stashCharacter(character)
				end
			end
		end
	elseif lineSorting or wordSorting then -- One sorting.
		-- Loop through words/lines.
		for _, folder in frame:GetChildren() do
			-- Verify instance.
			if not folder:IsA("Folder") then continue end
			
			-- Remove and store word/line folder.
			folder.Parent = nil
			folders[foldersAmount + 1] = folder
			
			-- Loop through characters.
			for _, character in folder:GetChildren() do
				stashCharacter(character)
			end
		end
	else -- No sorting.
		-- Loop through characters.
		for _, character in frame:GetChildren() do
			-- Verify instance.
			if not character:IsA(characterClass) then continue end
			
			stashCharacter(character)
		end
	end
end
local function render(frame, text, options)
	-- Cache frame size.
	local frameSize = frame.AbsoluteSize
	
	local frameWidth = frameSize.X
	local frameHeight = frameSize.Y
	
	-- Handle options.
	local font = options.Font
	
	local size = options.Size
	
	local color = options.Color
	local transparency = options.Transparency
	
	local offset = options.Offset; local offsetX, offsetY
	local rotation = options.Rotation
	
	local strokeSize = options.StrokeSize
	
	local shadowOffset = options.ShadowOffset; local shadowOffsetX, shadowOffsetY
	
	local lineHeight = options.LineHeight
	local characterSpacing = options.CharacterSpacing
	
	local truncationEnabled = options.Truncate
	
	local xAlignment = options.XAlignment
	local yAlignment = options.YAlignment
	
	local wordSorting = options.WordSorting
	local lineSorting = options.LineSorting
	
	local scaleSize = options.ScaleSize
	if scaleSize then
		-- Scale size.
		if scaleSize:sub(1, 1) == "R" then -- Relative to root.
			-- Find root size.
			local root = frame:FindFirstAncestorOfClass("GuiBase")
			local rootSize = if root then
				if root:IsA("ScreenGui") then
				camera.ViewportSize
				else
				root.AbsoluteSize
			else
				Vector2.zero
			
			-- Scale size.
			if scaleSize == "RootX" then
				size = size*0.01*rootSize.X
			elseif scaleSize == "RootY" then
				size = size*0.01*rootSize.Y
			else
				size = size*0.01*(rootSize.X + rootSize.Y)/2
			end
		else -- Relative to frame.
			if scaleSize == "FrameX" then
				size = size*0.01*frameWidth
			elseif scaleSize == "FrameY" then
				size = size*0.01*frameHeight
			else
				size = size*0.01*(frameWidth + frameHeight)/2
			end
		end
		
		-- Limit scaled size.
		if size < 1 then
			size = 1
		else
			-- Custom limits.
			local minimumSize = options.MinimumSize
			if minimumSize and options.Size < minimumSize then
				options.Size = minimumSize
			end
			local maximumSize = options.MaximumSize
			if maximumSize and options.Size > maximumSize then
				options.Size = maximumSize
			end
			
			-- Roblox font limit.
			if type(font) ~= "table" and size > 100 then
				size = 100
			end
		end
		
		-- Ensure integer size.
		size = math.round(size)
		
		-- Scale the related options.
		offsetX, offsetY = math.round(offset.X*0.01*size), math.round(offset.Y*0.01*size)
		if strokeSize then strokeSize = math.round(strokeSize*0.01*size) end
		if shadowOffset then shadowOffsetX, shadowOffsetY = math.round(shadowOffset.X*0.01*size), math.round(shadowOffset.Y*0.01*size) end
	else
		-- Ensure integer size.
		size = math.round(size)
		
		-- Save offsets in optimized format.
		offsetX, offsetY = offset.X, offset.Y
		if shadowOffset then shadowOffsetX, shadowOffsetY = shadowOffset.X, shadowOffset.Y end
	end
	
	lineHeight *= size
	
	-- Setup character functions.
	local getCharacterWidth, createCharacter
	if type(font) == "table" then
		-- Custom font.
		local image = "rbxassetid://"..tostring(font.Image)
		local scaleFactor = size/font.Size
		local characters = font.Characters
		local resampleMode = if options.Pixelated then Enum.ResamplerMode.Pixelated else Enum.ResamplerMode.Default
		
		--[[
		Character data (table):
			[1] = number - Size x
			[2] = number - Size y
			[3] = Vector2 - Image offset
			[4] = number - Offset x
			[5] = number - Offset y
			[6] = number - X advance
		]]--
		
		getCharacterWidth = function(character)
			local data = characters[character]
			return if data then
				data[6]*size*characterSpacing
				else -- Missing character.
				size*characterSpacing -- The 'missing' character is square, so height and width is the same.
		end
		if shadowOffset then
			-- Shadow.
			local shadowColor = options.ShadowColor
			local shadowTransparency = options.ShadowTransparency
			
			createCharacter = function(character, x, y)
				-- Calculate information.
				local data = characters[character]
				if data then
					-- Cache character data.
					local width = data[1]
					local height = data[2]
					local imageSize = Vector2.new(width, height)
					local imageOffset = data[3]
					
					-- Calculate position and size.
					local realX = x + data[4]*size
					local realY = y + data[5]*size
					local characterSize = UDim2.fromOffset(
						math.round(realX + width*scaleFactor) - math.round(realX),
						math.round(realY + height*scaleFactor) - math.round(realY)
					)
					
					-- Character shadow.
					local shadow = getImageLabel()
					do
						-- Stylize.
						shadow.BackgroundTransparency = 1
						shadow.Image = image
						shadow.ImageColor3 = shadowColor
						shadow.ImageTransparency = shadowTransparency
						shadow.ResampleMode = resampleMode
						-- Image cutout.
						shadow.ImageRectSize = imageSize
						shadow.ImageRectOffset = imageOffset
						-- Transformation.
						shadow.Size = characterSize
						shadow.Position = UDim2.fromOffset(
							math.round(realX) + offsetX + shadowOffsetX,
							math.round(realY) + offsetY + shadowOffsetY
						)
						shadow.Rotation = rotation
					end
					-- Main character.
					do
						-- Create and stylize.
						local main = getImageLabel()
						main.BackgroundTransparency = 1
						main.Image = image
						main.ImageColor3 = color
						main.ImageTransparency = transparency
						main.ResampleMode = resampleMode
						-- Image cutout.
						main.ImageRectSize = imageSize
						main.ImageRectOffset = imageOffset
						-- Transformation.
						main.Size = characterSize
						main.Position = UDim2.fromOffset(-shadowOffsetX, -shadowOffsetY) -- Counteract the shadow offset.
						-- Name and parent.
						main.Name = "Main"
						main.Parent = shadow
					end
					
					-- Return character instance.
					return shadow
				else -- Missing character.
					-- Create and stylize.
					local imageLabel = getImageLabel()
					imageLabel.BackgroundTransparency = 1
					imageLabel.Image = missingCharacter
					imageLabel.ImageColor3 = color
					imageLabel.ImageTransparency = transparency
					imageLabel.ResampleMode = resampleMode
					-- Transformation.
					imageLabel.Size = UDim2.fromOffset(size, size)
					imageLabel.Position = UDim2.fromOffset(
						math.round(x + size) + offsetX,
						math.round(y + size) + offsetY
					)
					imageLabel.Rotation = rotation
					
					-- Return character instance.
					return imageLabel
				end
			end
		else
			-- No shadow.
			createCharacter = function(character, x, y)
				local data = characters[character]
				if data then
					-- Create and stylize.
					local imageLabel = getImageLabel()
					imageLabel.BackgroundTransparency = 1
					imageLabel.Image = image
					imageLabel.ImageColor3 = color
					imageLabel.ImageTransparency = transparency
					imageLabel.ResampleMode = resampleMode
					-- Image cutout.
					local width = data[1]
					local height = data[2]
					imageLabel.ImageRectSize = Vector2.new(width, height)
					imageLabel.ImageRectOffset = data[3]
					-- Transformation.
					local realX = x + data[4]*size
					local realY = y + data[5]*size
					imageLabel.Size = UDim2.fromOffset(
						math.round(realX + width*scaleFactor) - math.round(realX),
						math.round(realY + height*scaleFactor) - math.round(realY)
					)
					imageLabel.Position = UDim2.fromOffset(
						math.round(realX) + offsetX,
						math.round(realY) + offsetY
					)
					imageLabel.Rotation = rotation
					
					-- Return character instance.
					return imageLabel
				else -- Missing character.
					-- Create and stylize.
					local imageLabel = getImageLabel()
					imageLabel.BackgroundTransparency = 1
					imageLabel.Image = missingCharacter
					imageLabel.ImageColor3 = color
					imageLabel.ImageTransparency = transparency
					-- Transformation.
					imageLabel.Size = UDim2.fromOffset(size, size)
					imageLabel.Position = UDim2.fromOffset(
						math.round(x + size) + offsetX,
						math.round(y + size) + offsetY
					)
					imageLabel.Rotation = rotation
					
					-- Return character instance.
					return imageLabel
				end
			end
		end
	else
		-- Roblox font.
		local strokeColor, strokeTransparency
		if strokeSize then
			if strokeSize < 1 then strokeSize = 1 end -- Limit again, in case it was scaled.
			strokeColor = options.StrokeColor
			strokeTransparency = options.StrokeTransparency
		end
		
		local invertedCharacterSpacing = 1/characterSpacing -- To avoid expensive division.
		local fontKey = font.Family..tostring(font.Weight.Value)..tostring(font.Style.Value)
		
		getCharacterWidth = function(character)
			local characterKey = character..fontKey
			local width = characterWidthCache[characterKey]
			if not width then
				textBoundsParams.Text = character
				width = TextService:GetTextBoundsAsync(textBoundsParams).X*0.01
				characterWidthCache[characterKey] = width
			end
			return width*size*characterSpacing
		end
		if shadowOffset then
			-- Shadow.
			local shadowColor = options.ShadowColor
			local shadowTransparency = options.ShadowTransparency
			
			createCharacter = function(character, x, y, width)
				-- Calculate size.
				local characterSize = UDim2.fromOffset(math.round(width*invertedCharacterSpacing), size)
				
				-- Character shadow.
				local shadow = getTextLabel()
				do
					-- Stylize.
					shadow.BackgroundTransparency = 1
					shadow.Text = character
					shadow.TextSize = size
					shadow.TextColor3 = shadowColor
					shadow.TextTransparency = shadowTransparency
					shadow.FontFace = font
					shadow.TextXAlignment = Enum.TextXAlignment.Left
					shadow.TextYAlignment = Enum.TextYAlignment.Top
					-- Transformation.
					shadow.Size = characterSize
					shadow.Rotation = rotation
					shadow.Position = UDim2.fromOffset(
						x + offsetX + shadowOffsetX,
						y + offsetY + shadowOffsetY
					)
				end
				-- Main character.
				local main = getTextLabel()
				do
					-- Stylize.
					main.BackgroundTransparency = 1
					main.Text = character
					main.TextSize = size
					main.TextColor3 = color
					main.TextTransparency = transparency
					main.FontFace = font
					main.TextXAlignment = Enum.TextXAlignment.Left
					main.TextYAlignment = Enum.TextYAlignment.Top
					-- Transform.
					main.Size = characterSize
					main.Position = UDim2.fromOffset(-shadowOffsetX, -shadowOffsetY) -- Counteract the shadow offset.
					-- Name and parent.
					main.Name = "Main"
					main.Parent = shadow
				end
				-- Apply stroke if options are given.
				if strokeSize then
					do
						local uiStroke = getUIStroke()
						uiStroke.Thickness = strokeSize
						uiStroke.Color = strokeColor
						uiStroke.Transparency = strokeTransparency
						uiStroke.Parent = main
					end
					do
						local uiStroke = getUIStroke()
						uiStroke.Thickness = strokeSize
						uiStroke.Color = strokeColor
						uiStroke.Transparency = strokeTransparency
						uiStroke.Parent = shadow
					end
				end
				
				-- Return character instance.
				return shadow
			end
		else
			-- No shadow.
			createCharacter = function(character, x, y, width)
				-- Create and stylize.
				local textLabel = getTextLabel()
				textLabel.BackgroundTransparency = 1
				textLabel.Text = character
				textLabel.TextSize = size
				textLabel.TextColor3 = color
				textLabel.TextTransparency = transparency
				textLabel.FontFace = font
				textLabel.TextXAlignment = Enum.TextXAlignment.Left
				textLabel.TextYAlignment = Enum.TextYAlignment.Top
				-- Transformation.
				textLabel.Size = UDim2.fromOffset(math.round(width*invertedCharacterSpacing), size)
				textLabel.Rotation = rotation
				textLabel.Position = UDim2.fromOffset(
					x + offsetX,
					y + offsetY
				)
				-- Apply stroke if options are given.
				if strokeSize then
					local uiStroke = getUIStroke()
					uiStroke.Thickness = strokeSize
					uiStroke.Color = strokeColor
					uiStroke.Transparency = strokeTransparency
					uiStroke.Parent = textLabel
				end
				-- Return character instance.
				return textLabel
			end
		end
	end
	
	-- Calculate base information.
	local textWidth = if xAlignment == "Justified" then frameWidth else 0
	
	local spaceWidth = getCharacterWidth(" ")
	
	local dotWidth = getCharacterWidth(".")
	local ellipsisWidth = dotWidth*3
	
	local lines = {}
	
	local truncated, truncate
	if truncationEnabled then
		truncate = function()
			-- Line count.
			local linesAmount = #lines
			
			-- Access last line.
			local line = lines[linesAmount]
			local lineWords = line[1]
			
			-- If the line is empty, we can simply put ellipsis here.
			if #lineWords == 0 then
				line[2] = ellipsisWidth
				
				local dot = {".", dotWidth}
				lineWords[1] = {dot, dot, dot}
				return
			end
			
			-- Calculate potential line width.
			local potentialLineWidth = ellipsisWidth
			for _, wordCharacters in lineWords do
				if wordCharacters then
					for _, characterData in wordCharacters do
						potentialLineWidth += characterData[2]
					end
				end
				potentialLineWidth += spaceWidth
			end
			
			-- Remove words one by one and check for space every time.
			for index = #lineWords, 1, -1 do
				local wordCharacters = lineWords[index]
				
				-- There may be empty words, caused by consecutive spaces. We skip those.
				if not wordCharacters then
					lineWords[index] = nil
					potentialLineWidth -= spaceWidth
					continue
				end
				
				-- Check for space at the end of the word.
				if potentialLineWidth < frameWidth then
					-- Update line width cache.
					line[2] = potentialLineWidth
					
					-- Add ellipsis and exit.
					local dot = {".", dotWidth}
					local charactersAmount = #wordCharacters
					wordCharacters[charactersAmount + 1] = dot
					wordCharacters[charactersAmount + 2] = dot
					wordCharacters[charactersAmount + 3] = dot
					return
				end
				
				-- Remove characters one by one and check for space every time.
				for index = #wordCharacters, 2, -1 do
					potentialLineWidth -= wordCharacters[index][2]
					wordCharacters[index] = nil
					
					if potentialLineWidth < frameWidth then
						-- Update line width cache.
						line[2] = potentialLineWidth
						
						-- Add ellipsis and exit.
						local dot = {".", dotWidth}
						local charactersAmount = #wordCharacters
						wordCharacters[charactersAmount + 1] = dot
						wordCharacters[charactersAmount + 2] = dot
						wordCharacters[charactersAmount + 3] = dot
						return
					end
				end
				
				-- Subtract remaining word width from potential, and remove word.
				potentialLineWidth -= spaceWidth + wordCharacters[1][2]
				lineWords[index] = nil
			end
			
			-- Stop or continue.
			if linesAmount == 1 then
				-- Last line, so we have no option but to put the ellipsis here.
				line[2] = ellipsisWidth
				
				local dot = {".", dotWidth}
				table.insert(lineWords, {dot, dot, dot})
			else
				-- Erase current line and repeat truncation on next line.
				lines[linesAmount] = nil
				truncate()
			end
		end
	end
	
	local lineWords = {}
	local lineWidth = -spaceWidth
	
	local lineIndex = 1
	
	for _, line in text:split("\n") do
		-- Process line.
		if line == "" then -- Means consecutive line-breaks.
			if #lineWords > 0 then
				-- Update text width.
				if lineWidth > textWidth then
					textWidth = lineWidth
				end
				-- Add current line.
				lines[lineIndex] = {lineWords, lineWidth}
				lineIndex += 1
			end
			-- Add empty line.
			lines[lineIndex] = {{}, 0}
			lineIndex += 1
			-- Reset line data.
			lineWidth = -spaceWidth
			lineWords = {}
		else
			-- Process words.
			local wordIndex = 1
			for _, word in line:split(" ") do
				if word == "" then -- Means consecutive spaces.
					lineWords[wordIndex] = false
					wordIndex += 1
					lineWidth += spaceWidth
				else
					local wordWidth = spaceWidth
					local wordCharacters = {}
					
					local characterIndex = 1
					for character in word:gmatch(utf8.charpattern) do
						local characterWidth = getCharacterWidth(character)
						wordWidth += characterWidth
						wordCharacters[characterIndex] = {character, characterWidth}
						characterIndex += 1
					end
					
					if lineWidth + wordWidth > frameWidth and wordIndex > 1 then
						-- Update text width.
						if lineWidth < frameWidth and lineWidth > textWidth then
							textWidth = lineWidth
						end
						
						-- Truncate if necessary.
						if truncationEnabled and lineIndex*lineHeight + size > frameHeight then
							-- Add word to line.
							lineWords[wordIndex] = wordCharacters
							wordIndex += 1
							-- Add current line.
							lines[lineIndex] = {lineWords, lineWidth}
							lineIndex += 1
							
							-- Truncate and exit.
							truncate()
							truncated = true
							break
						else
							-- Add current line.
							lines[lineIndex] = {lineWords, lineWidth}
							lineIndex += 1
							
							-- Initalize next line with the word that exceeded the boundary.
							lineWords = {wordCharacters}
							wordIndex = 2
							lineWidth = wordWidth
						end
					else
						-- Add word to line.
						lineWords[wordIndex] = wordCharacters
						wordIndex += 1
						lineWidth += wordWidth
					end
				end
			end
			
			-- Update text width.
			if lineWidth > textWidth then
				textWidth = lineWidth
			end
			
			-- Exit if truncated.
			if truncated then break end
			
			-- Add current line.
			lines[lineIndex] = {lineWords, lineWidth}
			lineIndex += 1
			-- Reset line data.
			lineWords = {}
			lineWidth = -spaceWidth
		end
	end
	
	-- Calculate final information and render.
	local textHeight, lineGap, y
	if yAlignment == "Top" then
		textHeight = (lineIndex - 2)*lineHeight + size
		lineGap = 0
		y = 0
	elseif yAlignment == "Center" then
		textHeight = (lineIndex - 2)*lineHeight + size
		lineGap = 0
		y = math.round((frameHeight - textHeight)/2)
	elseif yAlignment == "Bottom" then
		textHeight = (lineIndex - 2)*lineHeight + size
		lineGap = 0
		y = frameHeight - textHeight
	else
		-- Justified alignment.
		if #lines == 1 then
			textHeight = size
			lineGap = 0
			y = 0
		else
			textHeight = frameHeight
			local linesAmount = lineIndex - 2
			lineGap = (frameHeight - (linesAmount*lineHeight + size))/linesAmount
			y = 0
		end
	end
	
	local globalWordCount = 0 -- In case specifically only word sorting is enabled.
	local globalCharacterCount = 0 -- In case no sorting is enabled.
	
	for lineIndex, lineData in lines do
		-- Get the current line's words.
		local words = lineData[1]
		
		-- Horizontal alignment.
		local wordGap, x
		if xAlignment == "Left" then
			wordGap = 0
			x = 0
		elseif xAlignment == "Center" then
			wordGap = 0
			x = math.round((frameWidth - lineData[2])/2)
		elseif xAlignment == "Right" then
			wordGap = 0
			x = frameWidth - lineData[2]
		else
			-- Justified alignment.
			local wordsAmount = #words
			wordGap = if wordsAmount > 1 then
				(frameWidth - lineData[2])/(wordsAmount - 1)
				else
				0
			
			x = 0
		end
		
		-- Line sorting.
		local lineContainer = frame
		if lineSorting then
			lineContainer = getFolder()
			lineContainer.Name = tostring(lineIndex)
			lineContainer.Parent = frame
		end
		
		-- Create words.
		for wordIndex, word in words do
			if word then -- There may be empty words, caused by consecutive spaces. These we skip.
				local wordContainer
				if wordSorting then
					wordContainer = getFolder()
					-- Numerical naming.
					if lineSorting then
						wordContainer.Name = tostring(wordIndex)
					else
						globalWordCount += 1
						wordContainer.Name = tostring(globalWordCount)
					end
					-- Parent.
					wordContainer.Parent = lineContainer
				else
					wordContainer = lineContainer
				end
				
				-- Create characters.
				for characterIndex, characterData in word do
					local width = characterData[2]
					
					local instance = createCharacter(characterData[1], x, y, width)
					-- Numerical naming.
					if not lineSorting and not wordSorting then
						globalCharacterCount += 1
						instance.Name = tostring(globalCharacterCount)
					else
						instance.Name = tostring(characterIndex)
					end
					-- Parent.
					instance.Parent = wordContainer
					
					-- Add space before the next character.
					x += width
				end
			end
			
			-- Add space before the next word.
			x += spaceWidth + wordGap
		end
		
		-- Add space before the next line.
		y += lineHeight + lineGap
	end
	
	-- Save text bounds.
	frameTextBounds[frame] = Vector2.new(textWidth, textHeight)
	
	-- Fire update signal.
	if Signal then frameUpdateSignals[frame]:Fire() end
end

local function enableDynamic(frame, text)
	frameSizeConnections[frame] = frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		-- Clear current text.
		clear(frame)
		
		-- Render new text.
		local text = frameText[frame]
		if text == "" then
			frameTextBounds[frame] = Vector2.zero
			if Signal then frameUpdateSignals[frame]:Fire() end
		else
			render(frame, text, frameOptions[frame])
		end
	end)
end
local function create(frame, text, options)
	-- Cache information.
	frameText[frame] = text
	frameOptions[frame] = options
	
	-- Render new text.
	if text == "" then
		frameTextBounds[frame] = Vector2.zero
		if Signal then frameUpdateSignals[frame]:Fire() end
	else
		render(frame, text, options)
	end
end

--[[
Creates text in the specified frame.
If text is already present, it will overwrite text and merge options.

<strong>frame</strong>: The container and bounding box.
]]--
module.Create = function(frame: GuiObject, text: string, options: Options?)
	-- Find current options.
	local currentOptions = frameOptions[frame]
	
	-- Argument errors.
	if not currentOptions and (typeof(frame) ~= "Instance" or not frame:IsA("GuiObject")) then error("Invalid frame.", 2) end
	if type(text) ~= "string" then error("Invalid text.", 2) end
	
	-- Handle options.
	if currentOptions then -- Text has been created before in this frame.
		-- Clear current text.
		clear(frame)
		
		-- Handle options.
		if type(options) == "table" then
			-- Merge options.
			local newOptions = options
			options = currentOptions
			for key, value in newOptions do
				if optionsList[key] then
					if not value then
						options[key] = nil
					else
						options[key] = value
					end
				else
					warn("Invalid option '"..key.."'.")
				end
			end
			-- Correct new (merged) options.
			correctOptions(options)
		else
			options = currentOptions
		end
		
		-- Handle dynamic, calculate size, and render.
		if type(options.Dynamic) ~= "boolean" then
			options.Dynamic = defaults.Dynamic
		end
		if options.Dynamic == true then
			create(frame, text, options)
			enableDynamic(frame, text, options)
		else
			-- Dynamic disabling.
			if not options.Dynamic then
				local connection = frameSizeConnections[frame]
				if connection then connection:Disconnect() end
			end
			
			-- Get rid of the non-true value.
			options.Dynamic = nil
			
			-- Create.
			create(frame, text, options)
		end
	else -- First text creation for this frame.
		if Signal then frameUpdateSignals[frame] = Signal() end -- Create and save update signal.
		
		-- Correct options.
		if type(options) == "table" then
			for key in options do
				if not optionsList[key] then
					options[key] = nil
					warn("Invalid option '"..key.."'.")
				end
			end
		else
			options = {}
		end
		correctOptions(options)
		
		-- Handle dynamic, calculate size, and render.
		if type(options.Dynamic) ~= "boolean" then
			options.Dynamic = defaults.Dynamic
		end
		if options.Dynamic == true then
			create(frame, text, options)
			enableDynamic(frame, text, options)
		else
			-- Dynamic disabling.
			if not options.Dynamic then
				local connection = frameSizeConnections[frame]
				if connection then connection:Disconnect() end
			end
			
			-- Get rid of the non-true value.
			options.Dynamic = nil
			
			-- Create.
			create(frame, text, options)
		end
		
		-- Handle destroying.
		frame.Destroying:Once(function()
			-- Clear frame.
			clear(frame)
			-- Destroy signals.
			if Signal then
				frameUpdateSignals[frame]:Destroy()
				frameUpdateSignals[frame] = nil
			end
			-- Remove connections.
			frameSizeConnections[frame] = nil
			-- Clear data.
			frameText[frame] = nil
			frameOptions[frame] = nil
			frameTextBounds[frame] = nil
		end)
	end
end

return table.freeze(module)]]></ProtectedString>
							<string name="ScriptGuid">{3DFF20A2-71C4-4E2E-BFB3-88E4CC7EF9F8}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Text</string>
							<int64 name="SourceAssetId">138658986432597</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX48D79829C94B4E8D821BC065BCCF0237">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!optimize 2

-- Services.
local CollectionService = game:GetService("CollectionService")

-- Attempt to find the plugin object.
local plugin = script:FindFirstAncestorOfClass("Plugin")

-- Options list for validation.
local optionsList = require(script.Parent.Options)

-- Default defaults.
local defaults = {
	Font = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
	
	Size = 14,
	
	ScaleSize = nil,
	MinimumSize = nil,
	MaximumSize = nil,
	
	Color = Color3.fromRGB(0, 0, 0),
	Transparency = 0,
	
	Pixelated = false,
	
	Offset = Vector2.zero,
	Rotation = 0,
	
	StrokeSize = 5,
	StrokeColor = Color3.fromRGB(0, 0, 0),
	
	ShadowOffset = Vector2.new(0, 20),
	ShadowColor = Color3.fromRGB(50, 50, 50),
	
	LineHeight = 1,
	CharacterSpacing = 1,
	
	Truncate = false,
	
	XAlignment = "Left",
	YAlignment = "Top",
	
	WordSorting = false,
	LineSorting = false,
	
	Dynamic = false
}

-- Merge user defaults.
local userDefaults
if plugin then
	for _, instance in plugin:GetDescendants() do
		if instance:HasTag("TextDefaults") then
			userDefaults = require(instance)
			break
		end
	end
else
	userDefaults = CollectionService:GetTagged("TextDefaults")[1]
	if userDefaults then userDefaults = require(userDefaults) end
end
if userDefaults and type(userDefaults) == "table" then
	for key in userDefaults do
		if optionsList[key] then defaults[key] = userDefaults[key] end
	end
end

-- Remove false booleans.
for key, value in defaults do
	if value == false then defaults[key] = nil end
end

-- Return final defaults.
return defaults]]></ProtectedString>
								<string name="ScriptGuid">{E910246C-7658-40F6-A147-2361DF2D40FA}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Defaults</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6424CDC7DF9249A28F0862495EA447D8">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native

-- Services.
local TextService = game:GetService("TextService")

-- Option defaults.
local defaults = require(script.Parent.Defaults)

-- User fonts.
local userFonts = require(script.Parent.Fonts)

-- Option lists for validity checks.
local scaleSizeTypes = {
	RootX = true,
	RootY = true,
	RootXY = true,
	
	FrameX = true,
	FrameY = true,
	FrameXY = true
}

local xAlignments = {
	Left = true,
	Center = true,
	Right = true,
	Justified = true
}
local yAlignments = {
	Top = true,
	Center = true,
	Bottom = true,
	Justified = true
}

-- Text params for verifying Roblox fonts.
local textBoundsParams = Instance.new("GetTextBoundsParams")
textBoundsParams.Text = ""

-- Options corrector.
return function(options)
	if not scaleSizeTypes[options.ScaleSize] then
		options.ScaleSize = defaults.ScaleSize
	end
	if not scaleSizeTypes[options.ScaleSize] then
		-- Scale-size disabled.
		options.ScaleSize = nil
		options.MinimumSize = nil
		options.MaximumSize = nil
		
		if type(options.Size) ~= "number" then
			options.Size = defaults.Size
		elseif options.Size < 1 then
			options.Size = 1
		end
	else
		-- Scale-size enabled.
		if type(options.MinimumSize) ~= "number" then
			options.MinimumSize = defaults.MinimumSize
		end
		if type(options.MinimumSize) ~= "number" then
			options.MinimumSize = nil
		elseif options.MinimumSize < 1 then
			options.MinimumSize = 1
		end
		
		if type(options.MaximumSize) ~= "number" then
			options.MaximumSize = defaults.MaximumSize
		end
		if type(options.MaximumSize) ~= "number" then
			options.MaximumSize = nil
		elseif options.MaximumSize < 1 then
			options.MaximumSize = 1
		end
		
		if type(options.Size) ~= "number" then
			options.Size = defaults.Size
		end
	end
	
	local font = options.Font
	if font == nil then
		options.Font = defaults.Font
		
		-- Roblox font size limit.
		if options.Size > 100 then
			options.Size = 100
		end
	elseif typeof(font) == "Font" then -- Roblox font.
		-- Verify font.
		textBoundsParams.Font = options.Font
		textBoundsParams.Text = ""
		local _, result = pcall(TextService.GetTextBoundsAsync, TextService, textBoundsParams)
		if type(result) == "string" then
			warn("Invalid font. Fallback to default.")
			options.Font = defaults.Font
		end
		
		-- Roblox font size limit.
		if options.Size > 100 then
			options.Size = 100
		end
	else
		if not userFonts[font] then
			-- Warn about invalid font.
			warn("Invalid font. Fallback to default.")
			
			-- Apply default font.
			options.Font = defaults.Font
			
			-- Roblox font size limit.
			if options.Size > 100 then
				options.Size = 100
			end
		end
	end
	
	local lineHeight = options.LineHeight
	if type(lineHeight) ~= "number" then
		options.LineHeight = defaults.LineHeight
	elseif lineHeight < 0 then
		options.LineHeight = 0
	end
	local characterSpacing = options.CharacterSpacing
	if type(characterSpacing) ~= "number" then
		options.CharacterSpacing = defaults.CharacterSpacing
	elseif characterSpacing < 0 then
		options.CharacterSpacing = 0
	end
	
	if typeof(options.Color) ~= "Color3" then
		options.Color = defaults.Color
	end
	if type(options.Transparency) ~= "number" then
		options.Transparency = defaults.Transparency
	end
	
	local pixelated = options.Pixelated
	if pixelated == false then
		options.Pixelated = nil
	elseif pixelated ~= true then
		options.Pixelated = defaults.Pixelated
	end
	
	if typeof(options.Offset) ~= "Vector2" then
		options.Offset = defaults.Offset
	end
	if type(options.Rotation) ~= "number" then
		options.Rotation = defaults.Rotation
	end
	
	local strokeSize = options.StrokeSize
	local strokeColor = options.StrokeColor
	local strokeTransparency = options.StrokeTransparency
	if type(strokeSize) ~= "number" then
		if typeof(strokeColor) == "Color3" then
			options.StrokeSize = defaults.StrokeSize
			if type(strokeTransparency) ~= "number" then
				options.StrokeTransparency = options.Transparency
			end
		elseif type(strokeTransparency) == "number" then
			options.StrokeSize = defaults.StrokeSize
			if type(strokeColor) ~= "number" then
				options.StrokeColor = defaults.StrokeColor
			end
		else
			options.StrokeSize = nil
			options.StrokeColor = nil
			options.StrokeTransparency = nil
		end
	else
		if strokeSize < 1 then
			options.StrokeSize = 1
		end
		if typeof(strokeColor) ~= "Color3" then
			options.StrokeColor = defaults.StrokeColor
		end
		if type(strokeTransparency) ~= "number" then
			options.StrokeTransparency = options.Transparency
		end
	end
	
	local shadowOffset = options.ShadowOffset
	local shadowColor = options.ShadowColor
	local shadowTransparency = options.ShadowTransparency
	if typeof(shadowOffset) ~= "Vector2" then
		if typeof(shadowColor) == "Color3" then
			options.ShadowOffset = defaults.ShadowOffset
			if type(shadowTransparency) ~= "number" then
				options.ShadowTransparency = options.Transparency
			end
		elseif type(shadowTransparency) == "number" then
			options.ShadowOffset = defaults.ShadowOffset
			if type(shadowColor) ~= "number" then
				options.ShadowColor = defaults.ShadowColor
			end
		else
			options.ShadowOffset = nil
			options.ShadowColor = nil
			options.ShadowTransparency = nil
		end
	else
		if typeof(shadowColor) ~= "Color3" then
			options.ShadowColor = defaults.ShadowColor
		end
		if type(shadowTransparency) ~= "number" then
			options.ShadowTransparency = options.Transparency
		end
	end
	
	local truncate = options.Truncate
	if truncate == false then
		options.Truncate = nil
	elseif truncate ~= true then
		options.Truncate = defaults.Truncate
	end
	
	if not xAlignments[options.XAlignment] then
		options.XAlignment = defaults.XAlignment
	end
	if not yAlignments[options.YAlignment] then
		options.YAlignment = defaults.YAlignment
	end
	
	local wordSorting = options.WordSorting
	if wordSorting == false then
		options.WordSorting = nil
	elseif wordSorting ~= true then
		options.WordSorting = defaults.WordSorting
	end
	
	local lineSorting = options.LineSorting
	if lineSorting == false then
		options.LineSorting = nil
	elseif lineSorting ~= true then
		options.LineSorting = defaults.LineSorting
	end
end]]></ProtectedString>
								<string name="ScriptGuid">{2E72B42F-3B3B-4846-B4CB-DC18B795DED4}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">CorrectOptions</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX82E3597DF6EE4BAA95FF5AD5554F185D">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return {
	Font = true,
	
	Size = true,
	
	ScaleSize = true,
	MinimumSize = true,
	MaximumSize = true,
	
	Color = true,
	Transparency = true,
	
	Pixelated = true,
	
	Offset = true,
	Rotation = true,
	
	StrokeSize = true,
	StrokeColor = true,
	StrokeTransparency = true,
	
	ShadowOffset = true,
	ShadowColor = true,
	ShadowTransparency = true,
	
	LineHeight = true,
	CharacterSpacing = true,
	
	Truncate = true,
	
	XAlignment = true,
	YAlignment = true,
	
	WordSorting = true,
	LineSorting = true,
	
	Dynamic = true
}]]></ProtectedString>
								<string name="ScriptGuid">{175DD306-28C8-49AB-8FB3-DD24A67F8E9E}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Options</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX05D938426096444F89E02E7EA190189E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!optimize 2

-- Services.
local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")

-- Load and store all custom fonts.
local userFonts = {}

for _, module in CollectionService:GetTagged("Fonts") do
	if module:IsA("ModuleScript") then
		local fullModuleName = module:GetFullName()
		
		local fonts = require(module)
		
		if type(fonts) ~= "table" then
			warn("'"..fullModuleName.."' font data is not a table.")
		else
			if not next(fonts) then
				warn("'"..fullModuleName.."' font data table is empty.")
			else
				local player = Players.LocalPlayer
				local load
				if player then -- If running on client.
					local screenGui = Instance.new("ScreenGui")
					screenGui.Parent = player.PlayerGui
					
					local loading = 0
					load = function(image) -- For preloading the font image assets.
						-- Increment counter for currently loading images.
						loading += 1
						
						-- Setup image label for loading the current font.
						local label = Instance.new("ImageLabel")
						label.Size = UDim2.fromOffset(1, 1) -- As small as possible.
						label.BackgroundTransparency = 1
						label.ImageTransparency = 0.999 -- Trick to make the image invisible and still have it be loaded.
						label.ResampleMode = Enum.ResamplerMode.Pixelated
						label.Image = "rbxassetid://"..tostring(image)
						label.Parent = screenGui -- It's crucial that we put it in a visible ScreenGui, otherwise it won't be loaded.
						
						-- Detect load.
						coroutine.resume(coroutine.create(function()
							while true do
								task.wait()
								if label.IsLoaded then
									if loading == 1 then
										screenGui:Destroy()
									else
										loading -= 1
									end
									return
								end
							end
						end))
					end
				end
				
				local function handleCharacters(characters, size)
					local invertedFontSize = 1/size -- To avoid expensive division.
					
					for key, value in characters do
						-- Verify format.
						if type(key) ~= "string" then return end
						if type(value) ~= "table" then return end
						if type(value[1]) ~= "number" then return end
						if type(value[2]) ~= "number" then return end
						if typeof(value[3]) ~= "Vector2" then return end
						if type(value[4]) ~= "number" then return end
						if type(value[5]) ~= "number" then return end
						if type(value[6]) ~= "number" then return end
						
						-- Precalculate normalized offset and x-advance.
						value[4] *= invertedFontSize
						value[5] *= invertedFontSize
						value[6] *= invertedFontSize
					end
					
					return true
				end
				
				local remove = {} -- Because immediate removal will throw off the loop.
				local freeze = {} -- Because freezing before removal will result in errors.
				
				local processFonts
				
				local function handleTable(key, value, currentPath)
					if value.Image or value.Size or value.Characters then
						-- Verify format.
						if type(value.Image) ~= "number" then
							warn("Missing an image ID in '"..currentPath.."'")
							table.insert(remove, key)
							return
						end
						if type(value.Size) ~= "number" then
							warn("Missing a size in '"..currentPath.."'")
							table.insert(remove, key)
							return
						end
						if type(value.Characters) ~= "table" then
							warn("Missing characters in '"..currentPath.."'")
							table.insert(remove, key)
							return
						end
						if not handleCharacters(value.Characters, value.Size) then -- If not valid characters then.
							warn("Invalid characters in '"..currentPath.."'")
							table.insert(remove, key)
							return
						end
						
						-- Insert for later freeze.
						table.insert(freeze, key)
						
						-- Insert the font into raw fonts table.
						userFonts[value] = true
						
						-- Preload images.
						if player then -- If running on client.
							load(value.Image)
						end
					else
						processFonts(value, currentPath)
						table.freeze(value)
					end
				end
				processFonts = function(parent, parentPath)
					for key, value in parent do
						if type(value) ~= "table" then
							table.insert(remove, key)
						else
							handleTable(key, value, parentPath.."."..key)
						end
					end
					
					for index, key in remove do
						parent[key] = nil
						remove[index] = nil
					end
					for index, key in freeze do
						table.freeze(parent[key])
						freeze[index] = nil
					end
				end
				
				handleTable("", fonts, fullModuleName)
				if #freeze > 0 then table.freeze(fonts) end
			end
		end
	end
end

-- Return the global user fonts table.
return userFonts]]></ProtectedString>
								<string name="ScriptGuid">{AFEA0EA4-9804-4AE8-9EFB-551B627E219D}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Fonts</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX7709C92484AE43EC8247EB808945C254">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "Text+",
	Thumbnail = "rbxassetid://129198310435042",
	AssetId = 138658986432597,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @AlexanderLindholt"},
		{Text = "Description: Get ready to experience text in Roblox like it shouldve been."},
		{Text = "Version: (latest)"},

		{Separator = "Features"},
		{Text = " Custom fonts: Use any font file, whether one of your own or one you found online."},
		{Text = " Advanced control: Easily transform and style any individual character, word or line with freedom."},
		{Text = " Advanced control: Utilize awesome text styling like justified alignments and spacing controls."},
		{Text = " Advanced control: Effortlessly setup text scaling, so that its the perfect size on all devices."},
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{4973D328-85AE-427D-8B50-4C358874FAB1}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX787BF2846295440A986A40B4E76130CD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">NumberSpinner</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX47DD7B60C60245ED9360511F4D889B32">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "NumberSpinner",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 6523814884,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @boatbomber"},
		{Text = "Description: A easy way to create a number spinner animation"},
		{Text = "Version: (latest)"},

		{Separator = "Features"},
		{Text = " Uses proxies to automatically handle all your changes and values without you needing to ever call functions yourself"},
		{Text = " Supports all fonts, textsizes, and colors"},
		{Text = " Customizable spin speed"},
		{Text = " Customizable decimal places"},
		{Text = " Customizable prefix and suffix (default is $)"},
		{Text = " Support for comma placement"},
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{4DA5465B-EC85-42A5-8CCD-BF5100C8AE92}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFB415301E1384BB7B492956DC6E523A5">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Digit = require(script.Digit)

local NumberSpinner = {}

local READ_ONLY = {
	Frame = true,
	Digits = true,
	CommaLabels = true,
	Text = true,
}
local CUSTOM_PROPS = {
	Value = "number",
	Duration = "number",
	Decimals = "number",
	Prefix = "string",
	Suffix = "string",
	Commas = "boolean",
}
local TEXT_TO_LAYOUT = {
	[Enum.TextXAlignment.Center] = Enum.HorizontalAlignment.Center,
	[Enum.TextXAlignment.Left] = Enum.HorizontalAlignment.Left,
	[Enum.TextXAlignment.Right] = Enum.HorizontalAlignment.Right,
}

local DUMMY_FRAME = Instance.new("Frame")
local DUMMY_LABEL = Instance.new("TextLabel")
DUMMY_LABEL.TextSize = 25
DUMMY_LABEL.TextColor3 = Color3.fromRGB(250, 250, 255)
DUMMY_LABEL.FontFace = Font.new("SourceSans")

local function newSpinner()
	local Spinner = {
		-- Props
		Value = 0,
		Duration = 0.3,
		Decimals = 2,
		Prefix = "$",
		Suffix = "",
		Commas = false,

		-- Internal
		Digits = {
			Whole = table.create(3),
			Decimal = table.create(2),
		},
		CommaLabels = table.create(2),

		-- UIs (populated later)
		Frame = nil,
		Layout = nil,
		PrefixLabel = nil,
		SuffixLabel = nil,
		DecimalLabel = nil,
		NegativeLabel = nil,
	}

	local SpinnerProxy = setmetatable({}, {
		__index = function(_, key)
			local Direct = Spinner[key]
			if Direct then
				return Direct
			end

			local propExistsForFrame = pcall(function()
				local _ = DUMMY_FRAME[key]
			end)
			if propExistsForFrame then
				return Spinner.Frame[key]
			end

			local propExistsForLabel, labelProp = pcall(function()
				return DUMMY_LABEL[key]
			end)
			if propExistsForLabel then
				local digit = Spinner.Digits.Whole[1]
				if digit then
					return digit[key]
				else
					return labelProp
				end
			end

			--warn("Nothing found for",key)
			return nil
		end,
		__newindex = function(_, key, value)
			if READ_ONLY[key] then
				warn("Attempted to set read-only value Spinner." .. key)
				return
			end

			-- Handle setting of Frame properties
			local propExistsForFrame = pcall(function()
				local _ = DUMMY_FRAME[key]
			end)
			if propExistsForFrame then
				local t = typeof(DUMMY_FRAME[key])
				if (t ~= "nil") and (t ~= typeof(value)) then
					warn("Attempted to set Spinner." .. key .. " to invalid value (" .. tostring(value) .. ")")
					return
				end
				Spinner.Frame[key] = value
				return
			end

			-- Handle alignment since it's a special case
			if key == "TextXAlignment" then
				Spinner.Layout.HorizontalAlignment = TEXT_TO_LAYOUT[value]
				return
			end

			-- Handle setting of text related properties
			local propExistsForLabel = pcall(function()
				local _ = DUMMY_LABEL[key]
			end)
			if propExistsForLabel then
				local propType = typeof(DUMMY_LABEL[key])
				if (propType ~= "nil") and (propType ~= typeof(value)) then
					warn("Attempted to set Spinner." .. key .. " to invalid value (" .. tostring(value) .. ")")
					return
				end
				for _, digit in pairs(Spinner.Digits.Whole) do
					digit[key] = value
				end
				for _, digit in pairs(Spinner.Digits.Decimal) do
					digit[key] = value
				end
				for _, comma in pairs(Spinner.CommaLabels) do
					comma[key] = value
				end
				Spinner.PrefixLabel[key] = value
				Spinner.SuffixLabel[key] = value
				Spinner.DecimalLabel[key] = value
				Spinner.NegativeLabel[key] = value
				return
			end

			-- Handle setting of the custom spinner properties
			if CUSTOM_PROPS[key] then
				if typeof(value) ~= CUSTOM_PROPS[key] then
					warn("Attempted to set Spinner." .. key .. " to invalid value (" .. tostring(value) .. ")")
					return
				end
				Spinner[key] = value
				Spinner:Update(key, value)
				return
			end
		end,
	})

	function Spinner:Destroy()
		self.Frame:Destroy()
		table.clear(self)
	end

	function Spinner:Update(Type)
		if Type == "Prefix" then
			Spinner.PrefixLabel.Text = Spinner.Prefix
			return
		elseif Type == "Suffix" then
			Spinner.SuffixLabel.Text = Spinner.Suffix
			return
		end

		local AbsValue = math.abs(Spinner.Value)
		local isNegative = Spinner.Value < 0

		if Spinner.NegativeLabel then
			Spinner.NegativeLabel.Visible = isNegative
		end

		local TextValue = Spinner.Decimals > 0 and string.format("%." .. Spinner.Decimals .. "f", AbsValue)
			or string.format("%d", AbsValue)
		local split = string.split(TextValue, ".")
		local whole, decimal = split[1], split[2]
		if not whole then
			return
		end

		local numWhole = #whole
		for i = 1, numWhole do
			local digit = Spinner.Digits.Whole[i]

			if digit then
				digit.Duration = Spinner.Duration
				digit.Value = tonumber(string.sub(whole, i, i))
			else
				digit = Digit.new(SpinnerProxy, (i * 2) - 900, tonumber(string.sub(whole, i, i)))
				Spinner.Digits.Whole[i] = digit
			end
		end
		for i = numWhole + 1, #Spinner.Digits.Whole do
			local digit = Spinner.Digits.Whole[i]
			if digit then
				digit:Destroy()
				Spinner.Digits.Whole[i] = nil
			end
		end

		if Spinner.Commas then
			local endLayout = (numWhole * 2) - 900
			local str = string.format("%d", math.floor(math.abs(Spinner.Value)))
			local commaIndex = 0
			for i = 0, #str - 1, 3 do
				if i == 0 then
					continue
				end
				commaIndex += 1
				local CommaLabel = Spinner.CommaLabels[commaIndex]
				if not CommaLabel then
					CommaLabel = Instance.new("TextLabel")
					CommaLabel.Name = "Comma"
					CommaLabel.BackgroundTransparency = 1
					CommaLabel.Size = UDim2.new(0, 0, 1, 0)
					CommaLabel.FontFace = SpinnerProxy.FontFace
					CommaLabel.TextSize = SpinnerProxy.TextSize
					CommaLabel.TextColor3 = SpinnerProxy.TextColor3
					CommaLabel.Text = ","
					CommaLabel.AutomaticSize = Enum.AutomaticSize.X
					CommaLabel.Parent = Spinner.Frame

					Spinner.CommaLabels[commaIndex] = CommaLabel
				end

				CommaLabel.LayoutOrder = (endLayout - ((i - 1) * 2) - 1)
			end

			for i = commaIndex + 1, #Spinner.CommaLabels do
				Spinner.CommaLabels[i]:Destroy()
				Spinner.CommaLabels[i] = nil
			end
		end

		if not decimal then
			if Spinner.DecimalLabel then
				Spinner.DecimalLabel.Visible = false
			end
			for _, digit in ipairs(Spinner.Digits.Decimal) do
				digit:Destroy()
			end
			table.clear(Spinner.Digits.Decimal)
			return
		end

		if Spinner.DecimalLabel then
			Spinner.DecimalLabel.Visible = true
		end
		for i = 1, #decimal do
			local digit = Spinner.Digits.Decimal[i]

			if digit then
				digit.Duration = Spinner.Duration
				digit.Value = tonumber(string.sub(decimal, i, i))
			else
				digit = Digit.new(SpinnerProxy, i, tonumber(string.sub(decimal, i, i)))
				Spinner.Digits.Decimal[i] = digit
			end
		end
		for i = #decimal + 1, #Spinner.Digits.Decimal do
			local digit = Spinner.Digits.Decimal[i]
			if digit then
				digit:Destroy()
				Spinner.Digits.Decimal[i] = nil
			end
		end
	end

	return SpinnerProxy, Spinner
end

function NumberSpinner.new()
	local Spinner, RawSpinner = newSpinner()

	local Frame = Instance.new("Frame")
	Frame.BackgroundTransparency = 1
	Frame.ClipsDescendants = true
	Frame.Size = UDim2.new(0, 200, 0, 50)
	Frame.Position = UDim2.new(0, 0, 0, 0)

	local Layout = Instance.new("UIListLayout")
	Layout.SortOrder = Enum.SortOrder.LayoutOrder
	Layout.FillDirection = Enum.FillDirection.Horizontal
	Layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	Layout.VerticalAlignment = Enum.VerticalAlignment.Center
	Layout.Padding = UDim.new(0, 0)
	Layout.Parent = Frame

	local Prefix = Instance.new("TextLabel")
	Prefix.Name = "Prefix"
	Prefix.LayoutOrder = -1000
	Prefix.BackgroundTransparency = 1
	Prefix.Size = UDim2.new(0, 0, 1, 0)
	Prefix.FontFace = Spinner.FontFace
	Prefix.TextSize = Spinner.TextSize
	Prefix.TextColor3 = Spinner.TextColor3
	Prefix.Text = Spinner.Prefix
	Prefix.AutomaticSize = Enum.AutomaticSize.X
	Prefix.Parent = Frame

	local Suffix = Instance.new("TextLabel")
	Suffix.Name = "Suffix"
	Suffix.LayoutOrder = 1000
	Suffix.BackgroundTransparency = 1
	Suffix.Size = UDim2.new(0, 0, 1, 0)
	Suffix.FontFace = Spinner.FontFace
	Suffix.TextSize = Spinner.TextSize
	Suffix.TextColor3 = Spinner.TextColor3
	Suffix.Text = Spinner.Suffix
	Suffix.AutomaticSize = Enum.AutomaticSize.X
	Suffix.Parent = Frame

	local Decimal = Instance.new("TextLabel")
	Decimal.Name = "Decimal"
	Decimal.LayoutOrder = 0
	Decimal.BackgroundTransparency = 1
	Decimal.Size = UDim2.new(0, 0, 1, 0)
	Decimal.FontFace = Spinner.FontFace
	Decimal.TextSize = Spinner.TextSize
	Decimal.TextColor3 = Spinner.TextColor3
	Decimal.Text = "."
	Decimal.AutomaticSize = Enum.AutomaticSize.X
	Decimal.Parent = Frame

	local Negative = Instance.new("TextLabel")
	Negative.Name = "Negative"
	Negative.LayoutOrder = -999
	Negative.BackgroundTransparency = 1
	Negative.Size = UDim2.new(0, 0, 1, 0)
	Negative.FontFace = Spinner.FontFace
	Negative.TextSize = Spinner.TextSize
	Negative.TextColor3 = Spinner.TextColor3
	Negative.Text = "-"
	Negative.AutomaticSize = Enum.AutomaticSize.X
	Negative.Parent = Frame

	RawSpinner.Frame = Frame
	RawSpinner.Layout = Layout
	RawSpinner.PrefixLabel = Prefix
	RawSpinner.SuffixLabel = Suffix
	RawSpinner.DecimalLabel = Decimal
	RawSpinner.NegativeLabel = Negative

	Spinner:Update()

	return Spinner
end

function NumberSpinner.fromGuiObject(GuiObject)
	if typeof(GuiObject) ~= "Instance" then
		return
	end
	if not GuiObject:IsA("GuiObject") then
		return
	end

	local Spinner = NumberSpinner.new()

	Spinner.Name = "Spinner_" .. GuiObject.Name
	Spinner.SizeConstraint = GuiObject.SizeConstraint
	Spinner.Size = GuiObject.Size
	Spinner.Position = GuiObject.Position
	Spinner.AnchorPoint = GuiObject.AnchorPoint
	Spinner.Rotation = GuiObject.Rotation
	Spinner.LayoutOrder = GuiObject.LayoutOrder
	Spinner.ZIndex = GuiObject.ZIndex
	Spinner.Visible = GuiObject.Visible
	Spinner.BackgroundColor3 = GuiObject.BackgroundColor3
	Spinner.BorderColor3 = GuiObject.BorderColor3
	Spinner.BorderSizePixel = GuiObject.BorderSizePixel
	Spinner.BackgroundTransparency = GuiObject.BackgroundTransparency

	if GuiObject:IsA("TextLabel") or GuiObject:IsA("TextButton") or GuiObject:IsA("TextBox") then
		Spinner.FontFace = GuiObject.FontFace
		Spinner.TextSize = GuiObject.TextSize
		Spinner.TextColor3 = GuiObject.TextColor3
		Spinner.TextTransparency = GuiObject.TextTransparency
		Spinner.TextStrokeColor3 = GuiObject.TextStrokeColor3
		Spinner.TextStrokeTransparency = GuiObject.TextStrokeTransparency

		Spinner.Layout.HorizontalAlignment = TEXT_TO_LAYOUT[GuiObject.TextXAlignment]
	end

	Spinner.Parent = GuiObject.Parent

	GuiObject.Visible = false

	return Spinner
end

return NumberSpinner]]></ProtectedString>
							<string name="ScriptGuid">{A22AAA5E-11A3-4F45-8644-2436721201E3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">NumberSpinner</string>
							<int64 name="SourceAssetId">6523814884</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX93D403F83D744F27B0B594596581874B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local TextService = game:GetService("TextService")
local TweenService = game:GetService("TweenService")

local sizeTweenInfo = TweenInfo.new(0.15)

local Digit = {}

function Digit.new(Spinner, LayoutOrder, Value)
	local digit = {
		Duration = Spinner.Duration,
		Value = Value,

		Labels = table.create(10),
		CanvasTweens = table.create(10),
	}
	local tweenInfo = TweenInfo.new(Spinner.Duration)

	local Frame = Instance.new("Frame")
	Frame.Name = "digit"
	Frame.LayoutOrder = LayoutOrder
	Frame.BackgroundTransparency = 1
	Frame.Size = UDim2.new(0, 0, 0, Spinner.TextSize + 6)
	Frame.ClipsDescendants = true

	local Canvas = Instance.new("Frame")
	Canvas.Name = "canvas"
	Canvas.Size = UDim2.new(1, 0, 10, 0)
	Canvas.BackgroundTransparency = 1
	Canvas.Parent = Frame

	Canvas.Position = UDim2.new(0, 0, -digit.Value, 0)

	for i = 0, 9 do
		local n = Instance.new("TextLabel")
		n.Name = "n_" .. i
		n.BackgroundTransparency = 1
		n.TextSize = Spinner.TextSize
		n.TextColor3 = Spinner.TextColor3
		n.FontFace = Spinner.FontFace
		n.Text = i
		n.Size = UDim2.new(1, 0, 0.1, 0)
		n.Position = UDim2.new(0, 0, i * 0.1, 0)
		n.Parent = Canvas
		digit.Labels[i] = n
		digit.CanvasTweens[i] = TweenService:Create(Canvas, tweenInfo, { Position = UDim2.new(0, 0, -i, 0) })
	end

	Frame.Parent = Spinner.Frame

	local TextBoundsParams = Instance.new("GetTextBoundsParams")

	local function updateSize(shouldDelete)
		task.spawn(function()
			TextBoundsParams.Text = "8"
			TextBoundsParams.Font = Spinner.FontFace
			TextBoundsParams.Size = Spinner.TextSize
			TextBoundsParams.Width = Spinner.TextSize

			-- Errors like "Temp read failed." can occur for some circumstances.
			local success, textBounds = pcall(TextService.GetTextBoundsAsync, TextService, TextBoundsParams)
			if success then
				local tween = TweenService:Create(
					Frame,
					sizeTweenInfo,
					{ Size = UDim2.new(0, if shouldDelete then 0 else textBounds.X + 1, 0, textBounds.Y + 10) }
				)
				tween.Completed:Connect(function()
					if shouldDelete then
						Frame:Destroy()
						table.clear(digit)
					end
					tween:Destroy()
				end)
				tween:Play()
			end
		end)
	end

	updateSize()

	local digitProxy = setmetatable({}, {
		__index = function(_, key)
			local Direct = digit[key]
			if Direct then
				return Direct
			end

			local propExistsForLabel = pcall(function()
				local _ = digit.Labels[1][key]
			end)
			if propExistsForLabel then
				return digit.Labels[1][key]
			end

			return nil
		end,
		__newindex = function(_, key, value)
			local Direct = digit[key]
			if Direct then
				digit[key] = value
				digit:Update(key, value)
				return
			end

			local propExistsForLabel = pcall(function()
				local _ = digit.Labels[1][key]
			end)
			if propExistsForLabel then
				for i = 0, 9 do
					digit.Labels[i][key] = value
				end
				digit:Update(key, value)
			end
		end,
	})

	function digit:Destroy()
		updateSize(true)
	end

	function digit:Update(Type, UpdateValue)
		if Type == "Duration" then
			tweenInfo = TweenInfo.new(UpdateValue)
			for i = 0, 9 do
				digit.CanvasTweens[i] = TweenService:Create(Canvas, tweenInfo, { Position = UDim2.new(0, 0, -i, 0) })
			end
		elseif Type == "Value" then
			digit.CanvasTweens[UpdateValue]:Play()
		elseif Type == "TextSize" or Type == "FontFace" then
			updateSize()
		end
	end

	return digitProxy
end

return Digit]]></ProtectedString>
								<string name="ScriptGuid">{48E68D52-AA27-4588-9F30-7BF38227C38B}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Digit</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX46747F71193344C399096885027FE611">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ClassPP</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX9816E7F1A6F843099693D751670941D5">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "Class++",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @TenebrisNoctua"},
		{Text = "Description: Class++ is a module that aims to bring a class structure very similar to in languages such as C++ and Java to Luau. It brings access specifiers, function and operator overloading, inheritance, and many other features. It supports auto-completion with inheritance, and even has its own Type API!"},
		{Text = "Version: (latest)"},

		{Separator = "Features"},
		{Text = "Class++ offers a much simpler and easier experience while creating classes and objects, you no longer need to deal with the complexity of metatables to create a class system. And its features allow you to far surpass the things you were able to do with just metatables."},
	}
	
}]]></ProtectedString>
							<string name="ScriptGuid">{F9FB0B2B-3A38-41CB-A30A-EEE78DFDBA95}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX04B66D4D917D4200AA7E3C9DC75681B7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!native
--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		The main module of Class++.
	////
--]]

--////// Variables

local classpp = {}

local Util = require(script.Util)
local Error = require(script.Error)
local Type = require(script.Type)

local LogError = Error.logError
local LogErrorNonFatal = Error.logErrorNonFatal
local LogWarning = Error.logWarning

local operatorFuncNames: {string} = {"operator_add", "operator_sub", "operator_mul", "operator_div", "operator_idiv", "operator_mod", "operator_pow", "operator_unm", "operator_eq"}
local silenceUpdateWarning: boolean = script:GetAttribute("silenceUpdateWarning") or false

local Classes: {[string]: class} = {}

--////// Types

export type classData = Type.classData
export type class<AccessSpecifier = any?> = Type.class<AccessSpecifier>

type internalClassData = {
	Public: {[any]: any}?,
	Private: {[any]: any}?,
	Protected: {[any]: any}?,
	Friend: {any}?,
	Internal: {
		__type: string?,
		__locked: boolean?,
		constructor: (self: any, ...any) -> ()?,
		destructor: (self: any) -> ()?,
	}
}
type internalClass<AccessSpecifier = any?> = typeof(setmetatable({} :: {
	new: (...any) -> AccessSpecifier,
	extends: (className: string) -> (classData: classData) -> class<AccessSpecifier>,
	overload: (accessSpecifier: string, name: string, functionTable: {(...any) -> (any)}) -> (),
	static: (accessSpecifier: string, name: string, property: any) -> (),
	Name: string,
	Inherits: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end})),
	Friends: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end})),
	Statics: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end}))?
}, {
	__index = function(t, i) return end :: ({any}, any) -> (any),
	__newindex = function(t, i, v) end :: ({any}, any, any) -> (),
	__type = "",
	__classtype = "",
	__abstract = false,
	__final = false
}))

--////// Local Functions

--// A deep copy function for tables, with support for metatables.
local function deepCopy<T>(original: T & {[any]: any}): T & {[any]: any}
	local copy = table.clone(original) :: T & {[any]: any}

	for key, value in (original :: {[any]: any}) do
		if type(value) == "table" then
			local tmetatable = getmetatable(value);
			(copy :: {[any]: any})[key] = if not tmetatable then deepCopy(value) else setmetatable(deepCopy(value) :: {[any]: any}, tmetatable)
		end
	end

	return copy
end

--// Sorts the classData into an objectData that can be used inside objects.
local function sortAttributes(data: classData, className: string): internalClassData
	local classObjTbl: internalClassData = deepCopy(data)

	classObjTbl.Friend = nil
	classObjTbl.Internal = {
		__type = className,
		__locked = false
	}

	if classObjTbl["constructor"] then 
		classObjTbl.Internal.constructor = classObjTbl["constructor"] 
		classObjTbl["constructor"] = nil
	end

	if classObjTbl["destructor"] then
		classObjTbl.Internal.destructor = classObjTbl["destructor"]
		classObjTbl["destructor"] = nil
	end

	return classObjTbl
end

--// Recursively cleans the given table.
local function recursiveClean(tbl: {[any]: any})
	for key, value in tbl do
		if typeof(key) == "Instance" then key:Destroy() end
		if typeof(value) == "table" then
			for _, v in tbl do
				if v == value then return end
			end
			recursiveClean(value)
		elseif typeof(value) == "Instance" then
			value:Destroy()
		end

		tbl[key] = nil
	end
end

--// Cleans the objectData (except for the Internal data) and locks the object.
local function objectCleaner(objectTbl: {[string]: any}): {}
	for accessSpecifier, attributesData in objectTbl do
		if accessSpecifier == "Internal" then continue end
		recursiveClean(attributesData)
	end
	objectTbl.Internal.__locked = true
	return objectTbl
end

--// Merges classDatas of two related classes for inheritation.
local function mergeClassData(superClassData: classData, childClassData: classData): classData
	local newClassData: classData = {
		Public = {},
		Private = {},
		Protected = {}
	}

	for accessSpecifier, attributesData in superClassData do
		if accessSpecifier == "Private" then continue end
		if typeof(attributesData) == "function" then continue end

		for attributeName, attributeData in (attributesData :: any) do
			newClassData[accessSpecifier][attributeName] = attributeData
		end
	end

	for accessSpecifier, attributesData: any in childClassData do
		if typeof(accessSpecifier) ~= "string" then continue end

		local n: string? = if typeof(attributesData) == "function" then debug.info(attributesData, "n") else nil

		if n and n == "destructor" or n and n == "constructor" then
			newClassData[n] = attributesData
			continue
		end

		for attributeName, attributeData in attributesData do
			newClassData[accessSpecifier][attributeName] = attributeData
		end
	end

	return newClassData
end

--// Checks if the given string is a valid access specifier.
local function checkValidAccessSpecifier(specifierString: string): (boolean, string?)
	local accessSpecifiers: {string} = {"Public", "Private", "Protected", "Internal", "Friend"}

	for _, accessSpecifier in accessSpecifiers do
		if specifierString == accessSpecifier then
			return true, accessSpecifier
		end
	end

	return false
end

--// Returns the access specifier of an index.
local function returnAccessSpecifier(index: string, classData: any): string?
	for accessSpecifier, attributesData in classData do
		if typeof(attributesData) == "table" and attributesData[index] ~= nil then
			return accessSpecifier
		end
	end
	return
end

--// Finds the property that's been set to the given index. If given a string that contains an access specifier, it tries to find the property inside that access specifier.
local function findPropertyFromIndex(classData: internalClassData | classData, index: string, accessSpecifier: string?): any?
	local fAccessSpecifier = accessSpecifier or returnAccessSpecifier(index, classData)
	if not (classData :: any)[fAccessSpecifier] then return end
	if (classData :: any)[fAccessSpecifier][index] ~= nil then
		return (classData :: any)[fAccessSpecifier][index]
	end
	return
end

--// Calls an operator function from the given name.
local function callOperator(functionName, obj, obj2: any?, silenceError: boolean?): boolean | any
	if typeof(obj) == "userdata" then
		if obj[functionName] then
			return obj[functionName](obj, obj2)
		elseif not silenceError then
			LogError("classNoMatchingFunctionError", true, functionName)
		end
	elseif typeof(obj2) == "userdata" then
		if obj2[functionName] then
			return obj2[functionName](obj2, obj)
		elseif not silenceError then
			LogError("classNoMatchingFunctionError", true, functionName)
		end
	end

	return false
end

--// Checks if the given index has already been set inside an access specifier.
local function checkRedeclaration(classData: classData, index: string?): (boolean, any?)
	if not classData then return false end

	if index then
		local fnumber = 0
		for accessSpecifier, attributesData in classData do
			if typeof(attributesData) ~= "table" then continue end
			if (attributesData :: any)[index] then fnumber += 1 end
		end
		if fnumber >= 2 then return true, index end
	else
		for accessSpecifier, attributesData in classData do
			if typeof(attributesData) ~= "table" then continue end
			for attributeKey, _ in (attributesData :: any) do
				if checkRedeclaration(classData, attributeKey) then return true, attributeKey end
			end
		end
	end

	return false
end

--// Checks if there are any indexes inside the classData that aren't valid access specifiers or functions.
local function checkOutsideAccessSpecifierDecleration(classData: classData): boolean
	for index, value in classData do
		if typeof(index) ~= "string" then continue end
		if not checkValidAccessSpecifier(index) and index ~= "constructor" and index ~= "destructor" then
			return true
		end
	end

	return false
end

--// Sets the metamethods of an object.
local function setMetamethods(class: internalClass, classData: internalClassData, methods)
	methods.__metatable = 'The metatable is locked.'

	function methods:__index(index): any
		if classData.Internal.__locked == true then LogError("classObjectLocked", true) end

		local accessSpecifier = returnAccessSpecifier(index, classData)

		if accessSpecifier ~= "Public" then
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, index)
			elseif accessSpecifier == "Internal" and Util.getMethodContext(7) ~= Type.typeof then
				LogError("classPropertyIsInternal", true, index)
			elseif accessSpecifier == "Protected" and not Util.inClassScope(class, true, true, Classes) then
				LogError("classPropertyIsProtected", true, index)
			end
		end

		if index == "Destroy" then
			return function() 
				if classData.Internal.destructor then classData.Internal.destructor(self) end
				objectCleaner(classData)
			end
		end

		-- Checking if the index is calling an operator function, this part can be removed if you want to support operator functions still being callable even without operators.
		local sFound = string.find(index, "operator")
		if sFound then
			for _, opfuncname in operatorFuncNames do
				if index == opfuncname and Util.getMethodContext(5) ~= callOperator then
					LogError("nonNativeOperatorCall", true, index)
				end
			end
		end

		local rprop = findPropertyFromIndex(classData, index, accessSpecifier)
		if rprop ~= nil then return rprop elseif index ~= "constructor" and index ~= "destructor" and index ~= "__tostring" and not sFound then LogErrorNonFatal("classMemberNotFound", true, index) end

		return
	end

	function methods:__newindex(index, value)
		if classData.Internal.__locked == true then LogError("classObjectLocked", true) end
		if value == nil then LogError("classMemberCannotSetToNil", true) end

		local accessSpecifier = returnAccessSpecifier(index, classData)

		if accessSpecifier ~= "Public" then
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, index)
			elseif accessSpecifier == "Internal" then
				LogError("classPropertyIsInternal", true, index)
			elseif accessSpecifier == "Protected" and not Util.inClassScope(class, true, true, Classes) then				
				LogError("classPropertyIsProtected", true, index)
			end
		end

		for _, attributesData in classData do
			if typeof(attributesData) == "table" and (attributesData :: any)[index] ~= nil then
				if (attributesData :: any)[index] == value then return end
				(attributesData :: any)[index] = value
				return
			end
		end

		LogError("classMemberNotFound", true, index)
	end

	function methods:__tostring()
		if classData.Internal.__locked == true then LogError("classObjectLocked", true) end

		local result = callOperator("__tostring", self, nil, true)
		if result then
			return result
		else
			return class.Name
		end
	end

	for _, operatorFuncName in operatorFuncNames do
		if not (classData.Public :: {[any]: any})[operatorFuncName] then continue end

		methods[string.gsub(operatorFuncName, "operator", "_")] = function(obj, obj2)
			if classData.Internal.__locked == true then LogError("classObjectLocked", true) end
			return callOperator(operatorFuncName, obj, obj2)
		end
	end
end

--// Creates a new class object with the given classData, className and an additional internalFunctionsList table to allow access for functions inside it to write to Inherits and Friends tables.
local function createClassObject<AccessSpecifier>(nClassData: classData, className: string, internalFunctionsList: {(...any) -> (any)}?, superClassConstructor: (self: any, ...any) -> ()?): internalClass<AccessSpecifier>
	local class: internalClass = setmetatable({
		Inherits = setmetatable({}, { __tostring = function() return '{}' end, __newindex = function(t, i, v) local f = Util.getMethodContext(5) if f ~= createClassObject and internalFunctionsList and not table.find(internalFunctionsList, f) then LogError("attemptToModifyReadOnlyTable", false) end rawset(t :: any, i :: any, v :: any) end, __metatable = {} }),
		Friends = setmetatable({}, { __tostring = function() return '{}' end, __newindex = function(t, i, v) local f = Util.getMethodContext(5) if f ~= createClassObject and internalFunctionsList and not table.find(internalFunctionsList, f) then LogError("attemptToModifyReadOnlyTable", false) end rawset(t :: any, i :: any, v :: any) end, __metatable = {} }),
		Name = className
	} :: {
		new: (...any) -> AccessSpecifier,
		extends: (className: string) -> (classData: classData) -> class,
		overload: (accessSpecifier: string, name: string, functionTable: {(...any) -> (any)}) -> (),
		static: (accessSpecifier: string, name: string, property: any) -> (),
		Name: string,
		Inherits: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end})),
		Friends: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end})),
		Statics: typeof(setmetatable({}, {__newindex = function(t, i, v) end, __metatable = {}, __tostring = function() end}))?
	}, {
		__index = function(t, i) return rawget(t, i)  end,
		__newindex = function(t, i, v) rawset(t, i, v) end,
		__type = "",
		__classtype = "",
		__abstract = false,
		__final = false
	})

	class.Statics = setmetatable({}, {__tostring = function() return '{}' end, __newindex = function(t, i, v) local f = Util.getMethodContext(5) if f ~= class.static then LogError("attemptToModifyReadOnlyTable", false) end rawset(t :: any, i :: any, v :: any) end, __metatable = {}})

	if not nClassData.Public then nClassData.Public = {} end
	if not nClassData.Private then nClassData.Private = {} end
	if not nClassData.Protected then nClassData.Protected = {} end

	if nClassData.Friend then
		for _, friend in nClassData.Friend do
			table.insert(class.Friends :: any, friend)
		end
	end

	local overloadedFunctions = {}

	local methods = {
		__type = "Class",
		__classtype = className,
		__abstract = false,
		__final = false
	}

	methods.__index = function(t, i)
		if i == "__type" then return end
		if i == "__abstract" then 
			if classpp.abstract == Util.getMethodContext(5) or classpp.final == Util.getMethodContext(5) then
				return methods["__abstract"] 
			end
		end
		if i == "__final" then 
			if classpp.final == Util.getMethodContext(5) or classpp.abstract == Util.getMethodContext(5) then
				return methods["__final"] 
			end
		end
		if i == "__ovfunc" and Util.getMethodContext(5) == Util.inClassScope then
			return overloadedFunctions
		end

		local result = nClassData[i] or findPropertyFromIndex(nClassData, i)
		if not result then return (class.Statics :: any)[i] end

		local methodContext, name = Util.getMethodContext(5)
		if typeof(result) == "function" and methodContext ~= Util.inClassScope then LogError("cannotCallFunctionError") elseif typeof(result) == "table" and getmetatable(result) and getmetatable(result)["__call"] and methodContext ~= Util.inClassScope then LogError("cannotCallFunctionError") end

		return result
	end

	methods.__newindex = function(t, i, v)
		if i == "__type" then return end
		if i == "__abstract" then 
			if classpp.abstract == Util.getMethodContext(5) and v == true then
				methods.__abstract = true
				class.new = function()
					return LogError("attemptToCreateObjectFromAbstractClass", true)
				end
			end
			return
		end
		if i == "__final" then
			if classpp.final == Util.getMethodContext(5) and v == true then
				methods.__final = true
				class.extends = function()
					LogError("attemptToExtendAFinalClass", true)
					return function() 
						return setmetatable({}, {}) :: class
					end
				end
			end
			return
		end

		nClassData[i] = v

		return v
	end

	function class.new(...): any
		local newObjTbl: internalClassData = sortAttributes(nClassData, className)
		local newObj = newproxy(true)
		local methods = getmetatable(newObj)

		setMetamethods(class, newObjTbl, methods)

		if superClassConstructor then superClassConstructor(newObj, ...) end

		if newObjTbl.Internal.constructor then
			newObjTbl.Internal.constructor(newObj, ...)
		end

		return newObj
	end

	function class.extends(className: string): (extendedClassData: classData) -> class
		if typeof(className) ~= "string" then LogError("classNameNotString") end
		if Classes[className] then LogError("classAlreadyExists", false, className) end
		if not silenceUpdateWarning then LogWarning("compatibilityWarning", false) end

		return function(extendedClassData: classData): class
			local newClassData = mergeClassData(nClassData, extendedClassData)
			local newClass = createClassObject(newClassData, className, {debug.info(1, 'f')}, nClassData.constructor)
			Classes[className] = newClass

			table.insert(newClass.Inherits :: any, class)

			return newClass
		end
	end

	function class.overload(accessSpecifier: string, name: string, functionTable: {(...any) -> (any)})
		local accessSpecifierCheck, specifierName = checkValidAccessSpecifier(accessSpecifier)
		if not accessSpecifierCheck or specifierName and specifierName == "Internal" then LogError("invalidAccessSpecifierError", true) end
		if not name then LogError("overloadfunctionNameNotSet", true) end
		if typeof(functionTable) ~= "table" or #functionTable == 0 then LogError("overloadfunctionTableNotGiven", true) end

		for _, func in functionTable do
			if typeof(func) ~= "function" then LogError("expectedFunctionError", true, typeof(func)) end
			table.insert(overloadedFunctions, func)
		end

		local methods = {
			__index = function(tbl, i) return end,
			__newindex = function(tbl, i) return end
		}

		methods.__call = function(tbl, ...)
			if Util.getMethodContext(4) == deepCopy then return end

			local args = {...}
			local f = false
			for _, func in functionTable do
				local argCount, isVariadic = debug.info(func, 'a')
				if argCount == #args or isVariadic then
					f = true
					func(...)
					return -- Comment or remove this if you want to run multiple functions at the same time.
				end
			end

			if not f and #args > 0 then LogErrorNonFatal("overloadfunctionArgumentMismatch", false, #args, name) end
		end

		nClassData[specifierName][name] = setmetatable({}, methods)
	end

	function class.static(accessSpecifier: string, name: string, property: any)
		local accessSpecifierCheck, specifierName = checkValidAccessSpecifier(accessSpecifier)
		if not accessSpecifierCheck or specifierName and specifierName == "Internal" or specifierName and specifierName == "Protected" then LogError("invalidAccessSpecifierError", true) end
		if not name then LogError("staticMemberNameNotSet", true) end
		if not class.Statics then return end
		if not nClassData[specifierName] then nClassData[specifierName] = {} end

		if not silenceUpdateWarning then LogWarning("compatibilityWarning", false) end

		local newObj = newproxy(true)
		local methods = getmetatable(newObj)

		function methods:__index(index): any
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, name)
			end

			return property
		end

		function methods:__newindex(index, value)
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, name)
			end

			property = value
			return property
		end

		function methods:__call(...)
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, name)
			end

			if typeof(property) == "function" then 
				return property(...) 
			else
				return property
			end
		end

		function methods:__tostring()
			if accessSpecifier == "Private" and not Util.inClassScope(class, false, true, Classes) then
				LogError("classPropertyIsPrivate", true, name)
			end

			return tostring(property)
		end

		class.Statics[name] = newObj
	end

	return setmetatable(class :: any, methods)
end

--////// Module Functions

--[[
	Returns a new <code>class</code> with the given <code>className</code> and <code>classData</code>.
]]
function classpp.class(className: string): <T>(classData: {Public: T?} & classData) -> class<T>
	if typeof(className) ~= "string" then LogError("classNameNotString") end
	if Classes[className] then LogError("classAlreadyExists", false, className or "Unknown") end

	return function<T>(classData: classData & {Public: T?}): class<T>
		if typeof(classData) ~= "table" then LogError("classDataNotTable") end
		if getmetatable(classData :: any) or not select(1, pcall(setmetatable, classData, {})) then LogError("classDataContainsMetatable") end

		local isAPropertyRedeclared: boolean, redeclaredIndex: any? = checkRedeclaration(classData)
		if isAPropertyRedeclared then LogError("classPropertyRedeclaration", false, redeclaredIndex) end

		if findPropertyFromIndex(classData, "Destroy") then LogError("invalidDestructorDecleration", false) end
		if checkOutsideAccessSpecifierDecleration(classData) then LogError("invalidAccessSpecifierInClassDataError", false) end

		local nCObj: internalClass<T> = createClassObject(classData, className)
		Classes[className] = nCObj

		return nCObj
	end
end

--[[
	Marks the given <code>class</code> or <code>class</code>es as abstract. If given multiple, then the first class will be returned.
]]
function classpp.abstract(classTable: {class}): class
	if typeof(classTable) ~= "table" then LogError("invalidModifierArgument", true) end

	for _, class: class in classTable do
		if Type.typeof(class) ~= "Class" then LogError("typeofObjectIsNotClass") end
		if class["__final"] then LogError("illegalModifierCombination", true, `abstract and final`) end 

		class["__abstract"] = true
	end

	return classTable[1]
end

--[[
	Marks the given <code>class</code> or <code>class</code>es as final. If given multiple, then the first class will be returned.
]]
function classpp.final(classTable: {class}): class
	if typeof(classTable) ~= "table" then LogError("invalidModifierArgument", true) end

	for _, class: class in classTable do
		if Type.typeof(class) ~= "Class" then LogError("typeofObjectIsNotClass") end
		if class["__abstract"] then LogError("illegalModifierCombination", true, `final and abstract`) end 

		class["__final"] = true
	end

	return classTable[1]
end

--[[
	Returns the <code>class</code> with the given <code>className</code>, if it exists.
]]
function classpp.getClass(className: string): class
	if typeof(className) ~= "string" then LogError("classNameNotString") end
	if not Classes[className] then LogError("classNotFound") end

	return Classes[className]
end

classpp.Type = Type
classpp.Util = Util

return classpp]]></ProtectedString>
							<string name="ScriptGuid">{430BC156-7C8C-4A7F-8AAC-A1733EC46863}</string>
							<BinaryString name="AttributesSerialize">AQAAABQAAABzaWxlbmNlVXBkYXRlV2FybmluZwMA</BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ClassPP</string>
							<int64 name="SourceAssetId">18312821151</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX1F4C67C226224D93BC52E1E1802BA293">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!native
--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		Utilities for Class++.
	////
--]]

local Util = {}
local Type = require(script.Parent.Type)

--////// Types

type class = Type.class

--////// Util Functions

function Util.getMethodContext(level: number): ((...any) -> (any), string)
	local _, f, n = pcall(function() 
		local f = debug.info(level, 'f')
		local n = debug.info(level, 'n')

		return f, n
	end)

	return f, n
end

function Util.checkInheritance(class: class, classOrMethod: any | () -> ()): boolean
	for _, inherited in class.Inherits do
		if typeof(classOrMethod) == "table" and inherited == classOrMethod or inherited[classOrMethod] then
			return true
		end
	end

	return false
end

function Util.checkFriendship(class: class, methodName: string, method: (any) -> (any), classes: {[string]: any}): boolean
	for _, friend in class.Friends do
		if Type.typeof(friend) == "Class" and friend[methodName] then
			return true
		elseif typeof(friend) == "string" then
			if classes[friend] and classes[friend][methodName] then
				return true
			end
		elseif typeof(friend) == "function" and friend == method then
			return true
		end
	end

	return false
end

function Util.inClassScope(class: class, includeInherited: boolean, includeFriend: boolean, classes: {[string]: any}?, defaultLevel: number?): boolean
	local level: number = defaultLevel or 6

	while true do
		local method, methodName = Util.getMethodContext(level)
		if not method then return false end

		if class[methodName] == method then return true end
		if #methodName == 0 and table.find(class["__ovfunc"], method) then return true end

		local result = if includeInherited then Util.checkInheritance(class, method) else false or if includeFriend and classes then Util.checkFriendship(class, methodName, method, classes) else false
		if result then return true end

		if method == Type.typeof then return true end

		level += 1
	end

	return false
end

return Util]]></ProtectedString>
								<string name="ScriptGuid">{1AC24A70-DF42-4A70-AFE5-DE98CEAFE423}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Util</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5CFDFABD68DA463DBDDDA5B196B18597">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		Handles logging Class++ specific errors.
	////
--]]

--////// Variables

local classError = {}
local LogMessages = require(script.Parent.LogMessages)

--////// Local Functions

local function logMessage(messageType: string, includeTraceback: boolean?, tracebackString: string?, logType: string, ...)
	local formatString: string
	local messageString: string

	if LogMessages[messageType] ~= nil then
		formatString = LogMessages[messageType]
	else
		formatString = LogMessages["unknownError"]
	end

	if ... and includeTraceback then
		formatString = string.format(formatString, ...)
		messageString = `\{Class++}: {formatString}\n--- Stack Trace ---\n{tracebackString or debug.traceback(nil, 4)}`
	elseif ... and not includeTraceback then
		formatString = string.format(formatString, ...)
		messageString = `\{Class++}: {formatString}`
	elseif not ... and includeTraceback then
		messageString = `\{Class++}: {formatString}\n--- Stack Trace ---\n{tracebackString or debug.traceback(nil, 4)}`
	else
		messageString = `\{Class++}: {formatString}`
	end
	
	if logType == "Error" then
		error(messageString, 0)
	elseif logType == "Warning" then
		warn(messageString)
	end
end

--////// Module Functions

function classError.logError(messageType: string, includeTraceback: boolean?, ...)
	return logMessage(messageType, includeTraceback, nil, "Error", ...)
end

function classError.logErrorNonFatal(messageType: string, includeTraceback: boolean?, ...)
	local tracebackString: string = debug.traceback(nil, 4)
	
	task.spawn(function(...)
		return logMessage(messageType, includeTraceback, tracebackString, "Error", ...)
	end, ...)
end

function classError.logWarning(messageType: string, includeTraceback: boolean?, ...)
	return logMessage(messageType, includeTraceback, nil, "Warning", ...)
end

return classError
]]></ProtectedString>
								<string name="ScriptGuid">{0BCA86C1-B352-4DB3-9554-98EB211992A7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Error</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2A6FB4871CF644AFA1595490FF263FDA">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		Templates for Class++ log messages.
	////
--]]

return {
	attemptToModifyReadOnlyTable = "Cannot modify a read only table.",
	attemptToCreateObjectFromAbstractClass = "Cannot create an object from an abstracted class.",
	attemptToExtendAFinalClass = "Cannot create an inherited class from a final class.",
	cannotCallFunctionError = "Cannot call function directly.",
	classAlreadyExists = "Class \"%s\" already exists.",
	classDataNotTable = "Given ClassData value is not a table.",
	classDataContainsMetatable = "Given ClassData value contains a metatable.",
	classMemberCannotSetToNil = "Class members cannot be set to nil.",
	classMemberNotFound = "This class has no member named \"%s\".",
	classNameNotString = "Class name is not a string or is nil.",
	classNameNotSet = "A class name is not set for the created class.",
	classNotFound = "A class with the given name cannot be found.",
	classNoMatchingFunctionError = "No match for %s function in this class.",
	classObjectLocked = "This class object has been locked.",
	classPropertyIsPrivate = "Property \"%s\" is private in this class.",
	classPropertyIsProtected = "Property \"%s\" is protected in this class.",
	classPropertyIsInternal = "Property \"%s\" is internal in this class. You cannot access it.",
	classPropertyRedeclaration = "Cannot redeclare property \"%s\".",
	compatibilityWarning = "Compatibility Warning!\nIn the upcoming (2.0) update, Class++ will no longer support these methods:\nclass.extends\nFor more information, please go to this link:\nhttps://github.com/TenebrisNoctua/ClassPP/discussions/4\n(To silence this error, set the silenceUpdateWarning attribute in the main module instance to true.",
	expectedFunctionError = "Expected function, got: %s.",
	invalidAccessSpecifierError = "Given value is not a valid access specifier.",
	invalidAccessSpecifierInClassDataError = "Invalid access specifier or function found in classData table. Make sure the names are correct.",
	invalidDestructorDecleration = "Cannot create reserved function \"Destroy\".",
	invalidModifierArgument = "Given argument is not a class table.",
	illegalModifierCombination = "Cannot create an illegal combination of modifiers: %s",
	nonNativeOperatorCall = "Operator function %s cannot be called without its operator.",
	overloadfunctionArgumentMismatch = "A function to handle the given number of arguments (%d) have not been provided for the overloaded function: \"%s\"",
	overloadfunctionNameNotSet = "A function name has not been set for the overloaded function.",
	overloadfunctionTableNotGiven = "A function table has not been given for the overloaded function.",
	staticMemberNameNotSet = "A name has not been set for the static member.",
	typeofMetatableError = "A metatable for the given object cannot be found.",
	typeofObjectIsNotClass = "The given object is not a class type.",
	typeofObjectNotFound = "The given object's type cannot be found.",
	unknownError = "An unknown error has occured.",
}
]]></ProtectedString>
								<string name="ScriptGuid">{4EF9283B-AA2D-4173-BAED-AD143BE46C2A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">LogMessages</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7F006E71C4FC430D98AC4FB49E427673">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--!native
--!strict

--[[
	//// 
		Written by Tenebris Noctua.
		Custom type system for Class++ classes and objects.
	////
--]]

--////// Variables

local Type = {}
local LogError = require(script.Parent.Error).logError

--////// Types

export type classData = {
	constructor: (self: any, ...any) -> ()?,
	destructor: (self: any) -> ()?,
	Public: {[any]: any}?,
	Private: {[any]: any}?,
	Protected: {[any]: any}?,
	Friend: {any}?
}

export type class<AccessSpecifier = any?> = typeof(setmetatable({} :: {
	new: (...any) -> AccessSpecifier,
	extends: (className: string) -> (classData: classData) -> class<AccessSpecifier>,
	overload: (accessSpecifier: string, name: string, functionTable: {(...any) -> (any)}) -> (),
	static: (accessSpecifier: string, name: string, property: any) -> (),
	Name: string
}, {
	__index = function(t, i) return end :: ({any}, any) -> (any),
	__newindex = function(t, i, v) end :: ({any}, any, any) -> (),
	__type = "",
	__classtype = "",
	__abstract = false,
	__final = false
}))

--////// Module Functions

function Type.typeof(object: any): string?
	local objType = typeof(object)
	if objType ~= "table" and objType ~= "userdata" then return objType end
	
	local metatable = getmetatable(object)
	if not metatable then LogError("typeofMetatableError") end
	if metatable["__type"] then return metatable["__type"] end
	
	if objType == "userdata" then 
		local _, rType = select(1, pcall(function() return object.__type end))
		if rType then return rType end
	end 
	
	return LogError("typeofObjectNotFound")
end

function Type.typeofClass(classObj: class): string?
	if Type.typeof(classObj) ~= "Class" then LogError("typeofObjectIsNotClass") end
	
	local metatable = getmetatable(classObj)
	if metatable["__classtype"] then return metatable["__classtype"] end
	
	return LogError("typeofObjectNotFound")
end

return Type
]]></ProtectedString>
								<string name="ScriptGuid">{A339C1D9-7A07-4E1B-AFB4-FC2A50EA6066}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Type</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX49015CD720F34A4B82ED4F657D4F12C8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ColorMath</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX157FB2824C10423FBAF067CFC5D2C7AA">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "ColorMath",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 93416946935477,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @Crazyblox"},
		{Text = "Description: An easy-to-use math extension of the Color3 library. Color3 userdata doesnt support math, and stores its values as 0-1 sRGB floats. The sRGB color space splits dark and bright values between a linear scale [straight] and a gamma curve. sRGB originated in 1996, allocating human-noticeable color differences to an 8-bit integer. Due to this, sRGB needs converting to Linear RGB [AKA lRGB] so that we can do math."},
		{Text = "Version: (latest)"},

		{Separator = "API"},
		{Text = "API is minimal, accepting and returning 0-1 sRGB Color3. Color3s are converted from sRGB, calculated as lRGB, and converted back to sRGB. This can be costly in heavy loops, but this is designed for ease-of-use, not speed. Long-term compatibility is ensured by preventing below APIs being overwritten by Roblox. Colorspace conversions are included for more granular operation [eg. Color3:Lerp()]"},
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{E8BE7421-C0A5-462C-9A2D-0F995CD7DB7C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA63986E5C4A844BE97D08E17D2D45C5C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
--!optimize 2
--!native
--|bruh

--[[ ColorMath : Crazyblox 2025

	ABOUT:
An easy-to-use math extension of RBX Color3.
Color3 doesn't support math, and stores its values as 0-1 sRGB floats.
The sRGB color space splits dark and bright values between a linear scale [straight] and a gamma curve.
sRGB originated in 1996, allocating human-noticeable color differences to an 8-bit integer.
Due to this, sRGB needs converting to Linear RGB [AKA lRGB] so that we can do math.

	SETUP:
As this module is Color3-only, replacing the Color3 global is optimal for readability.
The below line gives you auto-complete where you would need it most for these functions.
local Color3 = require(path.to.module)

	API:
API is minimal, accepting and returning standard Color3 userdata.
Color3's are converted from sRGB, calculated as lRGB, and converted back to sRGB.
This can be costly in heavy loops, but this is designed for ease-of-use, not speed.
Long-term compatibility is ensured by preventing below API's being overrided by Roblox.
Colorspace conversions are included for more granular operation [eg. Color3:Lerp()]

Math [sRGB input only]:
ColorMath.add( Color3, ...Color3 ): Color3
ColorMath.sub( Color3, ...Color3 ): Color3
ColorMath.mul( Color3, ...Color3 ): Color3
ColorMath.div( Color3, ...Color3 ): Color3
ColorMath.idiv( Color3, ...Color3 ): Color3

Color Space:
ColorMath.sRGB_To_lRGB( ...Color3 ): ...Color3
ColorMath.lRGB_To_sRGB( ...Color3 ): ...Color3
]]

local ColorMath = {
	--Adds given Color3's in order
	add = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do 
			C += vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	--Subtracts given Color3's in order
	sub = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do
			C -= vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	--Multiplies given Color3's in order
	mul = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do
			C *= vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	--Divides given Color3's in order
	div = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do
			C /= vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	--Floor-divides given Color3's in order
	idiv = function( Start: Color3, ...: Color3 ): Color3
		--Start with initial color
		local C: vector = vector.create(
			Start.R <= 0.04045 and Start.R * 0.07739938080495357 or ( ( Start.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.G <= 0.04045 and Start.G * 0.07739938080495357 or ( ( Start.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
			Start.B <= 0.04045 and Start.B * 0.07739938080495357 or ( ( Start.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
		)
		--Iterate through remainder of colors
		for _, Color: Color3 in {...} do
			C //= vector.create(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			)
		end
		return Color3.new(
			C.x <= 0.0031308 and C.x * 12.92 or 1.055 * ( C.x ^ 0.4166666666666667 ) - 0.055,
			C.y <= 0.0031308 and C.y * 12.92 or 1.055 * ( C.y ^ 0.4166666666666667 ) - 0.055,
			C.z <= 0.0031308 and C.z * 12.92 or 1.055 * ( C.z ^ 0.4166666666666667 ) - 0.055
		)
	end,
	
	sRGB_To_lRGB = function( ...: Color3 ): ...Color3
		local C: {Color3} = {}
		for _, Color: Color3 in {...} do
			table.insert( C, Color3.new(
				Color.R <= 0.04045 and Color.R * 0.07739938080495357 or ( ( Color.R + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.G <= 0.04045 and Color.G * 0.07739938080495357 or ( ( Color.G + 0.055 ) * 0.9478672985781991 ) ^ 2.4,
				Color.B <= 0.04045 and Color.B * 0.07739938080495357 or ( ( Color.B + 0.055 ) * 0.9478672985781991 ) ^ 2.4
			) )
		end
		return table.unpack( C )
	end,
	
	lRGB_To_sRGB = function( ...: Color3 ): ...Color3
		local C: {Color3} = {}
		for _, Color: Color3 in {...} do
			table.insert( C, Color3.new(
				Color.R <= 0.0031308 and Color.R * 12.92 or 1.055 * ( Color.R ^ 0.4166666666666667 ) - 0.055,
				Color.G <= 0.0031308 and Color.G * 12.92 or 1.055 * ( Color.G ^ 0.4166666666666667 ) - 0.055,
				Color.B <= 0.0031308 and Color.B * 12.92 or 1.055 * ( Color.B ^ 0.4166666666666667 ) - 0.055
				) )
		end
		return table.unpack( C )
	end
}
for name, method in Color3 do
	if not ColorMath[ name ] then
		ColorMath[ name ] = method
	end
end
return table.freeze( ColorMath )]]></ProtectedString>
							<string name="ScriptGuid">{26eb6bc4-fcde-4366-8145-7609f8cc5f62}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ColorMath</string>
							<int64 name="SourceAssetId">93416946935477</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXFA45E8C7F6534EA78F06BA7A804C5DAF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ByteNet</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX583D6C14852343C7834903DD74FA2251">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "ByteNet",
	Thumbnail = "rbxassetid://76276498409431",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @ffrostfall"},
		{Text = "Description: ByteNet is an networking library which takes your Luau data, and serializes it into buffers. On the other end, ByteNet deserializes your data, and then feeds it back to your Luau code. You dont need to worry about type validation, optimization, packet structure, etc. ByteNet does all the hard parts for you! Strictly typed with an incredibly basic API that explains itself, ByteNet makes networking simple, easy, and quick. Theres very few concepts you need to grasp in order to use ByteNet; it has an incredibly minimalistic & simplistic, yet powerful API."},
		{Text = "Version: v0.4.3 (pre-release)"},

		{Separator = "Performance"},
		{Text = "ByteNet performs incredibly well compared to non-buffer based libraries like BridgeNet2. This is because ByteNet has a custom serializer that takes your Luau data and transforms it into a buffer, sending that and deserializing it on the other side."},
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{EF3BEA93-4C0E-48CA-AC88-FAED5655D703}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9BF4BC08C1CB4E6F9F11151D7FFDA16F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local clientProcess = require(script.process.client)
local array = require(script.dataTypes.array)
local bool = require(script.dataTypes.bool)
local buff = require(script.dataTypes.buff)
local cframe = require(script.dataTypes.cframe)
local float32 = require(script.dataTypes.float32)
local float64 = require(script.dataTypes.float64)
local inst = require(script.dataTypes.inst)
local int16 = require(script.dataTypes.int16)
local int32 = require(script.dataTypes.int32)
local int8 = require(script.dataTypes.int8)
local map = require(script.dataTypes.map)
local nothing = require(script.dataTypes.nothing)
local optional = require(script.dataTypes.optional)
local string = require(script.dataTypes.string)
local struct = require(script.dataTypes.struct)
local uint16 = require(script.dataTypes.uint16)
local uint32 = require(script.dataTypes.uint32)
local uint8 = require(script.dataTypes.uint8)
local unknown = require(script.dataTypes.unknown)
local vec2 = require(script.dataTypes.vec2)
local vec3 = require(script.dataTypes.vec3)
local namespace = require(script.namespaces.namespace)
local definePacket = require(script.packets.definePacket)
local serverProcess = require(script.process.server)
local values = require(script.replicated.values)
local types = require(script.types)

values.start()

if RunService:IsServer() then
	serverProcess.start()
else
	clientProcess.start()
end

return (
	table.freeze({
		definePacket = definePacket,
		defineNamespace = namespace,

		array = array,
		bool = bool(),
		optional = optional,
		uint8 = uint8(),
		uint16 = uint16(),
		uint32 = uint32(),
		int8 = int8(),
		int16 = int16(),
		int32 = int32(),
		float32 = float32(),
		float64 = float64(),
		cframe = cframe(),
		string = string(),
		vec2 = vec2(),
		vec3 = vec3(),
		buff = buff(),
		struct = struct,
		map = map,
		inst = inst(),
		unknown = unknown(),
		nothing = nothing(),
	}) :: any
) :: types.ByteNet
]]></ProtectedString>
							<string name="ScriptGuid">{01335CCD-029D-4B57-983B-D9906516B976}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">ByteNet</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX9C03A230570D4A0CAC83E59AB2453296">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[export type namespaceData = {
	packets: {
		[string]: any,
	},
	structs: {
		[number]: {
			[string]: any,
		},
	},
}

-- Externally used for defining packets
export type packetProps<T> = {
	value: T,
	reliabilityType: ("reliable" | "unreliable")?,
	callbackBehavior: {
		spawnThread: boolean,
		allowMultiple: boolean,
	}?,
}

-- Used internally for
export type channelData = {
	cursor: number,
	size: number,
	references: { unknown },
	buff: buffer,
}

-- Used internally for serializing and deserializing all data types
export type dataTypeInterface<T> = {
	write: (value: T) -> (),
	read: (b: buffer, cursor: number, references: { [number]: unknown }?) -> (T, number),
}

-- Somewhat public facing: used as return result in definePacket
type Packet<T> = {
	sendToAll: (data: T) -> (),
	sendTo: (data: T, target: Player) -> (),
	sendToList: (data: T, targets: { Player }) -> (),

	wait: () -> T,
	send: (data: T, target: Player?) -> (),
	listen: (callback: (data: T, player: Player?) -> ()) -> (),
}

-- Library type
export type ByteNet = {
	definePacket: <T>(props: packetProps<T>) -> Packet<T>,
	defineNamespace: <T>(name: string, namespace: () -> T) -> T,

	struct: <T>(format: T) -> T,
	bool: boolean,
	array: <T>(value: T) -> { [number]: T },
	optional: <T>(value: T) -> T?,
	inst: Instance,
	nothing: nil,
	unknown: unknown,
	uint8: number,
	uint16: number,
	uint32: number,
	int8: number,
	int16: number,
	int32: number,
	float32: number,
	float64: number,
	string: string,
	vec3: Vector3,
	vec2: Vector2,
	buff: buffer,
	cframe: CFrame,
	map: <K, V>(key: K, value: V) -> { [K]: V },
}

return nil
]]></ProtectedString>
								<string name="ScriptGuid">{CCBECB27-70DC-472F-B41D-5AA3492B42FF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">types</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX7969F57EF0F64F4EB630E0C1274E57F5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">dataTypes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXB93EE16A976647F3A48506F479F1DDCE">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16

--[[
	Create a new array with the given dataTypeInterface
]]
return function(valueType: types.dataTypeInterface<any>)
	local valueWrite = valueType.write
	local valueRead = valueType.read

	return {
		read = function(b: buffer, cursor: number)
			local arrayLength = buffer.readu16(b, cursor)
			local arrayCursor = cursor + 2
			local array = {}

			for _ = 1, arrayLength do
				local item, length = valueRead(b, arrayCursor)
				table.insert(array, item)

				arrayCursor += length
			end

			return array, arrayCursor - cursor
		end,
		write = function(value: any)
			local length = #value
			u16(length)

			-- numeric iteration is about 2x faster than generic iteration
			for i = 1, length do
				valueWrite(value[i])
			end
		end,
	}
end
]]></ProtectedString>
									<string name="ScriptGuid">{06860B59-2774-4CE8-A403-44E712AFD754}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">array</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX898A53B534834D96BDAD4A32CC774D21">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local boolean = {
	--[[
		1 = true
		0 = false
		
		Write and read based off a uint8
	]]
	read = function(b: buffer, cursor: number)
		return buffer.readu8(b, cursor) == 1, 1
	end,

	write = bufferWriter.bool,
}

return function(): types.dataTypeInterface<boolean>
	return boolean
end
]]></ProtectedString>
									<string name="ScriptGuid">{BCD344C1-D7E3-42E1-A024-AFBABC40E3BE}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">bool</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX14B9DDCAC4EE40939ED41AC50AA2D896">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16
local copy = bufferWriter.copy
local dyn_alloc = bufferWriter.dyn_alloc

local buff = {
	read = function(b: buffer, cursor: number)
		local length = buffer.readu16(b, cursor)
		local freshBuffer = buffer.create(length)

		-- copy the data from the main buffer to the new buffer with an offset of 2 because of length
		buffer.copy(freshBuffer, 0, b, cursor + 2, length)

		return freshBuffer, length + 2
	end,
	write = function(data: buffer)
		local length = buffer.len(data)
		u16(length)

		dyn_alloc(length)

		-- write the length of the buffer, then the buffer itself
		copy(data)
	end,
}

return function(): types.dataTypeInterface<buffer>
	return buff
end
]]></ProtectedString>
									<string name="ScriptGuid">{6FBDFD20-E265-4A0D-834E-888C71609CFD}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">buff</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC3D78B969B874E038EFE10AC923066A6">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f32NoAlloc = bufferWriter.f32NoAlloc
local alloc = bufferWriter.alloc

-- thanks jack :p
local cframe = {
	read = function(b: buffer, cursor: number)
		local x = buffer.readf32(b, cursor)
		local y = buffer.readf32(b, cursor + 4)
		local z = buffer.readf32(b, cursor + 8)
		local rx = buffer.readf32(b, cursor + 12)
		local ry = buffer.readf32(b, cursor + 16)
		local rz = buffer.readf32(b, cursor + 20)

		-- Re-construct the CFrame from the axis-angle representation
		local axis = Vector3.new(rx, ry, rz)
		local angle = axis.Magnitude

		return CFrame.fromAxisAngle(axis, angle) + Vector3.new(x, y, z), 24
	end,
	write = function(value: CFrame)
		-- Convert the CFrame to an axis-angle representation
		local x, y, z = value.X, value.Y, value.Z

		local axis, angle = value:ToAxisAngle()
		local rx, ry, rz = axis.X, axis.Y, axis.Z
		axis = axis * angle

		-- Math done, write it now
		alloc(24)
		f32NoAlloc(x)
		f32NoAlloc(y)
		f32NoAlloc(z)
		f32NoAlloc(rx)
		f32NoAlloc(ry)
		f32NoAlloc(rz)
	end,
}

return function(): types.dataTypeInterface<CFrame>
	return cframe
end
]]></ProtectedString>
									<string name="ScriptGuid">{5326F4A8-399E-4732-89A0-3F281180C058}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">cframe</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXCE9C33E5D2E147DC99EECBAF2EA172FF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f32 = bufferWriter.f32

local float32 = {
	write = f32,

	read = function(b: buffer, cursor: number)
		return buffer.readf32(b, cursor), 4
	end,
}

return function(): types.dataTypeInterface<number>
	return float32
end
]]></ProtectedString>
									<string name="ScriptGuid">{054B17FF-6958-4824-B695-690D009E9835}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">float32</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB18B10372F9441149548144743207106">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f64 = bufferWriter.f64

local float64 = {
	write = f64,

	read = function(b: buffer, cursor: number)
		return buffer.readf64(b, cursor), 8
	end,
}

return function(): types.dataTypeInterface<number>
	return float64
end
]]></ProtectedString>
									<string name="ScriptGuid">{2BA01641-0E2F-4891-99CF-1611DBEA7017}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">float64</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX35ACDBA6C7E64869B4D728408F1E85A0">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local readRefs = require(script.Parent.Parent.process.readRefs)
local types = require(script.Parent.Parent.types)

local reference = bufferWriter.reference
local alloc = bufferWriter.alloc

return function(): types.dataTypeInterface<Instance?>
	return {
		write = function(value)
			alloc(1)
			reference(value)
		end,

		read = function(b: buffer, cursor: number)
			local refs = readRefs.get()

			if not refs then
				return nil, 1
			end

			local ref = refs[buffer.readu8(b, cursor)]

			if typeof(ref) == "Instance" then
				return ref, 1
			else
				return nil, 1
			end
		end,
	}
end
]]></ProtectedString>
									<string name="ScriptGuid">{205C7EC2-C8C3-464D-A86D-0B0488C64005}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">inst</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC86306D86FEC44E6BC6313FDA0533033">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local i16 = bufferWriter.i16

local int16 = {
	write = i16,

	read = function(b: buffer, cursor: number)
		return buffer.readi16(b, cursor), 2
	end,
}

return function(): types.dataTypeInterface<number>
	return int16
end
]]></ProtectedString>
									<string name="ScriptGuid">{5813BEBC-AA41-4A87-9D6A-45713178C96E}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">int16</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0823D81212A24BEE852EA0D54B4467FF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local i32 = bufferWriter.i32

local int32 = {
	write = i32,

	read = function(b: buffer, cursor: number)
		return buffer.readi32(b, cursor), 4
	end,
}

return function(): types.dataTypeInterface<number>
	return int32
end
]]></ProtectedString>
									<string name="ScriptGuid">{FB7A1884-D370-4D47-9313-8639F41C82DB}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">int32</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0F33CB92E6B741B0B7CFFC608630B000">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local i8 = bufferWriter.i8

local int8 = {
	write = i8,

	read = function(b: buffer, cursor: number)
		return buffer.readi8(b, cursor), 1
	end,
}

return function(): types.dataTypeInterface<number>
	return int8
end
]]></ProtectedString>
									<string name="ScriptGuid">{C634BA0F-4C56-4468-90C0-03703DACB7F8}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">int8</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3340DD8FEDDB433BADB9388774DCB4A6">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16

-- thanks jack :p
return function(
	keyType: types.dataTypeInterface<any>,
	valueType: types.dataTypeInterface<any>
): types.dataTypeInterface<{ [any]: any }>
	-- Cache these functions to avoid the overhead of the index
	local keyWrite = keyType.write
	local valueWrite = valueType.write

	return {
		read = function(b: buffer, cursor: number)
			local map = {}
			local mapCursor = cursor

			-- Read map length
			local mapLength = buffer.readu16(b, mapCursor)
			mapCursor += 2

			for _ = 1, mapLength do
				-- read key/value pairs and add them to the map
				local key, keyLength = keyType.read(b, mapCursor)
				mapCursor += keyLength

				local value, valueLength = valueType.read(b, mapCursor)
				mapCursor += valueLength

				map[key] = value
			end

			-- Return the map, alongside length, because mapCursor - cursor = size
			return map, mapCursor - cursor
		end,
		write = function(map: any)
			local count = 0
			for _ in map do
				count += 1
			end

			-- Write length
			u16(count)

			for k, v in map do
				-- Write key/value pairs
				keyWrite(k)
				valueWrite(v)
			end
		end,
	}
end
]]></ProtectedString>
									<string name="ScriptGuid">{C87383CD-1936-43DB-B356-7D92573826CA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">map</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX60CE37B42CD1447C8E404263AA80407C">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)

local nothing = {
	write = function() end,

	read = function()
		return nil, 0
	end,
}

return function(): types.dataTypeInterface<nil>
	return nothing
end
]]></ProtectedString>
									<string name="ScriptGuid">{3F61FD56-8656-40ED-81FE-E772B3BAFFDD}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">nothing</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC9A06AA6772C410097C8859C371B140F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local bool = bufferWriter.bool

return function(valueType: types.dataTypeInterface<any>)
	local valueRead = valueType.read
	local valueWrite = valueType.write

	return {
		--[[
			first byte is a boolean, if it's true, the next bytes are the value of valueType
			if it's false, its length of 1 cuz only 1 boolean
		]]

		read = function(b: buffer, cursor: number)
			if buffer.readu8(b, cursor) == 0 then
				-- doesn't exist
				return nil, 1
			else
				-- exists, read the value
				local item, length = valueRead(b, cursor + 1)
				return item, length + 1
			end
		end,

		write = function(value: any)
			local exists = value ~= nil

			bool(exists)

			if exists then
				valueWrite(value)
			end
		end,
	}
end :: <T>(valueType: types.dataTypeInterface<T>) -> types.dataTypeInterface<T?>
]]></ProtectedString>
									<string name="ScriptGuid">{BED9B6B8-F8F5-4EA0-8504-5378705F61E2}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">optional</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5D42162FFC6D41008E4727CE1B48E312">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16
local writestring = bufferWriter.writestring
local dyn_alloc = bufferWriter.dyn_alloc

local str = {
	-- 2 bytes for the length, then the string

	read = function(b: buffer, cursor: number)
		local length = buffer.readu16(b, cursor)

		return buffer.readstring(b, cursor + 2, length), length + 2
	end,
	write = function(data: string)
		local length = string.len(data)
		u16(length)

		dyn_alloc(length)
		writestring(data)
	end,
}

return function(): types.dataTypeInterface<string>
	return str
end
]]></ProtectedString>
									<string name="ScriptGuid">{4933F234-893F-4FF9-9D21-69B6907C0B89}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">string</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0D124D70F30A41E48722B75205890954">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local namespacesDependencies = require(script.Parent.Parent.namespaces.namespacesDependencies)
local values = require(script.Parent.Parent.replicated.values)
local types = require(script.Parent.Parent.types)

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

type structData = {
	[string]: number,
}

return function(input: {
	[string]: types.dataTypeInterface<any>,
}): types.dataTypeInterface<any>
	-- This is used in the reading/writing parts, and isn't used in the initialization code
	-- It's used to store the index-value pairs and the index-key pairs
	-- Index being the position of the value in the array, and the key being the key in the struct dictionary
	local indexValueTypePairs: {
		[number]: types.dataTypeInterface<any>,
	} = {}
	local indexKeyPairs: { [number]: string } = {}

	--[[
		Array should look like {
			[index (1)] = value
			[index (2)] = value
		}

		Index value type is {
			[index (1)] = int32
		}

		Index key is {
			[index (1)] = "structField"
		}
	]]

	if runContext == "server" then
		local serializedStruct = {}

		-- Convert the struct to an array
		local count = 0
		for key in input do
			count += 1
			serializedStruct[key] = count

			-- Store the index-value pairs and the index-key pairs as a shortcut for serializing n all that
			indexValueTypePairs[count] = input[key]
			indexKeyPairs[count] = key
		end

		-- replicate
		namespacesDependencies.add(serializedStruct)
	elseif runContext == "client" then
		-- There's a layer of complexity added here because we have to access the namespace data
		namespacesDependencies.add(input)

		local name = namespacesDependencies.currentName()

		local namespaceReplicator = values.access(name)
		local namespaceData = namespaceReplicator:read() :: types.namespaceData

		-- struct id is just based on the order of creation in the namespace function
		local structData = namespaceData.structs[namespacesDependencies.currentLength()]

		-- Fetch the data from the server and store it in the index-value pairs and the index-key pairs
		for key, index in structData do
			indexValueTypePairs[index] = input[key]
			indexKeyPairs[index] = key
		end
	end

	return {
		read = function(b, cursor)
			local constructed = table.clone(input)
			local structCursor = cursor

			for index, valueType in indexValueTypePairs do
				local value, length = valueType.read(b, structCursor)

				constructed[indexKeyPairs[index]] = value

				structCursor += length
			end

			return constructed, structCursor - cursor
		end,

		write = function(structValue)
			for index, valueType in indexValueTypePairs do
				valueType.write(structValue[indexKeyPairs[index]])
			end
		end,
	}
end
]]></ProtectedString>
									<string name="ScriptGuid">{195DA38D-D472-42B1-95ED-00ADB8F801E6}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">struct</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX63FF5EB25BAA46B7A78527BF265F0943">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u16 = bufferWriter.u16

local uint16 = {
	write = u16,

	read = function(b: buffer, cursor: number)
		return buffer.readu16(b, cursor), 2
	end,
}

return function(): types.dataTypeInterface<number>
	return uint16
end
]]></ProtectedString>
									<string name="ScriptGuid">{1981A3EA-60F5-4A72-A7E0-E27B1AEC34FB}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">uint16</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF46660AF92AE466292E693E50C8FE7CB">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local u32 = bufferWriter.u32

local uint32 = {
	write = u32,

	read = function(b: buffer, cursor: number)
		return buffer.readu32(b, cursor), 4
	end,
}

return function(): types.dataTypeInterface<number>
	return uint32
end
]]></ProtectedString>
									<string name="ScriptGuid">{E44FA52F-7863-49DE-B2F3-F27D7D55E2A7}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">uint32</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3C272685AAB049189C4579B432C2972B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local bufferWriter = require(script.Parent.Parent.process.bufferWriter)

local u8 = bufferWriter.u8

local uint8 = {
	write = u8,

	read = function(b: buffer, cursor: number)
		return buffer.readu8(b, cursor), 1
	end,
}

return function(): types.dataTypeInterface<number>
	return uint8
end
]]></ProtectedString>
									<string name="ScriptGuid">{9130F908-8C5A-4752-A25D-DEE2169115AA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">uint8</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX652BFBECD9684DCD8C498EC9ABCC9F0F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local readRefs = require(script.Parent.Parent.process.readRefs)
local types = require(script.Parent.Parent.types)

local reference = bufferWriter.reference
local alloc = bufferWriter.alloc

return function(): types.dataTypeInterface<unknown>
	return {
		write = function(value: unknown)
			alloc(1)
			reference(value)
		end,

		read = function(b: buffer, cursor: number)
			local refs = readRefs.get()

			if not refs then
				return nil, 1
			end

			return refs[buffer.readu8(b, cursor)], 1
		end,
	}
end
]]></ProtectedString>
									<string name="ScriptGuid">{5ABB060C-D381-4FBD-AA78-7C150D9D5951}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">unknown</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB9110F5392F64170863BB3E5F073EFD1">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f32NoAlloc = bufferWriter.f32NoAlloc
local alloc = bufferWriter.alloc

local vec2 = {
	--[[
		2 float32s, one for X, one for Y
	]]

	read = function(b: buffer, cursor: number)
		return Vector2.new(buffer.readf32(b, cursor), buffer.readf32(b, cursor + 4)), 8
	end,

	write = function(value: Vector2)
		alloc(8)
		f32NoAlloc(value.X)
		f32NoAlloc(value.Y)
	end,
}

return function(): types.dataTypeInterface<Vector2>
	return vec2
end
]]></ProtectedString>
									<string name="ScriptGuid">{D1CB1B2A-6A7A-4F1E-9EC7-89156F5A6FBA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">vec2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX62E1DCF069964F988B985968C6EC1D88">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f32NoAlloc = bufferWriter.f32NoAlloc
local alloc = bufferWriter.alloc

local vec3 = {
	--[[
		3 floats, 12 bytes
	]]
	read = function(b: buffer, cursor: number)
		return Vector3.new(buffer.readf32(b, cursor), buffer.readf32(b, cursor + 4), buffer.readf32(b, cursor + 8)), 12
	end,

	write = function(value: Vector3)
		alloc(12)
		f32NoAlloc(value.X)
		f32NoAlloc(value.Y)
		f32NoAlloc(value.Z)
	end,
}

return function(): types.dataTypeInterface<Vector3>
	return vec3
end
]]></ProtectedString>
									<string name="ScriptGuid">{A19E7F2A-A7D9-4CE5-9BC8-6756667710C2}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">vec3</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX819CB7F0F2E84F63A7526FCBFC286D79">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">namespaces</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXCBB9F8D2EE674271AB85894C7C0D8E86">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[
	The file that contains the function for handling and creating namespaces.
	Namespaces aren't really anything special, they are just an encapsulation to make it easier to manage packets and structs.
	
	Dependency management is fun!
]]

local RunService = game:GetService("RunService")

local values = require(script.Parent.Parent.replicated.values)
local types = require(script.Parent.Parent.types)
local namespacesDependencies = require(script.Parent.namespacesDependencies)
local packetIDs = require(script.Parent.packetIDs)

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

local count = 0

return function(
	name: string,
	input: () -> {
		[string]: any,
	}
)
	local namespaceReplicator = values.access(name)

	namespacesDependencies.start(name)
	local packets: {
		[string]: (id: number) -> any,
	} = input()
	local structs = namespacesDependencies.empty()

	local result = {}

	if runContext == "server" then
		local constructedNamespace = {
			structs = {},
			packets = {},
		}

		for key in packets do
			count += 1
			constructedNamespace.packets[key] = count
			result[key] = packets[key](count)

			packetIDs.set(count, result[key])
		end

		for index, value in structs do
			constructedNamespace.structs[index] = value
		end

		namespaceReplicator:write(constructedNamespace)
	elseif runContext == "client" then
		-- yes, this means that packets technically don't need to be defined on the client
		-- we do it anyway for typechecking and perf shortcuts
		local namespaceData = namespaceReplicator:read() :: types.namespaceData

		for key, packet in packets do
			result[key] = packet(namespaceData.packets[key])

			packetIDs.set(namespaceData.packets[key], result[key])
		end
	end

	return result
end
]]></ProtectedString>
									<string name="ScriptGuid">{1848E0D0-61D8-4891-BFEE-933EDDBC900D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">namespace</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBDDD087E1EC04E30B4EB40C5403C3805">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[
	Basic dependency graph for structs created within a namespace
]]

local current: { [number]: any }?
local currentName: string

local namespacesDependencies = {}

function namespacesDependencies.start(name: string)
	current = {} :: { [number]: any }
	currentName = name
end

function namespacesDependencies.add(data)
	if not current then
		return
	end

	table.insert(current, data)
end

function namespacesDependencies.currentLength()
	return if current then #current else 0
end

function namespacesDependencies.currentName()
	return currentName
end

function namespacesDependencies.empty(): { [number]: any }
	if current == nil then
		return {}
	end

	local result = current
	current = nil

	return result
end

return namespacesDependencies
]]></ProtectedString>
									<string name="ScriptGuid">{95546D2B-5D7E-48A3-AE7D-6D5399413E09}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">namespacesDependencies</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX72AE2AF616204F06A5E23211E63C016B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--!native

--[[
	Exists solely to get a packet instance from an ID in the reader file.
	Might be able to be done in a better way?
]]
local dict = {}

local packetIDs = {}

function packetIDs.set(id: number, packet: any)
	dict[id] = packet
end

-- Use this instead of a get function for performance.
function packetIDs.ref()
	return dict
end

return packetIDs
]]></ProtectedString>
									<string name="ScriptGuid">{AA701365-64C7-4704-97C5-5DD9A98CD121}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">packetIDs</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX80B433280DEF47A6888BE9729E000D52">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">packets</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXB7FBCA7ECDCD4ABE918BBF38AC5EE78D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2

--[[
	Exists so that the namespace can set the ID of the packet

	Packet shouldnt need to care about making its own ID
]]
local types = require(script.Parent.Parent.types)
local packet = require(script.Parent.packet)

return function(props: types.packetProps<any>)
	return function(id: number)
		return packet(props, id)
	end
end
]]></ProtectedString>
									<string name="ScriptGuid">{0A40DD04-F25B-406B-B209-80FA2CE2655F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">definePacket</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0D7A8E303B6D48B3AFED3BF1DE8FE80D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local types = require(script.Parent.Parent.types)
local client = require(script.Parent.Parent.process.client)
local server = require(script.Parent.Parent.process.server)

local moduleRunContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

--[[
	We use closures here instead of metatables for performance
	It's just faster to use closures than metatables
]]
return function(props: types.packetProps<types.dataTypeInterface<any>>, id: number)
	-- Basic properties: reliability type, "unique" which is used to get the packet ID, and set up listeners
	local reliabilityType = props.reliabilityType or "reliable"
	local listeners = {}

	local serverSendFunction: (player: Player, id: number, writer: (value: any) -> (), data: any) -> () = if reliabilityType
			== "reliable"
		then server.sendPlayerReliable
		else server.sendPlayerUnreliable

	local serverSendAllFunction: (id: number, writer: (value: any) -> (), data: any) -> () = if reliabilityType
			== "reliable"
		then server.sendAllReliable
		else server.sendAllUnreliable

	local clientSendFunction: (id: number, writer: (value: any) -> (), data: any) -> () = if reliabilityType
			== "reliable"
		then client.sendReliable
		else client.sendUnreliable

	-- shorcut to avoid indexxing
	local writer = props.value.write

	local exported = {}

	-- RunContext error checking that doesn't have performance drawbacks
	setmetatable(exported, {
		__index = function(index)
			if
				(index == "sendTo" or index == "sendToAllExcept" or index == "sendToAll")
				and moduleRunContext == "client"
			then
				error("You cannot use sendTo, sendToAllExcept, or sendToAll on the client")
			elseif index == "send" and moduleRunContext == "server" then
				error("You cannot use send on the server")
			end
		end,
	})

	-- exposed for the reader file
	exported.reader = props.value.read

	if moduleRunContext == "server" then
		function exported.sendToList(data, players: { Player })
			for _, player in players do
				serverSendFunction(player, id, writer, data)
			end
		end

		function exported.sendTo(data, player: Player)
			serverSendFunction(player, id, writer, data)
		end

		function exported.sendToAllExcept(data, except: Player)
			for _, player: Player in Players:GetPlayers() do
				if player ~= except then
					serverSendFunction(player, id, writer, data)
				end
			end
		end

		function exported.sendToAll(data)
			serverSendAllFunction(id, writer, data)
		end
	elseif moduleRunContext == "client" then
		function exported.send(data)
			clientSendFunction(id, writer, data)
		end
	end

	function exported.wait()
		-- define it up here so we can use it to disconnect
		local index: number

		local runningThread = coroutine.running()
		table.insert(listeners, function(data, player)
			task.spawn(runningThread, data, player)

			-- Disconnects the listener
			table.remove(listeners, index)
		end)

		-- we connected, time to set the index for when we need to disconnect.
		index = #listeners

		-- the listener will resume the thread
		return coroutine.yield()
	end

	function exported.listen(callback)
		table.insert(listeners, callback)
	end

	function exported.getListeners()
		return listeners
	end

	return exported
end
]]></ProtectedString>
									<string name="ScriptGuid">{31F18280-ADF0-443D-B884-F19E43907C81}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">packet</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX7EC8F933880E430892686EBAD40B0431">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">process</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX5C8E739E45144CA7A6F6E47B3768AFCF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2

--[[
	Collects all write operations into a queue.
	When the buffer is written, it will be written in the order of the queue.
	
	All operations take in 2 parameters: the cursor and the value.
	Knowing this we can easily attach everything in a nice table, where
	{
		[1] = writer,
		[2] = cursor,
		[3] = value
	}
	
	A lot of these functions just exist as shorthand optimizations.
]]
local types = require(script.Parent.Parent.types)

local current: types.channelData

local size: number
local cursor: number
local buff: buffer
local references: { [number]: unknown }

local function alloc(bytes: number)
	if not (cursor + bytes >= size) then
		return
	end

	size = math.floor(size * 1.5)

	local newBuffer = buffer.create(size)
	buffer.copy(newBuffer, 0, buff)

	buff = newBuffer
end

local function dyn_alloc(bytes: number)
	while cursor + bytes >= size do
		size = math.floor(size * 1.5)
	end

	local newBuffer = buffer.create(size)
	buffer.copy(newBuffer, 0, buff)

	buff = newBuffer
end

local bufferWriter = {}

bufferWriter.alloc = alloc
bufferWriter.dyn_alloc = dyn_alloc

function bufferWriter.u8(value: number)
	alloc(1)
	buffer.writeu8(buff, cursor, value)
	cursor += 1
end

function bufferWriter.i8(value: number)
	alloc(1)
	buffer.writei8(buff, cursor, value)
	cursor += 1
end

-- this exists solely for the unknown and instance data type. Will likely be obselete soon enough
function bufferWriter.reference(value: any)
	table.insert(references, value)
	local index = #references

	buffer.writeu8(buff, cursor, index)
	cursor += 1
	print(references)
end

function bufferWriter.u16(value: number)
	alloc(2)
	buffer.writeu16(buff, cursor, value)
	cursor += 2
end

function bufferWriter.i16(value: number)
	alloc(2)
	buffer.writeu16(buff, cursor, value)
	cursor += 2
end

function bufferWriter.u32(value: number)
	alloc(4)
	buffer.writeu32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.writestring(value: string)
	buffer.writestring(buff, cursor, value)
	cursor += string.len(value)
end

function bufferWriter.i32(value: number)
	alloc(4)
	buffer.writei32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.f32NoAlloc(value: number)
	buffer.writef32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.f64NoAlloc(value: number)
	buffer.writef64(buff, cursor, value)
	cursor += 4
end

function bufferWriter.f32(value: number)
	alloc(4)
	buffer.writef32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.f64(value: number)
	alloc(8)
	buffer.writef64(buff, cursor, value)
	cursor += 8
end

function bufferWriter.copy(value)
	buffer.copy(buff, cursor, value)
	cursor += buffer.len(value)
end

function bufferWriter.bool(val: boolean)
	alloc(1)
	buffer.writeu8(buff, cursor, if val then 1 else 0)
	cursor += 1
end

function bufferWriter.load(channel: types.channelData)
	current = channel
	size = channel.size
	cursor = channel.cursor
	references = channel.references
	buff = channel.buff
end

function bufferWriter.export()
	current.size = size
	current.cursor = cursor
	current.references = references
	current.buff = buff

	return current
end

return bufferWriter
]]></ProtectedString>
									<string name="ScriptGuid">{6B32B726-AF36-4ED1-AD0F-DCD003B2A976}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">bufferWriter</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD7EE836D3DA741F9A7D5CD9840E336F7">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local types = require(script.Parent.Parent.types)
local read = require(script.Parent.read)
local bufferWriter = require(script.Parent.bufferWriter)

local alloc = bufferWriter.alloc
local u8 = bufferWriter.u8
local load = bufferWriter.load

local function onClientEvent(receivedBuffer, ref)
	read(receivedBuffer, ref)
end

-- Shared with: src/process/server.luau (Infeasible to split this into another file)
local function create()
	return {
		cursor = 0,
		size = 256,
		references = {},
		buff = buffer.create(256),
	}
end

local function dump(channel: types.channelData): (buffer, { unknown }?)
	local cursor = channel.cursor
	local dumpBuffer = buffer.create(cursor)

	buffer.copy(dumpBuffer, 0, channel.buff, 0, cursor)

	return dumpBuffer, if #channel.references > 0 then channel.references else nil
end
-- No longer shared

local reliable: types.channelData = create()
local unreliable: types.channelData = create()

local clientProcess = {}

function clientProcess.sendReliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	reliable = load(reliable)

	alloc(1)
	u8(id)
	writer(data)

	reliable = bufferWriter.export()
end

function clientProcess.sendUnreliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	unreliable = load(unreliable)

	alloc(1)
	u8(id)
	writer(data)

	unreliable = bufferWriter.export()
end

function clientProcess.start()
	local reliableRemote = ReplicatedStorage:WaitForChild("ByteNetReliable")
	reliableRemote.OnClientEvent:Connect(onClientEvent)

	local unreliableRemote = ReplicatedStorage:WaitForChild("ByteNetUnreliable")
	unreliableRemote.OnClientEvent:Connect(onClientEvent)

	RunService.Heartbeat:Connect(function()
		-- Again, checking if there's anything in the channel before we send it.
		if reliable.cursor > 0 then
			local b, r = dump(reliable)
			reliableRemote:FireServer(b, r)

			-- effectively clears the channel
			reliable.cursor = 0
			table.clear(reliable.references)
		end

		if unreliable.cursor > 0 then
			local b, r = dump(unreliable)
			unreliableRemote:FireServer(b, r)

			unreliable.cursor = 0
			table.clear(unreliable.references)
		end
	end)
end

return clientProcess
]]></ProtectedString>
									<string name="ScriptGuid">{85236C1B-5066-4AFA-B05A-03DB4B1F5D6B}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">client</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC0444E736CB3463BB3C3D0F29CC005EC">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--!native
local packetIDs = require(script.Parent.Parent.namespaces.packetIDs)
local readRefs = require(script.Parent.readRefs)

local ref = packetIDs.ref()
local freeThread: thread?

local function functionPasser(fn, ...)
	local aquiredThread = freeThread
	freeThread = nil
	fn(...)
	freeThread = aquiredThread
end

local function yielder()
	while true do
		functionPasser(coroutine.yield())
	end
end

local function runListener(fn, ...)
	if freeThread == nil then
		freeThread = coroutine.create(yielder)
		coroutine.resume(freeThread :: thread)
	end

	task.spawn(freeThread :: thread, fn, ...)
end

return function(incomingBuffer: buffer, references: { [number]: unknown }?, player: Player?)
	local length = buffer.len(incomingBuffer)
	local readCursor = 0

	readRefs.set(references)

	while readCursor < length do
		local packet = ref[buffer.readu8(incomingBuffer, readCursor)]
		readCursor += 1

		local value, valueLength = packet.reader(incomingBuffer, readCursor)

		readCursor += valueLength

		for _, listener in packet.getListeners() do
			runListener(listener, value, player)
		end
	end
end
]]></ProtectedString>
									<string name="ScriptGuid">{BC3129BA-DB01-441D-9116-8AD2B431D65E}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">read</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9F5E84C355324D54864498A17BD4C0B9">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--!native
local current

local readRefs = {}

function readRefs.set(refTable)
	current = refTable
end

function readRefs.get()
	return current
end

return readRefs
]]></ProtectedString>
									<string name="ScriptGuid">{90DD0D59-688F-4B72-8067-CB7BFB7B6295}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">readRefs</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA5C0CA44F4CF44108000FAD68CB29C3D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local types = require(script.Parent.Parent.types)
local read = require(script.Parent.read)
local bufferWriter = require(script.Parent.bufferWriter)

local alloc = bufferWriter.alloc
local u8 = bufferWriter.u8
local load = bufferWriter.load

-- All channelData is set to nil upon being sent which is why these are all optionals
local perPlayerReliable: { [Player]: types.channelData } = {}
local perPlayerUnreliable: { [Player]: types.channelData } = {}

-- Shared with: src/process/client.luau (Infeasible to split this into another file)
local function create()
	return {
		cursor = 0,
		size = 256,
		references = {},
		buff = buffer.create(256),
	}
end

local function dump(channel: types.channelData): (buffer, { unknown }?)
	local cursor = channel.cursor
	local dumpBuffer = buffer.create(cursor)

	buffer.copy(dumpBuffer, 0, channel.buff, 0, cursor)

	return dumpBuffer, if #channel.references > 0 then channel.references else nil
end
-- No longer shared

local globalReliable: types.channelData = create()
local globalUnreliable: types.channelData = create()

-- TODO handle invalid data better
local function onServerEvent(player: Player, data, references)
	-- Only accept buffer data
	if not (typeof(data) == "buffer") then
		return
	end

	read(data, references, player)
end

local function playerAdded(player)
	if not perPlayerReliable[player] then
		perPlayerReliable[player] = create()
	end

	if not perPlayerUnreliable[player] then
		perPlayerUnreliable[player] = create()
	end
end

local serverProcess = {}

function serverProcess.sendAllReliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	load(globalReliable)

	alloc(1)
	u8(id)
	writer(data)

	globalReliable = bufferWriter.export()
end

function serverProcess.sendAllUnreliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	load(globalUnreliable or create())

	alloc(1)
	u8(id)
	writer(data)

	globalUnreliable = bufferWriter.export()
end

function serverProcess.sendPlayerReliable(
	player: Player,
	id: number,
	writer: (value: any) -> (),
	data: { [string]: any }
)
	load(perPlayerReliable[player] or create())

	alloc(1)
	u8(id)
	writer(data)

	perPlayerReliable[player] = bufferWriter.export()
end

function serverProcess.sendPlayerUnreliable(
	player: Player,
	id: number,
	writer: (value: any) -> (),
	data: { [string]: any }
)
	load(perPlayerUnreliable[player])

	alloc(1)
	u8(id)
	writer(data)

	perPlayerUnreliable[player] = bufferWriter.export()
end

function serverProcess.start()
	local reliableRemote = Instance.new("RemoteEvent")
	reliableRemote.Name = "ByteNetReliable"
	reliableRemote.OnServerEvent:Connect(onServerEvent)
	reliableRemote.Parent = ReplicatedStorage

	local unreliableRemote = Instance.new("UnreliableRemoteEvent")
	unreliableRemote.Name = "ByteNetUnreliable"
	unreliableRemote.OnServerEvent:Connect(onServerEvent)
	unreliableRemote.Parent = ReplicatedStorage

	for _, player in Players:GetPlayers() do
		playerAdded(player)
	end

	Players.PlayerAdded:Connect(playerAdded)

	RunService.Heartbeat:Connect(function()
		-- Check if the channel has anything before trying to send it
		if globalReliable.cursor > 0 then
			local b, r = dump(globalReliable)
			reliableRemote:FireAllClients(b, r)

			globalReliable.cursor = 0
			table.clear(globalReliable.references)
		end

		if globalUnreliable.cursor > 0 then
			local b, r = dump(globalUnreliable)
			unreliableRemote:FireAllClients(b, r)

			globalUnreliable.cursor = 0
			table.clear(globalUnreliable.references)
		end

		for _, player in Players:GetPlayers() do
			if perPlayerReliable[player].cursor > 0 then
				local b, r = dump(perPlayerReliable[player])
				reliableRemote:FireClient(player, b, r)

				perPlayerReliable[player].cursor = 0
				table.clear(perPlayerReliable[player].references)
			end

			if perPlayerUnreliable[player].cursor > 0 then
				local b, r = dump(perPlayerUnreliable[player])
				unreliableRemote:FireClient(player, b, r)

				perPlayerUnreliable[player].cursor = 0
				table.clear(perPlayerUnreliable[player].references)
			end
		end
	end)
end

return serverProcess
]]></ProtectedString>
									<string name="ScriptGuid">{C9DEF7EE-7090-48CF-AA38-F9040E57FA6E}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">server</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXF1949164400C4D3FA02EAFEE4413745D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">replicated</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX8D18047A760B400886D7EB84959D5B25">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

local replicatedValuePrototype = {}
local replicatedValueMetatable = { __index = replicatedValuePrototype }
export type replicatedValueType = typeof(setmetatable(
	{} :: {
		_luauData: {},
		_value: StringValue,
	},
	replicatedValueMetatable
))

function replicatedValuePrototype.write(self: replicatedValueType, value: {})
	assert(runContext == "server", "cannot write to replicatdvalue on client")

	self._luauData = value

	-- self._value.Value :(
	self._value.Value = HttpService:JSONEncode(value)
end

function replicatedValuePrototype.read(self: replicatedValueType)
	return self._luauData
end

return function(valueObject: StringValue): replicatedValueType
	local self = setmetatable({}, replicatedValueMetatable)

	self._luauData = {}
	self._value = valueObject

	-- important note: We freeze the table on the client to ensure that it never is modified
	-- We initialize _luauData as an empty table because on the server, we don't need to freeze it.
	if runContext == "client" then
		self._luauData = table.freeze(HttpService:JSONDecode(valueObject.Value))

		valueObject.Changed:Connect(function(value: string)
			if not value then
				return
			end

			self._luauData = table.freeze(HttpService:JSONDecode(value))
		end)
	end

	return self
end
]]></ProtectedString>
									<string name="ScriptGuid">{F6875F30-F87B-476C-9EB6-6FA9AC060AD7}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">replicatedValue</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX52C783B687364F5083945888E244E116">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local replicatedValue = require(script.Parent.replicatedValue)

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"
local valueFolder: Folder
local valueDictionary: {
	[string]: replicatedValue.replicatedValueType,
} = {}

local values = {}

function values.start()
	if runContext == "server" then
		local storage = Instance.new("Folder")
		storage.Name = "BytenetStorage"
		storage.Parent = ReplicatedStorage

		valueFolder = storage
	elseif runContext == "client" then
		valueFolder = ReplicatedStorage:WaitForChild("BytenetStorage")
	end
end

function values.access(name: string): replicatedValue.replicatedValueType
	-- caching
	if valueDictionary[name] then
		return valueDictionary[name]
	end

	if runContext == "client" then
		local potentialValueInstance = valueFolder:FindFirstChild(name)
		if potentialValueInstance and potentialValueInstance:IsA("StringValue") then
			-- set up the value and return it
			local value = replicatedValue(potentialValueInstance)

			valueDictionary[name] = value

			return value
		end
	elseif runContext == "server" then
		-- create the value and return it
		local newValueInstance = Instance.new("StringValue")
		newValueInstance.Name = name
		newValueInstance.Parent = valueFolder

		local value = replicatedValue(newValueInstance)

		valueDictionary[name] = value

		return value
	end

	return valueDictionary[name]
end

return values
]]></ProtectedString>
									<string name="ScriptGuid">{85A2C33A-7AFE-4226-AE36-87F543B7B622}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">values</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX84366D33F08D4CE199044D20DC0ACFD5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">BoxLight</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX4F80CB4683754D03981CEC54BAFF8E8E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "BoxLight",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 126364728447912,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @123wolfyking"},
		{Text = "Description: Area module for lightning client changes."},
		{Text = "Version: (latest)"},
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{ECC4ED58-7DE1-4294-9219-759C1CBAB746}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXADE6601B4F2A445DA03BA45000FDA5C2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[







--------------------
-- Example script --
--------------------

local boxLight = -- MODULE LOCATION
local lightingBox = boxLight.new(workspace:WaitForChild("Part"))

lightingBox:setLighting({
	["Ambient"] = Color3.new(1, 1, 1);
	["OutdoorAmbient"] = Color3.new(1, 1, 1);
	["GlobalShadows"] = false;
})

lightingBox:setFadeTime(0.5)

lightingBox:startListening()

----------------------------------------
-- Methods (Capitalization matters!) --
----------------------------------------

module.new() -- Create a new lightingBox.

module:updateDefaultLighting() -- Updates the default lighting defined in the module.

lightingBox:setFadeTime(number) -- Set how long it takes to fade between changing lighting for this box only.

lightingBox:startListening() -- Starts listening for camera entering or exiting the box.

lightingBox:stopListening() -- Stops what :startListening() does.

lightingBox:setLighting() -- Expects dictionary with the properties that need to change. (Having missing values wont change them in Lighting)

------------------------------------------------
-- All changeable values trough :setLighting()--
------------------------------------------------

Ambient,
Brightness,
ColorShift_Bottom,
ColorShift_Top,
EnvironmentDiffuseScale,
EnvironmentSpecularScale,
GlobalShadows,
OutdoorAmbient,
ShadowSoftness,

ClockTime,
GeographicLatitude,

ExposureCompensation,

FogColor,
FogEnd,
FogStart,

--]]

-- KINDA MESSY CODE BELOW BEWARE!

-- Services

local ts = game:GetService("TweenService")
local rs = game:GetService("RunService")
local lighting = game:GetService("Lighting")

-- Original Lighting

local ogLighting = {
	Ambient = lighting.Ambient;
	Brightness = lighting.Brightness;
	ColorShift_Bottom = lighting.ColorShift_Bottom;
	ColorShift_Top = lighting.ColorShift_Top;
	EnvironmentDiffuseScale = lighting.EnvironmentDiffuseScale;
	EnvironmentSpecularScale = lighting.EnvironmentSpecularScale;
	GlobalShadows = lighting.GlobalShadows;
	OutdoorAmbient = lighting.OutdoorAmbient;
	ShadowSoftness = lighting.ShadowSoftness;

	ClockTime = lighting.ClockTime;
	GeographicLatitude = lighting.GeographicLatitude;

	ExposureCompensation = lighting.ExposureCompensation;
	
	FogColor = lighting.FogColor;
	FogEnd = lighting.FogEnd;
	FogStart = lighting.FogStart;
}

-- Module Functions

local module = {}
module.__index = module

function module.new(realObject)
	local self = setmetatable({}, module)
	self.area = realObject

	local config = Instance.new("Configuration")
	config.Name = realObject.Name .. "_LightingArea_Config"
	config.Parent = realObject

	local lightingConfig = Instance.new("Configuration")
	lightingConfig.Name = "Lighting_Config"
	lightingConfig.Parent = config

	local fadeTime = Instance.new("NumberValue")
	fadeTime.Name = "FadeTime"
	fadeTime.Value = 1
	fadeTime.Parent = config

	local enteredAreaEvent = Instance.new("BindableEvent")
	self.EnteredArea = enteredAreaEvent.Event
	self._enteredAreaEvent = enteredAreaEvent

	local leftAreaEvent = Instance.new("BindableEvent")
	self.LeftArea = leftAreaEvent.Event
	self._leftAreaEvent = leftAreaEvent

	return self
end

function module:setLighting(lightingTable)
	local config = self.area:FindFirstChild(self.area.Name .. "_LightingArea_Config")
	if not config then
		error("LightingArea_Config not found on area.")
	end
	local lightingConfig = config:FindFirstChild("Lighting_Config")
	if not lightingConfig then
		error("Lighting_Config not found in config.")
	end

	for propertyName, propertyValue in pairs(lightingTable) do
		if lighting[propertyName] == nil then
			error(propertyName .. " is not a valid member of Lighting!")
		end
		if not ogLighting[propertyName] then
			error(propertyName .. " is not changeable via this module!")
		end
		if propertyValue == nil then
			error("Can't set property to nil!")
		end

		local valueInstance
		local valueType = typeof(propertyValue)
		if valueType == "Color3" then
			valueInstance = Instance.new("Color3Value")
		elseif valueType == "number" then
			valueInstance = Instance.new("NumberValue")
		elseif valueType == "boolean" then
			valueInstance = Instance.new("BoolValue")
		elseif valueType == "Enum" then
			error("Cannot change Enum values!")
		else
			error("Unsupported type for property " .. propertyName.."!")
		end

		valueInstance.Name = propertyName
		valueInstance.Value = propertyValue
		valueInstance.Parent = lightingConfig
	end
end

function module:setFadeTime(time)
	local config = self.area:FindFirstChild(self.area.Name .. "_LightingArea_Config")
	if not config then
		error("LightingArea_Config not found on area")
	end
	local fadeTime = config:FindFirstChild("FadeTime")
	if not fadeTime then
		error("FadeTime not found in config")
	end
	fadeTime.Value = time
end

function module:startListening()

	local config = self.area:FindFirstChild(self.area.Name .. "_LightingArea_Config")
	if not config then
		error("LightingArea_Config not found on area.")
		return
	end

	local lightingConfig = config:FindFirstChild("Lighting_Config")
	if not lightingConfig then
		error("Lighting_Config not found in config.")
		return
	end

	-- https://devforum.roblox.com/t/best-way-to-check-if-a-position-is-inside-of-a-part/2035849/4

	local function isPointInVolume(point: Vector3, volumeCenter: CFrame, volumeSize: Vector3): boolean
		local volumeSpacePoint = volumeCenter:PointToObjectSpace(point)
		return volumeSpacePoint.X >= -volumeSize.X/2
			and volumeSpacePoint.X <= volumeSize.X/2
			and volumeSpacePoint.Y >= -volumeSize.Y/2
			and volumeSpacePoint.Y <= volumeSize.Y/2
			and volumeSpacePoint.Z >= -volumeSize.Z/2
			and volumeSpacePoint.Z <= volumeSize.Z/2
	end

	local function isPointInPart(point: Vector3, part: BasePart): boolean
		return isPointInVolume(point, part.CFrame, part.Size)
	end

	--

	local inArea = false

	local prev = inArea

	self.areaConnection = rs.Heartbeat:Connect(function()
		if isPointInPart(workspace.CurrentCamera.CFrame.Position, self.area) == true then
			inArea = true
			if prev ~= inArea then

				self._enteredAreaEvent:Fire()

				for _, v in ipairs(lightingConfig:GetChildren()) do
					if v:IsA("NumberValue") or v:IsA("Color3Value")then
						local t = ts:Create(
							game.Lighting, 
							TweenInfo.new(config.FadeTime.Value, Enum.EasingStyle.Linear),
							{[v.Name] = v.Value})
						t:Play()
					else
						task.delay(config.FadeTime.Value/2, function()
							game.Lighting[v.Name] = v.Value
						end)
					end
				end
			end
			prev = inArea
		else
			inArea = false
			if prev ~= inArea then
				self._leftAreaEvent:Fire()

				for n, v in pairs(ogLighting) do
					if typeof(v) == "number" or typeof(v) == "Color3" then
						local t = ts:Create(
							game.Lighting, 
							TweenInfo.new(config.FadeTime.Value, Enum.EasingStyle.Linear),
							{[n] = v})
						t:Play()
					else
						task.delay(config.FadeTime.Value/2, function()
							game.Lighting[n] = v
						end)
					end
				end
			end
			prev = inArea
		end
	end)
end

function module:stopListening()
	if self.areaConnection then
		self.areaConnection:DisConnect()
	else
		error("Tried to stop listening while not listening!")
	end
end

function module:updateDefaultLighting()
	ogLighting = {
		Ambient = lighting.Ambient;
		Brightness = lighting.Brightness;
		ColorShift_Bottom = lighting.ColorShift_Bottom;
		ColorShift_Top = lighting.ColorShift_Top;
		EnvironmentDiffuseScale = lighting.EnvironmentDiffuseScale;
		EnvironmentSpecularScale = lighting.EnvironmentSpecularScale;
		GlobalShadows = lighting.GlobalShadows;
		OutdoorAmbient = lighting.OutdoorAmbient;
		ShadowSoftness = lighting.ShadowSoftness;

		ClockTime = lighting.ClockTime;
		GeographicLatitude = lighting.GeographicLatitude;

		ExposureCompensation = lighting.ExposureCompensation;
		
		FogColor = lighting.FogColor;
		FogEnd = lighting.FogEnd;
		FogStart = lighting.FogStart;
	}
end

return module

-- (Mostly) coded by 123wolfyking]]></ProtectedString>
							<string name="ScriptGuid">{CDB0D2E9-0810-45F0-A1AC-EC74E035A6F2}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">BoxLight</string>
							<int64 name="SourceAssetId">126364728447912</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX20BF2E4E10804DFA893785885CC39D81">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Entity</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB8235F263AEC4DE788A4792DC60C349E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "EntityManager",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	AssetId = 132767696512938,
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @Danielhoteaale"},
		{Text = "Description: EntityManager is a flexible module that allows you to create reusable entities from any instance while attaching components and properties that enhance their functionality. Entities act as data containers, while components provide methods and logic that can be accessed globally anywhere, anytime."},
		{Text = "Version: 2.0.1"},
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{7A50592C-94C4-408D-913A-F7A594E6B574}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX98191424B3464168A3E8363ACCCF7CFC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[
            
                     | |      | |           (_)                   | |                  
  _ __ ___   __ _  __| | ___  | |__  _   _   _  __ _ _ __ ___   __| | __ _ _ __  _   _ 
 | '_ ` _ \ / _` |/ _` |/ _ \ | '_ \| | | | | |/ _` | '_ ` _ \ / _` |/ _` | '_ \| | | |
 | | | | | | (_| | (_| |  __/ | |_) | |_| | | | (_| | | | | | | (_| | (_| | | | | |_| |
 |_| |_| |_|\__,_|\__,_|\___| |_.__/ \__, | |_|\__,_|_| |_| |_|\__,_|\__,_|_| |_|\__, |
                                      __/ |                                       __/ |
                                     |___/                                       |___/ 

--]]

-- Globals
local Annotations = require(script:FindFirstChild("Annotations"))
local Components = require(script:FindFirstChild("Components"))

local Signal = require(script:FindFirstChild("Signal"))

-- Main module
local Entity: Annotations.module = {}
Entity.__index = Entity

local cached = {}
local nextId = 0

-- Private variables/methods
local _getCached = function(key): Annotations.Entity 
	-- Private function implementation
	if type(key) == "number" then
		for _, entity in pairs(cached) do
			if entity.Id == key then
				return entity
			end
		end
	end
	
	if type(key) == "string" then
		if cached[key] then
			return cached[key]
		end
	end
	
	if type(key) == "userdata" and key:IsA("Instance") then
		for _, entity in pairs(cached) do
			if entity.Properties.Instance == key then
				return entity
			end
		end
	end
	
	return
end

-- Constructor
function Entity.new(id, name, properties): Annotations.Entity
	if _getCached(id) then error("attempt to create entity with duplicate id '" .. id .. "', expected a unique identifier") end
	if _getCached(name) then error("attempt to create entity with duplicate name '" .. name .. "', expected a unique identifier") end

	local self: Annotations.Entity = setmetatable({}, Entity)

	-- Public properties
	self.Id = id
	self.Name = name
	self.Active = true
	self.Properties = self:_wrapProperties(properties)
	
	-- Increment id
	if id == nextId then nextId += 1 end
	
	-- Public events
	self.OnInitialized = Signal.new()
	self.OnDestroyed = Signal.new()
	self.OnComponentAdded = Signal.new()
	self.OnComponentRemoved = Signal.new()
	self.OnPropertyChanged = Signal.new()

	-- Private properties
	self._createdAt = tick()
	self._components = {}
	self._private = {
		Id = id,
		Name = name
	}
	
	cached[name] = self
	return self
end

-- Get cached entities
function Entity:Get(key): Annotations.Entity
	return _getCached(key)
end

function Entity:GetCached(): {Annotations.Entity}
	return cached
end

function Entity:GetNextId(): number
	return nextId
end

-- Public methods
function Entity:Initialize(): Annotations.Entity
	-- Initialize default components
	self:_setupComponents()
	self.OnInitialized:Fire(self)
	
	return self
end

function Entity:Destroy()
	-- Default behavior
	self.Active = false
	cached[self.Name] = nil

	-- Clean up components
	for _, component in pairs(self._components) do
		if type(component.Destroy) == "function" then
			component:Destroy()
		end
	end
	
	self.OnDestroyed:Fire(self)

	-- Clear metatable to prevent further use
	setmetatable(self, nil)
end

function Entity:AddComponent(componentName, component): Annotations.Component
	-- Check if the component already exists
	if self._components[componentName] then
		error("Component '" .. componentName .. "' is already added to entity '" .. self.Name .. "'")
	end
	
	-- Clone component type if not provided
	if not component then
		component = {} :: Annotations.Component
	end

	local _initialize = component.Initialize
	local _destroy = component.Destroy

	function component:Initialize()
		if _initialize then _initialize(self, self.Entity) end
	end

	function component:Destroy()
		if _destroy then _destroy(self, self.Entity) end
		self.Entity.OnComponentRemoved:Fire(self.Entity, self)
		self.Entity._components[componentName] = nil
	end
	
	component.Entity = self
	self._components[componentName] = component
	
	-- Initialize the component
	component:Initialize()
	self.OnComponentAdded:Fire(self, component)
	
	return component
end

function Entity:GetComponent(componentName): Annotations.Component?
	return self._components[componentName]
end

-- Private methods
function Entity:_setupComponents()
	-- Initialize default components from components module under the script
	if self.Properties and self.Properties.Instance then
		Components:LoadDefault(self)
	end
end

function Entity:_wrapProperties(properties)
	local selfRef = self
	local proxy = {}
	local internal = properties or {}

	setmetatable(proxy, {
		__index = function(_, key)
			return internal[key]
		end,

		__newindex = function(_, key, value)
			local oldValue = internal[key]
			if oldValue ~= value then
				internal[key] = value
				selfRef.OnPropertyChanged:Fire(selfRef, key, value, oldValue)
			end
		end,

		__pairs = function()
			return pairs(internal)
		end,

		__len = function()
			return #internal
		end,
	})

	return proxy
end

-- Indexing/metatables
function Entity:__newindex(key, value)
	-- Check if it's a protected property first
	if key == "Id" or key == "Name" then
		return
	end
	rawset(self, key, value)
end

function Entity:__index(key, value)
	-- Check if it's a protected property first
	if key == "Id" or key == "Name" then
		return self._private[key]
	end
	return Entity[key]
end

-- Logging
local version = ""
if script:FindFirstChild("Version") and script:FindFirstChild("Version"):IsA("ValueBase") then version = " " .. script.Version.Value end
print("[entitymanager" .. version .. "] :: Loaded successfully.")

-- Return the module
return Entity
]]></ProtectedString>
							<string name="ScriptGuid">{7BEF0BB7-401E-442B-A6BE-7EDEAC71C404}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Entity</string>
							<int64 name="SourceAssetId">132767696512938</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX23E738296F9848C2ABEF0681389A063D">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Signal
type Signal<T...> = {
	Connect: (self: Signal<T...>, callback: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, callback: (T...) -> ()) -> Connection,
	Fire: (self: Signal<T...>, T...) -> (),
	Wait: (self: Signal<T...>) -> (T...),
	DisconnectAll: (self: Signal<T...>) -> (),
}

-- Module type export
export type module = {
	-- Public methods
	new: (id: number, name: string, properties: {
		[string]: any,
		Instance: Instance?
	}?) -> (Entity),
	Get: (self: module, key: number|string|Instance) -> (Entity),
	GetCached: (self: module) -> ({Entity}),
	GetNextId: (self: module) -> (number)
}

-- Class exports
export type Entity = {
	-- Public properties
	Id: number,
	Name: string,
	Active: boolean,
	Properties: {
		[string]: any,
		Instance: Instance?
	},

	-- Public methods
	Initialize: (self: Entity) -> (Entity),
	Destroy: (self: Entity) -> (),
	AddComponent: (self: Entity, componentName: string, component: {
		Initialize: ((self: Component) -> ())?,
		Destroy: ((self: Component) -> ())?
	}?) -> (Component),
	GetComponent: (self: Entity, componentName: string) -> (Component?),
	
	-- Events
	OnInitialized: Signal<Entity>,
	OnDestroyed: Signal<Entity>,
	OnComponentAdded: Signal<Entity, Annotations.Component>,
	OnComponentRemoved: Signal<Entity, Annotations.Component>,
	OnPropertyChanged: Signal<Entity, string, any, any>
}

export type Component = {
	[string]: any,
	Entity: Entity,
	
	Initialize: (self: Component) -> (),
	Destroy: (self: Component) -> ()
}

export type Loader = {
	TargetClassName: string?,
	Component: Component
}

-- Empty return
return {}
]]></ProtectedString>
								<string name="ScriptGuid">{1F2DD4A5-8E7A-43E1-ACD8-C1062300CB13}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Annotations</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX95578F4A6F05490E8028E023FF49F978">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Globals
local Annotations = require(script.Parent:FindFirstChild("Annotations"))

-- Main module
local Components = {}

-- Public methods
function Components:LoadDefault(entity: Annotations.Entity)
	-- Get all components under this module
	for _, module in ipairs(script:GetChildren()) do
		if not module:IsA("ModuleScript") then continue end

		-- Load the component
		local component: Annotations.Loader = require(module)
		if entity.Properties.Instance and component.TargetClassName == entity.Properties.Instance.ClassName then
			entity:AddComponent(module.Name, component.Component)
		end
	end
end

function Components:Load(entity: Annotations.Entity, componentName: string)
	-- Load a specific component
	if not (script:FindFirstChild(componentName) or script.Extras:FindFirstChild(componentName)) then error("failed to load component '" .. componentName .. "', component does not exist or has been moved") end
	
	local module = script:FindFirstChild(componentName) or script.Extras:FindFirstChild(componentName)
	if not module then
		error("failed to load component '" .. componentName .. "', component does not exist or has been moved")
	end

	local component: Annotations.Loader = require(module)
	local loaded
	if (component.TargetClassName and entity.Properties.Instance and entity.Properties.Instance.ClassName == component.TargetClassName) or not component.TargetClassName then
		loaded = entity:AddComponent(componentName, component.Component)
	else
		error("failed to load component '" .. componentName .. "', instance class mismatch")
	end
	
	return loaded :: Annotations.Component
end

return Components]]></ProtectedString>
								<string name="ScriptGuid">{F4F30E49-80D8-43ED-B905-3F5F43721965}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Components</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXEDF1F09130FE4D8FB405D6D400D960AA">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[-- Globals
local DataStoreService = game:GetService("DataStoreService")

local Annotations = require(script.Parent.Parent:FindFirstChild("Annotations"))
local Configuration = require(script.Configuration)

local dataStore = DataStoreService:GetDataStore(Configuration.DataStoreName)

local component: Annotations.Component = {
	Initialize = function(self)
		-- Entity reference
		local self: Annotations.Entity = self.Entity
		
		local folder = Instance.new("Folder", self.Properties.Instance)
		folder.Name = Configuration.Folder
		
		for name, data in pairs(Configuration.Currencies) do
			local currency = Instance.new(data.Base, folder)
			currency.Name = name

			if Configuration.SavingEnabled then
				local playerId = self.Properties.Instance.UserId
				local playerData = dataStore:GetAsync(playerId)
				if playerData then
					currency.Value = playerData[currency.Name]
				else
					currency.Value = data.Default
				end
			end
		end
	end,
	
	Destroy = function(self)
		-- Entity reference
		local self: Annotations.Entity = self.Entity
		
		if Configuration.SavingEnabled then
			local playerId = self.Properties.Instance.UserId

			local data = {}
			for _, stats in pairs(self.Properties.Instance:FindFirstChild(Configuration.Folder):GetChildren()) do
				data[stats.Name] = stats.Value
			end

			
			local success, message = pcall(function()
				dataStore:SetAsync(playerId, data)
			end)
			if not success then
				warn("Data for user", playerId, "could not be saved (" .. message .. ")")
			end
		end
	end,
	
	AddCoins = function(self, coins)
		-- Entity reference
		local self: Annotations.Entity = self.Entity
		
		self.Properties.Instance.leaderstats.Coins.Value += coins
	end,
	
	CanAfford = function(self, price)
		-- Entity reference
		local self: Annotations.Entity = self.Entity
		
		return self.Properties.Instance.leaderstats.Coins.Value >= price
	end
}

-- Export component class
export type Component = {
	[string]: any,
	Entity: Entity,

	Initialize: (self: Component) -> (),
	Destroy: (self: Component) -> (),
	AddCoins: (self: Component, coins: number) -> (),
	CanAfford: (self: Component, price: number) -> (boolean)
}

-- Main component
return {
	TargetClassName = "Player",
	Component = component
}
]]></ProtectedString>
									<string name="ScriptGuid">{0D0DBC5B-6C44-41F4-BCCF-F22D9244B434}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">MultiStats</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXD34B31A0739B4C00B4BF9044A5C13527">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[return {
	Folder = "leaderstats",
	
	Currencies = {
		Coins = {
			Base = "IntValue",
			Default = 0
		},
		Rank = {
			Base = "StringValue",
			Default = "Guest"
		}
	},
	
	DataStoreName = "data",
	SavingEnabled = true
}
]]></ProtectedString>
										<string name="ScriptGuid">{73ECCF97-BF80-4D12-AB5E-0FF96E865639}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Configuration</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Script" referent="RBX5810FFEC240440E5B3A98633A4E9B35A">
									<Properties>
										<ProtectedString name="Source"><![CDATA[--[[

Module: MultiStats
Author: iAmDany (@Danielhoteaale)

Description:
Simple leaderstats component with data saving functionality.


---------------
component:AddCoins(coins)
Description: This method adds a specific number of coins to the entity.

Arguments:
- coins (number): The number of coins to add to the player's total. This argument should be a positive integer value indicating how many coins should be added.

Returns:
- None: This method does not return any value. It simply performs the action of adding coins to the entity.

Notes:
- Ensure that the component is properly loaded on the entity before calling this method.


---------------
component:CanAfford(price)
Description: This method checks if the current number of coins for the entity is higher than the required number of coins to afford a given item.

Arguments:
- price (number): The number of coins that need to be within the entity's total balance.

Returns:
- canAfford (boolean): Whether the entity can afford the specified price.
	
]]
]]></ProtectedString>
										<bool name="Disabled">true</bool>
										<Content name="LinkedSource"><null></null></Content>
										<token name="RunContext">0</token>
										<string name="ScriptGuid">{876DE906-A6F8-4F6E-999B-95448A0058C6}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Documentation</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX0D9C9DB0EE7941CA9AD9CE7010635E4B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Extras</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Script" referent="RBX431E3B4C4485437DB9082EA340A6627B">
									<Properties>
										<ProtectedString name="Source"><![CDATA[--[[
            
                     | |      | |           (_)                   | |                  
  _ __ ___   __ _  __| | ___  | |__  _   _   _  __ _ _ __ ___   __| | __ _ _ __  _   _ 
 | '_ ` _ \ / _` |/ _` |/ _ \ | '_ \| | | | | |/ _` | '_ ` _ \ / _` |/ _` | '_ \| | | |
 | | | | | | (_| | (_| |  __/ | |_) | |_| | | | (_| | | | | | | (_| | (_| | | | | |_| |
 |_| |_| |_|\__,_|\__,_|\___| |_.__/ \__, | |_|\__,_|_| |_| |_|\__,_|\__,_|_| |_|\__, |
                                      __/ |                                       __/ |
                                     |___/                                       |___/ 

Place any additional components here that don't require automatic initialization by default for all components.
Any components placed here must be loaded manually using Components:Load(entity, componentName).

]]
]]></ProtectedString>
										<bool name="Disabled">true</bool>
										<Content name="LinkedSource"><null></null></Content>
										<token name="RunContext">0</token>
										<string name="ScriptGuid">{F9813F91-BE2D-4D50-9E78-D1F2998C9AAD}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Information</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="StringValue" referent="RBX3C01099D580E41E6914828D779E748F8">
							<Properties>
								<string name="Value">v2.0.1</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Version</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX4E762078A4C8415997A4F25ECDC00BC4">
							<Properties>
								<ProtectedString name="Source"><![CDATA[--[[
            
                     | |      | |           (_)                   | |                  
  _ __ ___   __ _  __| | ___  | |__  _   _   _  __ _ _ __ ___   __| | __ _ _ __  _   _ 
 | '_ ` _ \ / _` |/ _` |/ _ \ | '_ \| | | | | |/ _` | '_ ` _ \ / _` |/ _` | '_ \| | | |
 | | | | | | (_| | (_| |  __/ | |_) | |_| | | | (_| | | | | | | (_| | (_| | | | | |_| |
 |_| |_| |_|\__,_|\__,_|\___| |_.__/ \__, | |_|\__,_|_| |_| |_|\__,_|\__,_|_| |_|\__, |
                                      __/ |                                       __/ |
                                     |___/                                       |___/ 

Thanks for using EntityManager! If you need any assistance please reach out to me on the Developer Forum or the GitHub repository by creating an issue.
Step by step instructions on what this script does are found in the Developer Forum post, make sure to check it out!

--]]

-- Globals
local ServerScriptService = game:GetService("ServerScriptService")
local Players = game:GetService("Players")

-- Require necessary modules
local Entity = require(ServerScriptService.Entity)
local Components = require(ServerScriptService.Entity.Components)

local MultiStats = require(ServerScriptService.Entity.Components.MultiStats)

Players.PlayerAdded:Connect(function(player)
	-- Initialize the entity with latest id and player's identifier
	local entityManager = Entity.new(Entity:GetNextId(), player.Name)
	entityManager.Properties.Instance = player
	entityManager:Initialize()
	
	-- Load the pre-packed MultiStats component
	local component: MultiStats.Component = entityManager:GetComponent("MultiStats")
	component:AddCoins(100)
	
	-- Check if player can afford a 500 coins priced item
	print(component:CanAfford(500))
end)
]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{DA20EC4A-EF3A-4866-8D63-7BE3F5DBFF94}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Example</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Script" referent="RBX894A31C22EA843A9908BBD87B196CEB7">
							<Properties>
								<ProtectedString name="Source"><![CDATA[--[[
            
                     | |      | |           (_)                   | |                  
  _ __ ___   __ _  __| | ___  | |__  _   _   _  __ _ _ __ ___   __| | __ _ _ __  _   _ 
 | '_ ` _ \ / _` |/ _` |/ _ \ | '_ \| | | | | |/ _` | '_ ` _ \ / _` |/ _` | '_ \| | | |
 | | | | | | (_| | (_| |  __/ | |_) | |_| | | | (_| | | | | | | (_| | (_| | | | | |_| |
 |_| |_| |_|\__,_|\__,_|\___| |_.__/ \__, | |_|\__,_|_| |_| |_|\__,_|\__,_|_| |_|\__, |
                                      __/ |                                       __/ |
                                     |___/                                       |___/ 

Thanks for using EntityManager! If you need any assistance please reach out to me on the Developer Forum or the GitHub repository by creating an issue.
If you have any suggestions or questions, you can reach out to me!

Check the Developer Forum post on this resource for information on how to use it and how to set it up





MIT License

Copyright (c) 2025 iAmDany (@Danielhoteaale)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

]]
]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{83975D44-FAF5-4F1B-B2CD-9C4FD764253F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Information</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2F0632FA0183425AB7FB55C4F7DD6D66">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal
]]></ProtectedString>
								<string name="ScriptGuid">{5024C62F-B2A4-4EEF-9D06-0CB599B8B8C7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Signal</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC80829B76BFE4ED29B410725ACE21CC7">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Globals
local Entity = require(script.Parent)
local Annotations = require(script.Parent:FindFirstChild("Annotations"))

-- Main module
local Filters = {}

-- Result sets logic
local ResultSet = {}
ResultSet.__index = ResultSet

-- Constructor
function ResultSet.new(items)
	local self = setmetatable({}, ResultSet)
	self._items = items or {}
	return self
end

-- Chainable methods
function ResultSet:forEach(fn)
	for _, item in ipairs(self._items) do
		fn(item)
	end
	return self
end

function ResultSet:map(fn): {any}
	local mapped = {}
	for _, item in ipairs(self._items) do
		table.insert(mapped, fn(item))
	end
	return ResultSet.new(mapped)
end

-- Find all entities with a specific component
function Filters:WithComponent(componentName): {Annotations.Entity}
	local results = {}
	for _, entity in pairs(Entity:GetCached()) do
		if entity:GetComponent(componentName) then
			table.insert(results, entity)
		end
	end
	return ResultSet.new(results)
end

-- Find all entities matching a condition
function Filters:Filter(predicate): {Annotations.Entity}
	local results = {}
	for _, entity in pairs(Entity:GetCached()) do
		if predicate(entity) then
			table.insert(results, entity)
		end
	end
	return ResultSet.new(results)
end

return Filters
]]></ProtectedString>
								<string name="ScriptGuid">{2031A56F-4164-4290-9293-74C93481DCDC}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Filters</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXE646ACB2A3EF44A28AC1C112A3B20B82">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">RbxShader</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX2DC374FCF56E44D8AC5A7E3F9345A1CE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "RbxShader",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @seanjosep39"},
		{Text = "Description: NOTE: This program utilizes Robloxs EditableImage feature, which requires developer age and ID verification. The shader engine can run virtually any shader program that operates on a per-pixel basis, just like those on Shadertoy. Porting these programs are relatively easy due to their code structuring being similar. If you wish to test the abilities of this engine or understand how to write shader programs with this engine, you can use any of the give example shader programs provided, which are also ports of pre-existing shader programs in Shadertoy. If you have an eye for possible optimizations, or how the shader could be better in any way, please feel free to contribute as this project is open-source and is open for contribution."},
		{Text = "Version: 1.8.5 (191)"},
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{51DAC175-4E9C-49D9-A2D8-9C9024F5B479}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC333F3745997403A9DC08E9A079417D1">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[
--[[
	================== RbxShader ===================
	
	Last updated: 12/05/2025
	Version: 1.8.5 (191)
	
	Learn more about the engine via: https://github.com/AnotherSubatomo/RbxShader
	
	Copyright (c) 2024, AnotherSubatomo
	SPDX-License-Identifier: MIT
]]

--!native
--!nonstrict

-- // Types
local Types = require(script.utils.Common)
export type EngineConfiguration = Types.EngineConfiguration
export type ShaderBuffer = Types.ShaderBuffer
export type Shader = Types.Shader

-- // Dependencies
local STRegistry = game:GetService('SharedTableRegistry')
local Run = game:GetService('RunService')
local Culler = require(script.Culler)
local argue = require(script.utils.Argue)

local Client = game.Players.LocalPlayer
local Mouse = Client:GetMouse()

local function GuiIsAWorldspaceGui(Screen: BillboardGui | SurfaceGui): boolean
	return Screen:IsA('SurfaceGui') or Screen:IsA('BillboardGui')
end

-- // Defaults
local MOUSE_REF = '@Mouse'

local ERROR = {
	"Configs.ScreenDivision must be divisible by 4 for maximum performance." ,
	"Canvas size too big, it's subdivisions are greater than 1024 x 1024 (EditableImage dimension limit)." ,
	"CanvasSize was unspecified." ,
	"Invalid shader given." ,
	"Shaders can't be ran on the server-side. I mean, just why?" ,
	"A ShaderID is necessary in manipulating specific shaders that run on the same script." ,
	"ShaderID has already been used." ,
	"Given ShaderID to fetch shader is not in use, are you sure it's typed correctly?" ,
	"Canvas size too small, minimum size is 4 x 4." ,
	"Given screen to display the shader in was invalid."
}

local DEFAULT_CONFIGURATIONS = {
	InterlaceFactor = 2 ,
	DualAxisInterlacing = true ,
	ScreenDivision = 16 ,
	IsBlurred = false ,
	OriginOffset = Vector2.yAxis, --> by OpenGL convention
	CountDirection = Vector2.new(1, -1) --> by OpenGL convention
} :: EngineConfiguration

argue( Run:IsClient() , ERROR[5] )

local MoveConnections = {}
local ShaderPrograms = {}
local RbxShader = {}

-- /* Create the environment for running the shader. */
function RbxShader.new(
	ShaderID : string ,
	Shader : ModuleScript ,
	Configuration : EngineConfiguration ,
	Host : Script ,
	Screen : GuiBase2d ,
	CanvasSize : Vector2
)
	-- /* Set default values */
	local BuiltConfiguration = require(Shader).CONFIGURATION
	Configuration = if type(Configuration) ~= "table" then {} else Configuration
	
	for Field : string , Default : any in DEFAULT_CONFIGURATIONS do
		Configuration[Field] = Configuration[Field] or BuiltConfiguration[Field] or Default
	end
	
	-- /* Screen can only be divided into multiples-of-4 parts */
	argue( Configuration.ScreenDivision % 4 == 0 , ERROR[1] )
	argue( CanvasSize , ERROR[3] )
	argue( typeof(Shader) == 'Instance' and Shader:IsA('ModuleScript') , ERROR[4] )
	argue( CanvasSize:Min(Vector2.one*4) == Vector2.one*4 , ERROR[9] )
	
	-- /* Calculate the dimensions of each subdivisions */
	local Subdivisions = Vector2.new(Configuration.ScreenDivision / 4, 4)
	local SubcanvasSize = (CanvasSize / Subdivisions):Floor()
	local ExcessSize = CanvasSize - SubcanvasSize * Subdivisions
	
	argue( SubcanvasSize:Max((Vector2.one*1025)) == Vector2.one*1025 , ERROR[2] )
	
	-- /* Create the screen from where we'll drawn on */
	argue( Screen and Screen:IsA('GuiBase2d') , ERROR[10] )
	Screen.Name = 'SHADERSCREEN@'..Shader.Name
	
	local Background = Instance.new('Frame')
	Background.Parent = Screen
	Background.Size = UDim2.fromScale(1, 1)
	Background.BackgroundColor3 = Color3.new()
	Background.Name = 'Background'
	
	local Centerer = Instance.new('UIListLayout')
	Centerer.Parent = Background
	Centerer.HorizontalAlignment = 'Center'
	Centerer.VerticalAlignment = 'Center'

	local Easel = Instance.new('ImageButton')
	Easel.Parent = Background
	Easel.Size = UDim2.fromScale(1, 1)
	Easel.BackgroundTransparency = 1
	Easel.Name = 'Easel'
	Easel.Image = ''
	
	local AspectRatio = Instance.new('UIAspectRatioConstraint')
	AspectRatio.Parent = Easel
	AspectRatio.AspectRatio = CanvasSize.X / CanvasSize.Y

	-- /* Create shader host. */
	argue( ShaderID, ERROR[6] )
	argue( not ShaderPrograms[ShaderID] , ERROR[7] )

	local Parent = Instance.new('Folder')
	Parent.Parent = Host
	Parent.Name = 'SHADER@'..ShaderID
	ShaderPrograms[ShaderID] = Parent
	
	local Link = Instance.new('ObjectValue')
	Link.Parent = Parent
	Link.Value = Screen
	Link.Name = 'ScreenLink'
	
	-- /* Assume inputs are needed */
	local iMouse = SharedTable.new({ X = 1, Y = 1 })
	
	Easel.MouseButton1Down:Connect( function ()
		-- # Only consider input when mouse is at the display of the shader.
		MoveConnections[ShaderID] = Mouse.Move:Connect( function ()
			local vs = workspace.CurrentCamera.ViewportSize		--@ viewport pixel size
			local eas = Easel.AbsoluteSize						--@ easel absolute pixel size
			local e = vs - eas									--@ excess viewport space
			local mp = Vector2.new(
				Mouse.X + Easel.AbsolutePosition.X,
				Mouse.Y + 48 + e.Y / 2
			)
			local rmp = mp - e									--@ relative mouse position (to easel)
			
			local Position = (rmp / eas * CanvasSize):Ceil()	--@ mouse position relative to canvas size

			SharedTable.update( iMouse, 'X', function()
				return Position.X
			end)
			SharedTable.update( iMouse, 'Y', function()
				return Position.Y
			end)
		end)
	end)

	local function DisconnectMoveConnection()
		if MoveConnections[ShaderID] ~= nil then
			MoveConnections[ShaderID]:Disconnect()
		end
	end
	
	Easel.MouseButton1Up:Connect(DisconnectMoveConnection)
	Easel.MouseLeave:Connect(DisconnectMoveConnection)
	
	STRegistry:SetSharedTable(ShaderID..MOUSE_REF, iMouse)
	
	-- /* Parallelize canvas calculations */
	local Workers : {Actor} = {}
	
	-- # Create worker threads
	for _ = 1, Configuration.ScreenDivision do
		local Actor = Instance.new('Actor')
		script.Worker:Clone().Parent = Actor
		table.insert(Workers, Actor)
	end
	
	script.Worker:Destroy()
	
	-- # Parent all actors under self
	for _, Actor : Actor in Workers do
		Actor.Parent = Parent
	end
	
	task.defer( function ()
		-- /* Set environment context */
		for y = 1, Subdivisions.Y do
			for x = 1, Subdivisions.X do
				local Actor = Workers[y+4*(x-1)]
				local CanvasCoords = Vector2.new(x, y)
				Actor:SendMessage('SetContext', ShaderID, Shader, CanvasSize, CanvasCoords, Configuration)
			end
		end

		-- /* Create the subcanvases */
		for y = 1, Subdivisions.Y do
			for x = 1, Subdivisions.X do
				local Actor = Workers[y+4*(x-1)]
				Actor.Worker.Name = 'Worker@'..y+4*(x-1)

				local Size : Vector2 = SubcanvasSize
				if y == Subdivisions.Y then Size += Vector2.new(0, ExcessSize.Y) end
				if x == Subdivisions.X then Size += Vector2.new(ExcessSize.X, 0) end

				local Scale : Vector2 = Size / CanvasSize
				Actor:SendMessage('MakeCanvas', Easel, Scale, Size)
			end
		end
	end)
	
	-- /* Put culler into action (if `Screen` is a SurfaceGui or BillboardGui) */
	-- * Runs the program if the part that the Gui is adorned to is still visible
	--	 on the user viewport or is within the max distance, pauses it if not.
	
	local WorldspaceGui = GuiIsAWorldspaceGui(Screen) and Screen
		or Screen:FindFirstChildOfClass('SurfaceGui') or Screen:FindFirstChildOfClass('BillboardGui')
	
	if WorldspaceGui then
		Culler.add(WorldspaceGui, ShaderID, function ()
			for _, Actor : Actor in Workers do
				Actor:SendMessage( 'Resume' , ShaderID )
			end
		end, function ()
			for _, Actor : Actor in Workers do
				Actor:SendMessage( 'Pause' , ShaderID )
			end
		end)
	end
end

--==============================
--[=[ SHADER PROGRAM ACTIONS ]=]
--==============================

local function GetWorkers ( Engine : LocalScript )
	local Workers = {}

	for _, Child : Instance in Engine:GetChildren() do
		if Child:IsA('Actor') then
			table.insert(Workers, Child)
		end
	end

	return Workers
end

local function CallAction( Action : string , ShaderID : string )
	argue( ShaderID, ERROR[6] )
	argue( ShaderPrograms[ShaderID], ERROR[8] )

	local Workers = GetWorkers( ShaderPrograms[ShaderID] )
	
	task.defer( function ()
		for _, Actor : Actor in Workers do
			Actor:SendMessage( Action )
		end
	end)
end

-- /* Halts a shader from running. */
function RbxShader.stop( ShaderID : string )
	CallAction( 'Stop', ShaderID )
end

-- /* Runs a shader. (Not a resume function) */
function RbxShader.run( ShaderID : string )
	CallAction( 'Run' , ShaderID )
end

-- /* Pauses the shader. */
function RbxShader.pause( ShaderID : string )
	CallAction( 'Pause', ShaderID )
end

-- /* Resumes the shader. */
function RbxShader.resume( ShaderID : string )
	CallAction( 'Resume', ShaderID )
end

-- /* Halts and terminates a shader program. */
function RbxShader.clear( ShaderID : string )
	argue( ShaderID, ERROR[6] )
	argue( ShaderPrograms[ShaderID], ERROR[8] )

	local Host = ShaderPrograms[ShaderID]
	local Screen = Host.ScreenLink.Value
	local Workers = GetWorkers( Host )

	for _, Actor : Actor in Workers do
		Actor:SendMessage( 'Stop' )
	end
	
	if GuiIsAWorldspaceGui(Screen) then
		Culler.remove(ShaderID)
	end
	
	STRegistry:SetSharedTable(ShaderID..MOUSE_REF, nil)
	Screen:Destroy()
	Host:ClearAllChildren()
	Host:Destroy()
end

-- /* Sets the configuration of the shader to something else. */
function RbxShader.set(
	ShaderID : string ,
	Configuration : EngineConfiguration
)
	argue( ShaderID, ERROR[6] )
	argue( ShaderPrograms[ShaderID], ERROR[8] )
	
	local Workers = GetWorkers( ShaderPrograms[ShaderID] )
	
	for Field : string , Default : any in DEFAULT_CONFIGURATIONS do
		Configuration[Field] = Configuration[Field] or Default
	end
	
	RbxShader.pause( ShaderID )
	
	for _, Actor : Actor in Workers do
		Actor:SendMessage( 'Set' , Configuration )
	end

	RbxShader.resume( ShaderID )
end



--================================
--[=[ SHADER UTILITY LIBRARIES ]=]
--================================

-- /* Retrieve the graphics-specific math library. */
function RbxShader:GetMathLib()
	return require(script.GraphicsMathLib)
end

return RbxShader]]></ProtectedString>
							<string name="ScriptGuid">{003FB9D1-3D8B-473D-8E34-C8E3432697A9}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">RbxShader</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXA931A3C299AA4CC8A532F903A3AB107B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[
--[=[
	GraphicsMathLib
	Reimplementation of commonly used
	GLSL functions in Luau.
	
	NOTE:
	- Reimplementation is incomplete
	- Do not implement function swizzling
	  just like what GLSL did, as Luau
	  is not powerful enough to do that
]=]

--!native

local MathLib = {}

function MathLib.fract_v3 ( v : Vector3 )
	return Vector3.new(
		v.X - math.floor(v.X) ,
		v.Y - math.floor(v.Y) ,
		v.Z - math.floor(v.Z)
	)
end

function MathLib.fract_v2 ( v : Vector2 )
	return Vector2.new(
		v.X - math.floor(v.X) ,
		v.Y - math.floor(v.Y)
	)
end

function MathLib.fract ( x : number )
	return x - math.floor(x)
end

function MathLib.smoothstep ( edge0 : number , edge1 : number , x : number )
	local t = math.clamp((x - edge0) / (edge1 - edge0), 0, 1);
	return t * t * (3 - 2 * t);
end

function MathLib.clamp_v3 ( v : Vector3 , min : number , max : number )
	return Vector3.new(
		math.clamp(v.X, min, max),
		math.clamp(v.Y, min, max),
		math.clamp(v.Z, min, max)
	)
end

function MathLib.clamp_v2 ( v : Vector2 , min : number , max : number )
	return Vector2.new(
		math.clamp(v.X, min, max),
		math.clamp(v.Y, min, max)
	)
end

function MathLib.sqrt_v3 ( v : Vector3 )
	return Vector3.new(
		math.sqrt(v.X) ,
		math.sqrt(v.Y) ,
		math.sqrt(v.Z)
	)
end

function MathLib.sqrt_v2 ( v : Vector2 )
	return Vector2.new(
		math.sqrt(v.X) ,
		math.sqrt(v.Y)
	)
end

function MathLib.sin_v3 ( v : Vector3 )
	return Vector3.new(
		math.sin(v.X) ,
		math.sin(v.Y) ,
		math.sin(v.Z)
	)
end

function MathLib.sin_v2 ( v : Vector2 )
	return Vector2.new(
		math.sin(v.X) ,
		math.sin(v.Y)
	)
end

function MathLib.cos_v3 ( v : Vector3 )
	return Vector3.new(
		math.cos(v.X) ,
		math.cos(v.Y) ,
		math.cos(v.Z)
	)
end

function MathLib.cos_v2 ( v : Vector2 )
	return Vector2.new(
		math.cos(v.X) ,
		math.cos(v.Y)
	)
end

function MathLib.yzx ( v : Vector3 )
	return Vector3.new(v.Y, v.Z, v.X)
end

function MathLib.zxy ( v : Vector3 )
	return Vector3.new(v.Z, v.X, v.Y)
end

function MathLib.xz ( v : Vector3 )
	return Vector2.new(v.X, v.Z)
end

function MathLib.yx ( v : Vector2 | Vector3 )
	return Vector2.new(v.Y, v.X)
end

function MathLib.step ( edge : number , x : number )
	return x < edge and 0 or 1
end

function MathLib.step_v3 ( edge : Vector3 , x : Vector3 )
	return Vector3.new(
		MathLib.step( edge.X , x.X ) ,
		MathLib.step( edge.Y , x.Y ) ,
		MathLib.step( edge.Z , x.Z )
	)
end

function MathLib.step_v2 ( edge : Vector2 , x : Vector2 )
	return Vector2.new(
		MathLib.step( edge.X , x.X ) ,
		MathLib.step( edge.Y , x.Y )
	)
end

-- // Basically lerp
function MathLib.mix_v3 ( x : Vector3 , y : Vector3 , a : number )
	return x:Lerp(y,a)
end

function MathLib.mix_v2 ( x : Vector2 , y : Vector2 , a : number )
	return x:Lerp(y,a)
end
function MathLib.mix ( x : number , y : number , a : number )
	return x + (y - x) * a
end

function MathLib.mod_v3 ( x : Vector3 , y : Vector3 )
	return Vector3.new(
		x.X % y.X ,
		x.Y % y.Y ,
		x.Z % y.Z
	)
end

function MathLib.mod_v2 ( x : Vector2 , y : Vector2 )
	return Vector2.new(
		x.X % y.X ,
		x.Y % y.Y
	)
end

function MathLib.reflect ( i : Vector3 , n : Vector3 )
	return i - 2 * n:Dot(i) * n
end

function MathLib.exp_v3 ( v : Vector3 )
	return Vector3.new(
		math.exp(v.X) ,
		math.exp(v.Y) ,
		math.exp(v.Z)
	)
end

function MathLib.exp_v2 ( v : Vector2 )
	return Vector2.new(
		math.exp(v.X) ,
		math.exp(v.Y)
	)
end

function MathLib.pow_v3 ( v : Vector3 , vp : Vector3 )
	return Vector3.new(
		math.pow(v.X, vp.X) ,
		math.pow(v.Y, vp.Y) ,
		math.pow(v.Z, vp.Z)
	)
end

function MathLib.pow_v2 ( v : Vector2 , vp : Vector3 )
	return Vector2.new(
		math.pow(v.X, vp.X) ,
		math.pow(v.Y, vp.Y)
	)
end

--[=[=======================
	/* NON-GLSL FUNCTIONS */
--========================]=]
function MathLib.v3_rgb ( v : Vector3 )
	return v.X, v.Y, v.Z
end

function MathLib.c3_rgb ( c : Color3 )
	return c.R, c.G, c.B
end

function MathLib.v3_rgba ( v : Vector3 , alpha : number? )
	return v.X, v.Y, v.Z, alpha
end

function MathLib.c3_rgba ( c : Color3 , alpha : number? )
	return c.R, c.G, c.B, alpha
end

function MathLib.c3 ( a : Color3 | Vector3 )
	return typeof(a) == 'Color3' and a or Color3.new( a.X, a.Y, a.Z )
end

for operation : string, func : () -> any in math do
	MathLib[operation] = func
end

MathLib.Vector4 = require(script.Parent.Vector4)

return MathLib]]></ProtectedString>
								<string name="ScriptGuid">{0B465419-CA38-40E8-BEC0-BD2739F52AAB}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GraphicsMathLib</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="LocalScript" referent="RBX4816658AED8A4809AE39F684897B250A">
							<Properties>
								<ProtectedString name="Source"><![CDATA[
--[=[
	Worker
	Multithreaded script responsible for rendering
	a dictated portion of the canvas.
]=]

--!native

-- // Dependencies
local Run = game:GetService('RunService')
local Actor = script:GetActor()

local root = game.ReplicatedStorage:WaitForChild('RbxShader')
local FastCanvas = require(root.Canvas)
local argue = require(root.utils.Argue):at('runtime')

local STRegistry = game:GetService('SharedTableRegistry')

local ERROR = {
	'Shader never had a `mainImage` function.' ,
	'Different shader buffers cannot not share the same letter.'
}

-- * Every type changes will have to be manually synced, unfortunately
local Types = require(root.utils.Common)
type ShaderBuffer = Types.ShaderBuffer
type Shader = Types.Shader
type EngineConfiguration = Types.EngineConfiguration
type FastCanvas = FastCanvas.Canvas

----------------------------------------------------------------------------------

local ShaderID : string = nil
local Shader : Shader = nil
local iResolution : Vector2 = nil
local CanvasCoords : Vector2 = nil
local Configuration : EngineConfiguration = nil

Actor:BindToMessage( 'SetContext' , function (
	__ShaderID : string ,
	__Shader : ModuleScript ,
	__iResolution : Vector2 ,
	__CanvasCoords : Vector2 ,
	__Configuration : EngineConfiguration
)
	ShaderID = __ShaderID
	Shader = require(__Shader)
	iResolution = __iResolution
	CanvasCoords = __CanvasCoords
	Configuration = __Configuration
end)

----------------------------------------------------------------------------------

local Canvas : FastCanvas = nil

Actor:BindToMessage( 'MakeCanvas' , function (
	Easel : Frame ,
	EaselSize : Vector2 ,
	CanvasSize : Vector2
)
	local Subeasel = Instance.new('Frame')
	Subeasel.Parent = Easel
	Subeasel.Size = UDim2.fromScale( EaselSize.X , EaselSize.Y )
	Subeasel.Position = UDim2.fromScale( EaselSize.X * (CanvasCoords.X-1) , EaselSize.Y * (CanvasCoords.Y-1) )
	Subeasel.BackgroundTransparency = 1

	Canvas = FastCanvas.new(Subeasel, CanvasSize, Configuration.IsBlurred)
	-- Initialize the image buffer to the given initial color and alpha
	Canvas:Fill(Configuration.InitialColor, Configuration.InitialAlpha)
	-- Initialize the VPM buffer to the given origin, offset, and counting direction
	local VirtualOrigin = Configuration.OriginOffset * iResolution
	local RelativeOffset = Canvas.Resolution * (CanvasCoords - Vector2.one)
	local CountDirection = Configuration.CountDirection
	Canvas:RecalculateVirtualPixelMapping(VirtualOrigin, RelativeOffset, CountDirection)
end)

----------------------------------------------------------------------------------

Actor:BindToMessage( 'Set' , function (
	NewConfiguration : EngineConfiguration
)
	-- # Do necessary updates
	-- @ Update resample mode
	if NewConfiguration.IsBlurred ~= Configuration.IsBlurred then
		local Resampler = Enum.ResamplerMode
		Canvas.__Easel.ResampleMode = NewConfiguration.IsBlurred and Resampler.Default or Resampler.Pixelated
	end
	-- @ Update pixel coordinate mapping
	if NewConfiguration.OriginOffset ~= Configuration.OriginOffset or
	NewConfiguration.CountDirection ~= Configuration.CountDirection then
		local VirtualOrigin = NewConfiguration.OriginOffset * iResolution
		local RelativeOffset = Canvas.Resolution * (CanvasCoords - Vector2.one)
		local CountDirection = NewConfiguration.CountDirection
		Canvas:RecalculateVirtualPixelMapping(VirtualOrigin, RelativeOffset, CountDirection)
	end
	Configuration = NewConfiguration
end)

----------------------------------------------------------------------------------

local RenderConnection : RBXScriptConnection = nil

-- # using os.clock() is smoother than os.time(), pretty sick
local oTime = os.clock()
local pTime = 0

-- /* Program runtime getter */
local function iTime()
	return os.clock() - oTime
end

-- /* Date getter */
local function iDate()
	local gt = os.date("%Y|%m|%d|%X"):split('|')
	local t = gt[4]:split(':')
	gt[4] = t[1] * 3600 + t[2] * 60 + t[3] + select(2, math.modf(os.clock()))

	for k, v in gt do
		gt[k] = tonumber(v)
	end

	return gt
end

-- /* Program runner */
local function RunProgram()
	-- # Fundamental variables
	local Buffers = {} --> collection of shader buffers
	local iMouse = STRegistry:GetSharedTable(ShaderID..'@Mouse') --> mouse position
	local InterlaceFactor = Configuration.InterlaceFactor
	local DualAxisInterlacing = Configuration.DualAxisInterlacing

	-- # Buffer implementation
	for Step : string , Buffer : ShaderBuffer in Shader do
		if type(Step) ~= "string" or Step:sub(1, 6) ~= 'buffer' then continue end
		local Order = Step:sub(7, 7):upper():byte() - 64
		argue( Buffers[Order] , ERROR[2] )
		Buffers[Order] = Buffer
	end

	-- Buffer sequence re-ordering
	-- * because some people may have accidentally skipped some letters
	local ReorderedBuffers = {}
	for _ : number , Buffer : ShaderBuffer in Buffers do
		table.insert(ReorderedBuffers, Buffer)
	end

	Buffers = ReorderedBuffers

	argue( Shader.mainImage , ERROR[1] )
	table.insert(Buffers, Shader.mainImage)

	-- # Interlacer implementation
	local Step = 1
	local StepX, StepY = 1, 1

	-- # Render functions
	-- @ with dual-axis interlacing
	local function DUIRendering ( iTimeDelta : number )

		if StepX > InterlaceFactor then StepX = 1; StepY += 1 end
		if StepY > InterlaceFactor then StepY = 1 end
		local iTime = iTime()
		local iDate = iDate()

		for __ , ShaderBuffer: ShaderBuffer in Buffers do
			for y = StepY , Canvas.Resolution.Y, InterlaceFactor do
				for x = StepX, Canvas.Resolution.X, InterlaceFactor do
					local fragColor = Vector3.new(Canvas:GetRGB(x, y))
					local fragCoords = Vector2.new(Canvas:GetVirtualPosition(x, y))

					Canvas:SetRGBA(x, y,
						ShaderBuffer(
							fragColor,
							fragCoords,
							iTime,
							iTimeDelta,
							iResolution,
							iMouse,
							iDate
						)
					)
				end
			end
		end

		task.synchronize()
		
		Canvas:Render()
		StepX += 1
	end

	-- @ without dual-axis interlacing
	local function UUIRendering ( iTimeDelta : number )

		if Step > InterlaceFactor then Step = 1 end
		local iTime = iTime()
		local iDate = iDate()

		for __ , ShaderBuffer: ShaderBuffer in Buffers do
			for y = Step , Canvas.Resolution.Y, InterlaceFactor do
				for x = 1, Canvas.Resolution.X do
					local fragColor = Vector3.new(Canvas:GetRGB(x, y))
					local fragCoords = Vector2.new(Canvas:GetVirtualPosition(x, y))

					Canvas:SetRGBA(x, y,
						ShaderBuffer(
							fragColor,
							fragCoords,
							iTime,
							iTimeDelta,
							iResolution,
							iMouse,
							iDate
						)
					)
				end
			end
		end

		task.synchronize()

		Canvas:Render()
		Step += 1
	end

	-- /* Rendering */
	local Renderer = DualAxisInterlacing and DUIRendering or UUIRendering

	task.synchronize()

	RenderConnection = Run.PreRender:ConnectParallel(Renderer)
end

----------------------------------------------------------------------------------

Actor:BindToMessageParallel( 'Run' , function ()
	-- /* Reset runtime. */
	oTime = os.clock()
	RunProgram()
end)

----------------------------------------------------------------------------------

Actor:BindToMessage( 'Pause' , function()
	pTime = iTime()
	if RenderConnection ~= nil then
		RenderConnection:Disconnect()
	end
end)

----------------------------------------------------------------------------------

Actor:BindToMessageParallel( 'Resume' , function()
	oTime += iTime() - pTime
	RunProgram()
end)

----------------------------------------------------------------------------------

Actor:BindToMessage( 'Stop' , function ()
	if RenderConnection ~= nil then
		RenderConnection:Disconnect()
	end
end)]]></ProtectedString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{F436DF48-3E71-4F8A-9C6E-03A73D8CFDF0}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Worker</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX75E6B93304BC4321B666DC3660389DC4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[
--[=[
	Culler
	While it doesn't necessarily "cull", it optimizes
	Billboard and Surface GUIs that have scripts connected
	to them by providing an interface that allows their
	scripts to stop whenever they are out of sight.

	Author: AnotherSubatomo (GitHub)
	SPDX-License-Identifier: MIT
]=]

--!native

type CullInfo = {
	UI : SurfaceGui | BillboardGui ,
	OnRender : () -> any ,
	OnUnrender : () -> any ,
	Rendered : boolean
}

local Run = game:GetService('RunService')
local Camera = workspace.CurrentCamera

local CullInfoMap : { [string] : CullInfo } = {}
local Culler = {}

-- /* Adds a GUI to the bucket of GUI's
--	  that will be decisively culled. */
function Culler.add(
	GUI : BillboardGui | SurfaceGui ,
	UID : string ,
	RenderCallback : () -> any ,
	UnrenderCallback : () -> any
)
	CullInfoMap[UID] = {
		UI = GUI;
		OnRender = RenderCallback;
		OnUnrender = UnrenderCallback;
		Rendered = true;
	}
end

-- /* Removes a GUI from the bucket. */
function Culler.remove( UID : string )
	local CullInfo = CullInfoMap[UID]
	table.clear(CullInfo)
	CullInfoMap[UID] = nil
end


-- /* Decides whether the GUI should be culled or not. */
local function ShouldRender( Should : boolean , CullInfo : CullInfo )
	-- # Will not cull or render if it is already rendered or culled.
	if Should and not CullInfo.Rendered then
		CullInfo.OnRender()
		CullInfo.Rendered = true
	elseif not Should and CullInfo.Rendered then
		CullInfo.OnUnrender()
		CullInfo.Rendered = false
	end
end

-- /* Cull loop */
Run.Heartbeat:Connect( function ()
	for _ , CullInfo : CullInfo in CullInfoMap do
		local UI = CullInfo.UI
		local Adornee = UI.Adornee
		local MaxDistance = UI.MaxDistance

		if not Adornee and UI:IsA('SurfaceGui') then
			Adornee = UI.Parent:IsA('BasePart') and UI.Parent or nil
		end

		if Adornee == nil then return end
		
		local _, IsOnScreen = workspace.CurrentCamera:WorldToViewportPoint(Adornee.Position)
		local Distance = (Camera.CFrame.Position - (Adornee :: BasePart).Position).Magnitude
		ShouldRender(IsOnScreen and Distance < MaxDistance, CullInfo)
	end
end)

assert( Run:IsClient() )
return Culler]]></ProtectedString>
								<string name="ScriptGuid">{B402C721-CC41-4903-AC39-05346225476F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Culler</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX489F3184B18E45E4864F851C19316E84">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[
--[=[
	Vector4
	Partial implementation of the
	`vec4` data type in GLSL.
]=]

--!native

local cos = math.cos
local sin = math.sin

local Vector4 = {}

function Vector4.new(
	x : number , y : number ,
	z : number , w : number
)
	local vec4 = { X = x , Y = y , Z = z , W = w }

	function vec4:Cos()
		return Vector4.new(
			cos(self.X) ,
			cos(self.Y) ,
			cos(self.Z) ,
			cos(self.W)
		)
	end

	function vec4:Sin()
		return Vector4.new(
			sin(self.X) ,
			sin(self.Y) ,
			sin(self.Z) ,
			sin(self.W)
		)
	end

	function vec4:Lerp( b : Vector4 , t : number )
		return Vector4.new(
			self.X + ( b.X - self.X ) * t ,
			self.Y + ( b.Y - self.Y ) * t ,
			self.Z + ( b.Z - self.Z ) * t ,
			self.W + ( b.W - self.W ) * t
		)
	end

	local function IsAVector4( p : {} )
		return type(p) == 'table' and p.X and p.Y and p.Z and p.W
	end

	setmetatable(vec4, {
		__add = function( a , b )
			return Vector4.new(
				a.X + b.X ,
				a.Y + b.Y ,
				a.Z + b.Z ,
				a.W + b.W
			)
		end,

		__sub = function( a , b )
			return Vector4.new(
				a.X - b.X ,
				a.Y - b.Y ,
				a.Z - b.Z ,
				a.W - b.W
			)
		end,

		__mul = function ( a , b )
			if not IsAVector4(a) then
				a, b = b, a
			end

			if IsAVector4(b) then
				return Vector4.new(
					a.X * b.X ,
					a.Y * b.Y ,
					a.Z * b.Z ,
					a.W * b.W
				)
			else
				return Vector4.new(
					a.X * b ,
					a.Y * b ,
					a.Z * b ,
					a.W * b
				)
			end
		end,

		__div = function ( a , b )
			if not IsAVector4(a) then
				a, b = b, a
			end

			if IsAVector4(b) then
				return Vector4.new(
					a.X / b.X ,
					a.Y / b.Y ,
					a.Z / b.Z ,
					a.W / b.W
				)
			else
				return Vector4.new(
					a.X / b ,
					a.Y / b ,
					a.Z / b ,
					a.W / b
				)
			end
		end,
	})

	return vec4
end

setmetatable(Vector4, {
	__index = function( self , index )
		if index == 'one' then
			return Vector4.new(1, 1, 1, 1)
		elseif index == 'zero' then
			return Vector4.new(0, 0, 0, 0)
		end
	end,
})

export type Vector4 = typeof(Vector4)

return Vector4]]></ProtectedString>
								<string name="ScriptGuid">{EB3AC051-13A0-4125-957B-81AB9D2BF8E5}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Vector4</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXC89B5CE7827641DFAB768555241A82B8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">utils</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX7CBAC137B490468D90F9A76F049EDEDC">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
--[=[ Basically an assertion with format. ]=]

--!native
--!strict

local argue = setmetatable({}, {
	__call = function (
		t : {} ,
		cond : any ,
		msg : string
	)
		msg = msg or 'Assertion failed!'
		local location = t.at or debug.info(2, "n")
		if not cond then return error( `@RbxShader/{location}: {msg}` ) end
	end
})

function argue:at( at : string )
	if typeof(at) ~= "string" then return argue end
	return setmetatable({ at = at }, getmetatable(argue))
end

return argue]]></ProtectedString>
									<string name="ScriptGuid">{05A9F075-D468-4A03-98B8-C3D7E1F1E0A7}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Argue</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9D1DE7664A21429D8AE6120874669CC4">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
-- [=[ Common types found across the scripts. ]=]
--!native

export type ShaderBuffer = (
	fragColor : Vector3 ,
	fragCoords : Vector2 ,
	iTime : number ,
	iTimeDelta : number ,
	iResolution : Vector2 ,
	iMouse : SharedTable ,
	iDate : {number}
) -> (number, number, number, number)

-- a few buffer name examples
export type BufferName = 'bufferA' | 'bufferB' | 'bufferC' | 'bufferD' | 'bufferE'

export type Shader = {
	CONFIGURATION : EngineConfiguration ,
	[BufferName] : ShaderBuffer ,
	mainImage : ShaderBuffer
}

export type EngineConfiguration = {
	InterlaceFactor : number ,
	DualAxisInterlacing : boolean ,
	ScreenDivision : number ,
	InitialColor : Color3? ,
	InitialAlpha : number? ,
	IsBlurred : boolean? ,
	OriginOffset : Vector2 ,
	CountDirection : Vector2
}

return true]]></ProtectedString>
									<string name="ScriptGuid">{93E9D6A1-441C-44F8-8D19-D04378E22D58}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Common</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXB758114446EB4E81AA7B2F6D6CA2939E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[
--[=[
	Canvas
	A simple EditableImage interface that mimics
	CanvasDraw's API design. Specifically built for RbxShader.
	
	NOTE:
	* RGBA values are normalized (between 0 and 1)
]=]

--!native

local Asset = game:GetService('AssetService')

local Resampler = Enum.ResamplerMode
local writeu8 = buffer.writeu8
local readu8 = buffer.readu8
local writeu16 = buffer.writeu16
local readu16 = buffer.readu16
-- * denormalizes a normalized number
local uint8 = function(n: number) : number
	return math.clamp(math.ceil(n * 255), 0, 255)
end

local Canvas = {}
Canvas.__index = Canvas

type Parent = GuiObject | Decal | Texture | SurfaceAppearance | MeshPart
export type Canvas = typeof(Canvas) & {
	Resolution: Vector2 ,
	__Easel: ImageLabel ,
	__Canvas: EditableImage ,
	__ImageBuffer: buffer ,
	__VPMBuffer: buffer
}

function Canvas.new(Parent: Parent, Resolution: Vector2, Blur: boolean?): (Canvas)
	Blur = Blur or false

	-- Build the necessary objects
	local Easel = Instance.new("ImageLabel")
	Easel.Name = "FastCanvas"
	Easel.BackgroundTransparency = 1
	Easel.ClipsDescendants = true
	Easel.Size = UDim2.fromScale(1, 1)
	Easel.Position = UDim2.fromScale(0.5, 0.5)
	Easel.AnchorPoint = Vector2.new(0.5, 0.5)
	Easel.ResampleMode = not Blur and Resampler.Pixelated or Resampler.Default
	Easel.Parent = Parent

	local AspectRatio = Instance.new("UIAspectRatioConstraint")
	AspectRatio.AspectRatio = Resolution.X / Resolution.Y
	AspectRatio.Parent = Easel
	
	local InternalCanvas = Asset:CreateEditableImage({ Size = Resolution })
	Easel.ImageContent = Content.fromObject(InternalCanvas)

	-- Build the 'Canvas' object
	local self = setmetatable({}, Canvas)
	self.Resolution = Resolution
	self.__Easel = Easel
	self.__Canvas = InternalCanvas
	self.__ImageBuffer = buffer.create(Resolution.X * Resolution.Y * 4)
	self.__VPMBuffer = buffer.create(Resolution.X * Resolution.Y * 4)
	-- ^^^ 'VPM' stands for 'virtual pixel mapping'
	-- * pure coincidence that the size of both buffers are the same
	
	return self
end

function Canvas:__GetIndex(X: number, Y: number): (number)
	return (Y - 1) * (self.Resolution.X * 4) + (X - 1) * 4
end

function Canvas:SetRGBA(X: number, Y: number, R: number, G: number, B: number, A: number): ()
	local Index = self:__GetIndex(X, Y)
	local ImgBuff = self.__ImageBuffer
	writeu8(ImgBuff, Index, uint8(R))
	writeu8(ImgBuff, Index + 1, uint8(G))
	writeu8(ImgBuff, Index + 2, uint8(B))
	writeu8(ImgBuff, Index + 3, uint8(A or 1))
	return nil
end

function Canvas:GetRGB(X: number, Y: number): (number, number, number)
	local Index = self:__GetIndex(X, Y)
	local ImgBuff = self.__ImageBuffer
	return readu8(ImgBuff, Index) / 255,
		readu8(ImgBuff, Index + 1) / 255,
		readu8(ImgBuff, Index + 2) / 255
end

function Canvas:Fill(Color: Color3?, Alpha: number?): ()
	Color = Color or Color3.new(1, 1, 1)
	Alpha = Alpha or 1
	
	for X = 1, self.Resolution.X do
		for Y = 1, self.Resolution.Y do
			self:SetRGBA(X, Y, Color.R, Color.G, Color.B, Alpha)
		end
	end
end

function Canvas:RecalculateVirtualPixelMapping(
	VirtualOrigin: Vector2 , --> in pixels
	RelativeOffset: Vector2 , --> in pixels
	CountDirection: Vector2 --> sign vector
): ()
	VirtualOrigin = VirtualOrigin:Floor()
	RelativeOffset = RelativeOffset:Floor()
	CountDirection = CountDirection:Sign()
	
	-- CountDirection sanitization
	if CountDirection.X == 0 then CountDirection += Vector2.xAxis end
	if CountDirection.Y == 0 then CountDirection += Vector2.yAxis end
	local VPMBuff = self.__VPMBuffer

	for X = 1, self.Resolution.X do
		for Y = 1, self.Resolution.Y do
			local Index = self:__GetIndex(X, Y)
			writeu16(VPMBuff, Index, VirtualOrigin.X + CountDirection.X * (X + RelativeOffset.X))
			writeu16(VPMBuff, Index + 2, VirtualOrigin.Y + CountDirection.Y * (Y + RelativeOffset.Y))
		end
	end
end

function Canvas:GetVirtualPosition(X: number, Y: number): (number, number)
	local Index = self:__GetIndex(X, Y)
	local VPMBuff = self.__VPMBuffer
	return readu16(VPMBuff, Index),
		readu16(VPMBuff, Index + 2)
end

function Canvas:Render(): ()
	local Canvas : EditableImage = self.__Canvas
	Canvas:WritePixelsBuffer(Vector2.zero, Canvas.Size, self.__ImageBuffer)
	return nil
end

function Canvas:Destroy(): ()
	self.__Canvas:Destroy()
	self.__Easel:Destroy()
	setmetatable(self, nil)
	table.clear(self)
	self = nil
	return nil
end

return Canvas]]></ProtectedString>
								<string name="ScriptGuid">{3ED39C4D-A565-4A7B-8D43-5727FDB6218C}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Canvas</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX90A103D81E6C406584847C1F786990D9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">DataPredict</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0C8D2826FE5E470DB7AD9F274822D5C9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[return {
	Name = "DataPredict",
	Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
	Format = {
		{Separator = "General Info"},
		{Text = "Creator: @MYOriginsWorkshop"},
		{Text = [[Their Quick Introduction: 
		What is machine learning?

		Machine learning is a way for computers to predict information based on the data we given to them. Machine learning can do three main tasks: Regression, Classification and Clustering.

		Regression: Generates a continuous value (e.g. -1.1, 2.09, 20) from given data.

		Classification: Generates a discrete value (e.g. 1, 2, 3), mainly for classifying given data.

		Clustering: Generates centroids (center of data) based on the given data and predict which centroids that a data belongs to.

		What is deep learning?

		Mainly covers the neural network models.

		So how do we use this library?

		In machine/deep learning, we mainly need to do training before we can predict things. To train, we need a lot of data and choose the correct models so that we can achieve very good results. Once training is done, you can use the model to predict values based on the data that was never seen before by the model.]]},
		{Text = "Version: 1.8.5 (191)"},
		{Separator = "Features"},
		{Text = "Deep reinforcement learning models, tabular reinforcement learning, deep generative models and sequence models are included"},
		{Text = "Optimizers, regularizers and a lot of utilities"},
		{Text = "Distributed training"},
		{Text = "Object-orientated library"},
	}
}]]></ProtectedString>
							<string name="ScriptGuid">{2657A14C-8186-466B-8329-4A48FFB35BF3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Config</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFEA3C6B893A54671884E292585A153EE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamMachineDeepAndReinforcementLearningLibrary = {}

local Models = script.Models

local Regularizers = script.Regularizers

local Optimizers = script.Optimizers

local ValueSchedulers = script.ValueSchedulers

local ExperienceReplays = script.ExperienceReplays

local QuickSetups = script.QuickSetups

local EligibilityTraces = script.EligibilityTraces

local ReinforcementLearningStrategies = script.ReinforcementLearningStrategies

local DistributedTrainingStrategies = script.DistributedTrainingStrategies

local Others = script.Others

AqwamMachineDeepAndReinforcementLearningLibrary.Models = {

	LinearRegression = require(Models.LinearRegression),
	
	QuantileLinearRegression = require(Models.QuantileLinearRegression),
	
	PoissonLinearRegression = require(Models.PoissonLinearRegression),
	
	NormalLinearRegression = require(Models.NormalLinearRegression),
	
	BayesianLinearRegression = require(Models.BayesianLinearRegression),
	
	BayesianQuantileLinearRegression = require(Models.BayesianQuantileLinearRegression),
	
	PassiveAggressiveRegressor = require(Models.PassiveAggressiveRegressor),
	
	SupportVectorRegression = require(Models.SupportVectorRegression),
	
	KNearestNeighboursRegressor = require(Models.KNearestNeighboursRegressor),
	
	LogisticRegression = require(Models.LogisticRegression),
	
	PassiveAggressiveClassifier = require(Models.PassiveAggressiveClassifier),
	
	OneClassPassiveAggressiveClassifier = require(Models.OneClassPassiveAggressiveClassifier),
	
	NeuralNetwork = require(Models.NeuralNetwork),
	
	OneClassSupportVectorMachine = require(Models.OneClassSupportVectorMachine),
	
	SupportVectorMachine = require(Models.SupportVectorMachine),
	
	NearestCentroid = require(Models.NearestCentroid),
	
	KNearestNeighboursClassifier = require(Models.KNearestNeighboursClassifier),
	
	GaussianNaiveBayes = require(Models.GaussianNaiveBayes),
	
	MultinomialNaiveBayes = require(Models.MultinomialNaiveBayes),
	
	BernoulliNaiveBayes = require(Models.BernoulliNaiveBayes),
	
	ComplementNaiveBayes = require(Models.ComplementNaiveBayes),
	
	CategoricalNaiveBayes = require(Models.CategoricalNaiveBayes),
	
	KMeans = require(Models.KMeans),
	
	FuzzyCMeans = require(Models.FuzzyCMeans),
	
	KMedoids = require(Models.KMedoids),
	
	AgglomerativeHierarchical = require(Models.AgglomerativeHierarchical),
	
	ExpectationMaximization = require(Models.ExpectationMaximization),
	
	MeanShift = require(Models.MeanShift),
	
	AffinityPropagation = require(Models.AffinityPropagation),
	
	DensityBasedSpatialClusteringOfApplicationsWithNoise = require(Models.DensityBasedSpatialClusteringOfApplicationsWithNoise),
	
	BisectingCluster = require(Models.BisectingCluster),
	
	DeepQLearning = require(Models.DeepQLearning),

	DeepDoubleQLearningV1 = require(Models.DeepDoubleQLearningV1),

	DeepDoubleQLearningV2 = require(Models.DeepDoubleQLearningV2),
	
	DeepClippedDoubleQLearning = require(Models.DeepClippedDoubleQLearning),
	
	DeepStateActionRewardStateAction = require(Models.DeepStateActionRewardStateAction),
	
	DeepDoubleStateActionRewardStateActionV1 = require(Models.DeepDoubleStateActionRewardStateActionV1),
	
	DeepDoubleStateActionRewardStateActionV2 = require(Models.DeepDoubleStateActionRewardStateActionV2),
	
	DeepExpectedStateActionRewardStateAction = require(Models.DeepExpectedStateActionRewardStateAction),
	
	DeepDoubleExpectedStateActionRewardStateActionV1 = require(Models.DeepDoubleExpectedStateActionRewardStateActionV1),
	
	DeepDoubleExpectedStateActionRewardStateActionV2 = require(Models.DeepDoubleExpectedStateActionRewardStateActionV2),
	
	DeepMonteCarloControl = require(Models.DeepMonteCarloControl),

	DeepOffPolicyMonteCarloControl = require(Models.DeepOffPolicyMonteCarloControl),
	
	REINFORCE = require(Models.REINFORCE),
	
	VanillaPolicyGradient = require(Models.VanillaPolicyGradient),
	
	ActorCritic = require(Models.ActorCritic),
	
	SoftActorCritic = require(Models.SoftActorCritic),
	
	AdvantageActorCritic = require(Models.AdvantageActorCritic),
	
	ProximalPolicyOptimization = require(Models.ProximalPolicyOptimization),
	
	ProximalPolicyOptimizationClip = require(Models.ProximalPolicyOptimizationClip),
	
	DeepDeterministicPolicyGradient = require(Models.DeepDeterministicPolicyGradient),
	
	TwinDelayedDeepDeterministicPolicyGradient = require(Models.TwinDelayedDeepDeterministicPolicyGradient),
	
	TabularQLearning = require(Models.TabularQLearning),
	
	TabularClippedDoubleQLearning = require(Models.TabularClippedDoubleQLearning),
	
	TabularDoubleQLearningV1 = require(Models.TabularDoubleQLearningV1),
	
	TabularDoubleQLearningV2 = require(Models.TabularDoubleQLearningV2),

	TabularStateActionRewardStateAction = require(Models.TabularStateActionRewardStateAction),
	
	TabularDoubleStateActionRewardStateActionV1 = require(Models.TabularDoubleStateActionRewardStateActionV1),

	TabularDoubleStateActionRewardStateActionV2 = require(Models.TabularDoubleStateActionRewardStateActionV2),
	
	TabularExpectedStateActionRewardStateAction = require(Models.TabularExpectedStateActionRewardStateAction),
	
	TabularDoubleExpectedStateActionRewardStateActionV1 = require(Models.TabularDoubleExpectedStateActionRewardStateActionV1),

	TabularDoubleExpectedStateActionRewardStateActionV2 = require(Models.TabularDoubleExpectedStateActionRewardStateActionV2),
	
	TabularMonteCarloControl = require(Models.TabularMonteCarloControl),
	
	TabularOffPolicyMonteCarloControl = require(Models.TabularOffPolicyMonteCarloControl),
	
	Markov = require(Models.Markov),
	
	DynamicBayesianNetwork = require(Models.DynamicBayesianNetwork),
	
	ConditionalRandomField = require(Models.ConditionalRandomField),
	
	KalmanFilter = require(Models.KalmanFilter),
	
	ExtendedKalmanFilter = require(Models.ExtendedKalmanFilter),
	
	UnscentedKalmanFilter = require(Models.UnscentedKalmanFilter),
	
	UnscentedKalmanFilterDataPredictVariant = require(Models.UnscentedKalmanFilterDataPredictVariant),
	
	GenerativeAdversarialNetwork = require(Models.GenerativeAdversarialNetwork),
	
	ConditionalGenerativeAdversarialNetwork = require(Models.ConditionalGenerativeAdversarialNetwork),

	WassersteinGenerativeAdversarialNetwork = require(Models.WassersteinGenerativeAdversarialNetwork),

	ConditionalWassersteinGenerativeAdversarialNetwork = require(Models.ConditionalWassersteinGenerativeAdversarialNetwork),

}

AqwamMachineDeepAndReinforcementLearningLibrary.Regularizers = {
	
	ElasticNet = require(Regularizers.ElasticNet),
	
	Lasso = require(Regularizers.Lasso),
	
	Ridge = require(Regularizers.Ridge),
	
}

AqwamMachineDeepAndReinforcementLearningLibrary.Optimizers = {

	AdaptiveDelta = require(Optimizers.AdaptiveDelta),
	
	AdaptiveFactor = require(Optimizers.AdaptiveFactor),
	
	AdaptiveGradient = require(Optimizers.AdaptiveGradient),

	AdaptiveMomentEstimation = require(Optimizers.AdaptiveMomentEstimation),

	AdaptiveMomentEstimationMaximum = require(Optimizers.AdaptiveMomentEstimationMaximum),
	
	AdaptiveMomentEstimationWeightDecay = require(Optimizers.AdaptiveMomentEstimationWeightDecay),
	
	Gravity = require(Optimizers.Gravity),
	
	Momentum = require(Optimizers.Momentum),

	NesterovAcceleratedAdaptiveMomentEstimation = require(Optimizers.NesterovAcceleratedAdaptiveMomentEstimation),
	
	RectifiedAdaptiveMomentEstimation = require(Optimizers.RectifiedAdaptiveMomentEstimation),
	
	ResilientBackwardPropagation = require(Optimizers.ResilientBackwardPropagation),
	
	RootMeanSquarePropagation = require(Optimizers.RootMeanSquarePropagation),

}

AqwamMachineDeepAndReinforcementLearningLibrary.ValueSchedulers = {
	
	Chained = require(ValueSchedulers.Chained),
	
	Constant = require(ValueSchedulers.Constant),
	
	CosineAnnealing = require(ValueSchedulers.CosineAnnealing),
	
	Exponential = require(ValueSchedulers.Exponential),
	
	InverseSquareRoot = require(ValueSchedulers.InverseSquareRoot),
	
	InverseTime = require(ValueSchedulers.InverseTime),
	
	Linear = require(ValueSchedulers.Linear),
	
	MultipleStep = require(ValueSchedulers.MultipleStep),
	
	Multiplicative = require(ValueSchedulers.Multiplicative),
	
	Polynomial = require(ValueSchedulers.Polynomial),
	
	Sequential = require(ValueSchedulers.Sequential),

	Step = require(ValueSchedulers.Step),

}

AqwamMachineDeepAndReinforcementLearningLibrary.ExperienceReplays = {

	UniformExperienceReplay = require(ExperienceReplays.UniformExperienceReplay),

	PrioritizedExperienceReplay = require(ExperienceReplays.PrioritizedExperienceReplay),

	NStepExperienceReplay = require(ExperienceReplays.NStepExperienceReplay),

}

AqwamMachineDeepAndReinforcementLearningLibrary.QuickSetups = {

	SingleCategoricalPolicy = require(QuickSetups.SingleCategoricalPolicy),

	SingleDiagonalGaussianPolicy = require(QuickSetups.SingleDiagonalGaussianPolicy),
	
	QueuedCategoricalPolicy = require(QuickSetups.QueuedCategoricalPolicy),

	QueuedDiagonalGaussianPolicy = require(QuickSetups.QueuedDiagonalGaussianPolicy),
	
	ParallelCategoricalPolicy = require(QuickSetups.ParallelCategoricalPolicy),

	ParallelDiagonalGaussianPolicy = require(QuickSetups.ParallelDiagonalGaussianPolicy),

}

AqwamMachineDeepAndReinforcementLearningLibrary.EligibilityTraces = {
	
	AccumulatingTrace = require(EligibilityTraces.AccumulatingTrace),
	
	ReplacingTrace = require(EligibilityTraces.ReplacingTrace),
	
	DutchTrace = require(EligibilityTraces.DutchTrace),
	
}

AqwamMachineDeepAndReinforcementLearningLibrary.ReinforcementLearningStrategies = {
	
	RandomNetworkDistillation = require(ReinforcementLearningStrategies.RandomNetworkDistillation),
	
	GenerativeAdversarialImitationLearning = require(ReinforcementLearningStrategies.GenerativeAdversarialImitationLearning),

	WassersteinGenerativeAdversarialImitationLearning = require(ReinforcementLearningStrategies.WassersteinGenerativeAdversarialImitationLearning),
	
}

AqwamMachineDeepAndReinforcementLearningLibrary.DistributedTrainingStrategies = {
	
	DistributedGradientsCoordinator = require(DistributedTrainingStrategies.DistributedGradientsCoordinator),

	DistributedModelParametersCoordinator = require(DistributedTrainingStrategies.DistributedModelParametersCoordinator),
	
}

AqwamMachineDeepAndReinforcementLearningLibrary.Others = {
	
	NormalModelModifier = require(Others.NormalModelModifier),
	
	ModelTrainingModifier = require(Others.ModelTrainingModifier),
	
	ModelSafeguardWrapper = require(Others.ModelSafeguardWrapper),
	
	ModelParametersMerger = require(Others.ModelParametersMerger),

	ModelChecker = require(Others.ModelChecker),
	
	OneVsAll = require(Others.OneVsAll),
	
	OneVsOne = require(Others.OneVsOne),

	OnlineLearning = require(Others.OnlineLearning),
	
	DatasetCreator = require(Others.DatasetCreator),
	
	ConfusionMatrixCreator = require(Others.ConfusionMatrixCreator),

}

return AqwamMachineDeepAndReinforcementLearningLibrary]]></ProtectedString>
							<string name="ScriptGuid">{A1A3DE44-14D3-4CBA-A2A0-D0CB278F4A31}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">DataPredict</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXCC85D79DF4E34B71A4DFE6106576DD70">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">EligibilityTraces</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX56BD3EAC48C0432C9BD57ADAB33BBB53">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseEligibilityTrace = require(script.Parent.BaseEligibilityTrace)

DutchTrace = {}

DutchTrace.__index = DutchTrace

setmetatable(DutchTrace, BaseEligibilityTrace)

local defaultAlpha = 0.5

function DutchTrace.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewDutchTrace = BaseEligibilityTrace.new(parameterDictionary)
	
	setmetatable(NewDutchTrace, DutchTrace)
	
	NewDutchTrace:setName("DutchTrace")
	
	NewDutchTrace.alpha = parameterDictionary.alpha or defaultAlpha
	
	NewDutchTrace:setIncrementFunction(function(eligibilityTraceMatrix, stateIndex, actionIndex)

		eligibilityTraceMatrix[stateIndex][actionIndex] = ((1 - NewDutchTrace.alpha) * eligibilityTraceMatrix[stateIndex][actionIndex]) + 1
		
		return eligibilityTraceMatrix
		
	end)
	
	return NewDutchTrace
	
end

return DutchTrace
]]></ProtectedString>
									<string name="ScriptGuid">{E8375C3B-7125-44EB-BA11-03EE08425114}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DutchTrace</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC2E6564F4EBB4DE2AA17511F9982F5AD">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseEligibilityTrace = require(script.Parent.BaseEligibilityTrace)

ReplacingTrace = {}

ReplacingTrace.__index = ReplacingTrace

setmetatable(ReplacingTrace, BaseEligibilityTrace)

function ReplacingTrace.new(parameterDictionary)
	
	local NewReplacingTrace = BaseEligibilityTrace.new(parameterDictionary)
	
	setmetatable(NewReplacingTrace, ReplacingTrace)
	
	NewReplacingTrace:setName("ReplacingTrace")
	
	NewReplacingTrace:setIncrementFunction(function(eligibilityTraceMatrix, stateIndex, actionIndex)
		
		eligibilityTraceMatrix[stateIndex][actionIndex] = 1
		
		return eligibilityTraceMatrix
		
	end)
	
	return NewReplacingTrace
	
end

return ReplacingTrace
]]></ProtectedString>
									<string name="ScriptGuid">{D648F52F-B93A-4305-8E54-26DCEDAEC131}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ReplacingTrace</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2D7B4DE4C70C4886A4CFB0D105924C47">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseEligibilityTrace = require(script.Parent.BaseEligibilityTrace)

AccumulatingTrace = {}

AccumulatingTrace.__index = AccumulatingTrace

setmetatable(AccumulatingTrace, BaseEligibilityTrace)

function AccumulatingTrace.new(parameterDictionary)
	
	local NewAccumulatingTrace = BaseEligibilityTrace.new(parameterDictionary)
	
	setmetatable(NewAccumulatingTrace, AccumulatingTrace)
	
	NewAccumulatingTrace:setName("AccumulatingTrace")
	
	NewAccumulatingTrace:setIncrementFunction(function(eligibilityTraceMatrix, stateIndex, actionIndex)

		eligibilityTraceMatrix[stateIndex][actionIndex] = eligibilityTraceMatrix[stateIndex][actionIndex] + 1
		
		return eligibilityTraceMatrix
		
	end)
	
	return NewAccumulatingTrace
	
end

return AccumulatingTrace
]]></ProtectedString>
									<string name="ScriptGuid">{52D6E148-DD2A-4E72-B037-C7A4C31AA781}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AccumulatingTrace</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX66F992D0ABD34F0FA27E03C35FB2BA68">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

BaseEligibilityTrace = {}

BaseEligibilityTrace.__index = BaseEligibilityTrace

setmetatable(BaseEligibilityTrace, BaseInstance)

local defaultLambda = 0.5

local defaultMode = "StateAction"

function BaseEligibilityTrace.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewBaseEligibilityTrace = BaseInstance.new()
	
	setmetatable(NewBaseEligibilityTrace, BaseEligibilityTrace)
	
	NewBaseEligibilityTrace:setName("BaseEligibilityTrace")
	
	NewBaseEligibilityTrace:setClassName("EligibilityTrace")
	
	NewBaseEligibilityTrace.lambda = parameterDictionary.lambda or defaultLambda
	
	NewBaseEligibilityTrace.mode = parameterDictionary.mode or defaultMode
	
	NewBaseEligibilityTrace.eligibilityTraceMatrix = nil
	
	return NewBaseEligibilityTrace
	
end

function BaseEligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray) -- This function is needed because we have double version of reinforcement learning algorithms require separate application of (temporalDifferenceErrorVector * eligibilityTraceMatrix).
	
	local mode = self.mode
	
	local eligibilityTraceMatrix = self.eligibilityTraceMatrix
	
	if (mode == "State") then 
		
		actionIndex = 1
		
	elseif (mode == "Action") then
		
		stateIndex = 1
		
	end
	
	if (not eligibilityTraceMatrix) then
		
		local selectedDimensionSizeArray
		
		if (mode == "StateAction") then
			
			selectedDimensionSizeArray = dimensionSizeArray
			
		elseif (mode == "State") then
			
			selectedDimensionSizeArray = {dimensionSizeArray[1], 1}
			
		elseif (mode == "Action") then
			
			selectedDimensionSizeArray = {1, dimensionSizeArray[2]}
			
		else
			
			error("Unknown mode.")
			
		end
		
		eligibilityTraceMatrix = AqwamTensorLibrary:createTensor(selectedDimensionSizeArray, 0)
		
	end

	eligibilityTraceMatrix = AqwamTensorLibrary:multiply(eligibilityTraceMatrix, discountFactor * self.lambda)
	
	self.eligibilityTraceMatrix = self.incrementFunction(eligibilityTraceMatrix, stateIndex, actionIndex)
	
end

function BaseEligibilityTrace:calculate(temporalDifferenceErrorVector)
	
	return AqwamTensorLibrary:multiply(temporalDifferenceErrorVector, self.eligibilityTraceMatrix)
	
end

function BaseEligibilityTrace:setIncrementFunction(incrementFunction)
	
	self.incrementFunction = incrementFunction
	
end

function BaseEligibilityTrace:getLambda()
	
	return self.lambda
	
end

function BaseEligibilityTrace:setLambda(lambda)

	self.lambda = lambda

end

function BaseEligibilityTrace:reset()
	
	self.eligibilityTraceMatrix = nil
	
end

return BaseEligibilityTrace]]></ProtectedString>
									<string name="ScriptGuid">{5EC0DBD2-66B9-4B11-8CBB-CBB946D7D4DA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BaseEligibilityTrace</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXD755D8962AC749EBB042B42137980176">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Regularizers</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX099A9DBA67474A428CC78364DBC346DB">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseRegularizer = require(script.Parent.BaseRegularizer)

ElasticNet = {}

ElasticNet.__index = ElasticNet

setmetatable(ElasticNet, BaseRegularizer)

function ElasticNet.new(parameterDictionary)
	
	local NewElasticNet = BaseRegularizer.new(parameterDictionary)
	
	setmetatable(NewElasticNet, ElasticNet)
	
	NewElasticNet:setName("ElasticNet")
	
	NewElasticNet:setCalculateCostFunction(function(weightMatrix)
		
		local lambda = NewElasticNet.lambda
		
		weightMatrix = NewElasticNet:adjustWeightMatrix(weightMatrix)
		
		local SquaredWeightMatrix = AqwamTensorLibrary:power(weightMatrix, 2)

		local sumSquaredWeightMatrix = AqwamTensorLibrary:sum(SquaredWeightMatrix)

		local absoluteWeightMatrix = AqwamTensorLibrary:applyFunction(math.abs, weightMatrix)

		local sumAbsoluteWeightMatrix = AqwamTensorLibrary:sum(absoluteWeightMatrix)

		local regularizationValuePart1 = lambda * sumSquaredWeightMatrix

		local regularizationValuePart2 = lambda * sumAbsoluteWeightMatrix

		return (regularizationValuePart1 + regularizationValuePart2)
		
	end)
	
	NewElasticNet:setCalculateFunction(function(weightMatrix)
		
		weightMatrix = NewElasticNet:adjustWeightMatrix(weightMatrix)
		
		local lambda = NewElasticNet.lambda
		
		local signMatrix = AqwamTensorLibrary:applyFunction(math.sign, weightMatrix)

		local regularizationMatrixPart1 = AqwamTensorLibrary:multiply(lambda, signMatrix)

		local regularizationMatrixPart2 = AqwamTensorLibrary:multiply(2, lambda, weightMatrix)

		return AqwamTensorLibrary:add(regularizationMatrixPart1, regularizationMatrixPart2)
		
	end)
	
	return NewElasticNet
	
end

return ElasticNet
]]></ProtectedString>
									<string name="ScriptGuid">{8FD3EDD0-DE97-4DB8-B207-8420C1B7A916}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ElasticNet</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX88DD336A5AAD4ADC9F699C9912839C81">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseRegularizer = require(script.Parent.BaseRegularizer)

Ridge = {}

Ridge.__index = Ridge

setmetatable(Ridge, BaseRegularizer)

function Ridge.new(parameterDictionary)
	
	local NewRidge = BaseRegularizer.new(parameterDictionary)
	
	setmetatable(NewRidge, Ridge)
	
	NewRidge:setName("Ridge")
	
	NewRidge:setCalculateCostFunction(function(weightMatrix)
		
		weightMatrix = NewRidge:adjustWeightMatrix(weightMatrix)

		local squaredWeightMatrix = AqwamTensorLibrary:power(weightMatrix, 2)

		local sumSquaredWeightMatrix = AqwamTensorLibrary:sum(squaredWeightMatrix)

		return (NewRidge.lambda * sumSquaredWeightMatrix)

	end)
	
	NewRidge:setCalculateFunction(function(weightMatrix)
		
		weightMatrix = NewRidge:adjustWeightMatrix(weightMatrix)
		
		return AqwamTensorLibrary:multiply(2, NewRidge.lambda, weightMatrix)
		
	end)
	
	return NewRidge
	
end

return Ridge
]]></ProtectedString>
									<string name="ScriptGuid">{0EA04044-ECED-4927-9C4F-62596577B971}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Ridge</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9DA5356DBADD47F295A777BF507D6DE5">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

BaseRegularizer = {}

BaseRegularizer.__index = BaseRegularizer

setmetatable(BaseRegularizer, BaseInstance)

local defaultLambda = 0.01

local defaultHasBias = "Automatic"

function BaseRegularizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewBaseRegularizer = BaseInstance.new()
	
	setmetatable(NewBaseRegularizer, BaseRegularizer)
	
	NewBaseRegularizer:setName("BaseRegularizer")
	
	NewBaseRegularizer:setClassName("Regularizer")
	
	NewBaseRegularizer.lambda = parameterDictionary.lambda or defaultLambda
	
	NewBaseRegularizer.hasBias = NewBaseRegularizer:getValueOrDefaultValue(parameterDictionary.hasBias, defaultHasBias)
	
	return NewBaseRegularizer
	
end

function BaseRegularizer:adjustWeightMatrix(weightMatrix)
	
	local hasBias = self.hasBias
	
	if (not hasBias) then return weightMatrix end
	
	local firstRowWeightMatrix = weightMatrix[1]
	
	if (hasBias == "Automatic") then
		
		for i, value in ipairs(firstRowWeightMatrix) do
			
			if (value ~= 1) then return weightMatrix end
			
		end
		
	end
	
	local newWeightMatrix = self:deepCopyTable(weightMatrix)
	
	firstRowWeightMatrix = newWeightMatrix[1]
	
	for i, _ in ipairs(firstRowWeightMatrix) do
		
		firstRowWeightMatrix[i] = 0
		
	end

	return newWeightMatrix

end

function BaseRegularizer:calculateCost(weightMatrix)
	
	return self.calculateCostFunction(weightMatrix)
	
end

function BaseRegularizer:setCalculateCostFunction(calculateCostFunction)

	self.calculateCostFunction = calculateCostFunction

end

function BaseRegularizer:calculate(weightMatrix)

	return self.calculateFunction(weightMatrix)

end

function BaseRegularizer:setCalculateFunction(calculateFunction)
	
	self.calculateFunction = calculateFunction
	
end

function BaseRegularizer:getLambda()
	
	return self.lambda
	
end

function BaseRegularizer:setLambda(lambda)

	self.lambda = lambda

end

return BaseRegularizer]]></ProtectedString>
									<string name="ScriptGuid">{8C4BBDFA-CE20-4112-9214-048687F2B9B0}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BaseRegularizer</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX99AD855FA4D14ED8B621FB51782FE248">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseRegularizer = require(script.Parent.BaseRegularizer)

Lasso = {}

Lasso.__index = Lasso

setmetatable(Lasso, BaseRegularizer)

function Lasso.new(parameterDictionary)
	
	local NewLasso = BaseRegularizer.new(parameterDictionary)
	
	setmetatable(NewLasso, Lasso)
	
	NewLasso:setName("Lasso")
	
	NewLasso:setCalculateCostFunction(function(weightMatrix)
		
		weightMatrix = NewLasso:adjustWeightMatrix(weightMatrix)

		local absoluteWeightMatrix = AqwamTensorLibrary:applyFunction(math.abs, weightMatrix)

		local sumAbsoluteWeightMatrix = AqwamTensorLibrary:sum(absoluteWeightMatrix)

		return (NewLasso.lambda * sumAbsoluteWeightMatrix)

	end)
	
	NewLasso:setCalculateFunction(function(weightMatrix)
		
		weightMatrix = NewLasso:adjustWeightMatrix(weightMatrix)
		
		local signMatrix = AqwamTensorLibrary:applyFunction(math.sign, weightMatrix)
		
		return AqwamTensorLibrary:multiply(signMatrix, NewLasso.lambda, weightMatrix)
		
	end)
	
	return NewLasso
	
end

return Lasso
]]></ProtectedString>
									<string name="ScriptGuid">{160EEE82-F0AD-4EDC-8C65-A6DBBA24502A}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Lasso</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX40D9DCC05C61486CA8CE3A53E847C329">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">DistributedTrainingStrategies</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX47C4F605C92A4232BC984122D5122355">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

DistributedModelParametersCoordinator = {}

DistributedModelParametersCoordinator.__index = DistributedModelParametersCoordinator

setmetatable(DistributedModelParametersCoordinator, BaseInstance)

local defaultTotalNumberOfChildModelUpdatesToUpdateMainModel = 10

local defaultCurrentTotalNumberOfChildModelUpdatesToUpdateMainModel = 0

function DistributedModelParametersCoordinator.new(parameterDictionary)
	
	local NewDistributedModelParametersCoordinator = BaseInstance.new(parameterDictionary)
	
	setmetatable(NewDistributedModelParametersCoordinator, DistributedModelParametersCoordinator)
	
	NewDistributedModelParametersCoordinator:setName("DistributedModelParametersCoordinator")
	
	NewDistributedModelParametersCoordinator:setClassName("DistributedModelParametersCoordinator")
	
	NewDistributedModelParametersCoordinator.totalNumberOfChildModelUpdatesToUpdateMainModel = parameterDictionary.totalNumberOfChildModelUpdatesToUpdateMainModel or defaultTotalNumberOfChildModelUpdatesToUpdateMainModel
	
	NewDistributedModelParametersCoordinator.currentTotalNumberOfChildModelUpdatesToUpdateMainModel = parameterDictionary.currentTotalNumberOfChildModelUpdatesToUpdateMainModel or defaultCurrentTotalNumberOfChildModelUpdatesToUpdateMainModel
	
	NewDistributedModelParametersCoordinator.ModelParametersMerger = parameterDictionary.ModelParametersMerger
	
	NewDistributedModelParametersCoordinator.ModelParametersArray = parameterDictionary.ModelParametersArray or {}
	
	NewDistributedModelParametersCoordinator.isDistributedLearningRunning = false
	
	return NewDistributedModelParametersCoordinator
	
end

function DistributedModelParametersCoordinator:addModelParameters(ModelParameters)
	
	if (not ModelParameters) then error("No model parameters.") end
	
	self.currentTotalNumberOfChildModelUpdatesToUpdateMainModel = self.currentTotalNumberOfChildModelUpdatesToUpdateMainModel + 1

	table.insert(self.ModelParametersArray, ModelParameters)
	
end

function DistributedModelParametersCoordinator:setModelParametersMerger(ModelParametersMerger)
	
	self.ModelParametersMerger = ModelParametersMerger or self.ModelParametersMerger
	
end

function DistributedModelParametersCoordinator:setMainModelParameters(MainModelParameters)
	
	self.MainModelParameters = MainModelParameters
	
end

function DistributedModelParametersCoordinator:getMainModelParameters()
	
	return self.MainModelParameters
	
end

function DistributedModelParametersCoordinator:getCurrentTotalNumberOfChildModelUpdatesToUpdateMainModel()
	
	return self.currentTotalNumberOfChildModelUpdatesToUpdateMainModel
	
end

function DistributedModelParametersCoordinator:start()
	
	if (self.isDistributedLearningRunning) then error("It is already running.") end
	
	self.isDistributedLearningRunning = true
	
	local modelParameterChangeCoroutine = coroutine.create(function()
		
		local ModelParametersArray = self.ModelParametersArray

		repeat
			
			task.wait()
			
			local totalNumberOfChildModelUpdatesToUpdateMainModel = self.totalNumberOfChildModelUpdatesToUpdateMainModel
			
			if (self.ModelParametersMerger) then 
				
				if (self.currentTotalNumberOfChildModelUpdatesToUpdateMainModel >= totalNumberOfChildModelUpdatesToUpdateMainModel) then
					
					self.currentTotalNumberOfChildModelUpdatesToUpdateMainModel = 0

					local CurrentModelParametersArray = {}

					for i = 1, totalNumberOfChildModelUpdatesToUpdateMainModel, 1 do

						table.insert(CurrentModelParametersArray, ModelParametersArray[i])

						table.remove(ModelParametersArray, i)

					end
					
					self.MainModelParameters = self.ModelParametersMerger:merge(CurrentModelParametersArray)

				end
				
			else
				
				warn("No model parameters merger.") 
				
			end

		until (not self.isDistributedLearningRunning)

	end)

	coroutine.resume(modelParameterChangeCoroutine)

	return modelParameterChangeCoroutine
		
end

function DistributedModelParametersCoordinator:stop()
	
	self.isDistributedLearningRunning = false
	
end

function DistributedModelParametersCoordinator:reset()
	
	self.currentTotalNumberOfChildModelUpdatesToUpdateMainModel = 0
	
end

return DistributedModelParametersCoordinator]]></ProtectedString>
									<string name="ScriptGuid">{03B67358-F896-420C-9765-BB13C8ABA948}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DistributedModelParametersCoordinator</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB585FB0402DA4291AE0309D32F988161">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

DistributedGradientsCoordinator = {}

DistributedGradientsCoordinator.__index = DistributedGradientsCoordinator

setmetatable(DistributedGradientsCoordinator, BaseInstance)

local defaultGradientChangeMode = "Descent"

local defaultAveragingRate = 0

local function checkDepth(array, depth)

	depth = depth or 0

	local valueType = typeof(array)

	if (valueType == "table") then

		return checkDepth(array[1], depth + 1)

	else

		return depth

	end

end

local function checkIfIsTableOfMatrices(array)

	local depth = checkDepth(array)

	local isTableOfMatrices = (depth == 3)

	return isTableOfMatrices

end

local function gradientDescent(ModelParameters, Gradients, isTableOfMatrices, averagingRate, averagingRateComplement)

	if (isTableOfMatrices) then

		local averagedSubModelParameters 

		local averagedSubGradient

		for i = 1, #ModelParameters, 1 do

			averagedSubModelParameters = AqwamTensorLibrary:multiply(ModelParameters[i], averagingRateComplement)

			averagedSubGradient = AqwamTensorLibrary:multiply(Gradients[i], averagingRate)

			ModelParameters[i] = AqwamTensorLibrary:subtract(averagedSubModelParameters, averagedSubGradient)

		end

	else

		local averagedModelParameters = AqwamTensorLibrary:multiply(ModelParameters, averagingRateComplement)

		local averagedGradient = AqwamTensorLibrary:multiply(Gradients, averagingRate)

		ModelParameters = AqwamTensorLibrary:subtract(ModelParameters, Gradients)

	end

end

local function gradientAscent(ModelParameters, Gradients, isTableOfMatrices, averagingRate, averagingRateComplement)

	if (isTableOfMatrices) then
		
		local averagedSubModelParameters 

		local averagedSubGradient

		for i = 1, #ModelParameters, 1 do
			
			averagedSubModelParameters = AqwamTensorLibrary:multiply(ModelParameters[i], averagingRateComplement)
			
			averagedSubGradient = AqwamTensorLibrary:multiply(Gradients[i], averagingRate)

			ModelParameters[i] = AqwamTensorLibrary:add(averagedSubModelParameters, averagedSubGradient)

		end

	else
		
		local averagedModelParameters = AqwamTensorLibrary:multiply(ModelParameters, averagingRateComplement)

		local averagedGradient = AqwamTensorLibrary:multiply(Gradients, averagingRate)

		ModelParameters = AqwamTensorLibrary:add(ModelParameters, Gradients)

	end

	return ModelParameters

end

local functionToApplyList = {
	
	["Descent"] = gradientDescent,
	
	["Ascent"] = gradientAscent
	
}

function DistributedGradientsCoordinator.new(parameterDictionary)

	local NewDistributedGradientsCoordinator = BaseInstance.new(parameterDictionary)

	setmetatable(NewDistributedGradientsCoordinator, DistributedGradientsCoordinator)
	
	NewDistributedGradientsCoordinator:setName("DistributedGradientsCoordinator")
	
	NewDistributedGradientsCoordinator:setClassName("DistributedGradientsCoordinator")
	
	NewDistributedGradientsCoordinator.gradientChangeMode = parameterDictionary.gradientChangeMode or defaultGradientChangeMode
	
	NewDistributedGradientsCoordinator.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate
	
	NewDistributedGradientsCoordinator.ModelParameters = parameterDictionary.ModelParameters
	
	NewDistributedGradientsCoordinator.GradientsArray = parameterDictionary.GradientsArray or {}

	NewDistributedGradientsCoordinator.isDistributedGradientsRunning = false

	return NewDistributedGradientsCoordinator

end

function DistributedGradientsCoordinator:addGradients(Gradients)
	
	table.insert(self.GradientsArray, Gradients)
	
end

function DistributedGradientsCoordinator:clearGradients()
	
	table.clear(self.GradientsArray)
	
end

function DistributedGradientsCoordinator:setModelParameters(ModelParameters, doNotDeepCopy)
	
	if (doNotDeepCopy) then
		
		self.ModelParameters = ModelParameters
		
	else
		
		self.ModelParameters = self:deepCopyTable(ModelParameters)
		
	end

end

function DistributedGradientsCoordinator:getModelParameters(doNotDeepCopy)
	
	if (doNotDeepCopy) then

		return self.ModelParameters

	else

		return self:deepCopyTable(self.ModelParameters)

	end

end

function DistributedGradientsCoordinator:start()
	
	if (not self.ModelParameters) then error("No model parameters loaded.") end

	if (self.isDistributedGradientsRunning) then error("It is already running.") end
	
	self.isDistributedGradientsRunning = true
	
	local isTableOfMatrices = checkIfIsTableOfMatrices(self.ModelParameters)
	
	local functionToApply = functionToApplyList[self.gradientChangeMode]
	
	local averagingRate = self.averagingRate

	local averagingRateComplement = 1 - averagingRate
	
	local GradientsArray = self.GradientsArray
	
	local gradientChangeCoroutine = coroutine.create(function()

		repeat

			task.wait()

			while (#GradientsArray > 0) do

				self.ModelParameters = functionToApply(self.ModelParameters, GradientsArray[1], isTableOfMatrices, averagingRate, averagingRateComplement)

				table.remove(GradientsArray, 1)

			end

		until (not self.isDistributedGradientsRunning)

	end)

	coroutine.resume(gradientChangeCoroutine)

	return gradientChangeCoroutine

end

function DistributedGradientsCoordinator:stop()

	self.isDistributedGradientsRunning = false

end

return DistributedGradientsCoordinator
]]></ProtectedString>
									<string name="ScriptGuid">{6E5912E7-EE43-4656-8E31-29B0A77C33E5}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DistributedGradientsCoordinator</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX276F3EF5C78348F08794B69F248ABE23">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">ReinforcementLearningStrategies</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXC6AAAB882C6D4C299A7EB5F899A204A0">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict-Neural/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.Parent.Models.BaseModel)

local GenerativeAdversarialImitationLearningBaseModel = {}

GenerativeAdversarialImitationLearningBaseModel.__index = GenerativeAdversarialImitationLearningBaseModel

setmetatable(GenerativeAdversarialImitationLearningBaseModel, BaseModel)

local defaultNumberOfStepsPerEpisode = 300

function GenerativeAdversarialImitationLearningBaseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewGenerativeAdversarialImitationLearningBaseModel = BaseModel.new(parameterDictionary)
	
	setmetatable(NewGenerativeAdversarialImitationLearningBaseModel, GenerativeAdversarialImitationLearningBaseModel)
	
	NewGenerativeAdversarialImitationLearningBaseModel:setName("GenerativeAdversarialImitationLearningBaseModel")
	
	NewGenerativeAdversarialImitationLearningBaseModel:setClassName("GenerativeAdversarialImitationLearning")
	
	NewGenerativeAdversarialImitationLearningBaseModel.numberOfStepsPerEpisode = parameterDictionary.numberOfStepsPerEpisode or defaultNumberOfStepsPerEpisode
	
	NewGenerativeAdversarialImitationLearningBaseModel.categoricalTrainFunction = parameterDictionary.categoricalTrainFunction
	
	NewGenerativeAdversarialImitationLearningBaseModel.diagonalGaussianTrainFunction = parameterDictionary.diagonalGaussianTrainFunction
	
	NewGenerativeAdversarialImitationLearningBaseModel.DiscriminatorModel = parameterDictionary.DiscriminatorModel
	
	NewGenerativeAdversarialImitationLearningBaseModel.GeneratorModel = parameterDictionary.GeneratorModel
	
	return NewGenerativeAdversarialImitationLearningBaseModel
	
end

function GenerativeAdversarialImitationLearningBaseModel:setCategoricalTrainFunction(categoricalTrainFunction)
	
	self.categoricalTrainFunction = categoricalTrainFunction
	
end

function GenerativeAdversarialImitationLearningBaseModel:setDiagonalGaussianTrainFunction(diagonalGaussianTrainFunction)
	
	self.diagonalGaussianTrainFunction = diagonalGaussianTrainFunction
	
end

function GenerativeAdversarialImitationLearningBaseModel:categoricalTrain(previousFeatureMatrix, expertActionMatrix, currentFeatureMatrix)
	
	self.categoricalTrainFunction(previousFeatureMatrix, expertActionMatrix, currentFeatureMatrix)
	
end

function GenerativeAdversarialImitationLearningBaseModel:diagonalGaussianTrain(previousFeatureMatrix, expertActionMeanMatrix, expertActionStandardDeviationMatrix, expertActionNoiseMatrix, currentFeatureMatrix)
	
	self.diagonalGaussianTrainFunction(previousFeatureMatrix, expertActionMeanMatrix, expertActionStandardDeviationMatrix, expertActionNoiseMatrix, currentFeatureMatrix)
	
end

function GenerativeAdversarialImitationLearningBaseModel:evaluate(featureMatrix)

	return self.DiscriminatorModel:predict(featureMatrix, true)

end

function GenerativeAdversarialImitationLearningBaseModel:generate(featureMatrix, returnOriginalOutput)

	return self.ReinforcementLearningModel:predict(featureMatrix, returnOriginalOutput)

end

function GenerativeAdversarialImitationLearningBaseModel:setDiscriminatorModel(DiscriminatorModel)

	self.DiscriminatorModel = DiscriminatorModel

end

function GenerativeAdversarialImitationLearningBaseModel:setReinforcementLearningModel(ReinforcementLearningModel)

	self.ReinforcementLearningModel = ReinforcementLearningModel

end

function GenerativeAdversarialImitationLearningBaseModel:getDiscriminatorModel()

	return self.DiscriminatorModel

end

function GenerativeAdversarialImitationLearningBaseModel:getReinforcementLearningModel()

	return self.ReinforcementLearningModel

end

function GenerativeAdversarialImitationLearningBaseModel:chooseIndexWithHighestValue(valueVector)

	valueVector = valueVector[1]

	local highestValue = -math.huge

	local highestIndex

	for i, value in ipairs(valueVector) do

		if (value > highestValue) then

			highestValue = value

			highestIndex = i

		end

	end

	return highestIndex

end

function GenerativeAdversarialImitationLearningBaseModel:breakMatrixToMultipleSmallerMatrices(matrix, batchSize)

	local numberOfBatches = math.ceil(#matrix/batchSize)

	local matrixBatchesTable = {}

	local batchPositions = {}

	local batchFeatureMatrix

	local batchLabelVector 

	for batch = 1, numberOfBatches, 1 do

		local startIndex = (batch - 1) * batchSize + 1

		local endIndex = math.min(batch * batchSize, #matrix)

		local batchFeatureMatrix = {}

		for i = startIndex, endIndex do table.insert(batchFeatureMatrix, matrix[i]) end

		table.insert(matrixBatchesTable, batchFeatureMatrix)

	end

	return matrixBatchesTable

end

return GenerativeAdversarialImitationLearningBaseModel]]></ProtectedString>
									<string name="ScriptGuid">{018A5EA8-BD88-4C28-A9CB-66ED35910E6F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">GenerativeAdversarialImitationLearningBaseModel</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBE07045F809749CEACF0A98B474F7F7F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibraryLinker = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GenerativeAdversarialImitationLearningBaseModel = require(script.Parent.GenerativeAdversarialImitationLearningBaseModel)

GenerativeAdversarialImitationLearning = {}

GenerativeAdversarialImitationLearning.__index = GenerativeAdversarialImitationLearning

setmetatable(GenerativeAdversarialImitationLearning, GenerativeAdversarialImitationLearningBaseModel)

function GenerativeAdversarialImitationLearning.new(parameterDictionary)
	
	local NewGenerativeAdversarialImitationLearning = GenerativeAdversarialImitationLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewGenerativeAdversarialImitationLearning, GenerativeAdversarialImitationLearning)
	
	NewGenerativeAdversarialImitationLearning:setName("GenerativeAdversarialImitationLearning")
	
	NewGenerativeAdversarialImitationLearning:setCategoricalTrainFunction(function(previousFeatureMatrix, expertActionMatrix, currentFeatureMatrix, terminalStateMatrix)
		
		local DiscriminatorModel = NewGenerativeAdversarialImitationLearning.DiscriminatorModel

		local ReinforcementLearningModel = NewGenerativeAdversarialImitationLearning.ReinforcementLearningModel

		if (not DiscriminatorModel) then error("No discriminator neural network.") end

		if (not ReinforcementLearningModel) then error("No reinforcement learning neural network.") end

		local numberOfStepsPerEpisode = NewGenerativeAdversarialImitationLearning.numberOfStepsPerEpisode

		local isOutputPrinted = NewGenerativeAdversarialImitationLearning.isOutputPrinted

		local ActionsList = ReinforcementLearningModel:getActionsList()

		local previousFeatureMatrixTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(previousFeatureMatrix, numberOfStepsPerEpisode)

		local expertActionMatrixTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(expertActionMatrix, numberOfStepsPerEpisode)

		local currentFeatureMatrixTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(currentFeatureMatrix, numberOfStepsPerEpisode)
		
		local terminalStateMatrixTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(terminalStateMatrix, numberOfStepsPerEpisode)

		local discriminatorInputNumberOfFeatures, discriminatorInputHasBias = DiscriminatorModel:getLayer(1)

		if (discriminatorInputNumberOfFeatures ~= (#expertActionMatrix[1] + #previousFeatureMatrix[1])) then error("The number of input neurons for the discriminator does not match the total number of both state features and expert actions.") end

		discriminatorInputNumberOfFeatures = discriminatorInputNumberOfFeatures + ((discriminatorInputHasBias and 1) or 0)

		local discriminatorInputVector = AqwamTensorLibraryLinker:createTensor({1, discriminatorInputNumberOfFeatures}, 1)

		for episode = 1, #previousFeatureMatrixTable, 1 do

			local previousFeatureSubMatrix = previousFeatureMatrixTable[episode]

			local expertActionSubMatrix = expertActionMatrixTable[episode]

			local currentFeatureSubMatrix = currentFeatureMatrixTable[episode]
			
			local terminalStateSubMatrix = terminalStateMatrixTable[episode]

			for step = 1, numberOfStepsPerEpisode, 1 do

				task.wait()

				local previousFeatureVector = {previousFeatureSubMatrix[step]}

				local expertActionVector = {expertActionSubMatrix[step]}

				local currentFeatureVector = {currentFeatureSubMatrix[step]}
				
				local terminalStateValue = terminalStateSubMatrix[step][1]

				local agentActionVector = ReinforcementLearningModel:predict(previousFeatureVector, true)

				local concatenatedExpertStateActionVector = AqwamTensorLibraryLinker:concatenate(previousFeatureVector, expertActionVector, 2)

				local concatenatedAgentStateActionVector = AqwamTensorLibraryLinker:concatenate(previousFeatureVector, agentActionVector, 2)

				if (discriminatorInputHasBias) then

					table.insert(concatenatedExpertStateActionVector[1], 1)

					table.insert(concatenatedAgentStateActionVector[1], 1)

				end

				local discriminatorExpertActionValue = DiscriminatorModel:predict(concatenatedExpertStateActionVector, true)[1][1]

				local discriminatorAgentActionValue = DiscriminatorModel:predict(concatenatedAgentStateActionVector, true)[1][1]

				local discriminatorLoss = math.log(discriminatorExpertActionValue) + math.log(1 - discriminatorAgentActionValue)

				local actionIndex = NewGenerativeAdversarialImitationLearning:chooseIndexWithHighestValue(expertActionVector)

				local action = ActionsList[actionIndex]

				if (not action) then error("Missing action at index " .. actionIndex .. ".") end

				ReinforcementLearningModel:categoricalUpdate(previousFeatureVector, action, discriminatorLoss, currentFeatureVector, terminalStateValue)

				DiscriminatorModel:forwardPropagate(discriminatorInputVector, true)

				DiscriminatorModel:backwardPropagate(discriminatorLoss, true)

				if (isOutputPrinted) then print("Episode: " .. episode .. "\t\tStep: " .. step .. "\t\tDiscriminator Loss: " .. discriminatorLoss) end

			end

			ReinforcementLearningModel:episodeUpdate(1)

		end
		
	end)
	
	NewGenerativeAdversarialImitationLearning:setDiagonalGaussianTrainFunction(function(previousFeatureMatrix, expertActionMeanMatrix, expertActionStandardDeviationMatrix, expertActionNoiseMatrix, currentFeatureMatrix, terminalStateMatrix)
		
		local DiscriminatorModel = NewGenerativeAdversarialImitationLearning.DiscriminatorModel

		local ReinforcementLearningModel = NewGenerativeAdversarialImitationLearning.ReinforcementLearningModel

		if (not DiscriminatorModel) then error("No discriminator neural network.") end

		if (not ReinforcementLearningModel) then error("No reinforcement learning neural network.") end

		local numberOfStepsPerEpisode = NewGenerativeAdversarialImitationLearning.numberOfStepsPerEpisode

		local isOutputPrinted = NewGenerativeAdversarialImitationLearning.isOutputPrinted

		local previousFeatureMatrixTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(previousFeatureMatrix, numberOfStepsPerEpisode)

		local expertActionMeanMatrixTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(expertActionMeanMatrix, numberOfStepsPerEpisode)

		local expertActionStandardDeviationTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(expertActionStandardDeviationMatrix, numberOfStepsPerEpisode)
		
		local expertActionNoiseTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(expertActionNoiseMatrix, numberOfStepsPerEpisode)

		local currentFeatureMatrixTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(currentFeatureMatrix, numberOfStepsPerEpisode)
		
		local terminalStateMatrixTable = NewGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(terminalStateMatrix, numberOfStepsPerEpisode)

		local discriminatorInputNumberOfFeatures, discriminatorInputHasBias = DiscriminatorModel:getLayer(1)

		if (discriminatorInputNumberOfFeatures ~= (#expertActionMeanMatrix[1] + #previousFeatureMatrix[1])) then error("The number of input neurons for the discriminator does not match the total number of both state features and expert actions.") end

		discriminatorInputNumberOfFeatures = discriminatorInputNumberOfFeatures + ((discriminatorInputHasBias and 1) or 0)

		local discriminatorInputVector = AqwamTensorLibraryLinker:createTensor({1, discriminatorInputNumberOfFeatures}, 1)

		local currentEpisode = 1

		for episode = 1, #previousFeatureMatrixTable, 1 do

			local previousFeatureSubMatrix = previousFeatureMatrixTable[episode]

			local expertActionMeanSubMatrix = expertActionMeanMatrixTable[episode]

			local expertActionStandardDeviationSubMatrix = expertActionStandardDeviationTable[episode]
			
			local expertActionNoiseSubMatrix = expertActionNoiseTable[episode]

			local currentFeatureSubMatrix = currentFeatureMatrixTable[episode]
			
			local terminalStateSubMatrix = terminalStateMatrixTable[episode]

			for step = 1, numberOfStepsPerEpisode, 1 do

				task.wait()

				local previousFeatureVector = {previousFeatureSubMatrix[step]}

				local expertActionMeanVector = {expertActionMeanSubMatrix[step]}

				local expertActionStandardDeviationVector = {expertActionStandardDeviationSubMatrix[step]}
				
				local expertActionNoiseVector = {expertActionNoiseSubMatrix[step]}

				local currentFeatureVector = {currentFeatureSubMatrix[step]}
				
				local terminalStateValue = terminalStateSubMatrix[step][1]

				local agentActionMeanVector = ReinforcementLearningModel:predict(previousFeatureVector, true)

				local concatenatedExpertStateActionVector = AqwamTensorLibraryLinker:concatenate(previousFeatureVector, expertActionMeanVector, 2)

				local concatenatedAgentStateActionVector = AqwamTensorLibraryLinker:concatenate(previousFeatureVector, agentActionMeanVector, 2)

				if (discriminatorInputHasBias) then

					table.insert(concatenatedExpertStateActionVector[1], 1)

					table.insert(concatenatedAgentStateActionVector[1], 1)

				end

				local discriminatorExpertActionValue = DiscriminatorModel:predict(concatenatedExpertStateActionVector, true)[1][1]

				local discriminatorAgentActionValue = DiscriminatorModel:predict(concatenatedAgentStateActionVector, true)[1][1]

				local discriminatorLoss = math.log(discriminatorExpertActionValue) + math.log(1 - discriminatorAgentActionValue)

				ReinforcementLearningModel:diagonalGaussianUpdate(previousFeatureVector, expertActionMeanVector, expertActionStandardDeviationVector, expertActionNoiseVector, discriminatorLoss, currentFeatureVector, terminalStateValue)

				DiscriminatorModel:forwardPropagate(discriminatorInputVector, true)

				DiscriminatorModel:update(discriminatorLoss, true)

				if (isOutputPrinted) then print("Episode: " .. currentEpisode .. "\t\tStep: " .. step .. "\t\tDiscriminator Loss: " .. discriminatorLoss) end

			end

			ReinforcementLearningModel:episodeUpdate(1)

		end
		
	end)
	
	return NewGenerativeAdversarialImitationLearning
	
end

return GenerativeAdversarialImitationLearning]]></ProtectedString>
									<string name="ScriptGuid">{AADC1FD5-60F8-4D93-967A-81029C17DD0C}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">GenerativeAdversarialImitationLearning</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXACF24242435C424F8D45A13B31890E09">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GenerativeAdversarialImitationLearningBaseModel = require(script.Parent.GenerativeAdversarialImitationLearningBaseModel)

WassersteinGenerativeAdversarialImitationLearning = {}

WassersteinGenerativeAdversarialImitationLearning.__index = WassersteinGenerativeAdversarialImitationLearning

setmetatable(WassersteinGenerativeAdversarialImitationLearning, GenerativeAdversarialImitationLearningBaseModel)

function WassersteinGenerativeAdversarialImitationLearning.new(parameterDictionary)
	
	local NewWassersteinGenerativeAdversarialImitationLearning = GenerativeAdversarialImitationLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewWassersteinGenerativeAdversarialImitationLearning, WassersteinGenerativeAdversarialImitationLearning)
	
	NewWassersteinGenerativeAdversarialImitationLearning:setName("WassersteinGenerativeAdversarialImitationLearning")
	
	NewWassersteinGenerativeAdversarialImitationLearning:setCategoricalTrainFunction(function(previousFeatureMatrix, expertActionMatrix, currentFeatureMatrix, terminalStateMatrix)
		
		local DiscriminatorModel = NewWassersteinGenerativeAdversarialImitationLearning.DiscriminatorModel

		local ReinforcementLearningModel = NewWassersteinGenerativeAdversarialImitationLearning.ReinforcementLearningModel

		if (not DiscriminatorModel) then error("No discriminator neural network.") end

		if (not ReinforcementLearningModel) then error("No reinforcement learning neural network.") end

		local numberOfStepsPerEpisode = NewWassersteinGenerativeAdversarialImitationLearning.numberOfStepsPerEpisode

		local isOutputPrinted = NewWassersteinGenerativeAdversarialImitationLearning.isOutputPrinted

		local ActionsList = ReinforcementLearningModel:getActionsList()

		local previousFeatureMatrixTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(previousFeatureMatrix, numberOfStepsPerEpisode)

		local expertActionMatrixTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(expertActionMatrix, numberOfStepsPerEpisode)

		local currentFeatureMatrixTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(currentFeatureMatrix, numberOfStepsPerEpisode)
		
		local terminalStateMatrixTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(terminalStateMatrix, numberOfStepsPerEpisode)

		local discriminatorInputNumberOfFeatures, discriminatorInputHasBias = DiscriminatorModel:getLayer(1)

		if (discriminatorInputNumberOfFeatures ~= (#expertActionMatrix[1] + #previousFeatureMatrix[1])) then error("The number of input neurons for the discriminator does not match the total number of both state features and expert actions.") end

		discriminatorInputNumberOfFeatures = discriminatorInputNumberOfFeatures + ((discriminatorInputHasBias and 1) or 0)

		local discriminatorInputVector = AqwamTensorLibrary:createTensor({1, discriminatorInputNumberOfFeatures}, 1)

		for episode = 1, #previousFeatureMatrixTable, 1 do

			local previousFeatureSubMatrix = previousFeatureMatrixTable[episode]

			local expertActionSubMatrix = expertActionMatrixTable[episode]

			local currentFeatureSubMatrix = currentFeatureMatrixTable[episode]
			
			local terminalStateSubMatrix = terminalStateMatrixTable[episode]

			for step = 1, numberOfStepsPerEpisode, 1 do

				task.wait()

				local previousFeatureVector = {previousFeatureSubMatrix[step]}

				local expertActionVector = {expertActionSubMatrix[step]}

				local currentFeatureVector = {currentFeatureSubMatrix[step]}
				
				local terminalStateValue = terminalStateSubMatrix[step][1]

				local agentActionVector = ReinforcementLearningModel:predict(previousFeatureVector, true)

				local concatenatedExpertStateActionVector = AqwamTensorLibrary:concatenate(previousFeatureVector, expertActionVector, 2)

				local concatenatedAgentStateActionVector = AqwamTensorLibrary:concatenate(previousFeatureVector, agentActionVector, 2)

				if (discriminatorInputHasBias) then

					table.insert(concatenatedExpertStateActionVector[1], 1)

					table.insert(concatenatedAgentStateActionVector[1], 1)

				end

				local discriminatorExpertActionValue = DiscriminatorModel:predict(concatenatedExpertStateActionVector, true)[1][1]

				local discriminatorAgentActionValue = DiscriminatorModel:predict(concatenatedAgentStateActionVector, true)[1][1]

				local discriminatorLoss = discriminatorExpertActionValue - discriminatorAgentActionValue

				local actionIndex = NewWassersteinGenerativeAdversarialImitationLearning:chooseIndexWithHighestValue(expertActionVector)

				local action = ActionsList[actionIndex]

				if (not action) then error("Missing action at index " .. actionIndex .. ".") end

				ReinforcementLearningModel:categoricalUpdate(previousFeatureVector, action, discriminatorLoss, currentFeatureVector, terminalStateValue)

				DiscriminatorModel:forwardPropagate(discriminatorInputVector, true)

				DiscriminatorModel:backwardPropagate(discriminatorLoss, true)

				if (isOutputPrinted) then print("Episode: " .. episode .. "\t\tStep: " .. step .. "\t\tDiscriminator Loss: " .. discriminatorLoss) end

			end

			ReinforcementLearningModel:episodeUpdate(1)

		end
		
		
	end)
	
	NewWassersteinGenerativeAdversarialImitationLearning:setDiagonalGaussianTrainFunction(function(previousFeatureMatrix, expertActionMeanMatrix, expertActionStandardDeviationMatrix, expertActionNoiseMatrix, currentFeatureMatrix, terminalStateMatrix)
		
		local DiscriminatorModel = NewWassersteinGenerativeAdversarialImitationLearning.DiscriminatorModel

		local ReinforcementLearningModel = NewWassersteinGenerativeAdversarialImitationLearning.ReinforcementLearningModel

		if (not DiscriminatorModel) then error("No discriminator neural network.") end

		if (not ReinforcementLearningModel) then error("No reinforcement learning neural network.") end

		local numberOfStepsPerEpisode = NewWassersteinGenerativeAdversarialImitationLearning.numberOfStepsPerEpisode

		local isOutputPrinted = NewWassersteinGenerativeAdversarialImitationLearning.isOutputPrinted

		local previousFeatureMatrixTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(previousFeatureMatrix, numberOfStepsPerEpisode)

		local expertActionMeanMatrixTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(expertActionMeanMatrix, numberOfStepsPerEpisode)

		local expertActionStandardDeviationTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(expertActionStandardDeviationMatrix, numberOfStepsPerEpisode)
		
		local expertActionNoiseTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(expertActionNoiseMatrix, numberOfStepsPerEpisode)

		local currentFeatureMatrixTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(currentFeatureMatrix, numberOfStepsPerEpisode)
		
		local terminalStateMatrixTable = NewWassersteinGenerativeAdversarialImitationLearning:breakMatrixToMultipleSmallerMatrices(terminalStateMatrix, numberOfStepsPerEpisode)

		local discriminatorInputNumberOfFeatures, discriminatorInputHasBias = DiscriminatorModel:getLayer(1)

		if (discriminatorInputNumberOfFeatures ~= (#expertActionMeanMatrix[1] + #previousFeatureMatrix[1])) then error("The number of input neurons for the discriminator does not match the total number of both state features and expert actions.") end

		discriminatorInputNumberOfFeatures = discriminatorInputNumberOfFeatures + ((discriminatorInputHasBias and 1) or 0)

		local discriminatorInputVector = AqwamTensorLibrary:createTensor({1, discriminatorInputNumberOfFeatures}, 1)

		local currentEpisode = 1

		for episode = 1, #previousFeatureMatrixTable, 1 do

			local previousFeatureSubMatrix = previousFeatureMatrixTable[episode]

			local expertActionMeanSubMatrix = expertActionMeanMatrixTable[episode]

			local expertActionStandardDeviationSubMatrix = expertActionStandardDeviationTable[episode]
			
			local expertActionNoiseSubMatrix = expertActionNoiseTable[episode]

			local currentFeatureSubMatrix = currentFeatureMatrixTable[episode]
			
			local terminalStateSubMatrix = terminalStateMatrixTable[episode]

			for step = 1, numberOfStepsPerEpisode, 1 do

				task.wait()

				local previousFeatureVector = {previousFeatureSubMatrix[step]}

				local expertActionMeanVector = {expertActionMeanSubMatrix[step]}

				local expertActionStandardDeviationVector = {expertActionStandardDeviationSubMatrix[step]}
				
				local expertActionNoiseVector = {expertActionNoiseSubMatrix[step]}

				local currentFeatureVector = {currentFeatureSubMatrix[step]}
				
				local terminalStateValue = terminalStateSubMatrix[step][1]

				local agentActionMeanVector = ReinforcementLearningModel:predict(previousFeatureVector, true)

				local concatenatedExpertStateActionVector = AqwamTensorLibrary:concatenate(previousFeatureVector, expertActionMeanVector, 2)

				local concatenatedAgentStateActionVector = AqwamTensorLibrary:concatenate(previousFeatureVector, agentActionMeanVector, 2)

				if (discriminatorInputHasBias) then

					table.insert(concatenatedExpertStateActionVector[1], 1)

					table.insert(concatenatedAgentStateActionVector[1], 1)

				end

				local discriminatorExpertActionValue = DiscriminatorModel:predict(concatenatedExpertStateActionVector, true)[1][1]

				local discriminatorAgentActionValue = DiscriminatorModel:predict(concatenatedAgentStateActionVector, true)[1][1]

				local discriminatorLoss = discriminatorExpertActionValue - discriminatorAgentActionValue

				ReinforcementLearningModel:diagonalGaussianUpdate(previousFeatureVector, expertActionMeanVector, expertActionStandardDeviationVector, expertActionNoiseVector, discriminatorLoss, currentFeatureVector, terminalStateValue)

				DiscriminatorModel:forwardPropagate(discriminatorInputVector, true)

				DiscriminatorModel:update(discriminatorLoss, true)

				if (isOutputPrinted) then print("Episode: " .. currentEpisode .. "\t\tStep: " .. step .. "\t\tDiscriminator Loss: " .. discriminatorLoss) end

			end

			ReinforcementLearningModel:episodeUpdate(1)

		end
		
	end)
	
	return NewWassersteinGenerativeAdversarialImitationLearning
	
end

return WassersteinGenerativeAdversarialImitationLearning]]></ProtectedString>
									<string name="ScriptGuid">{8520066F-CBB8-423A-A9CD-848765FCAD2F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">WassersteinGenerativeAdversarialImitationLearning</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE83E77ABC61E4DDE94CA150E1688F845">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

local RandomNetworkDistillation = {}

RandomNetworkDistillation.__index = RandomNetworkDistillation

setmetatable(RandomNetworkDistillation, BaseInstance)

function RandomNetworkDistillation.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewRandomNetworkDistillation = BaseInstance.new(parameterDictionary)
	
	setmetatable(NewRandomNetworkDistillation, RandomNetworkDistillation)
	
	NewRandomNetworkDistillation:setName("RandomNetworkDistillation")
	
	NewRandomNetworkDistillation:setClassName("RandomNetworkDistillation")
	
	NewRandomNetworkDistillation.Model = parameterDictionary.Model
	
	NewRandomNetworkDistillation.TargetModelParameters = parameterDictionary.TargetModelParameters
	
	NewRandomNetworkDistillation.PredictorModelParameters = parameterDictionary.PredictorModelParameters
	
	return NewRandomNetworkDistillation
	
end

function RandomNetworkDistillation:setModel(Model)
	
	self.Model = Model
	
end

function RandomNetworkDistillation:getModel(Model)
	
	return self.Model
	
end

function RandomNetworkDistillation:generate(featureMatrix)
	
	local Model = self.Model
	
	if (not Model) then error("No model.") end
	
	local TargetModelParameters = self.TargetModelParameters
	
	local PredictorModelParameters = self.PredictorModelParameters
	
	if (not TargetModelParameters) then
		
		Model:generateLayers()
		
		TargetModelParameters = Model:getModelParameters(true)
		
	end
	
	Model:setModelParameters(TargetModelParameters, true)
	
	local targetMatrix = Model:predict(featureMatrix, true)
	
	if (not PredictorModelParameters) then

		Model:generateLayers()

		PredictorModelParameters = Model:getModelParameters(true)

	end
	
	Model:setModelParameters(PredictorModelParameters, true)

	local predictorMatrix = Model:predict(featureMatrix, true)
	
	local errorMatrix = AqwamTensorLibrary:subtract(predictorMatrix, targetMatrix)
	
	local squaredErrorMatrix = AqwamTensorLibrary:power(errorMatrix, 2)
	
	local sumSquaredErrorMatrix = AqwamTensorLibrary:sum(squaredErrorMatrix, 2)
	
	local generatedMatrix = AqwamTensorLibrary:power(sumSquaredErrorMatrix, 0.5)

	Model:forwardPropagate(featureMatrix, true)

	Model:update(errorMatrix, true)
	
	self.TargetModelParameters = TargetModelParameters
	
	self.PredictorModelParameters = Model:getModelParameters(true)

	return generatedMatrix
	
end

function RandomNetworkDistillation:getTargetModelParameters(doNotDeepCopy)
	
	if (doNotDeepCopy) then
		
		return self.TargetModelParameters 
		
	else
		
		return self:deepCopyTable(self.TargetModelParameters)
		
	end
	
end

function RandomNetworkDistillation:getPredictorModelParameters(doNotDeepCopy)
	
	if (doNotDeepCopy) then

		return self.PredictorModelParameters 

	else

		return self:deepCopyTable(self.PredictorModelParameters)

	end
	
end

function RandomNetworkDistillation:setTargetModelParameters(TargetModelParameters, doNotDeepCopy)
	
	if (doNotDeepCopy) then

		self.TargetModelParameters = TargetModelParameters

	else

		self.TargetModelParameters = self:deepCopyTable(TargetModelParameters)

	end
	
end

function RandomNetworkDistillation:setPredictorModelParameters(PredictorModelParameters, doNotDeepCopy)
	
	if (doNotDeepCopy) then

		self.PredictorModelParameters = PredictorModelParameters

	else

		self.PredictorModelParameters = self:deepCopyTable(PredictorModelParameters)

	end

end

return RandomNetworkDistillation]]></ProtectedString>
									<string name="ScriptGuid">{F1D5C7D6-5840-4651-BD60-9FF65B0832EF}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">RandomNetworkDistillation</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXFFF7E9DC66524C138EE59C67F2FD1D97">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">ExperienceReplays</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX8C33B6C7B93646609978B501DA144BF6">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseExperienceReplay = require(script.Parent.BaseExperienceReplay)

PrioritizedExperienceReplay = {}

PrioritizedExperienceReplay.__index = PrioritizedExperienceReplay

setmetatable(PrioritizedExperienceReplay, BaseExperienceReplay)

local defaultAlpha = 0.6

local defaultBeta = 0.4

local defaultAggregateFunction = "Maximum"

local defaultEpsilon = 1e-16

local aggregateFunctionList = {
	
	["Maximum"] = function (valueVector) 
		
		return AqwamTensorLibrary:findMaximumValue(valueVector) 
		
	end,
	
	["Minimum"] = function (valueVector) 

		return AqwamTensorLibrary:findMinimumValue(valueVector) 

	end,
	
	["Sum"] = function (valueVector) 
		
		return AqwamTensorLibrary:sum(valueVector) 
		
	end,
	
	["Average"] = function (valueVector) 

		return AqwamTensorLibrary:sum(valueVector) / #valueVector[1] 

	end,
	
}

local function sample(probabilityArray)
	
	local sumProbability = 0
	
	for i, probability in ipairs(probabilityArray) do
		
		sumProbability = sumProbability + probability
		
	end
	
	local randomProbability = math.random() * sumProbability
	
	local cumulativeProbability = 0
	
	for probabilityIndex, probability in ipairs(probabilityArray) do
		
		cumulativeProbability = cumulativeProbability + probability
		
		if (randomProbability <= cumulativeProbability) then return probabilityIndex, probability end
		
	end
	
	return #probabilityArray, probabilityArray[#probabilityArray]
	
end

function PrioritizedExperienceReplay.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewPrioritizedExperienceReplay = BaseExperienceReplay.new(parameterDictionary)
	
	setmetatable(NewPrioritizedExperienceReplay, PrioritizedExperienceReplay)
	
	NewPrioritizedExperienceReplay:setName("PrioritizedExperienceReplay")
	
	NewPrioritizedExperienceReplay.alpha = parameterDictionary.alpha or defaultAlpha
	
	NewPrioritizedExperienceReplay.beta = parameterDictionary.beta or defaultBeta
	
	NewPrioritizedExperienceReplay.aggregateFunction = parameterDictionary.aggregateFunction or defaultAggregateFunction
	
	NewPrioritizedExperienceReplay.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	NewPrioritizedExperienceReplay.Model = parameterDictionary.Model
	
	NewPrioritizedExperienceReplay.priorityArray = parameterDictionary.priorityArray or {}
	
	NewPrioritizedExperienceReplay.weightArray = parameterDictionary.weightArray or {}
	
	NewPrioritizedExperienceReplay:setIsTemporalDifferenceErrorRequired(true)
	
	NewPrioritizedExperienceReplay:extendAddExperienceFunction(function()
		
		local maximumPriority = 1
		
		local priorityArray = NewPrioritizedExperienceReplay.priorityArray
		
		local weightArray = NewPrioritizedExperienceReplay.weightArray
		
		for i, priority in ipairs(priorityArray) do
			
			if (priority > maximumPriority) then
				
				maximumPriority = priority
				
			end
			
		end
		
		table.insert(priorityArray, maximumPriority)
		
		table.insert(weightArray, 0)
		
		NewPrioritizedExperienceReplay:removeFirstValueFromArrayIfExceedsBufferSize(priorityArray)
		
		NewPrioritizedExperienceReplay:removeFirstValueFromArrayIfExceedsBufferSize(weightArray)
	
	end)
	
	NewPrioritizedExperienceReplay:extendResetFunction(function()
		
		table.clear(NewPrioritizedExperienceReplay.priorityArray)
		
		table.clear(NewPrioritizedExperienceReplay.weightArray)
		
	end)
	
	NewPrioritizedExperienceReplay:setRunFunction(function()
		
		local Model = NewPrioritizedExperienceReplay.Model

		if (not Model) then error("No model.") end

		local batchArray = {}

		local alpha = NewPrioritizedExperienceReplay.alpha

		local beta = NewPrioritizedExperienceReplay.beta
		
		local epsilon = NewPrioritizedExperienceReplay.epsilon

		local replayBufferArray = NewPrioritizedExperienceReplay.replayBufferArray
		
		local temporalDifferenceArray = NewPrioritizedExperienceReplay.temporalDifferenceErrorArray
		
		local priorityArray = NewPrioritizedExperienceReplay.priorityArray
		
		local weightArray = NewPrioritizedExperienceReplay.weightArray

		local aggregateFunctionToApply = aggregateFunctionList[NewPrioritizedExperienceReplay.aggregateFunction]
		
		local batchSize = NewPrioritizedExperienceReplay.batchSize
		
		local replayBufferArraySize = #replayBufferArray

		local lowestNumberOfBatchSize = math.min(batchSize, replayBufferArraySize)		
		
		local probabilityArray = {}

		local sumPriorityAlpha = 0
		
		for i, priority in ipairs(priorityArray) do
			
			local priorityAlpha = math.pow(priority, alpha)
			
			probabilityArray[i] = priorityAlpha
			
			sumPriorityAlpha = sumPriorityAlpha + priorityAlpha
			
		end
		
		for i, probability in ipairs(probabilityArray) do
			
			probabilityArray[i] = probability / sumPriorityAlpha
			
		end

		local sizeArray = AqwamTensorLibrary:getDimensionSizeArray(replayBufferArray[1][1])

		local inputMatrix = AqwamTensorLibrary:createTensor(sizeArray, 1)

		local sumLossMatrix
		
		for i = 1, lowestNumberOfBatchSize, 1 do
			
			local index, probability = sample(probabilityArray, sumPriorityAlpha)
			
			local experience = replayBufferArray[index]
			
			local temporalDifferenceErrorValueOrVector = temporalDifferenceArray[index]

			local importanceSamplingWeight = math.pow((lowestNumberOfBatchSize * probability), -beta) / math.max(table.unpack(weightArray), epsilon) 
			
			if (type(temporalDifferenceErrorValueOrVector) ~= "number") then

				temporalDifferenceErrorValueOrVector = aggregateFunctionToApply(temporalDifferenceErrorValueOrVector)

			end
			
			weightArray[index] = importanceSamplingWeight

			priorityArray[index] = math.abs(temporalDifferenceErrorValueOrVector)

			local outputMatrix = Model:forwardPropagate(replayBufferArray[index][1], false)

			local lossMatrix = AqwamTensorLibrary:multiply(outputMatrix, temporalDifferenceErrorValueOrVector, importanceSamplingWeight)

			if (sumLossMatrix) then

				sumLossMatrix = AqwamTensorLibrary:add(sumLossMatrix, lossMatrix)

			else

				sumLossMatrix = lossMatrix

			end

		end

		Model:forwardPropagate(inputMatrix, true)

		Model:update(sumLossMatrix, true)
		
	end)
	
	return NewPrioritizedExperienceReplay
	
end

function PrioritizedExperienceReplay:setModel(Model)
	
	self.Model = Model or self.Model
	
end

return PrioritizedExperienceReplay]]></ProtectedString>
									<string name="ScriptGuid">{F081A5AF-C01D-428C-ACF7-1D29D1A5251A}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">PrioritizedExperienceReplay</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB291CE3D95A34DE6B3F2A153806A3648">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseExperienceReplay = require(script.Parent.BaseExperienceReplay)

NStepExperienceReplay = {}

NStepExperienceReplay.__index = NStepExperienceReplay

setmetatable(NStepExperienceReplay, BaseExperienceReplay)

local defaultNStep = 3

local function sample(replayBufferArray, batchSize)

	local batchArray = {}

	local replayBufferArray = replayBufferArray

	local replayBufferArraySize = #replayBufferArray

	local lowestNumberOfBatchSize = math.min(batchSize, replayBufferArraySize)

	for i = 1, lowestNumberOfBatchSize, 1 do

		table.insert(batchArray, replayBufferArray[i])

	end

	return batchArray

end

function NStepExperienceReplay.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewNStepExperienceReplay = BaseExperienceReplay.new(parameterDictionary)

	setmetatable(NewNStepExperienceReplay, NStepExperienceReplay)
	
	NewNStepExperienceReplay:setName("NStepExperienceReplay")

	NewNStepExperienceReplay.nStep = parameterDictionary.nStep or defaultNStep

	NewNStepExperienceReplay:setRunFunction(function(updateFunction)
		
		local replayBufferArray = NewNStepExperienceReplay.replayBufferArray

		local replayBufferBatchArray = sample(replayBufferArray, NewNStepExperienceReplay.batchSize)
		
		local replayBufferArraySize = #replayBufferArray
		
		local replayBufferBatchArraySize = #replayBufferBatchArray
		
		local nStep = math.min(NewNStepExperienceReplay.nStep, replayBufferBatchArraySize)
		
		local finalBatchArrayIndex = (replayBufferBatchArraySize - nStep) + 1

		for i = replayBufferBatchArraySize, finalBatchArrayIndex, -1 do updateFunction(table.unpack(replayBufferBatchArray[i])) end

	end)

	return NewNStepExperienceReplay

end

return NStepExperienceReplay]]></ProtectedString>
									<string name="ScriptGuid">{47250067-3BC9-4C28-A32D-C88D2B171F08}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">NStepExperienceReplay</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX80B4A3E5BCCE4227A5510C1B3E4A6F16">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

BaseExperienceReplay = {}

BaseExperienceReplay.__index = BaseExperienceReplay

setmetatable(BaseExperienceReplay, BaseInstance)

local defaultBatchSize = 32

local defaultMaximumBufferSize = 100

local defaultNumberOfRunsToUpdate = 1

local defaultNumberOfRuns = 0

local defaultIsTemporalDifferenceErrorRequired = false

function BaseExperienceReplay.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewBaseExperienceReplay = BaseInstance.new(parameterDictionary)
	
	setmetatable(NewBaseExperienceReplay, BaseExperienceReplay)
	
	NewBaseExperienceReplay:setName("ExperienceReplay")
	
	NewBaseExperienceReplay:setName("BaseExperienceReplay")

	NewBaseExperienceReplay.batchSize = parameterDictionary.batchSize or defaultBatchSize

	NewBaseExperienceReplay.numberOfRunsToUpdate = parameterDictionary.numberOfRunsToUpdate or defaultNumberOfRunsToUpdate

	NewBaseExperienceReplay.maximumBufferSize = parameterDictionary.maximumBufferSize or defaultMaximumBufferSize
	
	NewBaseExperienceReplay.numberOfRuns = parameterDictionary.numberOfRuns or defaultNumberOfRuns
	
	NewBaseExperienceReplay.replayBufferArray = parameterDictionary.replayBufferArray or {}
	
	NewBaseExperienceReplay.temporalDifferenceErrorArray = parameterDictionary.temporalDifferenceErrorArray or {}
	
	return NewBaseExperienceReplay
	
end

function BaseExperienceReplay:setParameters(batchSize, numberOfRunsToUpdate, maxBufferSize)
	
	self.batchSize = batchSize or self.batchSize

	self.numberOfRunsToUpdate = numberOfRunsToUpdate or self.numberOfRunsToUpdate

	self.maxBufferSize = maxBufferSize or self.maxBufferSize
	
end

function BaseExperienceReplay:extendResetFunction(resetFunction)
	
	self.resetFunction = resetFunction
	
end

function BaseExperienceReplay:reset()
	
	self.numberOfRuns = 0
	
	table.clear(self.replayBufferArray)
	
	table.clear(self.temporalDifferenceErrorArray)
	
	local resetFunction = self.resetFunction
	
	if resetFunction then resetFunction() end
	
end

function BaseExperienceReplay:setRunFunction(runFunction)
	
	self.runFunction = runFunction
	
end

function BaseExperienceReplay:run(updateFunction)

	local numberOfRuns = self.numberOfRuns + 1

	self.numberOfRuns = numberOfRuns

	if (numberOfRuns < self.numberOfRunsToUpdate) then return end

	self.numberOfRuns = 0

	self.runFunction(updateFunction)

end

function BaseExperienceReplay:removeFirstValueFromArrayIfExceedsBufferSize(targetArray)
	
	if (#targetArray > self.maximumBufferSize) then table.remove(targetArray, 1) end
	
end

function BaseExperienceReplay:extendAddExperienceFunction(addExperienceFunction)
	
	self.addExperienceFunction = addExperienceFunction
	
end

function BaseExperienceReplay:addExperience(...)
	
	local experience = {...}
	
	local replayBufferArray = self.replayBufferArray

	table.insert(replayBufferArray, experience)
	
	local addExperienceFunction = self.addExperienceFunction
	
	if (addExperienceFunction) then addExperienceFunction(...) end

	self:removeFirstValueFromArrayIfExceedsBufferSize(replayBufferArray)
	
end

function BaseExperienceReplay:extendAddTemporalDifferenceErrorFunction(addTemporalDifferenceErrorFunction)
	
	self.addTemporalDifferenceErrorFunction = addTemporalDifferenceErrorFunction
	
end

function BaseExperienceReplay:addTemporalDifferenceError(temporalDifferenceErrorVectorOrValue)

	if (not self.isTemporalDifferenceErrorRequired) then return end
	
	local temporalDifferenceErrorArray = self.temporalDifferenceErrorArray

	table.insert(temporalDifferenceErrorArray, temporalDifferenceErrorVectorOrValue)

	local addTemporalDifferenceErrorFunction = self.addTemporalDifferenceErrorFunction

	if (addTemporalDifferenceErrorFunction) then addTemporalDifferenceErrorFunction(temporalDifferenceErrorVectorOrValue) end

	self:removeFirstValueFromArrayIfExceedsBufferSize(temporalDifferenceErrorArray)

end

function BaseExperienceReplay:setIsTemporalDifferenceErrorRequired(option)

	self.isTemporalDifferenceErrorRequired = option

end

return BaseExperienceReplay]]></ProtectedString>
									<string name="ScriptGuid">{5AD58174-B83C-4E02-8B0B-D9F988315570}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BaseExperienceReplay</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5EEA85CED9C14BEE91578164795BC8FA">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseExperienceReplay = require(script.Parent.BaseExperienceReplay)

UniformExperienceReplay = {}

UniformExperienceReplay.__index = UniformExperienceReplay

setmetatable(UniformExperienceReplay, BaseExperienceReplay)

local function sample(replayBufferArray, batchSize)
	
	local batchArray = {}

	local replayBufferArray = replayBufferArray

	local replayBufferArraySize = #replayBufferArray

	local lowestNumberOfBatchSize = math.min(batchSize, replayBufferArraySize)
	
	local RandomObject = Random.new()

	for i = 1, lowestNumberOfBatchSize, 1 do

		local index = RandomObject:NextInteger(1, replayBufferArraySize)

		table.insert(batchArray, replayBufferArray[index])

	end

	return batchArray
	
end

function UniformExperienceReplay.new(parameterDictionary)
	
	local NewUniformExperienceReplay = BaseExperienceReplay.new(parameterDictionary)
	
	setmetatable(NewUniformExperienceReplay, UniformExperienceReplay)
	
	NewUniformExperienceReplay:setName("UniformExperienceReplay")
	
	NewUniformExperienceReplay:setRunFunction(function(updateFunction)
		
		local replayBufferBatchArray = sample(NewUniformExperienceReplay.replayBufferArray, NewUniformExperienceReplay.batchSize)

		for _, experience in ipairs(replayBufferBatchArray) do updateFunction(table.unpack(experience)) end
		
	end)
	
	return NewUniformExperienceReplay
	
end

return UniformExperienceReplay]]></ProtectedString>
									<string name="ScriptGuid">{E295044F-A8A0-4EEA-AB78-ACCD859538C9}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UniformExperienceReplay</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXFEC4FC89C8B548818E134927D3ACDBD5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">QuickSetups</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX48169335436647A982E47B3320274621">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

ReinforcementLearningBaseQuickSetup = {}

ReinforcementLearningBaseQuickSetup.__index = ReinforcementLearningBaseQuickSetup

setmetatable(ReinforcementLearningBaseQuickSetup, BaseInstance)

local defaultNumberOfReinforcementsPerEpisode = 500

local defaultIsOutputPrinted = true

function ReinforcementLearningBaseQuickSetup.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewReinforcementLearningBaseQuickSetup = BaseInstance.new(parameterDictionary)

	setmetatable(NewReinforcementLearningBaseQuickSetup, ReinforcementLearningBaseQuickSetup)
	
	NewReinforcementLearningBaseQuickSetup:setName("ReinforcementLearningBaseQuickSetup")

	NewReinforcementLearningBaseQuickSetup:setClassName("ReinforcementLearningQuickSetup")

	NewReinforcementLearningBaseQuickSetup.isOutputPrinted = NewReinforcementLearningBaseQuickSetup:getValueOrDefaultValue(parameterDictionary.isOutputPrinted, defaultIsOutputPrinted)  

	NewReinforcementLearningBaseQuickSetup.numberOfReinforcementsPerEpisode = parameterDictionary.numberOfReinforcementsPerEpisode or defaultNumberOfReinforcementsPerEpisode

	NewReinforcementLearningBaseQuickSetup.Model = parameterDictionary.Model
	
	NewReinforcementLearningBaseQuickSetup.reinforceFunction = parameterDictionary.reinforceFunction
	
	NewReinforcementLearningBaseQuickSetup.updateFunction = parameterDictionary.updateFunction

	NewReinforcementLearningBaseQuickSetup.episodeUpdateFunction = parameterDictionary.episodeUpdateFunction
	
	NewReinforcementLearningBaseQuickSetup.resetFunction = parameterDictionary.resetFunction

	return NewReinforcementLearningBaseQuickSetup

end

function ReinforcementLearningBaseQuickSetup:setReinforceFunction(reinforceFunction)
	
	self.reinforceFunction = reinforceFunction
	
end

function ReinforcementLearningBaseQuickSetup:setUpdateFunction(updateFunction)

	self.updateFunction = updateFunction

end

function ReinforcementLearningBaseQuickSetup:setEpisodeUpdateFunction(episodeUpdateFunction)

	self.episodeUpdateFunction = episodeUpdateFunction

end

function ReinforcementLearningBaseQuickSetup:setPrintOutput(option)

	self.isOutputPrinted = self:getValueOrDefaultValue(option, self.isOutputPrinted)

end

function ReinforcementLearningBaseQuickSetup:setResetFunction(resetFunction)
	
	self.resetFunction = resetFunction
	
end

function ReinforcementLearningBaseQuickSetup:reinforce(...)
	
	return self.reinforceFunction(...)

end

function ReinforcementLearningBaseQuickSetup:reset(...)

	return self.resetFunction(...)

end

function ReinforcementLearningBaseQuickSetup:setModel(Model)

	self.Model = Model

end

function ReinforcementLearningBaseQuickSetup:getModel()

	return self.Model

end

return ReinforcementLearningBaseQuickSetup]]></ProtectedString>
									<string name="ScriptGuid">{85BB7A9E-82AF-4180-93A7-62706E54788F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ReinforcementLearningBaseQuickSetup</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBD93963D9D3E47DF93789CDE36DEB4F7">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local ReinforcementLearningBaseQuickSetup = require(script.Parent.ReinforcementLearningBaseQuickSetup)

SingleDiagonalGaussianPolicyQuickSetup = {}

SingleDiagonalGaussianPolicyQuickSetup.__index = SingleDiagonalGaussianPolicyQuickSetup

setmetatable(SingleDiagonalGaussianPolicyQuickSetup, ReinforcementLearningBaseQuickSetup)

local defaultCurrentNumberOfReinforcements = 0

local defaultCurrentNumberOfEpisodes = 1

function SingleDiagonalGaussianPolicyQuickSetup.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewSingleDiagonalGaussianPolicyQuickSetup = ReinforcementLearningBaseQuickSetup.new(parameterDictionary)
	
	setmetatable(NewSingleDiagonalGaussianPolicyQuickSetup, SingleDiagonalGaussianPolicyQuickSetup)
	
	NewSingleDiagonalGaussianPolicyQuickSetup:setName("SingleDiagonalGaussianPolicyQuickSetup")
	
	NewSingleDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcements = parameterDictionary.currentNumberOfReinforcements or defaultCurrentNumberOfReinforcements

	NewSingleDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodes = parameterDictionary.currentNumberOfEpisodes or defaultCurrentNumberOfEpisodes
	
	NewSingleDiagonalGaussianPolicyQuickSetup.actionStandardDeviationVector = parameterDictionary.actionStandardDeviationVector
	
	NewSingleDiagonalGaussianPolicyQuickSetup.previousActionMeanVector = parameterDictionary.previousActionMeanVector

	NewSingleDiagonalGaussianPolicyQuickSetup.previousActionNoiseVector = parameterDictionary.previousActionNoiseVector
	
	NewSingleDiagonalGaussianPolicyQuickSetup:setReinforceFunction(function(currentFeatureVector, rewardValue)
		
		local Model = NewSingleDiagonalGaussianPolicyQuickSetup.Model

		if (not Model) then error("No model.") end
		
		local numberOfReinforcementsPerEpisode = NewSingleDiagonalGaussianPolicyQuickSetup.numberOfReinforcementsPerEpisode

		local currentNumberOfReinforcements = NewSingleDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcements + 1

		local currentNumberOfEpisodes = NewSingleDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodes
		
		local ExperienceReplay = NewSingleDiagonalGaussianPolicyQuickSetup.ExperienceReplay

		local previousFeatureVector = NewSingleDiagonalGaussianPolicyQuickSetup.previousFeatureVector

		local currentActionMeanVector = Model:predict(currentFeatureVector, true)
		
		local actionStandardDeviationVector = NewSingleDiagonalGaussianPolicyQuickSetup.actionStandardDeviationVector
		
		local previousActionNoiseVector = NewSingleDiagonalGaussianPolicyQuickSetup.previousActionNoiseVector
		
		local previousActionMeanVector =  NewSingleDiagonalGaussianPolicyQuickSetup.previousActionMeanVector
		
		local actionVectorDimensionSizeArray = AqwamTensorLibrary:getDimensionSizeArray(currentActionMeanVector)

		local currentActionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor(actionVectorDimensionSizeArray, 0, 1)
		
		local currentScaledActionNoiseVector = AqwamTensorLibrary:multiply(actionStandardDeviationVector, currentActionNoiseVector)
		
		local actionVector = AqwamTensorLibrary:add(currentActionMeanVector, currentScaledActionNoiseVector)
		
		local isEpisodeEnd = (currentNumberOfReinforcements >= numberOfReinforcementsPerEpisode)
		
		local terminalStateValue = (isEpisodeEnd and 1) or 0
	
		local temporalDifferenceError

		if (previousFeatureVector) then
			
			local updateFunction = NewSingleDiagonalGaussianPolicyQuickSetup.updateFunction

			temporalDifferenceError = Model:diagonalGaussianUpdate(previousFeatureVector, previousActionMeanVector, actionStandardDeviationVector, previousActionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

			if (updateFunction) then updateFunction(terminalStateValue) end

		end

		if (isEpisodeEnd) then

			local episodeUpdateFunction = NewSingleDiagonalGaussianPolicyQuickSetup.episodeUpdateFunction

			currentNumberOfReinforcements = 0

			currentNumberOfEpisodes = currentNumberOfEpisodes + 1

			Model:episodeUpdate(terminalStateValue)

			if episodeUpdateFunction then episodeUpdateFunction(terminalStateValue) end

		end
		
		if (ExperienceReplay) and (previousFeatureVector) then

			ExperienceReplay:addExperience(previousFeatureVector, previousActionMeanVector, actionStandardDeviationVector, previousActionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

			ExperienceReplay:addTemporalDifferenceError(temporalDifferenceError)

			ExperienceReplay:run(function(storedPreviousFeatureVector, storedActionMeanVector, storedActionStandardDeviationVector, storedActionNoiseVector, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

				return Model:diagonalGaussianUpdate(storedPreviousFeatureVector, storedActionMeanVector, storedActionStandardDeviationVector, storedActionNoiseVector, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

			end)

		end

		NewSingleDiagonalGaussianPolicyQuickSetup.previousFeatureVector = currentFeatureVector
		
		NewSingleDiagonalGaussianPolicyQuickSetup.previousActionMeanVector = currentActionMeanVector
		
		NewSingleDiagonalGaussianPolicyQuickSetup.previousActionNoiseVector = currentActionNoiseVector
		
		NewSingleDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcements = currentNumberOfReinforcements

		NewSingleDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodes = currentNumberOfEpisodes
		
		if (NewSingleDiagonalGaussianPolicyQuickSetup.isOutputPrinted) then print("Episode: " .. currentNumberOfEpisodes .. "\t\tReinforcement Count: " .. currentNumberOfReinforcements) end
		
		return actionVector
		
	end)
	
	NewSingleDiagonalGaussianPolicyQuickSetup:setResetFunction(function()
		
		NewSingleDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcements = 0

		NewSingleDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodes = 1

		NewSingleDiagonalGaussianPolicyQuickSetup.previousFeatureVector = nil

		NewSingleDiagonalGaussianPolicyQuickSetup.previousActionMeanVector = nil

		NewSingleDiagonalGaussianPolicyQuickSetup.previousActionNoiseVector = nil
		
	end)
	
	return NewSingleDiagonalGaussianPolicyQuickSetup
	
end

return SingleDiagonalGaussianPolicyQuickSetup]]></ProtectedString>
									<string name="ScriptGuid">{EA51F3EA-E8CA-4C7B-A94E-24835A2E977D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">SingleDiagonalGaussianPolicy</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXCC68A330F2D64705B09C45FFFC4739D9">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local CategoricalPolicyBaseQuickSetup = require(script.Parent.CategoricalPolicyBaseQuickSetup)

SingleCategoricalPolicyQuickSetup = {}

SingleCategoricalPolicyQuickSetup.__index = SingleCategoricalPolicyQuickSetup

setmetatable(SingleCategoricalPolicyQuickSetup, CategoricalPolicyBaseQuickSetup)

local defaultCurrentNumberOfReinforcements = 0

local defaultCurrentNumberOfEpisodes = 1

function SingleCategoricalPolicyQuickSetup.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewSingleCategoricalPolicyQuickSetup = CategoricalPolicyBaseQuickSetup.new(parameterDictionary)
	
	setmetatable(NewSingleCategoricalPolicyQuickSetup, SingleCategoricalPolicyQuickSetup)
	
	NewSingleCategoricalPolicyQuickSetup:setName("SingleCategoricalPolicyQuickSetup")
	
	NewSingleCategoricalPolicyQuickSetup.previousAction = parameterDictionary.previousAction
	
	NewSingleCategoricalPolicyQuickSetup.selectedActionCountVector = parameterDictionary.selectedActionCountVector
	
	NewSingleCategoricalPolicyQuickSetup.currentNumberOfReinforcements = parameterDictionary.currentNumberOfReinforcements or defaultCurrentNumberOfReinforcements

	NewSingleCategoricalPolicyQuickSetup.currentNumberOfEpisodes = parameterDictionary.currentNumberOfEpisodes or defaultCurrentNumberOfEpisodes
	
	NewSingleCategoricalPolicyQuickSetup:setReinforceFunction(function(currentFeatureVector, rewardValue, returnOriginalOutput)
		
		local Model = NewSingleCategoricalPolicyQuickSetup.Model
		
		if (not Model) then error("No model.") end
		
		local isOriginalValueNotAVector = (type(currentFeatureVector) ~= "table")
		
		if (isOriginalValueNotAVector) then currentFeatureVector = {{currentFeatureVector}} end
		
		local numberOfReinforcementsPerEpisode = NewSingleCategoricalPolicyQuickSetup.numberOfReinforcementsPerEpisode

		local currentNumberOfReinforcements = NewSingleCategoricalPolicyQuickSetup.currentNumberOfReinforcements + 1

		local currentNumberOfEpisodes = NewSingleCategoricalPolicyQuickSetup.currentNumberOfEpisodes
		
		local ExperienceReplay = NewSingleCategoricalPolicyQuickSetup.ExperienceReplay
		
		local previousFeatureVector = NewSingleCategoricalPolicyQuickSetup.previousFeatureVector
		
		local previousAction = NewSingleCategoricalPolicyQuickSetup.previousAction

		local ActionsList = Model:getActionsList()

		local actionVector = Model:predict(currentFeatureVector, true)
		
		local isEpisodeEnd = (currentNumberOfReinforcements >= numberOfReinforcementsPerEpisode)
		
		local terminalStateValue = (isEpisodeEnd and 1) or 0
		
		if (isOriginalValueNotAVector) then currentFeatureVector = currentFeatureVector[1][1] end
		
		local actionIndex, selectedActionCountVector, currentEpsilon = NewSingleCategoricalPolicyQuickSetup:selectAction(actionVector, NewSingleCategoricalPolicyQuickSetup.selectedActionCountVector, NewSingleCategoricalPolicyQuickSetup.currentEpsilon, NewSingleCategoricalPolicyQuickSetup.EpsilonValueScheduler, currentNumberOfReinforcements)

		local action = ActionsList[actionIndex]

		local actionValue = actionVector[1][actionIndex]
		
		local temporalDifferenceError

		if (previousFeatureVector) then
			
			local updateFunction = NewSingleCategoricalPolicyQuickSetup.updateFunction

			temporalDifferenceError = Model:categoricalUpdate(previousFeatureVector, previousAction, rewardValue, currentFeatureVector, terminalStateValue)

			if (updateFunction) then updateFunction(terminalStateValue) end

		end

		if (isEpisodeEnd) then

			local episodeUpdateFunction = NewSingleCategoricalPolicyQuickSetup.episodeUpdateFunction

			currentNumberOfReinforcements = 0

			currentNumberOfEpisodes = currentNumberOfEpisodes + 1

			Model:episodeUpdate(terminalStateValue)

			if episodeUpdateFunction then episodeUpdateFunction(terminalStateValue) end

		end
		
		if (ExperienceReplay) and (previousFeatureVector) then
			
			ExperienceReplay:addExperience(previousFeatureVector, previousAction, rewardValue, currentFeatureVector, terminalStateValue)

			ExperienceReplay:addTemporalDifferenceError(temporalDifferenceError)

			ExperienceReplay:run(function(storedPreviousFeatureVector, storedAction, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

				return Model:categoricalUpdate(storedPreviousFeatureVector, storedAction, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

			end)
			
		end

		NewSingleCategoricalPolicyQuickSetup.previousFeatureVector = currentFeatureVector
		
		NewSingleCategoricalPolicyQuickSetup.previousAction = action
		
		NewSingleCategoricalPolicyQuickSetup.selectedActionCountVector = selectedActionCountVector
		
		NewSingleCategoricalPolicyQuickSetup.currentEpsilon = currentEpsilon
		
		NewSingleCategoricalPolicyQuickSetup.currentNumberOfReinforcements = currentNumberOfReinforcements

		NewSingleCategoricalPolicyQuickSetup.currentNumberOfEpisodes = currentNumberOfEpisodes
		
		if (NewSingleCategoricalPolicyQuickSetup.isOutputPrinted) then print("Episode: " .. currentNumberOfEpisodes .. "\t\tReinforcement Count: " .. currentNumberOfReinforcements) end

		if (returnOriginalOutput) then return actionVector end

		return action, actionValue
		
	end)
	
	NewSingleCategoricalPolicyQuickSetup:setResetFunction(function()

		NewSingleCategoricalPolicyQuickSetup.currentNumberOfReinforcements = 0

		NewSingleCategoricalPolicyQuickSetup.currentNumberOfEpisodes = 1

		NewSingleCategoricalPolicyQuickSetup.previousFeatureVector = nil

		NewSingleCategoricalPolicyQuickSetup.previousAction = nil

		NewSingleCategoricalPolicyQuickSetup.selectedActionCountVector = nil

	end)
	
	return NewSingleCategoricalPolicyQuickSetup
	
end

return SingleCategoricalPolicyQuickSetup]]></ProtectedString>
									<string name="ScriptGuid">{F3B11F38-8D68-45DA-9B14-AE5841123EAE}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">SingleCategoricalPolicy</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBE217C70BCE0427D9049F0D4D15258E9">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local ReinforcementLearningBaseQuickSetup = require(script.Parent.ReinforcementLearningBaseQuickSetup)

CategoricalPolicyBaseQuickSetup = {}

CategoricalPolicyBaseQuickSetup.__index = CategoricalPolicyBaseQuickSetup

setmetatable(CategoricalPolicyBaseQuickSetup, ReinforcementLearningBaseQuickSetup)

local defaultActionSelectionFunction = "Maximum"

local defaultEpsilon = 0

local defaultTemperature = 1

local defaultCValue = 1

local RandomObject = Random.new()

local function selectIndexWithHighestValue(valueVector)
	
	local selectedIndex = 1
	
	local highestValue = -math.huge
	
	for index, value in ipairs(valueVector[1]) do

		if (value > highestValue) then

			highestValue = value

			selectedIndex = index

		end

	end
	
	return selectedIndex
	
end

local function calculateStableProbability(valueVector, temperature)

	local maximumValue = AqwamTensorLibrary:findMaximumValue(valueVector)

	local zValueVector = AqwamTensorLibrary:subtract(valueVector, maximumValue)
	
	local temperatureZValueVector = AqwamTensorLibrary:divide(zValueVector, temperature)

	local exponentVector = AqwamTensorLibrary:exponent(temperatureZValueVector)

	local sumExponentValue = AqwamTensorLibrary:sum(exponentVector)

	local probabilityVector = AqwamTensorLibrary:divide(exponentVector, sumExponentValue)

	return probabilityVector

end

local function calculateProbability(valueVector, temperature)

	local temperatureZValueVector = AqwamTensorLibrary:divide(valueVector, temperature)

	local exponentVector = AqwamTensorLibrary:exponent(temperatureZValueVector)

	local sumExponentValue = AqwamTensorLibrary:sum(exponentVector)

	local probabilityVector = AqwamTensorLibrary:divide(exponentVector, sumExponentValue)

	return probabilityVector

end

local function sample(probabilityVector)
	
	local unwrappedProbabilityVector = probabilityVector[1]

	local totalProbability = 0

	for _, probability in ipairs(unwrappedProbabilityVector) do

		totalProbability = totalProbability + probability

	end

	local randomProbability = math.random() * totalProbability

	local cumulativeProbability = 0

	for index, probability in ipairs(unwrappedProbabilityVector) do

		cumulativeProbability = cumulativeProbability + probability

		if (cumulativeProbability >= randomProbability) then return index end

	end

	return #unwrappedProbabilityVector

end

local function calculateUpperConfidenceBound(actionVector, cValue, selectedActionCountVector, currentNumberOfReinforcements)
	
	local naturalLogCurrentNumberOfReinforcements = math.log(currentNumberOfReinforcements)
	
	local upperConfidenceBoundVector1 = AqwamTensorLibrary:divide(naturalLogCurrentNumberOfReinforcements, selectedActionCountVector)
	
	local upperConfidenceBoundVector2 = AqwamTensorLibrary:multiply(cValue, upperConfidenceBoundVector1)
	
	local upperConfidenceBoundVector = AqwamTensorLibrary:add(actionVector, upperConfidenceBoundVector2)
	
	return upperConfidenceBoundVector
	
end

function CategoricalPolicyBaseQuickSetup:selectAction(actionVector, selectedActionCountVector, currentEpsilon, EpsilonValueScheduler, currentNumberOfReinforcements)
	
	local actionSelectionFunction = self.actionSelectionFunction
	
	local randomProbability = RandomObject:NextNumber()
	
	local actionIndex
	
	currentEpsilon = currentEpsilon or self.epsilon
	
	selectedActionCountVector = selectedActionCountVector or {table.create(#actionVector[1], 0)}
	
	if (randomProbability <= currentEpsilon) then
		
		actionIndex = RandomObject:NextInteger(1, #actionVector[1])
	
	elseif (actionSelectionFunction == "Maximum") then
		
		actionIndex = selectIndexWithHighestValue(actionVector)
	
	elseif (actionSelectionFunction == "StableSoftmaxSampling") or (actionSelectionFunction == "StableBoltzmannSampling") then
		
		local stableActionProbabilityVector = calculateStableProbability(actionVector, self.temperature)
		
		actionIndex = sample(stableActionProbabilityVector)
		
	elseif (actionSelectionFunction == "SoftmaxSampling") or (actionSelectionFunction == "BoltzmannSampling") then

		local actionProbabilityVector = calculateProbability(actionVector, self.temperature)

		actionIndex = sample(actionProbabilityVector)
		
	elseif (actionSelectionFunction == "UpperConfidenceBound") then
		
		local actionUpperConfidenceBoundVector = calculateUpperConfidenceBound(actionVector, self.cValue, selectedActionCountVector, currentNumberOfReinforcements)
		
		actionIndex = selectIndexWithHighestValue(actionUpperConfidenceBoundVector)
		
	else
		
		error("Invalid action selection function.")
		
	end
	
	selectedActionCountVector[1][actionIndex] = selectedActionCountVector[1][actionIndex] + 1
	
	if (EpsilonValueScheduler) then currentEpsilon = EpsilonValueScheduler:calculate(currentEpsilon) end
	
	return actionIndex, selectedActionCountVector, currentEpsilon
	
end

function CategoricalPolicyBaseQuickSetup.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewCategoricalPolicyBaseQuickSetup = ReinforcementLearningBaseQuickSetup.new(parameterDictionary)
	
	setmetatable(NewCategoricalPolicyBaseQuickSetup, CategoricalPolicyBaseQuickSetup)
	
	NewCategoricalPolicyBaseQuickSetup:setName("CategoricalPolicyBaseQuickSetup")
	
	NewCategoricalPolicyBaseQuickSetup:setClassName("CategoricalPolicyQuickSetup")
	
	local epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	NewCategoricalPolicyBaseQuickSetup.actionSelectionFunction = parameterDictionary.actionSelectionFunction or defaultActionSelectionFunction
	
	NewCategoricalPolicyBaseQuickSetup.epsilon = epsilon or defaultEpsilon
	
	NewCategoricalPolicyBaseQuickSetup.temperature = parameterDictionary.temperature or defaultTemperature
	
	NewCategoricalPolicyBaseQuickSetup.cValue = parameterDictionary.cValue or defaultCValue
	
	NewCategoricalPolicyBaseQuickSetup.EpsilonValueScheduler = parameterDictionary.EpsilonValueScheduler
	
	NewCategoricalPolicyBaseQuickSetup.selectedActionCountVector = parameterDictionary.selectedActionCountVector
	
	NewCategoricalPolicyBaseQuickSetup.currentEpsilon = parameterDictionary.currentEpsilon or epsilon
	
	return NewCategoricalPolicyBaseQuickSetup
	
end

return CategoricalPolicyBaseQuickSetup]]></ProtectedString>
									<string name="ScriptGuid">{33BCCFD2-A044-43F7-8BDD-2D08A0A106BD}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">CategoricalPolicyBaseQuickSetup</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFA406B927DD140D88796ABCC004C6F62">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local ReinforcementLearningBaseQuickSetup = require(script.Parent.ReinforcementLearningBaseQuickSetup)

DiagonalGaussianPolicyBaseQuickSetup = {}

DiagonalGaussianPolicyBaseQuickSetup.__index = DiagonalGaussianPolicyBaseQuickSetup

setmetatable(DiagonalGaussianPolicyBaseQuickSetup, ReinforcementLearningBaseQuickSetup)

function DiagonalGaussianPolicyBaseQuickSetup.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewDiagonalGaussianPolicyBaseQuickSetup = ReinforcementLearningBaseQuickSetup.new(parameterDictionary)
	
	setmetatable(NewDiagonalGaussianPolicyBaseQuickSetup, DiagonalGaussianPolicyBaseQuickSetup)
	
	NewDiagonalGaussianPolicyBaseQuickSetup:setName("DiagonalGaussianPolicyBaseQuickSetup")
	
	NewDiagonalGaussianPolicyBaseQuickSetup:setClassName("DiagonalGaussianPolicyQuickSetup")
	
	return NewDiagonalGaussianPolicyBaseQuickSetup
	
end

return DiagonalGaussianPolicyBaseQuickSetup]]></ProtectedString>
									<string name="ScriptGuid">{816A77D7-866B-4DB6-A654-D8799E574035}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DiagonalGaussianPolicyBaseQuickSetup</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA7BCF4FEB1BC4C88B4C3CA59434B10CC">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local CategoricalPolicyBaseQuickSetup = require(script.Parent.CategoricalPolicyBaseQuickSetup)

QueuedCategoricalPolicyQuickSetup = {}

QueuedCategoricalPolicyQuickSetup.__index = QueuedCategoricalPolicyQuickSetup

setmetatable(QueuedCategoricalPolicyQuickSetup, CategoricalPolicyBaseQuickSetup)

local defaultShareExperienceReplay = false

local defaultShareEligibilityTrace = false

local defaultShareSelectedActionCountVector = false

local defaultShareCurrentEpsilon = true

local defaultShareEpsilonValueScheduler = true

local defaultShareCurrentNumberOfReinforcements = false

local defaultShareCurrentNumberOfEpisodes = false

function QueuedCategoricalPolicyQuickSetup.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewQueuedCategoricalPolicyQuickSetup = CategoricalPolicyBaseQuickSetup.new(parameterDictionary)
	
	setmetatable(NewQueuedCategoricalPolicyQuickSetup, QueuedCategoricalPolicyQuickSetup)
	
	NewQueuedCategoricalPolicyQuickSetup:setName("QueuedCategoricalPolicyQuickSetup")
	
	-- Share toggles

	NewQueuedCategoricalPolicyQuickSetup.shareExperienceReplay = NewQueuedCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareExperienceReplay or defaultShareExperienceReplay)

	NewQueuedCategoricalPolicyQuickSetup.shareEligibilityTrace = NewQueuedCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareEligibilityTrace or defaultShareEligibilityTrace)

	NewQueuedCategoricalPolicyQuickSetup.shareSelectedActionCountVector = NewQueuedCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareSelectedActionCountVector or defaultShareSelectedActionCountVector)

	NewQueuedCategoricalPolicyQuickSetup.shareCurrentEpsilon = NewQueuedCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentEpsilon or defaultShareCurrentEpsilon)

	NewQueuedCategoricalPolicyQuickSetup.shareEpsilonValueScheduler = NewQueuedCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentEpsilon or defaultShareEpsilonValueScheduler)

	NewQueuedCategoricalPolicyQuickSetup.shareCurrentNumberOfEpisodes = NewQueuedCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentNumberOfEpisodes or defaultShareCurrentNumberOfEpisodes)

	NewQueuedCategoricalPolicyQuickSetup.shareCurrentNumberOfReinforcements = NewQueuedCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentNumberOfReinforcements or defaultShareCurrentNumberOfReinforcements)

	-- Dictionaries

	NewQueuedCategoricalPolicyQuickSetup.ExperienceReplayDictionary = parameterDictionary.ExperienceReplayDictionary or {}

	NewQueuedCategoricalPolicyQuickSetup.EligibilityTraceDictionary = parameterDictionary.EligibilityTraceDictionary or {}

	NewQueuedCategoricalPolicyQuickSetup.previousFeatureVectorDictionary = parameterDictionary.previousFeatureVectorDictionary or {}

	NewQueuedCategoricalPolicyQuickSetup.previousActionDictionary = parameterDictionary.previousActionDictionary or {}

	NewQueuedCategoricalPolicyQuickSetup.selectedActionCountVectorDictionary = parameterDictionary.selectedActionCountVectorDictionary or {}

	NewQueuedCategoricalPolicyQuickSetup.currentEpsilonDictionary = parameterDictionary.currentEpsilonDictionary or {}

	NewQueuedCategoricalPolicyQuickSetup.EpsilonValueSchedulerDictionary = parameterDictionary.EpsilonValueSchedulerDictionary or {}

	NewQueuedCategoricalPolicyQuickSetup.currentNumberOfReinforcementsDictionary = parameterDictionary.currentNumberOfReinforcementsDictionary or {}

	NewQueuedCategoricalPolicyQuickSetup.currentNumberOfEpisodesDictionary = parameterDictionary.currentNumberOfEpisodesDictionary or {}
	
	-- Queues
	
	NewQueuedCategoricalPolicyQuickSetup.inputQueueArray = parameterDictionary.inputQueueArray or {}
	
	NewQueuedCategoricalPolicyQuickSetup.agentIndexOutputQueueArray = parameterDictionary.agentIndexOutputQueueArray or {}
	
	NewQueuedCategoricalPolicyQuickSetup.outputQueueArray = parameterDictionary.outputQueueArray or {}
	
	-- Debounce
	
	NewQueuedCategoricalPolicyQuickSetup.isRunning = false
	
	NewQueuedCategoricalPolicyQuickSetup:setReinforceFunction(function(agentIndex, currentFeatureVector, rewardValue, returnOriginalOutput)
		
		if (not NewQueuedCategoricalPolicyQuickSetup.isRunning) then error("Not currently running.") end

		local experienceReplayIndex = (NewQueuedCategoricalPolicyQuickSetup.shareExperienceReplay and 1) or agentIndex

		local eligibilityTraceIndex = (NewQueuedCategoricalPolicyQuickSetup.shareEligibilityTrace and 1) or agentIndex

		local selectedActionCountVectorIndex = (NewQueuedCategoricalPolicyQuickSetup.shareSelectedActionCountVector and 1) or agentIndex

		local currentEpsilonIndex = (NewQueuedCategoricalPolicyQuickSetup.shareCurrentEpsilon and 1) or agentIndex

		local epsilonValueSchedulerIndex = (NewQueuedCategoricalPolicyQuickSetup.shareEpsilonValueScheduler and 1) or agentIndex

		local currentEpsilonSchedulerIndex = (NewQueuedCategoricalPolicyQuickSetup.shareEpsilonValueScheduler and 1) or agentIndex

		local numberOfReinforcementsIndex = (NewQueuedCategoricalPolicyQuickSetup.shareCurrentNumberOfReinforcements and 1) or agentIndex

		local numberOfEpisodesIndex = (NewQueuedCategoricalPolicyQuickSetup.shareCurrentNumberOfEpisodes and 1) or agentIndex

		local previousFeatureVectorDictionary = NewQueuedCategoricalPolicyQuickSetup.previousFeatureVectorDictionary

		local previousActionDictionary = NewQueuedCategoricalPolicyQuickSetup.previousActionDictionary

		local selectedActionCountVectorDictionary = NewQueuedCategoricalPolicyQuickSetup.selectedActionCountVectorDictionary

		local currentEpsilonDictionary = NewQueuedCategoricalPolicyQuickSetup.currentEpsilonDictionary

		local currentNumberOfReinforcementsDictionary = NewQueuedCategoricalPolicyQuickSetup.currentNumberOfReinforcementsDictionary

		local currentNumberOfEpisodesDictionary = NewQueuedCategoricalPolicyQuickSetup.currentNumberOfEpisodesDictionary

		local previousFeatureVector = previousFeatureVectorDictionary[agentIndex]

		local previousAction = previousActionDictionary[agentIndex]

		local selectedActionCountVector = selectedActionCountVectorDictionary[selectedActionCountVectorIndex]

		local currentEpsilon = currentEpsilonDictionary[currentEpsilonIndex]

		local EpsilonValueScheduler = NewQueuedCategoricalPolicyQuickSetup.EpsilonValueSchedulerDictionary[epsilonValueSchedulerIndex]

		local ExperienceReplay = NewQueuedCategoricalPolicyQuickSetup.ExperienceReplayDictionary[experienceReplayIndex]

		local EligibilityTrace = NewQueuedCategoricalPolicyQuickSetup.EligibilityTraceDictionary[eligibilityTraceIndex]

		local currentNumberOfReinforcements = (currentNumberOfReinforcementsDictionary[numberOfReinforcementsIndex] or 0) + 1

		local currentNumberOfEpisodes = currentNumberOfEpisodesDictionary[numberOfEpisodesIndex] or 1
		
		local terminalStateValue 
		
		local isEpisodeEnd
		
		if (currentNumberOfReinforcements >= NewQueuedCategoricalPolicyQuickSetup.numberOfReinforcementsPerEpisode) then
			
			isEpisodeEnd = true
			
			terminalStateValue = 1

			currentNumberOfEpisodes = currentNumberOfEpisodes + 1

			currentNumberOfReinforcements = 0

		else
			
			isEpisodeEnd = false
			
			terminalStateValue = 0

			currentNumberOfReinforcements = currentNumberOfReinforcements + 1

		end
		
		local inputArray = {agentIndex, previousFeatureVector, previousAction, rewardValue, currentFeatureVector, terminalStateValue, isEpisodeEnd, ExperienceReplay, EligibilityTrace, selectedActionCountVector, currentEpsilon, EpsilonValueScheduler, currentNumberOfReinforcements}
		
		table.insert(NewQueuedCategoricalPolicyQuickSetup.inputQueueArray, inputArray)
		
		local agentIndexQueueOutputArray = NewQueuedCategoricalPolicyQuickSetup.agentIndexOutputQueueArray

		local outputQueueArray = NewQueuedCategoricalPolicyQuickSetup.outputQueueArray
		
		local outputQueueArrayIndex
		
		repeat
			
			task.wait()
			
			outputQueueArrayIndex = table.find(agentIndexQueueOutputArray, agentIndex)
			
		until (outputQueueArrayIndex)
		
		local action, actionValue, actionVector, selectedActionCountVector, currentEpsilon = table.unpack(outputQueueArray[outputQueueArrayIndex])
		
		table.remove(agentIndexQueueOutputArray, outputQueueArrayIndex)
		
		table.remove(outputQueueArray, outputQueueArrayIndex)

		previousActionDictionary[agentIndex] = action

		previousFeatureVectorDictionary[agentIndex] = currentFeatureVector
		
		selectedActionCountVectorDictionary[selectedActionCountVectorIndex] = selectedActionCountVector
		
		currentEpsilonDictionary[currentEpsilonIndex] = currentEpsilon
		
		currentNumberOfReinforcementsDictionary[agentIndex] = currentNumberOfReinforcements

		currentNumberOfEpisodesDictionary[agentIndex] = currentNumberOfEpisodes
		
		if (NewQueuedCategoricalPolicyQuickSetup.isOutputPrinted) then
			
			print("Agent index: " .. agentIndex .. "\t\tEpisode: " .. currentNumberOfEpisodes .. "\t\tReinforcement Count: " .. currentNumberOfReinforcements) 
			
		end

		if (returnOriginalOutput) then return actionVector end

		return action, actionValue
		
	end)
	
	NewQueuedCategoricalPolicyQuickSetup:setResetFunction(function()

		NewQueuedCategoricalPolicyQuickSetup.previousFeatureVectorDictionary = {}

		NewQueuedCategoricalPolicyQuickSetup.previousActionDictionary = {}

		NewQueuedCategoricalPolicyQuickSetup.selectedActionCountVectorDictionary = {}

		NewQueuedCategoricalPolicyQuickSetup.currentEpsilonDictionary = {}

		for _, EpsilonValueScheduler in ipairs(NewQueuedCategoricalPolicyQuickSetup.EpsilonValueSchedulerDictionary) do EpsilonValueScheduler:reset() end

		NewQueuedCategoricalPolicyQuickSetup.currentNumberOfReinforcementsDictionary  = {}

		NewQueuedCategoricalPolicyQuickSetup.currentNumberOfEpisodesDictionary  = {}

		for _, ExperienceReplay in ipairs(NewQueuedCategoricalPolicyQuickSetup.ExperienceReplayDictionary) do ExperienceReplay:reset() end

		for _, EligibilityTrace in ipairs(NewQueuedCategoricalPolicyQuickSetup.EligibilityTraceDictionary) do EligibilityTrace:reset() end

	end)
	
	return NewQueuedCategoricalPolicyQuickSetup
	
end

function QueuedCategoricalPolicyQuickSetup:start()
	
	if (self.isRunning) then error("It is already active.") end
	
	local functionToRun = coroutine.create(function()
		
		self.isRunning = true
		
		local Model = self.Model

		local numberOfReinforcementsPerEpisode = self.numberOfReinforcementsPerEpisode

		local updateFunction = self.updateFunction

		local episodeUpdateFunction = self.episodeUpdateFunction

		local inputQueueArray = self.inputQueueArray

		local agentIndexQueueOutputArray = self.agentIndexOutputQueueArray

		local outputQueueArray = self.outputQueueArray

		local ActionsList = Model:getActionsList()

		local agentIndex

		local previousFeatureVector

		local previousAction

		local rewardValue

		local currentFeatureVector

		local terminalStateValue

		local isEpisodeEnd

		local ExperienceReplay

		local EligibilityTrace
		
		local selectedActionCountVector
		
		local currentEpsilon
		
		local EpsilonValueScheduler
		
		local currentNumberOfReinforcements

		local isOriginalValueNotAVector

		local actionVector

		local actionIndex

		local action

		local actionValue

		local temporalDifferenceError

		local outputArray

		while(self.isRunning) do

			while (#inputQueueArray == 0) do task.wait() end
			
			pcall(function()
				
				agentIndex, previousFeatureVector, previousAction, rewardValue, currentFeatureVector, terminalStateValue, isEpisodeEnd, ExperienceReplay, EligibilityTrace, selectedActionCountVector, currentEpsilon, EpsilonValueScheduler, currentNumberOfReinforcements = table.unpack(inputQueueArray[1])

				isOriginalValueNotAVector = (type(currentFeatureVector) ~= "table")

				if (isOriginalValueNotAVector) then currentFeatureVector = {{currentFeatureVector}} end

				actionVector = Model:predict(currentFeatureVector, true)

				Model.EligibilityTrace = EligibilityTrace

				if (isOriginalValueNotAVector) then currentFeatureVector = currentFeatureVector[1][1] end

				actionIndex, selectedActionCountVector, currentEpsilon = self:selectAction(actionVector, selectedActionCountVector, currentEpsilon, EpsilonValueScheduler, currentNumberOfReinforcements)

				action = ActionsList[actionIndex]

				actionValue = actionVector[1][actionIndex]

				if (previousFeatureVector) then

					temporalDifferenceError = Model:categoricalUpdate(previousFeatureVector, previousAction, rewardValue, currentFeatureVector, terminalStateValue)

					if (updateFunction) then updateFunction(terminalStateValue, agentIndex) end

				end

				if (isEpisodeEnd) then

					Model:episodeUpdate(terminalStateValue)

					if episodeUpdateFunction then episodeUpdateFunction(terminalStateValue, agentIndex) end

				end

				if (ExperienceReplay) and (previousFeatureVector) then

					ExperienceReplay:addExperience(previousFeatureVector, previousAction, rewardValue, currentFeatureVector, terminalStateValue)

					ExperienceReplay:addTemporalDifferenceError(temporalDifferenceError)

					ExperienceReplay:run(function(storedPreviousFeatureVector, storedAction, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

						return Model:categoricalUpdate(storedPreviousFeatureVector, storedAction, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

					end)

				end

				outputArray = {action, actionValue, actionVector, selectedActionCountVector, currentEpsilon}
				
				table.insert(outputQueueArray, outputArray)

				table.insert(agentIndexQueueOutputArray, agentIndex)
				
			end)

			table.remove(inputQueueArray, 1)

		end
		
	end)
	
	coroutine.resume(functionToRun)
	
end

function QueuedCategoricalPolicyQuickSetup:stop()
	
	if (not self.isRunning) then error("It is not active.") end
	
	self.isRunning = false
	
end

return QueuedCategoricalPolicyQuickSetup]]></ProtectedString>
									<string name="ScriptGuid">{2F72DD29-3DD7-4958-AC7E-DF3AA5233286}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">QueuedCategoricalPolicy</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX65F1242E5B754C1BB2D5016FD13BC013">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DiagonalGaussianPolicyBaseQuickSetup = require(script.Parent.DiagonalGaussianPolicyBaseQuickSetup)

QueuedDiagonalGaussianPolicyQuickSetup = {}

QueuedDiagonalGaussianPolicyQuickSetup.__index = QueuedDiagonalGaussianPolicyQuickSetup

setmetatable(QueuedDiagonalGaussianPolicyQuickSetup, DiagonalGaussianPolicyBaseQuickSetup)

local defaultShareExperienceReplay = false

local defaultShareCurrentNumberOfReinforcements = false

local defaultShareCurrentNumberOfEpisodes = false

function QueuedDiagonalGaussianPolicyQuickSetup.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewQueuedDiagonalGaussianPolicyQuickSetup = DiagonalGaussianPolicyBaseQuickSetup.new(parameterDictionary)
	
	setmetatable(NewQueuedDiagonalGaussianPolicyQuickSetup, QueuedDiagonalGaussianPolicyQuickSetup)
	
	NewQueuedDiagonalGaussianPolicyQuickSetup:setName("QueuedDiagonalGaussianPolicyQuickSetup")
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.actionStandardDeviationVector = parameterDictionary.actionStandardDeviationVector
	
	-- Share toggles
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.shareExperienceReplay = NewQueuedDiagonalGaussianPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareExperienceReplay or defaultShareExperienceReplay)
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.shareCurrentNumberOfReinforcements = NewQueuedDiagonalGaussianPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentNumberOfReinforcements or defaultShareCurrentNumberOfReinforcements)
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.shareCurrentNumberOfEpisodes = NewQueuedDiagonalGaussianPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentNumberOfEpisodes or defaultShareCurrentNumberOfEpisodes)
	
	-- Dictionaries

	NewQueuedDiagonalGaussianPolicyQuickSetup.ExperienceReplayDictionary = parameterDictionary.ExperienceReplayDictionary or {}

	NewQueuedDiagonalGaussianPolicyQuickSetup.previousFeatureVectorDictionary = parameterDictionary.previousFeatureVectorDictionary or {}

	NewQueuedDiagonalGaussianPolicyQuickSetup.previousActionMeanVectorDictionary = parameterDictionary.previousActionMeanVectorDictionary or {}
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.previousActionNoiseVectorDictionary = parameterDictionary.previousActionNoiseVectorDictionary or {}
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcementsDictionary = parameterDictionary.currentNumberOfReinforcementsDictionary or {}
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodesDictionary = parameterDictionary.currentNumberOfEpisodesDictionary or {}
	
	-- Queues
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.inputQueueArray = parameterDictionary.inputQueueArray or {}
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.agentIndexOutputQueueArray = parameterDictionary.agentIndexOutputQueueArray or {}
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.outputQueueArray = parameterDictionary.outputQueueArray or {}
	
	-- Debounce
	
	NewQueuedDiagonalGaussianPolicyQuickSetup.isRunning = false
	
	NewQueuedDiagonalGaussianPolicyQuickSetup:setReinforceFunction(function(agentIndex, currentFeatureVector, rewardValue)
		
		if (not NewQueuedDiagonalGaussianPolicyQuickSetup.isRunning) then error("Not currently running.") end
		
		local experienceReplayIndex = (NewQueuedDiagonalGaussianPolicyQuickSetup.shareExperienceReplay and 1) or agentIndex
		
		local numberOfReinforcementsIndex = (NewQueuedDiagonalGaussianPolicyQuickSetup.shareCurrentNumberOfReinforcements and 1) or agentIndex
		
		local numberOfEpisodesIndex = (NewQueuedDiagonalGaussianPolicyQuickSetup.shareCurrentNumberOfEpisodes and 1) or agentIndex
		
		local previousFeatureVectorDictionary = NewQueuedDiagonalGaussianPolicyQuickSetup.previousFeatureVectorDictionary
		
		local previousActionMeanVectorDictionary = NewQueuedDiagonalGaussianPolicyQuickSetup.previousActionMeanVectorDictionary
		
		local previousActionNoiseVectorDictionary = NewQueuedDiagonalGaussianPolicyQuickSetup.previousActionNoiseVectorDictionary
		
		local currentNumberOfReinforcementsDictionary = NewQueuedDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcementsDictionary
		
		local currentNumberOfEpisodesDictionary = NewQueuedDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodesDictionary
		
		local previousFeatureVector = previousFeatureVectorDictionary[agentIndex]
		
		local previousActionMeanVector = previousActionMeanVectorDictionary[agentIndex]
		
		local previousActionNoiseVector = previousActionNoiseVectorDictionary[agentIndex]
		
		local ExperienceReplay = NewQueuedDiagonalGaussianPolicyQuickSetup.ExperienceReplayDictionary[experienceReplayIndex]
		
		local currentNumberOfReinforcements = currentNumberOfReinforcementsDictionary[numberOfReinforcementsIndex] or 0
		
		local currentNumberOfEpisodes = currentNumberOfEpisodesDictionary[numberOfEpisodesIndex] or 1
		
		local terminalStateValue 
		
		local isEpisodeEnd
		
		if (currentNumberOfReinforcements >= NewQueuedDiagonalGaussianPolicyQuickSetup.numberOfReinforcementsPerEpisode) then
			
			isEpisodeEnd = true
			
			terminalStateValue = 1

			currentNumberOfEpisodes = currentNumberOfEpisodes + 1

			currentNumberOfReinforcements = 0

		else
			
			isEpisodeEnd = false
			
			terminalStateValue = 0

			currentNumberOfReinforcements = currentNumberOfReinforcements + 1

		end
		
		local inputArray = {agentIndex, previousFeatureVector, previousActionMeanVector, previousActionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue, isEpisodeEnd, ExperienceReplay}
		
		table.insert(NewQueuedDiagonalGaussianPolicyQuickSetup.inputQueueArray, inputArray)
		
		local agentIndexQueueOutputArray = NewQueuedDiagonalGaussianPolicyQuickSetup.agentIndexOutputQueueArray

		local outputQueueArray = NewQueuedDiagonalGaussianPolicyQuickSetup.outputQueueArray
		
		local outputQueueArrayIndex
		
		repeat
			
			task.wait()
			
			outputQueueArrayIndex = table.find(agentIndexQueueOutputArray, agentIndex)
			
		until (outputQueueArrayIndex)
		
		local actionVector, currentActionMeanVector, currentActionNoiseVector = table.unpack(outputQueueArray[outputQueueArrayIndex])
		
		table.remove(agentIndexQueueOutputArray, outputQueueArrayIndex)
		
		table.remove(outputQueueArray, outputQueueArrayIndex)
		
		previousFeatureVectorDictionary[agentIndex] = currentFeatureVector

		previousActionMeanVectorDictionary[agentIndex] = currentActionMeanVector
		
		previousActionNoiseVectorDictionary[agentIndex] = currentActionNoiseVector

		currentNumberOfReinforcementsDictionary[agentIndex] = currentNumberOfReinforcements

		currentNumberOfEpisodesDictionary[agentIndex] = currentNumberOfEpisodes
		
		if (NewQueuedDiagonalGaussianPolicyQuickSetup.isOutputPrinted) then
			
			print("Agent index: " .. agentIndex .. "\t\tEpisode: " .. currentNumberOfEpisodes .. "\t\tReinforcement Count: " .. currentNumberOfReinforcements) 
			
		end

		return actionVector
		
	end)
	
	NewQueuedDiagonalGaussianPolicyQuickSetup:setResetFunction(function(agentIndex, currentFeatureVector, rewardValue)

		NewQueuedDiagonalGaussianPolicyQuickSetup.previousFeatureVectorDictionary = {}

		NewQueuedDiagonalGaussianPolicyQuickSetup.previousActionMeanVectorDictionary = {}

		NewQueuedDiagonalGaussianPolicyQuickSetup.previousActionNoiseVectorDictionary = {}

		NewQueuedDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcementsDictionary  = {}

		NewQueuedDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodesDictionary  = {}

		for _, ExperienceReplay in ipairs(NewQueuedDiagonalGaussianPolicyQuickSetup.ExperienceReplayDictionary) do ExperienceReplay:reset() end

	end)
	
	return NewQueuedDiagonalGaussianPolicyQuickSetup
	
end

function QueuedDiagonalGaussianPolicyQuickSetup:start()
	
	if (self.isRunning) then error("It is already active.") end
	
	local functionToRun = coroutine.create(function()
		
		self.isRunning = true
		
		local Model = self.Model
		
		local actionStandardDeviationVector = self.actionStandardDeviationVector

		local numberOfReinforcementsPerEpisode = self.numberOfReinforcementsPerEpisode

		local updateFunction = self.updateFunction

		local episodeUpdateFunction = self.episodeUpdateFunction

		local inputQueueArray = self.inputQueueArray

		local agentIndexQueueOutputArray = self.agentIndexOutputQueueArray

		local outputQueueArray = self.outputQueueArray

		local ActionsList = Model:getActionsList()

		local agentIndex

		local previousFeatureVector

		local previousActionMeanVector
		
		local previousActionNoiseVector

		local rewardValue

		local currentFeatureVector

		local terminalStateValue

		local isEpisodeEnd

		local ExperienceReplay
		
		local currentNumberOfReinforcements

		local isOriginalValueNotAVector

		local actionMeanVector

		local temporalDifferenceError
		
		local actionVectorDimensionSizeArray
		
		local actionVector
		
		local actionMeanVector
		
		local actionNoiseVector
		
		local scaledActionNoiseVector 
		
		local outputArray = {}

		while(self.isRunning) do

			while (#inputQueueArray == 0) do task.wait() end
			
			pcall(function()
				
				agentIndex, previousFeatureVector, previousActionMeanVector, previousActionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue, isEpisodeEnd, ExperienceReplay = table.unpack(inputQueueArray[1])

				isOriginalValueNotAVector = (type(currentFeatureVector) ~= "table")

				if (isOriginalValueNotAVector) then currentFeatureVector = {{currentFeatureVector}} end

				actionMeanVector = Model:predict(currentFeatureVector, true)

				actionVectorDimensionSizeArray = AqwamTensorLibrary:getDimensionSizeArray(actionMeanVector)

				actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor(actionVectorDimensionSizeArray, 0, 1)

				scaledActionNoiseVector = AqwamTensorLibrary:multiply(actionStandardDeviationVector, actionNoiseVector)

				actionVector = AqwamTensorLibrary:add(actionMeanVector, scaledActionNoiseVector)

				if (isOriginalValueNotAVector) then currentFeatureVector = currentFeatureVector[1][1] end

				if (previousFeatureVector) then

					temporalDifferenceError = Model:diagonalGaussianUpdate(previousFeatureVector, previousActionMeanVector, actionStandardDeviationVector, previousActionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

					if (updateFunction) then updateFunction(terminalStateValue, agentIndex) end

				end

				if (isEpisodeEnd) then

					Model:episodeUpdate(terminalStateValue)

					if episodeUpdateFunction then episodeUpdateFunction(terminalStateValue, agentIndex) end

				end

				if (ExperienceReplay) and (previousFeatureVector) then

					ExperienceReplay:addExperience(previousFeatureVector, previousActionMeanVector, actionStandardDeviationVector, previousActionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

					ExperienceReplay:addTemporalDifferenceError(temporalDifferenceError)

					ExperienceReplay:run(function(storedPreviousFeatureVector, storedActionMeanVector, storedActionStandardDeviationVector, storedActionNoiseVector, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

						return Model:diagonalGaussianUpdate(storedPreviousFeatureVector, storedActionMeanVector, storedActionStandardDeviationVector, storedActionNoiseVector, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

					end)

				end
				
				outputArray = {actionVector, actionMeanVector, actionNoiseVector}
				
				table.insert(outputQueueArray, outputArray)

				table.insert(agentIndexQueueOutputArray, agentIndex)
				
			end)

			table.remove(inputQueueArray, 1)

		end
		
	end)
	
	coroutine.resume(functionToRun)
	
end

function QueuedDiagonalGaussianPolicyQuickSetup:stop()
	
	if (not self.isRunning) then error("It is not active.") end
	
	self.isRunning = false
	
end

return QueuedDiagonalGaussianPolicyQuickSetup]]></ProtectedString>
									<string name="ScriptGuid">{1F0B0427-ABF1-4BF3-9821-D74FB74A00EF}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">QueuedDiagonalGaussianPolicy</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAAB72B1FF43E45C6A3E9D6B85DC842F6">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local CategoricalPolicyBaseQuickSetup = require(script.Parent.CategoricalPolicyBaseQuickSetup)

ParallelCategoricalPolicyQuickSetup = {}

ParallelCategoricalPolicyQuickSetup.__index = ParallelCategoricalPolicyQuickSetup

setmetatable(ParallelCategoricalPolicyQuickSetup, CategoricalPolicyBaseQuickSetup)

local defaultShareExperienceReplay = false

local defaultShareEligibilityTrace = false

local defaultShareSelectedActionCountVector = false

local defaultShareCurrentEpsilon = true

local defaultShareEpsilonValueScheduler = true

local defaultShareCurrentNumberOfReinforcements = false

local defaultShareCurrentNumberOfEpisodes = false

function ParallelCategoricalPolicyQuickSetup.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewParallelCategoricalPolicyQuickSetup = CategoricalPolicyBaseQuickSetup.new(parameterDictionary)
	
	setmetatable(NewParallelCategoricalPolicyQuickSetup, ParallelCategoricalPolicyQuickSetup)
	
	NewParallelCategoricalPolicyQuickSetup:setName("ParallelCategoricalPolicyQuickSetup")
	
	-- Share toggles
	
	NewParallelCategoricalPolicyQuickSetup.shareExperienceReplay = NewParallelCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareExperienceReplay or defaultShareExperienceReplay)
	
	NewParallelCategoricalPolicyQuickSetup.shareEligibilityTrace = NewParallelCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareEligibilityTrace or defaultShareEligibilityTrace)
	
	NewParallelCategoricalPolicyQuickSetup.shareSelectedActionCountVector = NewParallelCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareSelectedActionCountVector or defaultShareSelectedActionCountVector)
	
	NewParallelCategoricalPolicyQuickSetup.shareCurrentEpsilon = NewParallelCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentEpsilon or defaultShareCurrentEpsilon)
	
	NewParallelCategoricalPolicyQuickSetup.shareEpsilonValueScheduler = NewParallelCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentEpsilon or defaultShareEpsilonValueScheduler)
	
	NewParallelCategoricalPolicyQuickSetup.shareCurrentNumberOfEpisodes = NewParallelCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentNumberOfEpisodes or defaultShareCurrentNumberOfEpisodes)
	
	NewParallelCategoricalPolicyQuickSetup.shareCurrentNumberOfReinforcements = NewParallelCategoricalPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentNumberOfReinforcements or defaultShareCurrentNumberOfReinforcements)
	
	-- Dictionaries

	NewParallelCategoricalPolicyQuickSetup.ExperienceReplayDictionary = parameterDictionary.ExperienceReplayDictionary or {}

	NewParallelCategoricalPolicyQuickSetup.EligibilityTraceDictionary = parameterDictionary.EligibilityTraceDictionary or {}

	NewParallelCategoricalPolicyQuickSetup.previousFeatureVectorDictionary = parameterDictionary.previousFeatureVectorDictionary or {}

	NewParallelCategoricalPolicyQuickSetup.previousActionDictionary = parameterDictionary.previousActionDictionary or {}
	
	NewParallelCategoricalPolicyQuickSetup.selectedActionCountVectorDictionary = parameterDictionary.selectedActionCountVectorDictionary or {}
	
	NewParallelCategoricalPolicyQuickSetup.currentEpsilonDictionary = parameterDictionary.currentEpsilonDictionary or {}
	
	NewParallelCategoricalPolicyQuickSetup.EpsilonValueSchedulerDictionary = parameterDictionary.EpsilonValueSchedulerDictionary or {}
	
	NewParallelCategoricalPolicyQuickSetup.currentNumberOfReinforcementsDictionary = parameterDictionary.currentNumberOfReinforcementsDictionary or {}
	
	NewParallelCategoricalPolicyQuickSetup.currentNumberOfEpisodesDictionary = parameterDictionary.currentNumberOfEpisodesDictionary or {}
	
	NewParallelCategoricalPolicyQuickSetup:setReinforceFunction(function(agentIndex, currentFeatureVector, rewardValue, returnOriginalOutput)
		
		local Model = NewParallelCategoricalPolicyQuickSetup.Model

		if (not Model) then error("No model.") end
		
		local isOriginalValueNotAVector = (type(currentFeatureVector) ~= "table")
		
		local numberOfReinforcementsPerEpisode = NewParallelCategoricalPolicyQuickSetup.numberOfReinforcementsPerEpisode
		
		local experienceReplayIndex = (NewParallelCategoricalPolicyQuickSetup.shareExperienceReplay and 1) or agentIndex
		
		local eligibilityTraceIndex = (NewParallelCategoricalPolicyQuickSetup.shareEligibilityTrace and 1) or agentIndex
		
		local selectedActionCountVectorIndex = (NewParallelCategoricalPolicyQuickSetup.shareSelectedActionCountVector and 1) or agentIndex
		
		local currentEpsilonIndex = (NewParallelCategoricalPolicyQuickSetup.shareCurrentEpsilon and 1) or agentIndex
		
		local epsilonValueSchedulerIndex = (NewParallelCategoricalPolicyQuickSetup.shareEpsilonValueScheduler and 1) or agentIndex
		
		local currentEpsilonSchedulerIndex = (NewParallelCategoricalPolicyQuickSetup.shareEpsilonValueScheduler and 1) or agentIndex
		
		local numberOfReinforcementsIndex = (NewParallelCategoricalPolicyQuickSetup.shareCurrentNumberOfReinforcements and 1) or agentIndex
		
		local numberOfEpisodesIndex = (NewParallelCategoricalPolicyQuickSetup.shareCurrentNumberOfEpisodes and 1) or agentIndex
		
		local previousFeatureVectorDictionary = NewParallelCategoricalPolicyQuickSetup.previousFeatureVectorDictionary
		
		local previousActionDictionary = NewParallelCategoricalPolicyQuickSetup.previousActionDictionary
		
		local selectedActionCountVectorDictionary = NewParallelCategoricalPolicyQuickSetup.selectedActionCountVectorDictionary
		
		local currentEpsilonDictionary = NewParallelCategoricalPolicyQuickSetup.currentEpsilonDictionary
		
		local currentNumberOfReinforcementsDictionary = NewParallelCategoricalPolicyQuickSetup.currentNumberOfReinforcementsDictionary
		
		local currentNumberOfEpisodesDictionary = NewParallelCategoricalPolicyQuickSetup.currentNumberOfEpisodesDictionary
		
		local previousFeatureVector = previousFeatureVectorDictionary[agentIndex]
		
		local previousAction = previousActionDictionary[agentIndex]
		
		local selectedActionCountVector = selectedActionCountVectorDictionary[selectedActionCountVectorIndex]
		
		local currentEpsilon = currentEpsilonDictionary[currentEpsilonIndex]
		
		local EpsilonValueScheduler = NewParallelCategoricalPolicyQuickSetup.EpsilonValueSchedulerDictionary[epsilonValueSchedulerIndex]
		
		local ExperienceReplay = NewParallelCategoricalPolicyQuickSetup.ExperienceReplayDictionary[experienceReplayIndex]
		
		local EligibilityTrace = NewParallelCategoricalPolicyQuickSetup.EligibilityTraceDictionary[eligibilityTraceIndex]
		
		local currentNumberOfReinforcements = (currentNumberOfReinforcementsDictionary[numberOfReinforcementsIndex] or 0) + 1
		
		local currentNumberOfEpisodes = currentNumberOfEpisodesDictionary[numberOfEpisodesIndex] or 1
		
		local ActionsList = Model:getActionsList()

		local actionVector = Model:predict(currentFeatureVector, true)
		
		local isEpisodeEnd = (currentNumberOfReinforcements >= numberOfReinforcementsPerEpisode)

		local terminalStateValue = (isEpisodeEnd and 1) or 0

		if (isOriginalValueNotAVector) then currentFeatureVector = currentFeatureVector[1][1] end

		local actionIndex, selectedActionCountVector = NewParallelCategoricalPolicyQuickSetup:selectAction(actionVector, selectedActionCountVector, currentEpsilon, EpsilonValueScheduler, currentNumberOfReinforcements)

		local action = ActionsList[actionIndex]

		local actionValue = actionVector[1][actionIndex]
		
		local temporalDifferenceError

		if (previousFeatureVector) then

			local updateFunction = NewParallelCategoricalPolicyQuickSetup.updateFunction

			temporalDifferenceError = Model:categoricalUpdate(previousFeatureVector, previousAction, rewardValue, currentFeatureVector, terminalStateValue)

			if (updateFunction) then updateFunction(terminalStateValue) end

		end

		if (isEpisodeEnd) then

			local episodeUpdateFunction = NewParallelCategoricalPolicyQuickSetup.episodeUpdateFunction

			currentNumberOfReinforcements = 0

			currentNumberOfEpisodes = currentNumberOfEpisodes + 1

			Model:episodeUpdate(terminalStateValue)

			if episodeUpdateFunction then episodeUpdateFunction(terminalStateValue) end

		end

		if (ExperienceReplay) and (previousFeatureVector) then

			ExperienceReplay:addExperience(previousFeatureVector, previousAction, rewardValue, currentFeatureVector, terminalStateValue)

			ExperienceReplay:addTemporalDifferenceError(temporalDifferenceError)

			ExperienceReplay:run(function(storedPreviousFeatureVector, storedAction, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

				return Model:categoricalUpdate(storedPreviousFeatureVector, storedAction, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

			end)

		end
		
		previousFeatureVectorDictionary[agentIndex] = currentFeatureVector

		previousActionDictionary[agentIndex] = action
		
		selectedActionCountVectorDictionary[selectedActionCountVectorIndex] = selectedActionCountVector
		
		currentEpsilonDictionary[actionIndex] = currentEpsilon

		currentNumberOfReinforcementsDictionary[agentIndex] = currentNumberOfReinforcements

		currentNumberOfEpisodesDictionary[agentIndex] = currentNumberOfEpisodes
		
		if (NewParallelCategoricalPolicyQuickSetup.isOutputPrinted) then
			
			print("Agent index: " .. agentIndex .. "\t\tEpisode: " .. currentNumberOfEpisodes .. "\t\tReinforcement Count: " .. currentNumberOfReinforcements) 
			
		end

		if (returnOriginalOutput) then return actionVector end

		return action, actionValue
		
	end)
	
	NewParallelCategoricalPolicyQuickSetup:setResetFunction(function()

		NewParallelCategoricalPolicyQuickSetup.previousFeatureVectorDictionary = {}

		NewParallelCategoricalPolicyQuickSetup.previousActionDictionary = {}

		NewParallelCategoricalPolicyQuickSetup.selectedActionCountVectorDictionary = {}
		
		NewParallelCategoricalPolicyQuickSetup.currentEpsilonDictionary = {}
		
		for _, EpsilonValueScheduler in ipairs(NewParallelCategoricalPolicyQuickSetup.EpsilonValueSchedulerDictionary) do EpsilonValueScheduler:reset() end

		NewParallelCategoricalPolicyQuickSetup.currentNumberOfReinforcementsDictionary  = {}

		NewParallelCategoricalPolicyQuickSetup.currentNumberOfEpisodesDictionary  = {}

		for _, ExperienceReplay in ipairs(NewParallelCategoricalPolicyQuickSetup.ExperienceReplayDictionary) do ExperienceReplay:reset() end

		for _, EligibilityTrace in ipairs(NewParallelCategoricalPolicyQuickSetup.EligibilityTraceDictionary) do EligibilityTrace:reset() end

	end)
	
	return NewParallelCategoricalPolicyQuickSetup
	
end

return ParallelCategoricalPolicyQuickSetup]]></ProtectedString>
									<string name="ScriptGuid">{86A76229-0DE3-44DA-B89B-E9734078173B}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ParallelCategoricalPolicy</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX714C3045A5AA4FDD98F8BBB779EAC775">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DiagonalGaussianPolicyBaseQuickSetup = require(script.Parent.DiagonalGaussianPolicyBaseQuickSetup)

ParallelDiagonalGaussianPolicyQuickSetup = {}

ParallelDiagonalGaussianPolicyQuickSetup.__index = ParallelDiagonalGaussianPolicyQuickSetup

setmetatable(ParallelDiagonalGaussianPolicyQuickSetup, DiagonalGaussianPolicyBaseQuickSetup)

local defaultShareExperienceReplay = false

local defaultShareCurrentNumberOfReinforcements = false

local defaultShareCurrentNumberOfEpisodes = false

function ParallelDiagonalGaussianPolicyQuickSetup.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewParallelDiagonalGaussianPolicyQuickSetup = DiagonalGaussianPolicyBaseQuickSetup.new(parameterDictionary)
	
	setmetatable(NewParallelDiagonalGaussianPolicyQuickSetup, ParallelDiagonalGaussianPolicyQuickSetup)
	
	NewParallelDiagonalGaussianPolicyQuickSetup:setName("ParallelDiagonalGaussianPolicyQuickSetup")
	
	NewParallelDiagonalGaussianPolicyQuickSetup.actionStandardDeviationVector = parameterDictionary.actionStandardDeviationVector
	
	-- Share toggles
	
	NewParallelDiagonalGaussianPolicyQuickSetup.shareExperienceReplay = NewParallelDiagonalGaussianPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareExperienceReplay or defaultShareExperienceReplay)
	
	NewParallelDiagonalGaussianPolicyQuickSetup.shareCurrentNumberOfReinforcements = NewParallelDiagonalGaussianPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentNumberOfReinforcements or defaultShareCurrentNumberOfReinforcements)
	
	NewParallelDiagonalGaussianPolicyQuickSetup.shareCurrentNumberOfEpisodes = NewParallelDiagonalGaussianPolicyQuickSetup:getValueOrDefaultValue(parameterDictionary.shareCurrentNumberOfEpisodes or defaultShareCurrentNumberOfEpisodes)
	
	-- Dictionaries

	NewParallelDiagonalGaussianPolicyQuickSetup.ExperienceReplayDictionary = parameterDictionary.ExperienceReplayDictionary or {}

	NewParallelDiagonalGaussianPolicyQuickSetup.previousFeatureVectorDictionary = parameterDictionary.previousFeatureVectorDictionary or {}

	NewParallelDiagonalGaussianPolicyQuickSetup.previousActionMeanVectorDictionary = parameterDictionary.previousActionMeanVectorDictionary or {}
	
	NewParallelDiagonalGaussianPolicyQuickSetup.previousActionNoiseVectorDictionary = parameterDictionary.previousActionNoiseVectorDictionary or {}
	
	NewParallelDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcementsDictionary = parameterDictionary.currentNumberOfReinforcementsDictionary or {}
	
	NewParallelDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodesDictionary = parameterDictionary.currentNumberOfEpisodesDictionary or {}
	
	NewParallelDiagonalGaussianPolicyQuickSetup:setReinforceFunction(function(agentIndex, currentFeatureVector, rewardValue)
		
		local Model = NewParallelDiagonalGaussianPolicyQuickSetup.Model

		if (not Model) then error("No model.") end
		
		local actionStandardDeviationVector = NewParallelDiagonalGaussianPolicyQuickSetup.actionStandardDeviationVector
		
		local numberOfReinforcementsPerEpisode = NewParallelDiagonalGaussianPolicyQuickSetup.numberOfReinforcementsPerEpisode
		
		local experienceReplayIndex = (NewParallelDiagonalGaussianPolicyQuickSetup.shareExperienceReplay and 1) or agentIndex
		
		local numberOfReinforcementsIndex = (NewParallelDiagonalGaussianPolicyQuickSetup.shareCurrentNumberOfReinforcements and 1) or agentIndex
		
		local numberOfEpisodesIndex = (NewParallelDiagonalGaussianPolicyQuickSetup.shareCurrentNumberOfEpisodes and 1) or agentIndex
		
		local previousFeatureVectorDictionary = NewParallelDiagonalGaussianPolicyQuickSetup.previousFeatureVectorDictionary
		
		local previousActionMeanVectorDictionary = NewParallelDiagonalGaussianPolicyQuickSetup.previousActionMeanVectorDictionary
		
		local previousActionNoiseVectorDictionary = NewParallelDiagonalGaussianPolicyQuickSetup.previousActionNoiseVectorDictionary
		
		local currentNumberOfReinforcementsDictionary = NewParallelDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcementsDictionary
		
		local currentNumberOfEpisodesDictionary = NewParallelDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodesDictionary
		
		local previousFeatureVector = previousFeatureVectorDictionary[agentIndex]
		
		local previousActionMeanVector = previousActionMeanVectorDictionary[agentIndex]
		
		local previousActionNoiseVector = previousActionNoiseVectorDictionary[agentIndex]
		
		local ExperienceReplay = NewParallelDiagonalGaussianPolicyQuickSetup.ExperienceReplayDictionary[experienceReplayIndex]
		
		local currentNumberOfReinforcements = currentNumberOfReinforcementsDictionary[numberOfReinforcementsIndex] or 0
		
		local currentNumberOfEpisodes = currentNumberOfEpisodesDictionary[numberOfEpisodesIndex] or 1
		
		local currentActionMeanVector = Model:predict(currentFeatureVector, true)
		
		local actionVectorDimensionSizeArray = AqwamTensorLibrary:getDimensionSizeArray(currentActionMeanVector)

		local currentActionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor(actionVectorDimensionSizeArray, 0, 1)

		local currentScaledActionNoiseVector = AqwamTensorLibrary:multiply(actionStandardDeviationVector, currentActionNoiseVector)

		local actionVector = AqwamTensorLibrary:add(currentActionMeanVector, currentScaledActionNoiseVector)

		local isEpisodeEnd = (currentNumberOfReinforcements >= numberOfReinforcementsPerEpisode)

		local terminalStateValue = (isEpisodeEnd and 1) or 0

		local temporalDifferenceError

		if (previousFeatureVector) then

			local updateFunction = NewParallelDiagonalGaussianPolicyQuickSetup.updateFunction

			temporalDifferenceError = Model:diagonalGaussianUpdate(previousFeatureVector, previousActionMeanVector, actionStandardDeviationVector, previousActionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

			if (updateFunction) then updateFunction(terminalStateValue) end

		end

		if (isEpisodeEnd) then

			local episodeUpdateFunction = NewParallelDiagonalGaussianPolicyQuickSetup.episodeUpdateFunction

			currentNumberOfReinforcements = 0

			currentNumberOfEpisodes = currentNumberOfEpisodes + 1

			Model:episodeUpdate(terminalStateValue)

			if episodeUpdateFunction then episodeUpdateFunction(terminalStateValue) end

		end

		if (ExperienceReplay) and (previousFeatureVector) then

			ExperienceReplay:addExperience(previousFeatureVector, previousActionMeanVector, actionStandardDeviationVector, previousActionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

			ExperienceReplay:addTemporalDifferenceError(temporalDifferenceError)

			ExperienceReplay:run(function(storedPreviousFeatureVector, storedActionMeanVector, storedActionStandardDeviationVector, storedActionNoiseVector, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

				return Model:diagonalGaussianUpdate(storedPreviousFeatureVector, storedActionMeanVector, storedActionStandardDeviationVector, storedActionNoiseVector, storedRewardValue, storedCurrentFeatureVector, storedTerminalStateValue)

			end)

		end
		
		previousFeatureVectorDictionary[agentIndex] = currentFeatureVector

		previousActionMeanVectorDictionary[agentIndex] = currentActionMeanVector
		
		previousActionNoiseVectorDictionary[agentIndex] = currentActionNoiseVector

		currentNumberOfReinforcementsDictionary[agentIndex] = currentNumberOfReinforcements

		currentNumberOfEpisodesDictionary[agentIndex] = currentNumberOfEpisodes
		
		if (NewParallelDiagonalGaussianPolicyQuickSetup.isOutputPrinted) then
			
			print("Agent index: " .. agentIndex .. "\t\tEpisode: " .. currentNumberOfEpisodes .. "\t\tReinforcement Count: " .. currentNumberOfReinforcements) 
			
		end

		return actionVector
		
	end)
	
	NewParallelDiagonalGaussianPolicyQuickSetup:setResetFunction(function(agentIndex, currentFeatureVector, rewardValue)
		
		NewParallelDiagonalGaussianPolicyQuickSetup.previousFeatureVectorDictionary = {}

		NewParallelDiagonalGaussianPolicyQuickSetup.previousActionMeanVectorDictionary = {}

		NewParallelDiagonalGaussianPolicyQuickSetup.previousActionNoiseVectorDictionary = {}

		NewParallelDiagonalGaussianPolicyQuickSetup.currentNumberOfReinforcementsDictionary  = {}

		NewParallelDiagonalGaussianPolicyQuickSetup.currentNumberOfEpisodesDictionary  = {}

		for _, ExperienceReplay in ipairs(NewParallelDiagonalGaussianPolicyQuickSetup.ExperienceReplayDictionary) do ExperienceReplay:reset() end
		
	end)
	
	return NewParallelDiagonalGaussianPolicyQuickSetup
	
end

return ParallelDiagonalGaussianPolicyQuickSetup]]></ProtectedString>
									<string name="ScriptGuid">{CAFBF59F-6D74-48D0-8116-A502E5CE0D10}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ParallelDiagonalGaussianPolicy</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX1E5FCC1C03EE423C8E19994D1BCA1251">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Optimizers</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX4D7BD6A14AC949A8942D8708BD1F873B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

RootMeanSquarePropagationOptimizer = {}

RootMeanSquarePropagationOptimizer.__index = RootMeanSquarePropagationOptimizer

setmetatable(RootMeanSquarePropagationOptimizer, BaseOptimizer)

local defaultBeta = 0.1

local defaultWeightDecayRate = 0

local defaultEpsilon = 1e-16

function RootMeanSquarePropagationOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewRootMeanSquarePropagationOptimizer = BaseOptimizer.new(parameterDictionary)
	
	setmetatable(NewRootMeanSquarePropagationOptimizer, RootMeanSquarePropagationOptimizer)
	
	NewRootMeanSquarePropagationOptimizer:setName("RootMeanSquarePropagation")
	
	NewRootMeanSquarePropagationOptimizer.beta = parameterDictionary.beta or defaultBeta
	
	NewRootMeanSquarePropagationOptimizer.weightDecayRate = NewRootMeanSquarePropagationOptimizer.weightDecayRate or defaultWeightDecayRate
	
	NewRootMeanSquarePropagationOptimizer.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	--------------------------------------------------------------------------------
	
	NewRootMeanSquarePropagationOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewRootMeanSquarePropagationOptimizer.optimizerInternalParameterArray or {}
		
		local previousVelocity = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local beta = NewRootMeanSquarePropagationOptimizer.beta
		
		local weightDecayRate = NewRootMeanSquarePropagationOptimizer.weightDecayRate
		
		local gradientMatrix = costFunctionDerivativeMatrix

		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end

		local squaredCostFunctionDerivativeMatrix = AqwamTensorLibrary:power(gradientMatrix, 2)

		local vMatrixPart1 = AqwamTensorLibrary:multiply(beta, previousVelocity)

		local vMatrixPart2 = AqwamTensorLibrary:multiply((1 - beta), squaredCostFunctionDerivativeMatrix)

		local velocityMatrix = AqwamTensorLibrary:add(vMatrixPart1, vMatrixPart2)

		local velocityNonZeroDivisorMatrix = AqwamTensorLibrary:add(velocityMatrix, NewRootMeanSquarePropagationOptimizer.epsilon)

		local squaredRootVelocityMatrix = AqwamTensorLibrary:applyFunction(math.sqrt, velocityNonZeroDivisorMatrix)

		local costFunctionDerivativeMatrixPart1 = AqwamTensorLibrary:divide(gradientMatrix, squaredRootVelocityMatrix)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrixPart1)

		NewRootMeanSquarePropagationOptimizer.optimizerInternalParameterArray = {velocityMatrix}

		return costFunctionDerivativeMatrix
		
	end)
	
	return NewRootMeanSquarePropagationOptimizer
	
end

function RootMeanSquarePropagationOptimizer:setBeta(beta)
	
	self.beta = beta
	
end

function RootMeanSquarePropagationOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

function RootMeanSquarePropagationOptimizer:setEpsilon(epsilon)

	self.epsilon = epsilon

end

return RootMeanSquarePropagationOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{063FF75C-21A6-4CEB-BEAA-5350036948CC}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">RootMeanSquarePropagation</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD03E769A4BA348848DFD3BFB2521328B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

NesterovAcceleratedAdaptiveMomentEstimationOptimizer = {}

NesterovAcceleratedAdaptiveMomentEstimationOptimizer.__index = NesterovAcceleratedAdaptiveMomentEstimationOptimizer

setmetatable(NesterovAcceleratedAdaptiveMomentEstimationOptimizer, BaseOptimizer)

local defaultBeta1 = 0.9

local defaultBeta2 = 0.999

local defaultWeightDecayRate = 0

local defaultEpsilon = 1e-16

function NesterovAcceleratedAdaptiveMomentEstimationOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer = BaseOptimizer.new(parameterDictionary)

	setmetatable(NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer, NesterovAcceleratedAdaptiveMomentEstimationOptimizer)
	
	NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer:setName("NesterovAcceleratedAdaptiveMomentEstimation")
	
	NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.beta1 = parameterDictionary.beta1 or defaultBeta1

	NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.beta2 = parameterDictionary.beta2 or defaultBeta2
	
	NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.weightDecayRate = parameterDictionary.weightDecayRate or defaultWeightDecayRate

	NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	--------------------------------------------------------------------------------
	
	NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.optimizerInternalParameterArray or {}
		
		local previousMMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)

		local previousNMatrix = optimizerInternalParameterArray[2] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local timeValue = (optimizerInternalParameterArray[3] or 0) + 1
		
		local beta1 = NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.beta1
		
		local beta2 = NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.beta2
		
		local weightDecayRate = NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.weightDecayRate
		
		local gradientMatrix = costFunctionDerivativeMatrix
		
		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end
		
		local oneMinusBeta1 = (1 - beta1)

		local meanCostFunctionDerivativeMatrix = AqwamTensorLibrary:divide(gradientMatrix, oneMinusBeta1)

		local mMatrixPart1 = AqwamTensorLibrary:multiply(beta1, previousMMatrix)

		local mMatrixPart2 = AqwamTensorLibrary:multiply(oneMinusBeta1, gradientMatrix)

		local mMatrix = AqwamTensorLibrary:add(mMatrixPart1, mMatrixPart2)

		local meanMMatrix = AqwamTensorLibrary:divide(mMatrix, oneMinusBeta1)

		local squaredGradientDerivativeMatrix = AqwamTensorLibrary:power(gradientMatrix, 2)

		local nMatrixPart1 = AqwamTensorLibrary:multiply(beta2, previousNMatrix)

		local nMatrixPart2 = AqwamTensorLibrary:multiply((1 - beta2), squaredGradientDerivativeMatrix)

		local nMatrix = AqwamTensorLibrary:add(nMatrixPart1, nMatrixPart2)
		
		local multipliedNMatrix = AqwamTensorLibrary:multiply(beta2, nMatrix)

		local meanNMatrix = AqwamTensorLibrary:divide(multipliedNMatrix, (1 - math.pow(beta2, timeValue)))

		local finalMMatrixPart1 = AqwamTensorLibrary:multiply(oneMinusBeta1, meanCostFunctionDerivativeMatrix)

		local finalMMatrixPart2 = AqwamTensorLibrary:multiply(beta1, meanMMatrix)

		local finalMMatrix = AqwamTensorLibrary:add(finalMMatrixPart1, finalMMatrixPart2)

		local squareRootedDivisor = AqwamTensorLibrary:applyFunction(math.sqrt, meanNMatrix)

		local finalDivisor = AqwamTensorLibrary:add(squareRootedDivisor, NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.epsilon)

		local costFunctionDerivativeMatrixPart1 = AqwamTensorLibrary:divide(finalMMatrix, finalDivisor)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrixPart1)
		
		NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer.optimizerInternalParameterArray = {mMatrix, nMatrix, timeValue}

		return costFunctionDerivativeMatrix
		
	end)
	
	return NewNesterovAcceleratedAdaptiveMomentEstimationOptimizer

end

function NesterovAcceleratedAdaptiveMomentEstimationOptimizer:setBeta1(beta1)
	
	self.beta1 = beta1
	
end

function NesterovAcceleratedAdaptiveMomentEstimationOptimizer:setBeta2(beta2)
		
	self.beta2 = beta2
	
end

function NesterovAcceleratedAdaptiveMomentEstimationOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

function NesterovAcceleratedAdaptiveMomentEstimationOptimizer:setEpsilon(epsilon)

	self.epsilon = epsilon

end

return NesterovAcceleratedAdaptiveMomentEstimationOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{9E48ACB2-3E7E-4ABA-8A68-A711830DB33D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">NesterovAcceleratedAdaptiveMomentEstimation</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFC1B01372B4D4140B678F6E7DB66EBAD">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

MomentumOptimizer = {}

MomentumOptimizer.__index = MomentumOptimizer

setmetatable(MomentumOptimizer, BaseOptimizer)

local defaultDecayRate = 0.1

local defaultWeightDecayRate = 0

function MomentumOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewMomentumOptimizer = BaseOptimizer.new(parameterDictionary)
	
	setmetatable(NewMomentumOptimizer, MomentumOptimizer)
	
	NewMomentumOptimizer:setName("Momentum")
	
	NewMomentumOptimizer.decayRate = parameterDictionary.decayRate or defaultDecayRate
	
	NewMomentumOptimizer.weightDecayRate = NewMomentumOptimizer.weightDecayRate or defaultWeightDecayRate
	
	--------------------------------------------------------------------------------
	
	NewMomentumOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewMomentumOptimizer.optimizerInternalParameterArray or {}
		
		local previousVelocityMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local weightDecayRate = NewMomentumOptimizer.weightDecayRate

		local gradientMatrix = costFunctionDerivativeMatrix

		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end
		
		local velocityMatrixPart1 = AqwamTensorLibrary:multiply(NewMomentumOptimizer.decayRate, previousVelocityMatrix)

		local velocityMatrixPart2 = AqwamTensorLibrary:multiply(learningRate, gradientMatrix)

		local velocityMatrix = AqwamTensorLibrary:add(velocityMatrixPart1, velocityMatrixPart2)

		costFunctionDerivativeMatrix = velocityMatrix
		
		NewMomentumOptimizer.optimizerInternalParameterArray = {velocityMatrix}

		return costFunctionDerivativeMatrix
		
	end)
	
	return NewMomentumOptimizer
	
end

function MomentumOptimizer:setDecayRate(decayRate)
	
	self.decayRate = decayRate
	
end

function MomentumOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

return MomentumOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{67D8A4C6-0B4C-493C-B421-5B26E9045592}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Momentum</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX523E87678341452FAA7772D45D900B36">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

GravityOptimizer = {}

GravityOptimizer.__index = GravityOptimizer

setmetatable(GravityOptimizer, BaseOptimizer)

local defaultInitialStepSize = 0.01

local defaultMovingAverage = 0.9

local defaultWeightDecayRate = 0

local function calculateGaussianDensity(mean, standardDeviation)

	local exponentStep1 = math.pow(mean, 2)

	local exponentPart2 = math.pow(standardDeviation, 2)

	local exponentStep3 = exponentStep1 / exponentPart2

	local exponentStep4 = -0.5 * exponentStep3

	local exponentWithTerms = math.exp(exponentStep4)

	local divisor = standardDeviation * math.sqrt(2 * math.pi)

	local gaussianDensity = exponentWithTerms / divisor

	return gaussianDensity

end

function GravityOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewGravityOptimizer = BaseOptimizer.new(parameterDictionary)
	
	setmetatable(NewGravityOptimizer, GravityOptimizer)
	
	NewGravityOptimizer:setName("Gravity")
	
	NewGravityOptimizer.initialStepSize = parameterDictionary.initialStepSize or defaultInitialStepSize
	
	NewGravityOptimizer.movingAverage = parameterDictionary.movingAverage or defaultMovingAverage
	
	NewGravityOptimizer.weightDecayRate = parameterDictionary.weightDecayRate or defaultWeightDecayRate
	
	--------------------------------------------------------------------------------
	
	NewGravityOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewGravityOptimizer.optimizerInternalParameterArray or {}
		
		local previousVelocityMatrix = optimizerInternalParameterArray[1]
		
		local timeValue = (optimizerInternalParameterArray[2] or 0) + 1
		
		local weightDecayRate = NewGravityOptimizer.weightDecayRate
		
		if (not previousVelocityMatrix) then

			local standardDeviation = NewGravityOptimizer.initialStepSize / learningRate

			local gaussianDensity = calculateGaussianDensity(0, standardDeviation)

			previousVelocityMatrix = AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), gaussianDensity)

		end
		
		local gradientMatrix = costFunctionDerivativeMatrix
		
		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end

		local meanMovingAverage = ((NewGravityOptimizer.movingAverage * timeValue) + 1) / (timeValue + 2)

		local absoluteGradientMatrix = AqwamTensorLibrary:applyFunction(math.abs, gradientMatrix)

		local maximumGradientValue = AqwamTensorLibrary:findMaximumValue(absoluteGradientMatrix)

		local mMatrix = AqwamTensorLibrary:divide(1, maximumGradientValue)

		local weirdLMatrixPart1 = AqwamTensorLibrary:divide(gradientMatrix, mMatrix)

		local weirdLMatrixPart2 = AqwamTensorLibrary:power(weirdLMatrixPart1, 2)

		local weirdLMatrixPart3 = AqwamTensorLibrary:add(1, weirdLMatrixPart2)

		local weirdLMatrix = AqwamTensorLibrary:divide(gradientMatrix, weirdLMatrixPart3)

		local velocityMatrixPart1 = AqwamTensorLibrary:multiply(meanMovingAverage, previousVelocityMatrix)

		local velocityMatrixPart2 = AqwamTensorLibrary:multiply((1 - meanMovingAverage), weirdLMatrix)

		local velocityMatrix = AqwamTensorLibrary:add(velocityMatrixPart1, velocityMatrixPart2)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, velocityMatrix)

		NewGravityOptimizer.optimizerInternalParameterArray = {velocityMatrix, timeValue}

		return costFunctionDerivativeMatrix
		
	end)
	
	return NewGravityOptimizer
	
end

function GravityOptimizer:setInitialStepSize(initialStepSize)
	
	self.initialStepSize = initialStepSize
	
end

function GravityOptimizer:setMovingAverage(movingAverage)

	self.movingAverage = movingAverage

end

function GravityOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

return GravityOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{E701303A-0594-466D-A279-D98C748A0BD3}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Gravity</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC12CB0B4D6E5400B917CB06195ECF922">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

AdaptiveMomentEstimationMaximumOptimizer = {}

AdaptiveMomentEstimationMaximumOptimizer.__index = AdaptiveMomentEstimationMaximumOptimizer

setmetatable(AdaptiveMomentEstimationMaximumOptimizer, BaseOptimizer)

local defaultBeta1 = 0.9

local defaultBeta2 = 0.999

local defaultWeightDecayRate = 0

local defaultEpsilon = 1e-16

function AdaptiveMomentEstimationMaximumOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewAdaptiveMomentEstimationMaximumOptimizer = BaseOptimizer.new(parameterDictionary)

	setmetatable(NewAdaptiveMomentEstimationMaximumOptimizer, AdaptiveMomentEstimationMaximumOptimizer)
	
	NewAdaptiveMomentEstimationMaximumOptimizer:setName("AdaptiveMomentEstimationMaximum")

	NewAdaptiveMomentEstimationMaximumOptimizer.beta1 = parameterDictionary.beta1 or defaultBeta1
	
	NewAdaptiveMomentEstimationMaximumOptimizer.beta2 = parameterDictionary.beta2 or defaultBeta2
	
	NewAdaptiveMomentEstimationMaximumOptimizer.weightDecayRate = parameterDictionary.weightDecayRate or defaultWeightDecayRate
	
	NewAdaptiveMomentEstimationMaximumOptimizer.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	--------------------------------------------------------------------------------
	
	NewAdaptiveMomentEstimationMaximumOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewAdaptiveMomentEstimationMaximumOptimizer.optimizerInternalParameterArray or {}

		local momentMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)

		local exponentWeightMatrix = optimizerInternalParameterArray[2] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local timeValue = (optimizerInternalParameterArray[3] or 0) + 1
		
		local beta1 = NewAdaptiveMomentEstimationMaximumOptimizer.beta1
		
		local beta2 = NewAdaptiveMomentEstimationMaximumOptimizer.beta2
		
		local weightDecayRate = NewAdaptiveMomentEstimationMaximumOptimizer.weightDecayRate
		
		local gradientMatrix = costFunctionDerivativeMatrix
		
		if (weightDecayRate ~= 0) then
			
			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)
			
			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)
			
		end

		local momentMatrixPart1 = AqwamTensorLibrary:multiply(beta1, momentMatrix)

		local momentMatrixPart2 = AqwamTensorLibrary:multiply((1 - beta1), gradientMatrix)

		momentMatrix = AqwamTensorLibrary:add(momentMatrixPart1, momentMatrixPart2)

		local exponentWeightMatrixPart1 = AqwamTensorLibrary:multiply(beta2, exponentWeightMatrix)

		local exponentWeightMatrixPart2 = AqwamTensorLibrary:applyFunction(math.abs, gradientMatrix)

		exponentWeightMatrix = AqwamTensorLibrary:applyFunction(math.max, exponentWeightMatrixPart1, exponentWeightMatrixPart2)

		local divisorMatrixPart1 = 1 - math.pow(beta1, timeValue)

		local divisorMatrixPart2 = AqwamTensorLibrary:add(exponentWeightMatrix, NewAdaptiveMomentEstimationMaximumOptimizer.epsilon)

		local divisorMatrix = AqwamTensorLibrary:multiply(divisorMatrixPart1, divisorMatrixPart2)

		local costFunctionDerivativeMatrixPart1 = AqwamTensorLibrary:divide(momentMatrix, divisorMatrix)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrixPart1)
		
		NewAdaptiveMomentEstimationMaximumOptimizer.optimizerInternalParameterArray = {momentMatrix, exponentWeightMatrix, timeValue}

		return costFunctionDerivativeMatrix

	end)

	return NewAdaptiveMomentEstimationMaximumOptimizer

end

function AdaptiveMomentEstimationMaximumOptimizer:setBeta1(beta1)
	
	self.beta1 = beta1
	
end

function AdaptiveMomentEstimationMaximumOptimizer:setBeta2(beta2)
		
	self.beta2 = beta2
	
end

function AdaptiveMomentEstimationMaximumOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

function AdaptiveMomentEstimationMaximumOptimizer:setEpsilon(epsilon)

	self.epsilon = epsilon

end

return AdaptiveMomentEstimationMaximumOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{3C9252FA-3150-480C-BAB9-71D03CF24C05}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AdaptiveMomentEstimationMaximum</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1F76B94E2CED455A8AE8D3343AC35DB2">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

AdaptiveMomentEstimationOptimizer = {}

AdaptiveMomentEstimationOptimizer.__index = AdaptiveMomentEstimationOptimizer

setmetatable(AdaptiveMomentEstimationOptimizer, BaseOptimizer)

local defaultBeta1 = 0.9

local defaultBeta2 = 0.999

local defaultWeightDecayRate = 0

local defaultEpsilon = 1e-16

function AdaptiveMomentEstimationOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewAdaptiveMomentEstimationOptimizer = BaseOptimizer.new(parameterDictionary)
	
	NewAdaptiveMomentEstimationOptimizer:setName("AdaptiveMomentEstimation")
	
	setmetatable(NewAdaptiveMomentEstimationOptimizer, AdaptiveMomentEstimationOptimizer)
	
	NewAdaptiveMomentEstimationOptimizer.beta1 = parameterDictionary.beta1 or defaultBeta1
	
	NewAdaptiveMomentEstimationOptimizer.beta2 = parameterDictionary.beta2 or defaultBeta2
	
	NewAdaptiveMomentEstimationOptimizer.weightDecayRate = parameterDictionary.weightDecayRate or defaultWeightDecayRate
	
	NewAdaptiveMomentEstimationOptimizer.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	--------------------------------------------------------------------------------
	
	NewAdaptiveMomentEstimationOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewAdaptiveMomentEstimationOptimizer.optimizerInternalParameterArray or {}
		
		local previousMomentumMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)

		local previousVelocityMatrix = optimizerInternalParameterArray[2] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local timeValue = (optimizerInternalParameterArray[3] or 0) + 1
		
		local beta1 = NewAdaptiveMomentEstimationOptimizer.beta1

		local beta2 = NewAdaptiveMomentEstimationOptimizer.beta2
		
		local weightDecayRate = NewAdaptiveMomentEstimationOptimizer.weightDecayRate

		local gradientMatrix = costFunctionDerivativeMatrix
		
		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end
		
		local momentumMatrixPart1 = AqwamTensorLibrary:multiply(beta1, previousMomentumMatrix)

		local momentumMatrixPart2 = AqwamTensorLibrary:multiply((1 - beta1), gradientMatrix)

		local momentumMatrix = AqwamTensorLibrary:add(momentumMatrixPart1, momentumMatrixPart2)

		local squaredGradientDerivativeMatrix = AqwamTensorLibrary:power(gradientMatrix, 2)

		local velocityMatrixPart1 = AqwamTensorLibrary:multiply(beta2, previousVelocityMatrix)

		local velocityMatrixPart2 = AqwamTensorLibrary:multiply((1 - beta2), squaredGradientDerivativeMatrix)

		local velocityMatrix = AqwamTensorLibrary:add(velocityMatrixPart1, velocityMatrixPart2)

		local meanMomentumMatrix = AqwamTensorLibrary:divide(momentumMatrix, (1 - math.pow(beta1, timeValue)))

		local meanVelocityMatrix = AqwamTensorLibrary:divide(velocityMatrix, (1 - math.pow(beta2, timeValue)))

		local squareRootedDivisor = AqwamTensorLibrary:applyFunction(math.sqrt, meanVelocityMatrix)

		local finalDivisorMatrix = AqwamTensorLibrary:add(squareRootedDivisor, NewAdaptiveMomentEstimationOptimizer.epsilon)

		local costFunctionDerivativeMatrixPart1 = AqwamTensorLibrary:divide(meanMomentumMatrix, finalDivisorMatrix)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrixPart1)
		
		NewAdaptiveMomentEstimationOptimizer.optimizerInternalParameterArray = {momentumMatrix, velocityMatrix, timeValue}

		return costFunctionDerivativeMatrix
		
	end)

	return NewAdaptiveMomentEstimationOptimizer

end

function AdaptiveMomentEstimationOptimizer:setBeta1(beta1)
	
	self.beta1 = beta1
	
end

function AdaptiveMomentEstimationOptimizer:setBeta2(beta2)
		
	self.beta2 = beta2
	
end

function AdaptiveMomentEstimationOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

function AdaptiveMomentEstimationOptimizer:setEpsilon(epsilon)

	self.epsilon = epsilon

end

return AdaptiveMomentEstimationOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{57B2F772-587F-422B-AD91-F07DA75A2A9C}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AdaptiveMomentEstimation</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3BA96C5C6860454082D4475B7E3C8A2F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

AdaptiveDeltaOptimizer = {}

AdaptiveDeltaOptimizer.__index = AdaptiveDeltaOptimizer

setmetatable(AdaptiveDeltaOptimizer, BaseOptimizer)

local defaultDecayRate = 0.9

local defaultWeightDecayRate = 0

local defaultEpsilon = 1e-16

function AdaptiveDeltaOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewAdaptiveDeltaOptimizer = BaseOptimizer.new(parameterDictionary)

	setmetatable(NewAdaptiveDeltaOptimizer, AdaptiveDeltaOptimizer)
	
	NewAdaptiveDeltaOptimizer:setName("AdaptiveDelta")
	
	NewAdaptiveDeltaOptimizer.decayRate = parameterDictionary.decayRate or defaultDecayRate
	
	NewAdaptiveDeltaOptimizer.weightDecayRate = NewAdaptiveDeltaOptimizer.weightDecayRate or defaultWeightDecayRate
	
	NewAdaptiveDeltaOptimizer.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	--------------------------------------------------------------------------------
	
	NewAdaptiveDeltaOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewAdaptiveDeltaOptimizer.optimizerInternalParameterArray or {}
		
		local previousRunningGradientSquaredMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local decayRate = NewAdaptiveDeltaOptimizer.decayRate
		
		local weightDecayRate = NewAdaptiveDeltaOptimizer.weightDecayRate

		local gradientMatrix = costFunctionDerivativeMatrix

		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end

		local gradientSquaredMatrix = AqwamTensorLibrary:power(gradientMatrix, 2)

		local runningDeltaMatrixPart1 = AqwamTensorLibrary:multiply(decayRate, previousRunningGradientSquaredMatrix)

		local runningDeltaMatrixPart2 = AqwamTensorLibrary:multiply((1 - decayRate), gradientSquaredMatrix)

		local currentRunningGradientSquaredMatrix = AqwamTensorLibrary:add(runningDeltaMatrixPart1, runningDeltaMatrixPart2)

		local rootMeanSquareMatrixPart1 = AqwamTensorLibrary:add(currentRunningGradientSquaredMatrix, NewAdaptiveDeltaOptimizer.epsilon)

		local rootMeanSquareMatrix = AqwamTensorLibrary:applyFunction(math.sqrt, rootMeanSquareMatrixPart1)

		local costFunctionDerivativeMatrixPart1 = AqwamTensorLibrary:divide(gradientMatrix, rootMeanSquareMatrix)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrixPart1)

		NewAdaptiveDeltaOptimizer.optimizerInternalParameterArray = {currentRunningGradientSquaredMatrix}

		return costFunctionDerivativeMatrix
		
	end)

	return NewAdaptiveDeltaOptimizer

end

function AdaptiveDeltaOptimizer:setDecayRate(decayRate)

	self.decayRate = decayRate

end

function AdaptiveDeltaOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

function AdaptiveDeltaOptimizer:setEpsilon(epsilon)

	self.epsilon = epsilon

end

return AdaptiveDeltaOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{4FC2C6B5-9606-4E51-8B72-7C2AF53C7515}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AdaptiveDelta</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9041C8D902C54E268F2DC730A1BB0693">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

AdaptiveGradientOptimizer = {}

AdaptiveGradientOptimizer.__index = AdaptiveGradientOptimizer

setmetatable(AdaptiveGradientOptimizer, BaseOptimizer)

local defaultWeightDecayRate = 0

function AdaptiveGradientOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewAdaptiveGradientOptimizer = BaseOptimizer.new(parameterDictionary)
	
	setmetatable(NewAdaptiveGradientOptimizer, AdaptiveGradientOptimizer)
	
	NewAdaptiveGradientOptimizer:setName("AdaptiveGradient")
	
	NewAdaptiveGradientOptimizer.weightDecayRate = NewAdaptiveGradientOptimizer.weightDecayRate or defaultWeightDecayRate
	
	--------------------------------------------------------------------------------
	
	NewAdaptiveGradientOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewAdaptiveGradientOptimizer.optimizerInternalParameterArray or {}
		
		local previousSumOfGradientSquaredMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local weightDecayRate = NewAdaptiveGradientOptimizer.weightDecayRate
		
		local gradientMatrix = costFunctionDerivativeMatrix
		
		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end
		
		local gradientSquaredMatrix = AqwamTensorLibrary:power(gradientMatrix, 2)

		local currentSumOfGradientSquaredMatrix = AqwamTensorLibrary:add(previousSumOfGradientSquaredMatrix, gradientSquaredMatrix)

		local squareRootSumOfGradientSquaredMatrix = AqwamTensorLibrary:applyFunction(math.sqrt, currentSumOfGradientSquaredMatrix)

		local costFunctionDerivativeMatrixPart1 = AqwamTensorLibrary:divide(gradientMatrix, squareRootSumOfGradientSquaredMatrix)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrixPart1)

		NewAdaptiveGradientOptimizer.optimizerInternalParameterArray = {currentSumOfGradientSquaredMatrix}

		return costFunctionDerivativeMatrix
		
	end)
	
	return NewAdaptiveGradientOptimizer
	
end

function AdaptiveGradientOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

return AdaptiveGradientOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{DE2C3398-AB01-4E00-ACA5-0E646D6239A1}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AdaptiveGradient</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2282F25A36A747358677B53EFFDED9A9">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

BaseOptimizer = {}

BaseOptimizer.__index = BaseOptimizer

setmetatable(BaseOptimizer, BaseInstance)

function BaseOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewBaseOptimizer = BaseInstance.new(parameterDictionary)

	setmetatable(NewBaseOptimizer, BaseOptimizer)

	NewBaseOptimizer:setName("BaseOptimizer")

	NewBaseOptimizer:setClassName("Optimizer")
	
	NewBaseOptimizer.LearningRateValueScheduler = parameterDictionary.LearningRateValueScheduler

	NewBaseOptimizer.calculateFunction = nil

	NewBaseOptimizer.optimizerInternalParameterArray = nil

	return NewBaseOptimizer

end

function BaseOptimizer:calculate(learningRate, costFunctionDerivativeTensor, weightTensor)

	local LearningRateValueScheduler = self.LearningRateValueScheduler

	if (LearningRateValueScheduler) then learningRate = LearningRateValueScheduler:calculate(learningRate) end
	
	costFunctionDerivativeTensor = self.calculateFunction(learningRate, costFunctionDerivativeTensor, weightTensor)

	return costFunctionDerivativeTensor

end

function BaseOptimizer:setCalculateFunction(calculateFunction)

	self.calculateFunction = calculateFunction

end

function BaseOptimizer:setLearningRateValueScheduler(LearningRateValueScheduler)

	self.LearningRateValueScheduler = LearningRateValueScheduler

end

function BaseOptimizer:getLearningRateValueScheduler()

	return self.LearningRateValueScheduler

end

function BaseOptimizer:getOptimizerInternalParameterArray(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.optimizerInternalParameterArray

	else

		return self:deepCopyTable(self.optimizerInternalParameterArray)

	end

end

function BaseOptimizer:setOptimizerInternalParameterArray(optimizerInternalParameterArray, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.optimizerInternalParameterArray = optimizerInternalParameterArray

	else

		self.optimizerInternalParameterArray = self:deepCopyTable(optimizerInternalParameterArray)

	end

end

function BaseOptimizer:reset()

	self.optimizerInternalParameterArray = nil

end

return BaseOptimizer
]]></ProtectedString>
									<string name="ScriptGuid">{185D041B-FCD7-434F-87EC-AB6B957F7920}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BaseOptimizer</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX13FEE437B5FD45E2864297CF5FF937C6">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

ResilientBackwardPropagationOptimizer = {}

ResilientBackwardPropagationOptimizer.__index = ResilientBackwardPropagationOptimizer

setmetatable(ResilientBackwardPropagationOptimizer, BaseOptimizer)

local defaultEtaPlus = 0.5

local defaultEtaMinus = 1.2

local defaultMinimumStepSize = 1e-6

local defaultMaximumStepSize = 50

local defaultWeightDecayRate = 0

function ResilientBackwardPropagationOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewResilientBackwardPropagationOptimizer = BaseOptimizer.new(parameterDictionary)
	
	setmetatable(NewResilientBackwardPropagationOptimizer, ResilientBackwardPropagationOptimizer)
	
	NewResilientBackwardPropagationOptimizer:setName("ResilientBackwardPropagation")
	
	NewResilientBackwardPropagationOptimizer.etaPlus = parameterDictionary.etaPlus or defaultEtaPlus
	
	NewResilientBackwardPropagationOptimizer.etaMinus = parameterDictionary.etaMinus or defaultEtaMinus
	
	NewResilientBackwardPropagationOptimizer.maximumStepSize = parameterDictionary.maximumStepSize or defaultMaximumStepSize
	
	NewResilientBackwardPropagationOptimizer.minimumStepSize = parameterDictionary.minimumStepSize or defaultMinimumStepSize
	
	NewResilientBackwardPropagationOptimizer.weightDecayRate = parameterDictionary.weightDecayRate or defaultWeightDecayRate
	
	--------------------------------------------------------------------------------
	
	NewResilientBackwardPropagationOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewResilientBackwardPropagationOptimizer.optimizerInternalParameterArray or {}
		
		local previousGradientMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local learningRateMatrix = optimizerInternalParameterArray[2] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), learningRate)
		
		local etaPlus = NewResilientBackwardPropagationOptimizer.etaPlus
		
		local etaMinus = NewResilientBackwardPropagationOptimizer.etaMinus
		
		local maximumStepSize = NewResilientBackwardPropagationOptimizer.maximumStepSize
		
		local minimumStepSize = NewResilientBackwardPropagationOptimizer.minimumStepSize
		
		local weightDecayRate = NewResilientBackwardPropagationOptimizer.weightDecayRate
		
		local gradientMatrix = costFunctionDerivativeMatrix
		
		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end
		
		local multipliedGradientMatrix = AqwamTensorLibrary:multiply(gradientMatrix, previousGradientMatrix)
		
		for i, unwrappedMultipliedGradientVector in ipairs(multipliedGradientMatrix) do
			
			for j, unwrappedGradientValue in ipairs(unwrappedMultipliedGradientVector) do
				
				if (unwrappedGradientValue > 0) then
					
					learningRateMatrix[i][j] = math.min(learningRateMatrix[i][j] * etaPlus, maximumStepSize)
					
				elseif (unwrappedGradientValue < 0) then
					
					learningRateMatrix[i][j] = math.max(learningRateMatrix[i][j] * etaMinus, minimumStepSize)
					
					gradientMatrix[i][j] = 0
					
				end
				
			end
			
		end
		
		local signMatrix = AqwamTensorLibrary:applyFunction(math.sign, gradientMatrix)
		
		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRateMatrix, signMatrix)

		NewResilientBackwardPropagationOptimizer.optimizerInternalParameterArray = {gradientMatrix, learningRateMatrix}

		return costFunctionDerivativeMatrix
		
	end)
	
	return NewResilientBackwardPropagationOptimizer
	
end

function ResilientBackwardPropagationOptimizer:setEtaPlus(etaPlus)
	
	self.etaPlus = etaPlus
	
end

function ResilientBackwardPropagationOptimizer:setEtaMinus(etaMinus)

	self.etaMinus = etaMinus

end

function ResilientBackwardPropagationOptimizer:setMaximumStepSize(maximumStepSize)

	self.maximumStepSize = maximumStepSize

end

function ResilientBackwardPropagationOptimizer:setMinimumStepSize(minimumStepSize)

	self.minimumStepSize = minimumStepSize

end

return ResilientBackwardPropagationOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{546FD379-122B-4297-B522-C40F6FF343BE}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ResilientBackwardPropagation</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBCA5101BFF3543CDAF5C6186A9D2789E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

AdaptiveFactorOptimizer = {}

AdaptiveFactorOptimizer.__index = AdaptiveFactorOptimizer

setmetatable(AdaptiveFactorOptimizer, BaseOptimizer)

local defaultBeta2DecayRate = -0.8

local defaultWeightDecayRate = 0

local defaultClipValue = 1

local defaultEpsilon1 = 1e-16

local defaultEpsilon2 = 1e-16

function AdaptiveFactorOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewAdaptiveFactorOptimizer = BaseOptimizer.new(parameterDictionary)

	setmetatable(NewAdaptiveFactorOptimizer, AdaptiveFactorOptimizer)
	
	NewAdaptiveFactorOptimizer:setName("AdaptiveFactor")
	
	NewAdaptiveFactorOptimizer.beta2DecayRate = parameterDictionary.beta2DecayRate or defaultBeta2DecayRate
	
	NewAdaptiveFactorOptimizer.weightDecayRate = parameterDictionary.weightDecayRate or defaultWeightDecayRate
	
	NewAdaptiveFactorOptimizer.clipValue = parameterDictionary.clipValue or defaultClipValue
	
	NewAdaptiveFactorOptimizer.epsilon1 = parameterDictionary.epsilon1 or defaultEpsilon1
	
	NewAdaptiveFactorOptimizer.epsilon2 = parameterDictionary.epsilon2 or defaultEpsilon2
	
	--------------------------------------------------------------------------------
	
	NewAdaptiveFactorOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local dimensionSizeArray = AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix)
		
		local optimizerInternalParameterArray = NewAdaptiveFactorOptimizer.optimizerInternalParameterArray or {}
		
		local secondMomentRowFactorMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)
		
		local secondMomentColumnFactorMatrix = optimizerInternalParameterArray[2] or AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)
		
		local timeValue = (optimizerInternalParameterArray[3] or 0) + 1
		
		local beta2DecayRate = NewAdaptiveFactorOptimizer.beta2DecayRate
		
		local weightDecayRate = NewAdaptiveFactorOptimizer.weightDecayRate
		
		local beta2 = 1 - math.pow(timeValue, beta2DecayRate)
		
		local oneMinusBeta2 = 1 - beta2
		
		local gradientMatrix = costFunctionDerivativeMatrix
		
		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end
		
		local squaredGradientMatrix = AqwamTensorLibrary:power(gradientMatrix, 2)
		
		local oneRowMatrix = AqwamTensorLibrary:createTensor({dimensionSizeArray[1], 1}, 1)
		
		local oneColumnMatrix = AqwamTensorLibrary:createTensor({dimensionSizeArray[2], 1}, 1)
		
		local transposedOneRowMatrix = AqwamTensorLibrary:transpose(oneRowMatrix)
		
		local transposedOneColumnMatrix = AqwamTensorLibrary:transpose(oneColumnMatrix)
		
		local dotProductOnMatrix = AqwamTensorLibrary:dotProduct(oneRowMatrix, transposedOneColumnMatrix)
		
		local epsilonMultiplyDotProductOnMatrix = AqwamTensorLibrary:multiply(NewAdaptiveFactorOptimizer.epsilon1, dotProductOnMatrix)
		
		local squaredGradientAddEpsilonMultiplyDotProductOnMatrix = AqwamTensorLibrary:add(squaredGradientMatrix, epsilonMultiplyDotProductOnMatrix)
		
		local secondMomentRowFactorMatrixPart1 = AqwamTensorLibrary:multiply(beta2, secondMomentRowFactorMatrix)
		
		local secondMomentRowFactorMatrixPart2 = AqwamTensorLibrary:multiply(oneMinusBeta2, squaredGradientAddEpsilonMultiplyDotProductOnMatrix)
		
		local secondMomentRowFactorMatrixPart3 = AqwamTensorLibrary:dotProduct(secondMomentRowFactorMatrixPart2, oneColumnMatrix)
		
		secondMomentRowFactorMatrix = AqwamTensorLibrary:add(secondMomentRowFactorMatrixPart1, secondMomentRowFactorMatrixPart3)
		
		local secondMomentColumnFactorMatrixPart1 = AqwamTensorLibrary:multiply(beta2, secondMomentColumnFactorMatrix)
		
		local secondMomentColumnFactorMatrixPart2 = AqwamTensorLibrary:dotProduct(transposedOneRowMatrix, squaredGradientAddEpsilonMultiplyDotProductOnMatrix)
		
		local secondMomentColumnFactorMatrixPart3 = AqwamTensorLibrary:multiply(oneMinusBeta2, secondMomentRowFactorMatrixPart2)
		
		secondMomentColumnFactorMatrix = AqwamTensorLibrary:add(secondMomentColumnFactorMatrixPart1, secondMomentColumnFactorMatrixPart3)
		
		local velocityMatrixPart1 = AqwamTensorLibrary:multiply(secondMomentRowFactorMatrix, secondMomentColumnFactorMatrix)
		
		local velocityMatrixPart2 = AqwamTensorLibrary:dotProduct(transposedOneRowMatrix, secondMomentRowFactorMatrix)
		
		local velocityMatrix = AqwamTensorLibrary:divide(velocityMatrixPart1, velocityMatrixPart2)
		
		local uMatrix = AqwamTensorLibrary:divide(gradientMatrix, AqwamTensorLibrary:applyFunction(math.sqrt, velocityMatrix))
		
		local squareRootVelocityMatrix = AqwamTensorLibrary:applyFunction(math.sqrt, velocityMatrix)
		
		local dividedRootMeanSquaredXMatrix = AqwamTensorLibrary:divide(uMatrix, weightMatrix)
		
		local momentum = math.min(learningRate, (1 / math.sqrt(timeValue)))
		
		local alpha = AqwamTensorLibrary:applyFunction(math.max, {{NewAdaptiveFactorOptimizer.epsilon2}}, dividedRootMeanSquaredXMatrix)
		
		alpha = AqwamTensorLibrary:multiply(alpha, momentum)
		
		local rootMeanSquaredUMatrixPart1 = AqwamTensorLibrary:divide(gradientMatrix, squareRootVelocityMatrix)
		
		local rootMeanSquaredUMatrix = AqwamTensorLibrary:unaryMinus(rootMeanSquaredUMatrixPart1)
		
		local dividedRootMeanSquaredUMatrix = AqwamTensorLibrary:divide(rootMeanSquaredUMatrix, NewAdaptiveFactorOptimizer.clipValue)
		
		local finalUMatrix = AqwamTensorLibrary:divide(uMatrix, AqwamTensorLibrary:applyFunction(math.max, dividedRootMeanSquaredUMatrix, {{1}}))
		
		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, finalUMatrix)

		NewAdaptiveFactorOptimizer.optimizerInternalParameterArray = {secondMomentRowFactorMatrix, secondMomentColumnFactorMatrix, timeValue}

		return costFunctionDerivativeMatrix
		
	end)

	return NewAdaptiveFactorOptimizer

end

function AdaptiveFactorOptimizer:setBeta2DecayRate(beta2DecayRate)

	self.beta2DecayRate = beta2DecayRate

end

function AdaptiveFactorOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

function AdaptiveFactorOptimizer:setClipValue(clipValue)

	self.clipValue = clipValue

end

function AdaptiveFactorOptimizer:setEpsilon1(epsilon1)

	self.epsilon1 = epsilon1

end

function AdaptiveFactorOptimizer:setEpsilon2(epsilon2)

	self.epsilon2 = epsilon2

end

return AdaptiveFactorOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{33E084FC-E160-4999-BB9D-A520BAFE0934}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AdaptiveFactor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDAB49C817ECA44E39CE60A0A9FE8B081">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

AdaptiveMomentEstimationWeightDecayOptimizer = {}

AdaptiveMomentEstimationWeightDecayOptimizer.__index = AdaptiveMomentEstimationWeightDecayOptimizer

setmetatable(AdaptiveMomentEstimationWeightDecayOptimizer, BaseOptimizer)

local defaultAlpha = 0.001

local defaultBeta1 = 0.9

local defaultBeta2 = 0.999

local defaultWeightDecayRate = 0.01

local defaultEpsilon = 1e-16

function AdaptiveMomentEstimationWeightDecayOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewAdaptiveMomentEstimationWeightDecayOptimizer = BaseOptimizer.new(parameterDictionary)
	
	NewAdaptiveMomentEstimationWeightDecayOptimizer:setName("AdaptiveMomentEstimationWeightDecay")
	
	setmetatable(NewAdaptiveMomentEstimationWeightDecayOptimizer, AdaptiveMomentEstimationWeightDecayOptimizer)
	
	NewAdaptiveMomentEstimationWeightDecayOptimizer.alpha = parameterDictionary.alpha or defaultBeta1
	
	NewAdaptiveMomentEstimationWeightDecayOptimizer.beta1 = parameterDictionary.beta1 or defaultBeta1
	
	NewAdaptiveMomentEstimationWeightDecayOptimizer.beta2 = parameterDictionary.beta2 or defaultBeta2
	
	NewAdaptiveMomentEstimationWeightDecayOptimizer.weightDecayRate = parameterDictionary.weightDecayRate or defaultWeightDecayRate
	
	NewAdaptiveMomentEstimationWeightDecayOptimizer.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	--------------------------------------------------------------------------------
	
	NewAdaptiveMomentEstimationWeightDecayOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewAdaptiveMomentEstimationWeightDecayOptimizer.optimizerInternalParameterArray or {}
		
		local previousMomentumMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)

		local previousVelocityMatrix = optimizerInternalParameterArray[2] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local timeValue = (optimizerInternalParameterArray[3] or 0) + 1
		
		local beta1 = NewAdaptiveMomentEstimationWeightDecayOptimizer.beta1

		local beta2 = NewAdaptiveMomentEstimationWeightDecayOptimizer.beta2

		local decayedWeightMatrix = AqwamTensorLibrary:multiply(NewAdaptiveMomentEstimationWeightDecayOptimizer.weightDecayRate, weightMatrix)

		local gradientMatrix = AqwamTensorLibrary:add(costFunctionDerivativeMatrix, decayedWeightMatrix)
		
		local momentumMatrixPart1 = AqwamTensorLibrary:multiply(beta1, previousMomentumMatrix)

		local momentumMatrixPart2 = AqwamTensorLibrary:multiply((1 - beta1), gradientMatrix)

		local momentumMatrix = AqwamTensorLibrary:add(momentumMatrixPart1, momentumMatrixPart2)

		local squaredGradientDerivativeMatrix = AqwamTensorLibrary:power(gradientMatrix, 2)

		local velocityMatrixPart1 = AqwamTensorLibrary:multiply(beta2, previousVelocityMatrix)

		local velocityMatrixPart2 = AqwamTensorLibrary:multiply((1 - beta2), squaredGradientDerivativeMatrix)

		local velocityMatrix = AqwamTensorLibrary:add(velocityMatrixPart1, velocityMatrixPart2)

		local meanMomentumMatrix = AqwamTensorLibrary:divide(momentumMatrix, (1 - math.pow(beta1, timeValue)))

		local meanVelocityMatrix = AqwamTensorLibrary:divide(velocityMatrix, (1 - math.pow(beta2, timeValue)))

		local squareRootedDivisor = AqwamTensorLibrary:applyFunction(math.sqrt, meanVelocityMatrix)

		local finalDivisorMatrix = AqwamTensorLibrary:add(squareRootedDivisor, NewAdaptiveMomentEstimationWeightDecayOptimizer.epsilon)
		
		local costFunctionDerivativeMatrixPart1 = AqwamTensorLibrary:multiply(NewAdaptiveMomentEstimationWeightDecayOptimizer.alpha, meanMomentumMatrix)

		local costFunctionDerivativeMatrixPart2 = AqwamTensorLibrary:divide(costFunctionDerivativeMatrixPart1, finalDivisorMatrix)
		
		local costFunctionDerivativeMatrixPart3 = AqwamTensorLibrary:add(costFunctionDerivativeMatrixPart2, decayedWeightMatrix)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrixPart3)
		
		NewAdaptiveMomentEstimationWeightDecayOptimizer.optimizerInternalParameterArray = {momentumMatrix, velocityMatrix, timeValue}

		return costFunctionDerivativeMatrix
		
	end)

	return NewAdaptiveMomentEstimationWeightDecayOptimizer

end

function AdaptiveMomentEstimationWeightDecayOptimizer:setAlpha(alpha)

	self.alpha = alpha

end

function AdaptiveMomentEstimationWeightDecayOptimizer:setBeta1(beta1)
	
	self.beta1 = beta1
	
end

function AdaptiveMomentEstimationWeightDecayOptimizer:setBeta2(beta2)
		
	self.beta2 = beta2
	
end

function AdaptiveMomentEstimationWeightDecayOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

function AdaptiveMomentEstimationWeightDecayOptimizer:setEpsilon(epsilon)

	self.epsilon = epsilon

end

return AdaptiveMomentEstimationWeightDecayOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{FFAD4725-1883-4A79-B08C-85E7FAFB955F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AdaptiveMomentEstimationWeightDecay</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX27150AE4C82A40FDA6F12B145428AD07">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseOptimizer = require(script.Parent.BaseOptimizer)

RectifiedAdaptiveMomentEstimationOptimizer = {}

RectifiedAdaptiveMomentEstimationOptimizer.__index = RectifiedAdaptiveMomentEstimationOptimizer

setmetatable(RectifiedAdaptiveMomentEstimationOptimizer, BaseOptimizer)

local defaultBeta1 = 0.9

local defaultBeta2 = 0.999

local defaultWeightDecayRate = 0

local defaultEpsilon = 1e-16

function RectifiedAdaptiveMomentEstimationOptimizer.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewRectifiedAdaptiveMomentEstimationOptimizer = BaseOptimizer.new(parameterDictionary)
	
	NewRectifiedAdaptiveMomentEstimationOptimizer:setName("RectifiedAdaptiveMomentEstimation")
	
	setmetatable(NewRectifiedAdaptiveMomentEstimationOptimizer, RectifiedAdaptiveMomentEstimationOptimizer)
	
	local beta2 = parameterDictionary.beta2 or defaultBeta2
	
	NewRectifiedAdaptiveMomentEstimationOptimizer.beta1 = parameterDictionary.beta1 or defaultBeta1
	
	NewRectifiedAdaptiveMomentEstimationOptimizer.beta2 = beta2
	
	NewRectifiedAdaptiveMomentEstimationOptimizer.weightDecayRate = parameterDictionary.weightDecayRate or defaultWeightDecayRate
	
	NewRectifiedAdaptiveMomentEstimationOptimizer.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	NewRectifiedAdaptiveMomentEstimationOptimizer.pInfinity = ((2 / (1 - beta2)) - 1)
	
	--------------------------------------------------------------------------------
	
	NewRectifiedAdaptiveMomentEstimationOptimizer:setCalculateFunction(function(learningRate, costFunctionDerivativeMatrix, weightMatrix)
		
		local optimizerInternalParameterArray = NewRectifiedAdaptiveMomentEstimationOptimizer.optimizerInternalParameterArray or {}
		
		local previousMomentumMatrix = optimizerInternalParameterArray[1] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)

		local previousVelocityMatrix = optimizerInternalParameterArray[2] or AqwamTensorLibrary:createTensor(AqwamTensorLibrary:getDimensionSizeArray(costFunctionDerivativeMatrix), 0)
		
		local timeValue = (optimizerInternalParameterArray[3] or 0) + 1
		
		local beta1 = NewRectifiedAdaptiveMomentEstimationOptimizer.beta1

		local beta2 = NewRectifiedAdaptiveMomentEstimationOptimizer.beta2
		
		local weightDecayRate = NewRectifiedAdaptiveMomentEstimationOptimizer.weightDecayRate
		
		local pInfinity = NewRectifiedAdaptiveMomentEstimationOptimizer.pInfinity

		local gradientMatrix = costFunctionDerivativeMatrix
		
		if (weightDecayRate ~= 0) then

			local decayedWeightMatrix = AqwamTensorLibrary:multiply(weightDecayRate, weightMatrix)

			gradientMatrix = AqwamTensorLibrary:add(gradientMatrix, decayedWeightMatrix)

		end
		
		local momentumMatrixPart1 = AqwamTensorLibrary:multiply(beta1, previousMomentumMatrix)

		local momentumMatrixPart2 = AqwamTensorLibrary:multiply((1 - beta1), gradientMatrix)

		local momentumMatrix = AqwamTensorLibrary:add(momentumMatrixPart1, momentumMatrixPart2)

		local squaredGradientDerivativeMatrix = AqwamTensorLibrary:power(gradientMatrix, 2)

		local velocityMatrixPart1 = AqwamTensorLibrary:multiply(beta2, previousVelocityMatrix)

		local velocityMatrixPart2 = AqwamTensorLibrary:multiply((1 - beta2), squaredGradientDerivativeMatrix)

		local velocityMatrix = AqwamTensorLibrary:add(velocityMatrixPart1, velocityMatrixPart2)

		local meanMomentumMatrix = AqwamTensorLibrary:divide(momentumMatrix, (1 - math.pow(beta1, timeValue)))
		
		local powerBeta2 = math.pow(beta2, timeValue)
		
		local p = pInfinity - ((2 * timeValue * powerBeta2) / (1 - powerBeta2))
		
		if (p > 4) then
			
			local squareRootVelocityMatrix = AqwamTensorLibrary:applyFunction(math.sqrt, velocityMatrix)
			
			local adaptiveLearningRateMatrixPart1 = AqwamTensorLibrary:add(squareRootVelocityMatrix, NewRectifiedAdaptiveMomentEstimationOptimizer.epsilon)
			
			local adaptiveLearningRateMatrix = AqwamTensorLibrary:divide((1 - powerBeta2), adaptiveLearningRateMatrixPart1)
			
			local varianceRectificationNominatorValue = (p - 4) * (p - 2) * pInfinity
			
			local varianceRectificationDenominatorValue = (pInfinity - 4) * (pInfinity - 2) * p
			
			local varianceRectificationValue =  math.sqrt(varianceRectificationNominatorValue / varianceRectificationDenominatorValue)
			
			costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply((learningRate * varianceRectificationValue), meanMomentumMatrix, adaptiveLearningRateMatrix)
			
		else
			
			costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, meanMomentumMatrix)
			
		end
		
		NewRectifiedAdaptiveMomentEstimationOptimizer.optimizerInternalParameterArray = {momentumMatrix, velocityMatrix, timeValue}

		return costFunctionDerivativeMatrix
		
	end)

	return NewRectifiedAdaptiveMomentEstimationOptimizer

end

function RectifiedAdaptiveMomentEstimationOptimizer:setBeta1(beta1)
	
	self.beta1 = beta1
	
end

function RectifiedAdaptiveMomentEstimationOptimizer:setBeta2(beta2)
		
	self.beta2 = beta2
	
end

function RectifiedAdaptiveMomentEstimationOptimizer:setWeightDecayRate(weightDecayRate)

	self.weightDecayRate = weightDecayRate

end

function RectifiedAdaptiveMomentEstimationOptimizer:setEpsilon(epsilon)

	self.epsilon = epsilon

end

return RectifiedAdaptiveMomentEstimationOptimizer]]></ProtectedString>
									<string name="ScriptGuid">{B7769C24-5F0E-47A2-BAEB-9BA36E051B26}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">RectifiedAdaptiveMomentEstimation</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ObjectValue" referent="RBX065318B5C94A45C89EFC512C7762C692">
							<Properties>
								<Ref name="Value">null</Ref>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">AqwamTensorLibraryLinker</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXF551036B637148738017AD6A077672B8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Cores</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX74F7D455E5FE4A4E80D9682414613AEA">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AHAMachineLearningAndDeepLearningLibraryInstance = {}

AHAMachineLearningAndDeepLearningLibraryInstance.__index = AHAMachineLearningAndDeepLearningLibraryInstance

local currentID = 0

local function deepCopyTable(original, copies)

	copies = copies or {}

	local originalType = type(original)

	local copy

	if (originalType == 'table') then

		if copies[original] then

			copy = copies[original]

		else

			copy = {}

			copies[original] = copy

			for originalKey, originalValue in next, original, nil do

				copy[deepCopyTable(originalKey, copies)] = deepCopyTable(originalValue, copies)

			end

			setmetatable(copy, deepCopyTable(getmetatable(original), copies))

		end

	else

		copy = original

	end

	return copy

end

local function incrementIDs(object)
	
	if (type(object) == "table") then
		
		if (object.id) then
			
			currentID = currentID + 1
			
			object.id = currentID
			
		end
		
		for _, value in pairs(object) do incrementIDs(value) end
		
	end
	
end

function AHAMachineLearningAndDeepLearningLibraryInstance.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	if (type(parameterDictionary) ~= "table") then error("The constructor requires a parameter dictionary (table).") end
	
	local NewAHAMachineLearningAndDeepLearningLibraryInstance = {}

	setmetatable(NewAHAMachineLearningAndDeepLearningLibraryInstance, AHAMachineLearningAndDeepLearningLibraryInstance)
	
	currentID = currentID + 1
	
	NewAHAMachineLearningAndDeepLearningLibraryInstance.id = currentID
	
	NewAHAMachineLearningAndDeepLearningLibraryInstance.name = "Unknown"

	NewAHAMachineLearningAndDeepLearningLibraryInstance.className = "Unknown"
	
	return NewAHAMachineLearningAndDeepLearningLibraryInstance
	
end

function AHAMachineLearningAndDeepLearningLibraryInstance:getID()

	return self.id

end

function AHAMachineLearningAndDeepLearningLibraryInstance:setName(name)

	self.name = name

end

function AHAMachineLearningAndDeepLearningLibraryInstance:getName()

	return self.name

end

function AHAMachineLearningAndDeepLearningLibraryInstance:setClassName(className)

	self.className = className

end

function AHAMachineLearningAndDeepLearningLibraryInstance:getClassName()

	return self.className

end

function AHAMachineLearningAndDeepLearningLibraryInstance:getValueOrDefaultValue(value, defaultValue)

	if (type(value) == "nil") then return defaultValue end

	return value

end

function AHAMachineLearningAndDeepLearningLibraryInstance:deepCopyTable(original)

	return deepCopyTable(original)

end

function AHAMachineLearningAndDeepLearningLibraryInstance:clone()
	
	local clonedInstance = deepCopyTable(self)
	
	incrementIDs(clonedInstance)
	
	return clonedInstance
	
end

function AHAMachineLearningAndDeepLearningLibraryInstance:destroy()
	
	setmetatable(self, nil)

	table.clear(self)

	self = nil
	
end

return AHAMachineLearningAndDeepLearningLibraryInstance]]></ProtectedString>
									<string name="ScriptGuid">{EB9FB670-8409-4C71-8E5A-39176B011B67}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BaseInstance</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE12635189ED843DDB766C9DECC29D905">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local distanceFunctionDictionary = {

	["Manhattan"] = function (x1, x2)

		local part1 = AqwamTensorLibrary:subtract(x1, x2)

		part1 = AqwamTensorLibrary:applyFunction(math.abs, part1)

		local distance = AqwamTensorLibrary:sum(part1)

		return distance 

	end,

	["Euclidean"] = function (x1, x2)

		local part1 = AqwamTensorLibrary:subtract(x1, x2)

		local part2 = AqwamTensorLibrary:power(part1, 2)

		local part3 = AqwamTensorLibrary:sum(part2)

		local distance = math.sqrt(part3)

		return distance 

	end,

	["Cosine"] = function(x1, x2)

		local dotProductedX = AqwamTensorLibrary:dotProduct(x1, AqwamTensorLibrary:transpose(x2))[1][1]

		local x1MagnitudePart1 = AqwamTensorLibrary:power(x1, 2)

		local x1MagnitudePart2 = AqwamTensorLibrary:sum(x1MagnitudePart1)

		local x1Magnitude = math.sqrt(x1MagnitudePart2, 2)

		local x2MagnitudePart1 = AqwamTensorLibrary:power(x2, 2)

		local x2MagnitudePart2 = AqwamTensorLibrary:sum(x2MagnitudePart1)

		local x2Magnitude = math.sqrt(x2MagnitudePart2, 2)

		local normX = x1Magnitude * x2Magnitude

		local similarity = dotProductedX / normX

		local cosineDistance = 1 - similarity

		return cosineDistance

	end,

}

return distanceFunctionDictionary]]></ProtectedString>
									<string name="ScriptGuid">{DCED419C-3B1F-428A-84B9-0A99E04AC94F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DistanceFunctionDictionary</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAA3AE4066E0641409533F1D0FE20F96E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local zTableFunction = {}

local zTable = {

	["-3.9"] = {

		["-0.00"] = 0.00005,
		["-0.01"] = 0.00005,
		["-0.02"] = 0.00004,
		["-0.03"] = 0.00004,
		["-0.04"] = 0.00004,
		["-0.05"] = 0.00004,
		["-0.06"] = 0.00004,
		["-0.07"] = 0.00004,
		["-0.08"] = 0.00003,
		["-0.09"] = 0.00003,

	},

	["-3.8"] = {

		["-0.00"] = 0.00007,
		["-0.01"] = 0.00007,
		["-0.02"] = 0.00007,
		["-0.03"] = 0.00006,
		["-0.04"] = 0.00006,
		["-0.05"] = 0.00006,
		["-0.06"] = 0.00006,
		["-0.07"] = 0.00005,
		["-0.08"] = 0.00005,
		["-0.09"] = 0.00005,

	},

	["-3.7"] = {

		["-0.00"] = 0.00011,
		["-0.01"] = 0.00010,
		["-0.02"] = 0.00010,
		["-0.03"] = 0.00010,
		["-0.04"] = 0.00009,
		["-0.05"] = 0.00009,
		["-0.06"] = 0.00008,
		["-0.07"] = 0.00008,
		["-0.08"] = 0.00008,
		["-0.09"] = 0.00008,


	},

	["-3.6"] = {

		["-0.00"] = 0.00016,
		["-0.01"] = 0.00015,
		["-0.02"] = 0.00015,
		["-0.03"] = 0.00014,
		["-0.04"] = 0.00014,
		["-0.05"] = 0.00013,
		["-0.06"] = 0.00013,
		["-0.07"] = 0.00012,
		["-0.08"] = 0.00012,
		["-0.09"] = 0.00011,

	},

	["-3.5"] = {

		["-0.00"] = 0.00023,
		["-0.01"] = 0.00022,
		["-0.02"] = 0.00022,
		["-0.03"] = 0.00021,
		["-0.04"] = 0.00020,
		["-0.05"] = 0.00019,
		["-0.06"] = 0.00019,
		["-0.07"] = 0.00018,
		["-0.08"] = 0.00017,
		["-0.09"] = 0.00017,

	},

	["-3.4"] = {

		["-0.00"] = 0.00034,
		["-0.01"] = 0.00032,
		["-0.02"] = 0.00031,
		["-0.03"] = 0.00030,
		["-0.04"] = 0.00029,
		["-0.05"] = 0.00028,
		["-0.06"] = 0.00027,
		["-0.07"] = 0.00026,
		["-0.08"] = 0.00025,
		["-0.09"] = 0.00024,

	},

	["-3.3"] = {

		["-0.00"] = 0.00048,
		["-0.01"] = 0.00047,
		["-0.02"] = 0.00045,
		["-0.03"] = 0.00043,
		["-0.04"] = 0.00042,
		["-0.05"] = 0.00040,
		["-0.06"] = 0.00039,
		["-0.07"] = 0.00038,
		["-0.08"] = 0.00036,
		["-0.09"] = 0.00035,

	},

	["-3.2"] = {

		["-0.00"] = 0.00069,
		["-0.01"] = 0.00066,
		["-0.02"] = 0.00064,
		["-0.03"] = 0.00062,
		["-0.04"] = 0.00060,
		["-0.05"] = 0.00058,
		["-0.06"] = 0.00056,
		["-0.07"] = 0.00054,
		["-0.08"] = 0.00052,
		["-0.09"] = 0.00050,

	},

	["-3.1"] = {

		["-0.00"] = 0.00097,
		["-0.01"] = 0.00094,
		["-0.02"] = 0.00090,
		["-0.03"] = 0.00087,
		["-0.04"] = 0.00084,
		["-0.05"] = 0.00082,
		["-0.06"] = 0.00079,
		["-0.07"] = 0.00076,
		["-0.08"] = 0.00074,
		["-0.09"] = 0.00071,

	},

	["-3.0"] = {

		["-0.00"] = 0.00135,
		["-0.01"] = 0.00131,
		["-0.02"] = 0.00126,
		["-0.03"] = 0.00122,
		["-0.04"] = 0.00118,
		["-0.05"] = 0.00114,
		["-0.06"] = 0.00111,
		["-0.07"] = 0.00107,
		["-0.08"] = 0.00104,
		["-0.09"] = 0.00100,

	},

	["-2.9"] = {

		["-0.00"] = 0.00187,
		["-0.01"] = 0.00181,
		["-0.02"] = 0.00175,
		["-0.03"] = 0.00169,
		["-0.04"] = 0.00164,
		["-0.05"] = 0.00159,
		["-0.06"] = 0.00154,
		["-0.07"] = 0.00149,
		["-0.08"] = 0.00144,
		["-0.09"] = 0.00139,

	},

	["-2.8"] = {

		["-0.00"] = 0.00256,
		["-0.01"] = 0.00248,
		["-0.02"] = 0.00240,
		["-0.03"] = 0.00233,
		["-0.04"] = 0.00226,
		["-0.05"] = 0.00219,
		["-0.06"] = 0.00212,
		["-0.07"] = 0.00205,
		["-0.08"] = 0.00199,
		["-0.09"] = 0.00193,

	},

	["-2.7"] = {

		["-0.00"] = 0.00347,
		["-0.01"] = 0.00336,
		["-0.02"] = 0.00326,
		["-0.03"] = 0.00317,
		["-0.04"] = 0.00307,
		["-0.05"] = 0.00298,
		["-0.06"] = 0.00289,
		["-0.07"] = 0.00280,
		["-0.08"] = 0.00272,
		["-0.09"] = 0.00264,
	},

	["-2.6"] = {
		["-0.00"] = 0.00466,
		["-0.01"] = 0.00453,
		["-0.02"] = 0.00440,
		["-0.03"] = 0.00427,
		["-0.04"] = 0.00415,
		["-0.05"] = 0.00402,
		["-0.06"] = 0.00391,
		["-0.07"] = 0.00379,
		["-0.08"] = 0.00368,
		["-0.09"] = 0.00357,
	},

	["-2.5"] = {
		["-0.00"] = 0.00621,
		["-0.01"] = 0.00604,
		["-0.02"] = 0.00587,
		["-0.03"] = 0.00570,
		["-0.04"] = 0.00554,
		["-0.05"] = 0.00539,
		["-0.06"] = 0.00523,
		["-0.07"] = 0.00508,
		["-0.08"] = 0.00494,
		["-0.09"] = 0.00480,
	},

	["-2.4"] = {

		["-0.00"] = 0.00820,
		["-0.01"] = 0.00798,
		["-0.02"] = 0.00776,
		["-0.03"] = 0.00755,
		["-0.04"] = 0.00734,
		["-0.05"] = 0.00714,
		["-0.06"] = 0.00695,
		["-0.07"] = 0.00676,
		["-0.08"] = 0.00657,
		["-0.09"] = 0.00639,

	},

	["-2.3"] = {

		["-0.00"] = 0.01072,
		["-0.01"] = 0.01044,
		["-0.02"] = 0.01017,
		["-0.03"] = 0.00990,
		["-0.04"] = 0.00964,
		["-0.05"] = 0.00939,
		["-0.06"] = 0.00914,
		["-0.07"] = 0.00889,
		["-0.08"] = 0.00866,
		["-0.09"] = 0.00842,

	},

	["-2.2"] = {

		["-0.00"] = 0.01390,
		["-0.01"] = 0.01355,
		["-0.02"] = 0.01321,
		["-0.03"] = 0.01287,
		["-0.04"] = 0.01255,
		["-0.05"] = 0.01222,
		["-0.06"] = 0.01191,
		["-0.07"] = 0.01160,
		["-0.08"] = 0.01130,
		["-0.09"] = 0.01101,

	},

	["-2.1"] = {

		["-0.00"] = 0.01786,
		["-0.01"] = 0.01743,
		["-0.02"] = 0.01700,
		["-0.03"] = 0.01659,
		["-0.04"] = 0.01618,
		["-0.05"] = 0.01578,
		["-0.06"] = 0.01539,
		["-0.07"] = 0.01500,
		["-0.08"] = 0.01463,
		["-0.09"] = 0.01426,

	},

	["-2.0"] = {

		["-0.00"] = 0.02275,
		["-0.01"] = 0.02222,
		["-0.02"] = 0.02169,
		["-0.03"] = 0.02118,
		["-0.04"] = 0.02068,
		["-0.05"] = 0.02018,
		["-0.06"] = 0.01970,
		["-0.07"] = 0.01923,
		["-0.08"] = 0.01876,
		["-0.09"] = 0.01831,

	},

	["-1.9"] = {

		["-0.00"] = 0.02872,
		["-0.01"] = 0.02807,
		["-0.02"] = 0.02743,
		["-0.03"] = 0.02680,
		["-0.04"] = 0.02619,
		["-0.05"] = 0.02559,
		["-0.06"] = 0.02500,
		["-0.07"] = 0.02442,
		["-0.08"] = 0.02385,
		["-0.09"] = 0.02330,

	},

	["-1.8"] = {

		["-0.00"] = 0.03593,
		["-0.01"] = 0.03515,
		["-0.02"] = 0.03438,
		["-0.03"] = 0.03362,
		["-0.04"] = 0.03288,
		["-0.05"] = 0.03216,
		["-0.06"] = 0.03144,
		["-0.07"] = 0.03074,
		["-0.08"] = 0.03005,
		["-0.09"] = 0.02938,

	},

	["-1.7"] = {

		["-0.00"] = 0.04457,
		["-0.01"] = 0.04363,
		["-0.02"] = 0.04272,
		["-0.03"] = 0.04182,
		["-0.04"] = 0.04093,
		["-0.05"] = 0.04006,
		["-0.06"] = 0.03920,
		["-0.07"] = 0.03836,
		["-0.08"] = 0.03754,
		["-0.09"] = 0.03673,

	},

	["-1.6"] = {

		["-0.00"] = 0.05480,
		["-0.01"] = 0.05370,
		["-0.02"] = 0.05262,
		["-0.03"] = 0.05155,
		["-0.04"] = 0.05050,
		["-0.05"] = 0.04947,
		["-0.06"] = 0.04846,
		["-0.07"] = 0.04746,
		["-0.08"] = 0.04648,
		["-0.09"] = 0.04551,

	},

	["-1.5"] = {

		["-0.00"] = 0.06681,
		["-0.01"] = 0.06552,
		["-0.02"] = 0.06426,
		["-0.03"] = 0.06301,
		["-0.04"] = 0.06178,
		["-0.05"] = 0.06057,
		["-0.06"] = 0.05938,
		["-0.07"] = 0.05821,
		["-0.08"] = 0.05705,
		["-0.09"] = 0.05592,

	},

	["-1.4"] = {

		["-0.00"] = 0.08076,
		["-0.01"] = 0.07927,
		["-0.02"] = 0.07780,
		["-0.03"] = 0.07636,
		["-0.04"] = 0.07493,
		["-0.05"] = 0.07353,
		["-0.06"] = 0.07215,
		["-0.07"] = 0.07078,
		["-0.08"] = 0.06944,
		["-0.09"] = 0.06811,

	},

	["-1.3"] = {

		["-0.00"] = 0.09680,
		["-0.01"] = 0.09510,
		["-0.02"] = 0.09342,
		["-0.03"] = 0.09176,
		["-0.04"] = 0.09012,
		["-0.05"] = 0.08851,
		["-0.06"] = 0.08692,
		["-0.07"] = 0.08534,
		["-0.08"] = 0.08379,
		["-0.09"] = 0.08226,

	},

	["-1.2"] = {

		["-0.00"] = 0.11507,
		["-0.01"] = 0.11314,
		["-0.02"] = 0.11123,
		["-0.03"] = 0.10935,
		["-0.04"] = 0.10749,
		["-0.05"] = 0.10565,
		["-0.06"] = 0.10383,
		["-0.07"] = 0.10204,
		["-0.08"] = 0.10027,
		["-0.09"] = 0.09853,

	},

	["-1.1"] = {

		["-0.00"] = 0.13567,
		["-0.01"] = 0.13350,
		["-0.02"] = 0.13136,
		["-0.03"] = 0.12924,
		["-0.04"] = 0.12714,
		["-0.05"] = 0.12507,
		["-0.06"] = 0.12302,
		["-0.07"] = 0.12100,
		["-0.08"] = 0.11900,
		["-0.09"] = 0.11702,

	},

	["-1.0"] = {

		["-0.00"] = 0.15866,
		["-0.01"] = 0.15625,
		["-0.02"] = 0.15386,
		["-0.03"] = 0.15151,
		["-0.04"] = 0.14917,
		["-0.05"] = 0.14686,
		["-0.06"] = 0.14457,
		["-0.07"] = 0.14231,
		["-0.08"] = 0.14007,
		["-0.09"] = 0.13786,

	},

	["-0.9"] = {

		["-0.00"] = 0.18406,
		["-0.01"] = 0.18141,
		["-0.02"] = 0.17879,
		["-0.03"] = 0.17619,
		["-0.04"] = 0.17361,
		["-0.05"] = 0.17106,
		["-0.06"] = 0.16853,
		["-0.07"] = 0.16602,
		["-0.08"] = 0.16354,
		["-0.09"] = 0.16109,

	},

	["-0.8"] = {

		["-0.00"] = 0.21186,
		["-0.01"] = 0.20897,
		["-0.02"] = 0.20611,
		["-0.03"] = 0.20327,
		["-0.04"] = 0.20045,
		["-0.05"] = 0.19766,
		["-0.06"] = 0.19489,
		["-0.07"] = 0.19215,
		["-0.08"] = 0.18943,
		["-0.09"] = 0.18673,

	},

	["-0.7"] = {

		["-0.00"] = 0.24196,
		["-0.01"] = 0.23885,
		["-0.02"] = 0.23576,
		["-0.03"] = 0.23270,
		["-0.04"] = 0.22965,
		["-0.05"] = 0.22663,
		["-0.06"] = 0.22363,
		["-0.07"] = 0.22065,
		["-0.08"] = 0.21770,
		["-0.09"] = 0.21476,
	},

	["-0.6"] = {

		["-0.00"] = 0.27425,
		["-0.01"] = 0.27093,
		["-0.02"] = 0.26763,
		["-0.03"] = 0.26435,
		["-0.04"] = 0.26109,
		["-0.05"] = 0.25785,
		["-0.06"] = 0.25463,
		["-0.07"] = 0.25143,
		["-0.08"] = 0.24825,
		["-0.09"] = 0.24510,
	},

	["-0.5"] = {

		["-0.00"] = 0.30854,
		["-0.01"] = 0.30503,
		["-0.02"] = 0.30153,
		["-0.03"] = 0.29806,
		["-0.04"] = 0.29460,
		["-0.05"] = 0.29116,
		["-0.06"] = 0.28774,
		["-0.07"] = 0.28434,
		["-0.08"] = 0.28096,
		["-0.09"] = 0.27760,
	},

	["-0.4"] = {

		["-0.00"] = 0.34458,
		["-0.01"] = 0.34090,
		["-0.02"] = 0.33724,
		["-0.03"] = 0.33360,
		["-0.04"] = 0.32997,
		["-0.05"] = 0.32636,
		["-0.06"] = 0.32276,
		["-0.07"] = 0.31918,
		["-0.08"] = 0.31561,
		["-0.09"] = 0.31207,
	},

	["-0.3"] = {

		["-0.00"] = 0.38209,
		["-0.01"] = 0.37828,
		["-0.02"] = 0.37448,
		["-0.03"] = 0.37070,
		["-0.04"] = 0.36693,
		["-0.05"] = 0.36317,
		["-0.06"] = 0.35942,
		["-0.07"] = 0.35569,
		["-0.08"] = 0.35197,
		["-0.09"] = 0.34827,
	},

	["-0.2"] = {

		["-0.00"] = 0.42074,
		["-0.01"] = 0.41683,
		["-0.02"] = 0.41294,
		["-0.03"] = 0.40905,
		["-0.04"] = 0.40517,
		["-0.05"] = 0.40129,
		["-0.06"] = 0.39743,
		["-0.07"] = 0.39358,
		["-0.08"] = 0.38974,
		["-0.09"] = 0.38591,
	},

	["-0.1"] = {

		["-0.00"] = 0.46017,
		["-0.01"] = 0.45620,
		["-0.02"] = 0.45224,
		["-0.03"] = 0.44828,
		["-0.04"] = 0.44433,
		["-0.05"] = 0.44038,
		["-0.06"] = 0.43644,
		["-0.07"] = 0.43251,
		["-0.08"] = 0.42858,
		["-0.09"] = 0.42465,
	},

	["-0.0"] = {

		["-0.00"] = 0.50000,
		["-0.01"] = 0.49601,
		["-0.02"] = 0.49202,
		["-0.03"] = 0.48803,
		["-0.04"] = 0.48405,
		["-0.05"] = 0.48006,
		["-0.06"] = 0.47608,
		["-0.07"] = 0.47210,
		["-0.08"] = 0.46812,
		["-0.09"] = 0.46414,

	},

}

local cachedRowValueArray = {}

for k in pairs(zTable) do table.insert(cachedRowValueArray, tonumber(k)) end

table.sort(cachedRowValueArray)

local rowStringFormat = "%.1f"

local columnStringFormat = "%.2f"

function zTableFunction:getStandardNormalCumulativeDistributionFunction(zValue)

	local rowStringFormat = rowStringFormat

	local columnStringFormat = columnStringFormat

	local stringFormatFunction = string.format

	local isPositive = (zValue > 0)

	local finalZValue = (isPositive and -zValue) or zValue

	local clampedZValue = math.clamp(finalZValue, -3.9, 0)

	local rowValue = math.floor(clampedZValue * 10) / 10

	local rowString = stringFormatFunction(rowStringFormat, rowValue)

	local rowTable = zTable[rowString]

	if (not rowTable) then return end

	local columnValue = finalZValue - rowValue

	local absoluteColumnValue = math.abs(columnValue)

	local lowerColumnValue = math.floor(columnValue * 100) / 100

	local upperColumnValue = lowerColumnValue + 0.01

	local lowerColumnString = stringFormatFunction(columnStringFormat, lowerColumnValue)

	local upperColumnString = stringFormatFunction(columnStringFormat, upperColumnValue)

	local lowerCumulativeDistributionFunctionValue = rowTable[lowerColumnString]

	local upperCumulativeDistributionFunctionValue = rowTable[upperColumnString]

	if (not lowerCumulativeDistributionFunctionValue) then return upperCumulativeDistributionFunctionValue end

	if (not upperCumulativeDistributionFunctionValue) then return lowerCumulativeDistributionFunctionValue end

	local fraction = (absoluteColumnValue - lowerColumnValue) / (upperColumnValue - lowerColumnValue)

	local cumulativeDistributionFunctionValue = lowerCumulativeDistributionFunctionValue + (upperCumulativeDistributionFunctionValue - lowerCumulativeDistributionFunctionValue) * fraction

	if (isPositive) then cumulativeDistributionFunctionValue = 1 - cumulativeDistributionFunctionValue end

	return cumulativeDistributionFunctionValue

end

function zTableFunction:getStandardNormalInverseCumulativeDistributionFunction(probability)

	local rowStringFormat = rowStringFormat

	local columnStringFormat = columnStringFormat

	local stringFormatFunction = string.format

	local isFlipped = (probability > 0.5)

	local finalProbability = (isFlipped and (1 - probability)) or probability

	local clampedProbability = math.clamp(finalProbability, 0.00005, 0.5)

	local closestZValue

	local rowString

	local rowTable

	local columnValueArray

	local columnValue1

	local columnValue2

	local probabilityValue1

	local probabilityValue2

	local fraction

	local closestZValue

	for _, rowValue in ipairs(cachedRowValueArray) do

		rowString = stringFormatFunction(rowStringFormat, rowValue)

		rowTable = zTable[rowString]

		columnValueArray = {}

		for k in pairs(rowTable) do table.insert(columnValueArray, tonumber(k)) end

		table.sort(columnValueArray)

		for i = 1, #columnValueArray - 1 do

			columnValue1 = columnValueArray[i]

			columnValue2 = columnValueArray[i + 1]

			probabilityValue1 = rowTable[stringFormatFunction(columnStringFormat, columnValue1)]

			probabilityValue2 = rowTable[stringFormatFunction(columnStringFormat, columnValue2)]

			if (clampedProbability >= probabilityValue1) and (clampedProbability <= probabilityValue2) then

				fraction = (clampedProbability - probabilityValue1) / (probabilityValue2 - probabilityValue1)

				closestZValue = rowValue - (columnValue1 + (fraction * (columnValue2 - columnValue1)))

				break

			end

		end

		if (closestZValue) then break end

	end

	if (isFlipped) and (closestZValue) then closestZValue = -closestZValue end

	return closestZValue

end

return zTableFunction
]]></ProtectedString>
									<string name="ScriptGuid">{7A973D9C-8039-45B5-B1BF-2A9B89F38837}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ZTableFunction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX3AF3AF64D7B34485972CAB5C357E9E22">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">ValueSchedulers</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX8A79568871CF42EFAF31D3538C38FD01">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

StepValueScheduler = {}

StepValueScheduler.__index = StepValueScheduler

setmetatable(StepValueScheduler, BaseValueScheduler)

local defaultTimeValue = 100

local defaultDecayRate = 0.5

function StepValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewStepValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewStepValueScheduler, StepValueScheduler)
	
	NewStepValueScheduler:setName("Step")
	
	NewStepValueScheduler.timeValue = parameterDictionary.timeValue or defaultTimeValue
	
	NewStepValueScheduler.decayRate = parameterDictionary.decayRate or defaultDecayRate
	
	--------------------------------------------------------------------------------
	
	NewStepValueScheduler:setCalculateFunction(function(value, timeValue)

		return (value * math.pow(NewStepValueScheduler.decayRate, (math.floor(timeValue / NewStepValueScheduler.timeValue))))
		
	end)
	
	return NewStepValueScheduler
	
end

function StepValueScheduler:setTimeValue(timeValue)

	self.timeValue = timeValue

end

function StepValueScheduler:setDecayRate(decayRate)
	
	self.decayRate = decayRate
	
end

return StepValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{BA57D1EE-661C-4763-85B3-285DA003E366}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Step</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC566C72C05284F678716999A1DDFD93F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

MultiplicativeValueScheduler = {}

MultiplicativeValueScheduler.__index = MultiplicativeValueScheduler

setmetatable(MultiplicativeValueScheduler, BaseValueScheduler)

function MultiplicativeValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewMultiplicativeValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewMultiplicativeValueScheduler, MultiplicativeValueScheduler)
	
	NewMultiplicativeValueScheduler:setName("Multiplicative")
	
	local functionToRun = parameterDictionary.functionToRun
	
	if (not functionToRun) then error("No function to run.") end
	
	NewMultiplicativeValueScheduler.functionToRun = functionToRun
	
	--------------------------------------------------------------------------------
	
	NewMultiplicativeValueScheduler:setCalculateFunction(function(value, timeValue)

		return (value * NewMultiplicativeValueScheduler.functionToRun(timeValue))
		
	end)
	
	return NewMultiplicativeValueScheduler
	
end

function MultiplicativeValueScheduler:setFunctionToRun(functionToRun)
	
	self.functionToRun = functionToRun
	
end

return MultiplicativeValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{58191CCC-F10A-473B-B1AC-AE2A62141FC8}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Multiplicative</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC51B15A8723944DDA7D2B4CF4A7BBADC">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

BaseValueScheduler = {}

BaseValueScheduler.__index = BaseValueScheduler

setmetatable(BaseValueScheduler, BaseInstance)

local defaultValue = 0

function BaseValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewBaseValueScheduler = BaseInstance.new(parameterDictionary)
	
	setmetatable(NewBaseValueScheduler, BaseValueScheduler)
	
	NewBaseValueScheduler:setName("BaseValueScheduler")

	NewBaseValueScheduler:setClassName("ValueScheduler")
	
	NewBaseValueScheduler.calculateFunction = parameterDictionary.calculateFunction
	
	NewBaseValueScheduler.timeValue = parameterDictionary.timeValue or defaultValue
	
	return NewBaseValueScheduler
	
end

function BaseValueScheduler:calculate(valueToSchedule, valueToScale)
	
	local timeValue = self.timeValue
	
	timeValue = timeValue + 1
	
	self.timeValue = timeValue
	
	valueToSchedule = self.calculateFunction(valueToSchedule, timeValue)
	
	if (not valueToScale) then return valueToSchedule end
	
	return AqwamTensorLibrary:multiply(valueToSchedule, valueToScale)
	
end

function BaseValueScheduler:setCalculateFunction(calculateFunction)
	
	self.calculateFunction = calculateFunction
	
end

function BaseValueScheduler:reset()

	self.timeValue = 0

end

return BaseValueScheduler
]]></ProtectedString>
									<string name="ScriptGuid">{FD11A180-BCFE-4D8D-94C4-02FD8719A80D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BaseValueScheduler</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX72AB2144E0B4451B9EA24DEAFD641CEF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

ExponentValueScheduler = {}

ExponentValueScheduler.__index = ExponentValueScheduler

setmetatable(ExponentValueScheduler, BaseValueScheduler)

local defaultDecayRate = 0.5

function ExponentValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewExponentValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewExponentValueScheduler, ExponentValueScheduler)
	
	NewExponentValueScheduler:setName("Exponent")
	
	NewExponentValueScheduler.decayRate = parameterDictionary.decayRate or defaultDecayRate
	
	--------------------------------------------------------------------------------
	
	NewExponentValueScheduler:setCalculateFunction(function(value, timeValue)

		return (value * math.exp(-NewExponentValueScheduler.decayRate * timeValue))
		
	end)
	
	return NewExponentValueScheduler
	
end

function ExponentValueScheduler:setDecayRate(decayRate)
	
	self.decayRate = decayRate
	
end

return ExponentValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{0FA572FA-9241-4786-BC05-3EF9AAB571E6}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Exponential</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX362CE95B9698460FB1A64A3380EC1C7F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

PolynomialValueScheduler = {}

PolynomialValueScheduler.__index = PolynomialValueScheduler

setmetatable(PolynomialValueScheduler, BaseValueScheduler)

local defaultTotalTimeValue = 5

local defaultPower = 1

function PolynomialValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewPolynomialValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewPolynomialValueScheduler, PolynomialValueScheduler)
	
	NewPolynomialValueScheduler:setName("Polynomial")
	
	NewPolynomialValueScheduler.totalTimeValue = parameterDictionary.totalTimeValue or defaultTotalTimeValue
	
	NewPolynomialValueScheduler.power = parameterDictionary.power or defaultPower
	
	--------------------------------------------------------------------------------
	
	NewPolynomialValueScheduler:setCalculateFunction(function(value, timeValue)

		return (value * math.pow((1 - (timeValue / NewPolynomialValueScheduler.totalTimeValue)), NewPolynomialValueScheduler.power))
		
	end)
	
	return NewPolynomialValueScheduler
	
end

function PolynomialValueScheduler:setTotalTimeValue(totalTimeValue)
	
	self.totalTimeValue = totalTimeValue
	
end

function PolynomialValueScheduler:setPower(power)
	
	self.power = power
	
end

return PolynomialValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{6D42E3B1-5DFE-42FA-AD4D-BB9B83F3546A}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Polynomial</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX916E7157217D4C78992D89C22945606E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

CosineAnnealingValueScheduler = {}

CosineAnnealingValueScheduler.__index = CosineAnnealingValueScheduler

setmetatable(CosineAnnealingValueScheduler, BaseValueScheduler)

local defaultMaximumTimeValue = 5

local defaultMinimumValue = 1

function CosineAnnealingValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewCosineAnnealingValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewCosineAnnealingValueScheduler, CosineAnnealingValueScheduler)
	
	NewCosineAnnealingValueScheduler:setName("CosineAnnealing")
	
	NewCosineAnnealingValueScheduler.maximumTimeValue = parameterDictionary.maximumTimeValue or defaultMaximumTimeValue
	
	NewCosineAnnealingValueScheduler.minimumValue = parameterDictionary.minimumValue or defaultMinimumValue
	
	--------------------------------------------------------------------------------
	
	NewCosineAnnealingValueScheduler:setCalculateFunction(function(value, timeValue)
		
		local minimumValue = NewCosineAnnealingValueScheduler.minimumValue
		
		local multiplyValuePart1 = 1 + math.cos((timeValue * math.pi) / NewCosineAnnealingValueScheduler.maximumTimeValue)
		
		local multiplyValuePart2 = (value - minimumValue)
		
		local multiplyValue = 0.5 * multiplyValuePart1 * multiplyValuePart2
		
		return (minimumValue + multiplyValue)
		
	end)
	
	return NewCosineAnnealingValueScheduler
	
end

function CosineAnnealingValueScheduler:setMaximumTimeValue(maximumTimeValue)
	
	self.maximumTimeValue = maximumTimeValue
	
end

function CosineAnnealingValueScheduler:setMinimumValue(minimumValue)

	self.minimumValue = minimumValue

end

return CosineAnnealingValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{4F4CEAD7-AE66-472D-9A90-9C2D0DF45BA3}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">CosineAnnealing</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA8C63FA9FFC24721AF0F353D6003082B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

ChainedValueScheduler = {}

ChainedValueScheduler.__index = ChainedValueScheduler

setmetatable(ChainedValueScheduler, BaseValueScheduler)

function ChainedValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewChainedValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewChainedValueScheduler, ChainedValueScheduler)
	
	NewChainedValueScheduler:setName("Chained")
	
	local ValueSchedulerArray = parameterDictionary.ValueSchedulerArray
	
	if (not ValueSchedulerArray) then error("No value scheduler array.") end
	
	if (#ValueSchedulerArray <= 0) then error("No value scheduler.") end
	
	NewChainedValueScheduler.ValueSchedulerArray = ValueSchedulerArray
	
	--------------------------------------------------------------------------------
	
	NewChainedValueScheduler:setCalculateFunction(function(value, timeValue)
		
		for _, ValueScheduler in ipairs(NewChainedValueScheduler.ValueSchedulerArray) do
			
			value = ValueScheduler:calculate(value, timeValue)
			
		end

		return value
		
	end)
	
	return NewChainedValueScheduler
	
end

function ChainedValueScheduler:setValueSchedulerArray(ValueSchedulerArray)
	
	self.ValueSchedulerArray = ValueSchedulerArray
	
end

return ChainedValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{171CCAEC-5CFB-4738-A342-A65968995CED}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Chained</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX711D2B2D00434C7696EAB0EFEB41EBAF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

MultipleStepValueScheduler = {}

MultipleStepValueScheduler.__index = MultipleStepValueScheduler

setmetatable(MultipleStepValueScheduler, BaseValueScheduler)

local defaultDecayRate = 0.5

function MultipleStepValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewMultipleStepValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewMultipleStepValueScheduler, MultipleStepValueScheduler)
	
	NewMultipleStepValueScheduler:setName("MultipleStep")
	
	local timeValueArray = parameterDictionary.timeValueArray
	
	if (not timeValueArray) then error("No time value array.") end
	
	if (#timeValueArray <= 0) then error("No time value.") end
	
	NewMultipleStepValueScheduler.timeValueArray = timeValueArray
	
	NewMultipleStepValueScheduler.decayRate = parameterDictionary.decayRate or defaultDecayRate
	
	--------------------------------------------------------------------------------
	
	NewMultipleStepValueScheduler:setCalculateFunction(function(value, timeValue)
		
		local decayCount = 0
		
		for i, timeValueMilestone in ipairs(NewMultipleStepValueScheduler.timeValueArray) do
			
			if (timeValue <= timeValueMilestone) then break end
				
			decayCount = decayCount + 1
			
		end

		return (value * math.pow(NewMultipleStepValueScheduler.decayRate, decayCount))
		
	end)
	
	return NewMultipleStepValueScheduler
	
end

function MultipleStepValueScheduler:setTimeValueArray(timeValueArray)

	self.timeValueArray = timeValueArray

end

function MultipleStepValueScheduler:setDecayRate(decayRate)
	
	self.decayRate = decayRate
	
end

return MultipleStepValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{E117BE78-978A-4BB1-A2FA-CA1AF964A7B0}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">MultipleStep</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF6D334A9EF824C97875529620A72F060">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

ConstantValueScheduler = {}

ConstantValueScheduler.__index = ConstantValueScheduler

setmetatable(ConstantValueScheduler, BaseValueScheduler)

local defaultTimeValue = 1

local defaultDecayRate = 0.5

function ConstantValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewConstantValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewConstantValueScheduler, ConstantValueScheduler)
	
	NewConstantValueScheduler:setName("Constant")
	
	NewConstantValueScheduler.timeValue = parameterDictionary.timeValue or defaultTimeValue
	
	NewConstantValueScheduler.decayRate = parameterDictionary.decayRate or defaultDecayRate
	
	--------------------------------------------------------------------------------
	
	NewConstantValueScheduler:setCalculateFunction(function(value, timeValue)
		
		if (timeValue <= NewConstantValueScheduler.timeValue) then return value end

		return (value * NewConstantValueScheduler.decayRate)
		
	end)
	
	return NewConstantValueScheduler
	
end

function ConstantValueScheduler:setTimeValue(timeValue)

	self.timeValue = timeValue

end

function ConstantValueScheduler:setDecayRate(decayRate)
	
	self.decayRate = decayRate
	
end

return ConstantValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{AEB61745-2F0C-4A9A-95ED-3ECEEAB7783B}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Constant</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX54B15D11F8984AEE8DAB9CFA4A5E5CD2">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

LinearValueScheduler = {}

LinearValueScheduler.__index = LinearValueScheduler

setmetatable(LinearValueScheduler, BaseValueScheduler)

local defaultTimeValue = 5

local defaultStartFactor = 1/3

local defaultEndFactor = 1

function LinearValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewLinearValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewLinearValueScheduler, LinearValueScheduler)
	
	NewLinearValueScheduler:setName("Linear")
	
	NewLinearValueScheduler.timeValue = parameterDictionary.timeValue or defaultTimeValue
	
	NewLinearValueScheduler.startFactor = parameterDictionary.startFactor or defaultStartFactor
	
	NewLinearValueScheduler.endFactor = parameterDictionary.endFactor or defaultEndFactor
	
	--------------------------------------------------------------------------------
	
	NewLinearValueScheduler:setCalculateFunction(function(value, timeValue)
		
		local otherTimeValue = NewLinearValueScheduler.timeValue
		
		local endFactor = NewLinearValueScheduler.endFactor
		
		if (timeValue >= otherTimeValue) then return (value * endFactor) end
		
		local startFactor = NewLinearValueScheduler.startFactor
		
		local factor = startFactor + ((endFactor - startFactor) * (timeValue / otherTimeValue))

		return (value * factor)
		
	end)
	
	return NewLinearValueScheduler
	
end

function LinearValueScheduler:setTimeValue(timeValue)

	self.timeValue = timeValue

end

function LinearValueScheduler:setStartFactor(startFactor)
	
	self.startFactor = startFactor
	
end

function LinearValueScheduler:setEndFactor(endFactor)
	
	self.endFactor = endFactor
	
end

return LinearValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{549E0410-BCFC-4F98-B03D-B1E48E887781}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Linear</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7DFB3856BEE0429EA3B4A3EC7EE11EF1">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

SequentialValueScheduler = {}

SequentialValueScheduler.__index = SequentialValueScheduler

setmetatable(SequentialValueScheduler, BaseValueScheduler)

function SequentialValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewSequentialValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewSequentialValueScheduler, SequentialValueScheduler)
	
	NewSequentialValueScheduler:setName("Sequential")
	
	local ValueSchedulerArray = parameterDictionary.ValueSchedulerArray
	
	local timeValueArray = parameterDictionary.timeValueArray
	
	if (not ValueSchedulerArray) then error("No value scheduler array.") end
	
	local numberOfValueSchedulers = #ValueSchedulerArray
	
	if (numberOfValueSchedulers <= 0) then error("No value scheduler.") end
	
	if (not timeValueArray) then error("No time value array.") end
	
	local numberOfTimeValueArray = #timeValueArray

	if (numberOfTimeValueArray <= 0) then error("No time value.") end
	
	if (numberOfValueSchedulers ~= numberOfTimeValueArray) then error("The number of value schedulers is not equal to the number of time values.") end
	
	NewSequentialValueScheduler.ValueSchedulerArray = ValueSchedulerArray
	
	NewSequentialValueScheduler.timeValueArray = timeValueArray
	
	--------------------------------------------------------------------------------
	
	NewSequentialValueScheduler:setCalculateFunction(function(value, timeValue)
		
		local ValueSchedulerArray = NewSequentialValueScheduler.ValueSchedulerArray
		
		local timeValueArray = NewSequentialValueScheduler.timeValueArray
		
		for i, ValueScheduler in ipairs(ValueSchedulerArray) do
			
			if (timeValue <= timeValueArray[i]) then return ValueScheduler:calculate(value, timeValue) end
			
		end

		return ValueSchedulerArray[#ValueSchedulerArray]:calculate(value, timeValue) 
		
	end)
	
	return NewSequentialValueScheduler
	
end

function SequentialValueScheduler:setValueSchedulerArray(ValueSchedulerArray)
	
	self.ValueSchedulerArray = ValueSchedulerArray
	
end

function SequentialValueScheduler:setTimeValueArray(timeValueArray)

	self.timeValueArray = timeValueArray

end

return SequentialValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{A270422A-AF6B-49D1-A227-8E8F12CC7FF6}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Sequential</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8B99CD8B7C9642F8A62B4FF061217D89">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

InverseTimeValueScheduler = {}

InverseTimeValueScheduler.__index = InverseTimeValueScheduler

setmetatable(InverseTimeValueScheduler, BaseValueScheduler)

local defaultDecayRate = 0.5

function InverseTimeValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewInverseTimeValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewInverseTimeValueScheduler, InverseTimeValueScheduler)
	
	NewInverseTimeValueScheduler:setName("InverseTime")
	
	NewInverseTimeValueScheduler.decayRate = parameterDictionary.decayRate or defaultDecayRate
	
	--------------------------------------------------------------------------------
	
	NewInverseTimeValueScheduler:setCalculateFunction(function(value, timeValue)

		return (value / (1 + (NewInverseTimeValueScheduler.decayRate * timeValue)))
		
	end)
	
	return NewInverseTimeValueScheduler
	
end

function InverseTimeValueScheduler:setDecayRate(decayRate)
	
	self.decayRate = decayRate
	
end

return InverseTimeValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{D7445F0D-2968-4582-B675-07AD989F5FF8}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">InverseTime</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX17A5AE128AA542A5987A1D31B92ADC85">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseValueScheduler = require(script.Parent.BaseValueScheduler)

InverseSquareRootValueScheduler = {}

InverseSquareRootValueScheduler.__index = InverseSquareRootValueScheduler

setmetatable(InverseSquareRootValueScheduler, BaseValueScheduler)

function InverseSquareRootValueScheduler.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewInverseSquareRootValueScheduler = BaseValueScheduler.new(parameterDictionary)
	
	setmetatable(NewInverseSquareRootValueScheduler, InverseSquareRootValueScheduler)
	
	NewInverseSquareRootValueScheduler:setName("InverseSquareRoot")
	
	--------------------------------------------------------------------------------
	
	NewInverseSquareRootValueScheduler:setCalculateFunction(function(value, timeValue)

		return (value / math.pow(timeValue, 0.5))
		
	end)
	
	return NewInverseSquareRootValueScheduler
	
end

return InverseSquareRootValueScheduler]]></ProtectedString>
									<string name="ScriptGuid">{B5D9CC3A-F6D0-47B4-AEFC-579D54548B5B}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">InverseSquareRoot</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXA2127C6CCB8D46238D6511DB581EAEDB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Others</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX507AAAA97153447E8DF09FB4FA8573EB">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

local ModelTrainingModifier = require(script.Parent.ModelTrainingModifier)

local ModelSafeguardWrapper = {}

ModelSafeguardWrapper.__index = ModelSafeguardWrapper

setmetatable(ModelSafeguardWrapper, BaseInstance)

local defaultIgnoreUpdateOnDefect = false

local defaultRemoveDefectiveDataOnDefect = true

local defaultReplaceValuesOnDefect = true

local defaultModifyModelOnDefect = true

local defaultStoreDefectiveUpdateInformation = false

local defaultMaximumAcceptableCostMultiplier = 1

local function checkIfAllAreNumbers(matrix)
	
	local numberOfRows = #matrix
	
	local numberOfColumns = #matrix[1]
	
	for row = 1, numberOfRows, 1 do
		
		for column = 1, numberOfColumns, 1 do
			
			if (type(matrix[row][column]) ~= "number") then return false end
			
		end
		
	end
	
	return true
	
end

local function getMaximumAcceptableCost(dataMatrixArray, hasClassification)
	
	local sum = 0
	
	local partialSum
	
	local absoluteDataMatrix
	
	for i, dataMatrix in ipairs(dataMatrixArray) do
		
		if (i == 2) and (hasClassification) and (#dataMatrix[1] == 1) then
			
			partialSum = #dataMatrix
			
		else
			
			absoluteDataMatrix = AqwamTensorLibrary:applyFunction(math.abs, dataMatrix)
			
			partialSum = AqwamTensorLibrary:sum(absoluteDataMatrix)
			
		end
		
		sum = sum + partialSum
		
	end
	
	return sum
	
end

local function checkIfIsAcceptableValue(value, minimumValue, maximumValue)
	
	local isValidValue = (value == value) and (value ~= math.huge) and (value ~= -math.huge) and (type(value) == "number")
	
	if (not isValidValue) then return false end
	
	if (minimumValue) then
		
		if (value < minimumValue) then return false end
		
	end
	
	if (maximumValue) then

		if (value > maximumValue) then return false end

	end

	return true

end

local function checkIfModelParametersAreAcceptable(ModelParameters, minimumValue, maximumValue)
	
	local isAcceptable = true
	
	if (type(ModelParameters) == "table") then
		
		for _, value in pairs(ModelParameters) do
			
			isAcceptable = checkIfModelParametersAreAcceptable(value, minimumValue, maximumValue)
			
			if (not isAcceptable) then return false end
			
		end
		
	else
		
		isAcceptable = checkIfIsAcceptableValue(ModelParameters, minimumValue, maximumValue)
		
	end
	
	return isAcceptable
	
end

local function markRowsWithUnknownClass(dataMatrix, ClassesList)

	local numberOfData = #dataMatrix

	local rowWithUnknownClassArray = {}

	local index = 1

	for i, unwrappedDataVector in ipairs(dataMatrix) do

		if (not table.find(ClassesList, unwrappedDataVector[1])) then

			rowWithUnknownClassArray[index] = i

			index = index + 1

		end

	end

	return rowWithUnknownClassArray

end

local function markRowsWithDefectiveData(dataMatrix)

	local numberOfData = #dataMatrix

	local rowWithDefectiveDataArray = {}

	local index = 1

	for i, unwrappedDataVector in ipairs(dataMatrix) do

		for f, value in ipairs(unwrappedDataVector) do

			if (not checkIfIsAcceptableValue(value)) then

				rowWithDefectiveDataArray[index] = i

				index = index + 1

				break

			end

		end

	end

	return rowWithDefectiveDataArray

end

local function mergeRowWithDefectiveDataArrays(rowWithDefectiveDataArrayArray)
	
	local mergedArray = {}
	
	local seenDictionary = {}
	
	local index = 1

	for _, array in ipairs(rowWithDefectiveDataArrayArray) do
		
		for _, item in ipairs(array) do
			
			if (not seenDictionary[item]) then
				
				mergedArray[index] = item
				
				seenDictionary[item] = true
				
				index = index + 1
				
			end
			
		end
		
	end

	return mergedArray
	
end

local function removeRows(rowToRemoveArray, dataMatrix)
	
	local newDataMatrix = {}
	
	local index = 1
	
	for i, unwrappedDataVector in ipairs(dataMatrix) do
		
		if (not table.find(rowToRemoveArray, i)) then
			
			newDataMatrix[index] = unwrappedDataVector
			
			index = index + 1
			
		end
		
	end
	
	return newDataMatrix
	
end

-- If even a single column contains a defective value, remove the whole row.

local function removeDefectiveData(dataMatrixArray, hasClassification, ClassesList)
	
	local rowWithDefectiveDataArrayArray = {}
	
	local newDataMatrixArray = {}
	
	for i, dataMatrix in ipairs(dataMatrixArray) do
		
		if (i == 2) and (hasClassification) and (#dataMatrix[1] == 1) then
			
			rowWithDefectiveDataArrayArray[i] = markRowsWithUnknownClass(dataMatrix, ClassesList)
			
		else
			
			rowWithDefectiveDataArrayArray[i] = markRowsWithDefectiveData(dataMatrix)
			
		end
		
	end
	
	local rowWithDefectiveDataArray = mergeRowWithDefectiveDataArrays(rowWithDefectiveDataArrayArray)
	
	for i, dataMatrix in ipairs(dataMatrixArray) do
		
		newDataMatrixArray[i] = removeRows(rowWithDefectiveDataArray, dataMatrix)
		
	end
	
	return newDataMatrixArray

end

local function deepCopyTable(original, copies)

	copies = copies or {}

	local originalType = type(original)

	local copy

	if (originalType == 'table') then

		if copies[original] then

			copy = copies[original]

		else

			copy = {}

			copies[original] = copy

			for originalKey, originalValue in next, original, nil do

				copy[deepCopyTable(originalKey, copies)] = deepCopyTable(originalValue, copies)

			end

			setmetatable(copy, deepCopyTable(getmetatable(original), copies))

		end

	else -- number, string, boolean, etc

		copy = original

	end

	return copy

end

function ModelSafeguardWrapper.new(parameterDictionary)
	
	local NewModelSafeguardWrapper = BaseInstance.new(parameterDictionary)
	
	setmetatable(NewModelSafeguardWrapper, ModelSafeguardWrapper)
	
	NewModelSafeguardWrapper:setName("ModelSafeguardWrapper")
	
	NewModelSafeguardWrapper:setClassName("ModelSafeguardWrapper")
	
	local Model = parameterDictionary.Model
	
	local isOutputPrinted = NewModelSafeguardWrapper:getValueOrDefaultValue(parameterDictionary.isOutputPrinted, Model.isOutputPrinted)
	
	NewModelSafeguardWrapper.Model = Model
	
	NewModelSafeguardWrapper.ignoreUpdateOnDefect = NewModelSafeguardWrapper:getValueOrDefaultValue(parameterDictionary.ignoreUpdateOnDefect, defaultIgnoreUpdateOnDefect)
	
	NewModelSafeguardWrapper.removeDefectiveDataOnDefect = NewModelSafeguardWrapper:getValueOrDefaultValue(parameterDictionary.removeDefectiveDataOnDefect, defaultRemoveDefectiveDataOnDefect)
	
	NewModelSafeguardWrapper.replaceValuesOnDefect = NewModelSafeguardWrapper:getValueOrDefaultValue(parameterDictionary.replaceValuesOnDefect, defaultReplaceValuesOnDefect)
	
	NewModelSafeguardWrapper.modifyModelOnDefect = NewModelSafeguardWrapper:getValueOrDefaultValue(parameterDictionary.modifyModelOnDefect, defaultModifyModelOnDefect)
	
	NewModelSafeguardWrapper.storeDefectiveUpdateInformation = NewModelSafeguardWrapper:getValueOrDefaultValue(parameterDictionary.storeDefectiveUpdateInformation, defaultStoreDefectiveUpdateInformation)
	
	NewModelSafeguardWrapper.maximumAcceptableCostMultiplier = NewModelSafeguardWrapper:getValueOrDefaultValue(parameterDictionary.maximumAcceptableCostMultiplier, defaultMaximumAcceptableCostMultiplier)
	
	NewModelSafeguardWrapper.ModifiedModel = parameterDictionary.ModifiedModel or ModelTrainingModifier.new({Model = Model, mode = "Stochastic", isOutputPrinted = isOutputPrinted})
	
	NewModelSafeguardWrapper.canUseModel = true
	
	NewModelSafeguardWrapper.defectiveUpdateInformationDictionary = {}
	
	return NewModelSafeguardWrapper
	
end

function ModelSafeguardWrapper:runSandboxedEnvironment(eventName, Model, functionToRun, onDefectFunctionToRunDictionary)
	
	self.canUseModel = false

	local ignoreUpdateOnDefect = self.ignoreUpdateOnDefect

	local storeDefectiveUpdateInformation = self.storeDefectiveUpdateInformation
	
	local defectiveUpdateInformationDictionary = self.defectiveUpdateInformationDictionary

	local OriginalModelParameters = Model:getModelParameters()
	
	local isAcceptable = false
	
	local valueArray
	
	local currentTimeString
	
	self.OriginalModelParameters = OriginalModelParameters
	
	local isSuccessful = pcall(function()
		
		isAcceptable, valueArray = functionToRun()
		
	end)
	
	if (isSuccessful) and (isAcceptable) then
		
		self.canUseModel = true
		
		self.OriginalModelParameters = nil
		
		return table.unpack(valueArray or {})
		
	end
	
	if (storeDefectiveUpdateInformation) then

		defectiveUpdateInformationDictionary[tostring(os.time())] = eventName

	end
	
	Model:setModelParameters(OriginalModelParameters)

	if (ignoreUpdateOnDefect) or ((not ignoreUpdateOnDefect) and (not onDefectFunctionToRunDictionary)) then 

		self.canUseModel = true
		
		self.OriginalModelParameters = nil

		return table.unpack(valueArray or {})

	end
	
	local onDefectSettingArray = {self.removeDefectiveDataOnDefect,  self.replaceValuesOnDefect, self.removeDefectiveDataOnDefect, self.modifyModelOnDefect}

	local onDefectFunctionNameArray = {"removeDefectFunction", "replaceValueFunction", "removeDefectFunction", "modifyModelFunction"}
	
	local onDefectFunctionName

	local onDefectFunctionToRun
	
	local canFixDefect
	
	for i, value in ipairs(onDefectSettingArray) do
		
		if (value) then
			
			onDefectFunctionName = onDefectFunctionNameArray[i]
			
			onDefectFunctionToRun = onDefectFunctionToRunDictionary[onDefectFunctionName]
			
			if (onDefectFunctionToRun) then 
				
				canFixDefect = pcall(onDefectFunctionToRun)
				
				Model:setModelParameters(OriginalModelParameters)
				
				if (not canFixDefect) then
					
					if (storeDefectiveUpdateInformation) then

						defectiveUpdateInformationDictionary[tostring(os.time())] = eventName .. " + " .. onDefectFunctionName

					end
					
					break 
					
				end
				
				isSuccessful = pcall(function()

					isAcceptable, valueArray = functionToRun()

				end)

				if (isSuccessful) and (isAcceptable) then

					self.canUseModel = true
					
					self.OriginalModelParameters = nil

					return table.unpack(valueArray or {})

				end
				
			end
			
		end
		
	end
	
	Model:setModelParameters(OriginalModelParameters)
	
	self.canUseModel = true
	
	self.OriginalModelParameters = nil
	
	return table.unpack(valueArray or {})
	
end

function ModelSafeguardWrapper:train(...)
	
	local Model = self.Model

	local ClassesList = Model.ClassesList or Model.StatesList or Model.ObservationStatesList
	
	local maximumAcceptableCostMultiplier = self.maximumAcceptableCostMultiplier
	
	local isTable = (type(ClassesList) == "table")
	
	local numberOfClasses = (isTable and #ClassesList) or 0
	
	local hasClassification = (numberOfClasses ~= 0)
	
	local dataMatrixArray = {...}
	
	local numberOfDataMatrix = #dataMatrixArray
	
	local numberOfData
	
	local costArray
	
	local finalCostValue
	
	local maximumAcceptableCost
	
	local isAcceptableValue
	
	local UpdatedModelParameters
	
	local valueToReturnArray
	
	local onDefectFunctionToRunDictionary = {
		
		["removeDefectFunction"] = function()
			
			dataMatrixArray = removeDefectiveData(dataMatrixArray, hasClassification)
			
		end,
		
		["replaceValueFunction"] = function()
			
			for i, dataMatrix in ipairs(dataMatrixArray) do
				
				if (i ~= 2) or (not hasClassification) or (#dataMatrix[1] ~= 1) then

					if (checkIfAllAreNumbers(dataMatrix)) then

						dataMatrixArray[i] = AqwamTensorLibrary:zScoreNormalization(dataMatrix, 2)

					end

				end
				
			end
			
		end,
		
		["modifyModelFunction"] = function()
			
			local ModifiedModel = self.ModifiedModel
			
			if (not ModifiedModel) then return end
			
			Model = ModifiedModel
			
		end,
		
	}
	
	return self:runSandboxedEnvironment("train", Model, function()
		
		valueToReturnArray = {}
		
		numberOfData = #dataMatrixArray[1]
		
		for i = 2, numberOfDataMatrix, 1 do
			
			if (numberOfData ~= #dataMatrixArray[i]) then error("The number of data for all input matrices are not equal.") end
			
		end
		
		-- No data means no training.
		
		if (numberOfData == 0) then return true, valueToReturnArray end
		
		costArray = Model:train(table.unpack(dataMatrixArray))
		
		UpdatedModelParameters = Model:getModelParameters()
		
		if (not costArray) then
			
			isAcceptableValue = checkIfModelParametersAreAcceptable(UpdatedModelParameters)
			
			return isAcceptableValue, valueToReturnArray
			
		end
		
		finalCostValue = costArray[#costArray]
		
		if (type(finalCostValue) ~= "number") then

			isAcceptableValue = checkIfModelParametersAreAcceptable(UpdatedModelParameters)

			return isAcceptableValue, valueToReturnArray
			
		end
		
		maximumAcceptableCost = maximumAcceptableCostMultiplier * getMaximumAcceptableCost(dataMatrixArray, hasClassification)
		
		isAcceptableValue = checkIfIsAcceptableValue(finalCostValue, -maximumAcceptableCost, maximumAcceptableCost)
		
		valueToReturnArray[1] = costArray
		
		return isAcceptableValue, valueToReturnArray
		
	end, onDefectFunctionToRunDictionary)
	
end

function ModelSafeguardWrapper:update(...)
	
	local Model = self.Model
	
	local valueArray = {...}
	
	local UpdatedModelParameters

	return self:runSandboxedEnvironment("update", Model, function()

		Model:update(table.unpack(valueArray))
		
		UpdatedModelParameters = Model:getModelParameters()

		return checkIfModelParametersAreAcceptable(UpdatedModelParameters)

	end)
	
end

function ModelSafeguardWrapper:predict(...)
	
	return self.Model:predict(...)
	
end

function ModelSafeguardWrapper:setModel(Model)
	
	self.Model = Model
	
end

function ModelSafeguardWrapper:getModel()

	return self.Model

end

function ModelSafeguardWrapper:getModelParameters(doNotDeepCopy, ...)
	
	if (self.canUseModel) then
		
		return self.Model:getModelParameters(doNotDeepCopy, ...)
		
	end
	
	local OriginalModelParameters = self.OriginalModelParameters
		
	if (doNotDeepCopy) then
		
		return OriginalModelParameters
		
	end
	
	return deepCopyTable(OriginalModelParameters)

end

function ModelSafeguardWrapper:setModelParameters(ModelParameters, doNotDeepCopy, ...)
	
	if (self.canUseModel) then

		self.Model:setModelParameters(ModelParameters, doNotDeepCopy, ...)

	end

	if (doNotDeepCopy) then

		self.OriginalModelParameters = ModelParameters

	end
	
	self.OriginalModelParameters = deepCopyTable(ModelParameters)

end

function ModelSafeguardWrapper:getCanUseModel()
	
	return self.canUseModel
	
end

function ModelSafeguardWrapper:waitUntilCanUseModel(timeout, waitDuration)
	
	timeout = timeout or math.huge

	while (not self.canUseModel) do
		
		timeout = timeout - task.wait(waitDuration)
		
		if (timeout <= 0) then return false end
		
	end

	return true
	
end

function ModelSafeguardWrapper:restart(ModelParameters, forceRestart)
	
	if (self.canUseModel) then
		
		if (not forceRestart) then return end
		
	end
	
	ModelParameters = ModelParameters or self.OriginalModelParameters
	
	if (ModelParameters) then
		
		self.Model:setModelParameters(ModelParameters)
		
	end
	
	self.canUseModel = true
	
end

return ModelSafeguardWrapper]]></ProtectedString>
									<string name="ScriptGuid">{8EEC6F52-DBCF-4904-9CC3-69097351EED5}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ModelSafeguardWrapper</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEFEE989CB5DD470B944F6EDB3BF9E84C">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

local ModelTrainingModifier = {}

ModelTrainingModifier.__index = ModelTrainingModifier

setmetatable(ModelTrainingModifier, BaseInstance)

local defaultMode = "Stochastic"

local defaultBatchSize = 2

local defaultIsOutputPrinted = true

function ModelTrainingModifier.new(parameterDictionary)
	
	local NewModelTrainingModifier = BaseInstance.new(parameterDictionary)
	
	setmetatable(NewModelTrainingModifier, ModelTrainingModifier)
	
	NewModelTrainingModifier:setName("ModelTrainingModifier")
	
	NewModelTrainingModifier:setClassName("ModelTrainingModifier")
	
	NewModelTrainingModifier.Model = parameterDictionary.Model
	
	NewModelTrainingModifier.mode = parameterDictionary.mode or defaultMode

	NewModelTrainingModifier.batchSize = parameterDictionary.batchSize or defaultBatchSize
	
	NewModelTrainingModifier.isOutputPrinted = NewModelTrainingModifier:getValueOrDefaultValue(parameterDictionary.isOutputPrinted, defaultIsOutputPrinted)
	
	return NewModelTrainingModifier
	
end

local function breakMatrixToMultipleSmallerMatrices(matrix, batchSize)
	
	local numberOfBatches = math.ceil(#matrix/batchSize)
	
	local matrixBatchesTable = {}
	
	local batchPositions = {}
	
	local batchFeatureMatrix
	
	local batchLabelVector 
	
	for batch = 1, numberOfBatches, 1 do
		
		local startIndex = (batch - 1) * batchSize + 1
		
		local endIndex = math.min(batch * batchSize, #matrix)
		
		local batchFeatureMatrix = {}
		
		for i = startIndex, endIndex do table.insert(batchFeatureMatrix, matrix[i]) end
		
		table.insert(matrixBatchesTable, batchFeatureMatrix)
		
	end
	
	return matrixBatchesTable
	
end

function ModelTrainingModifier:batchTrain(...)
	
	return self.Model:train(...)
	
end

function ModelTrainingModifier:miniBatchTrain(...)
	
	local batchSize = self.batchSize
	
	if (batchSize < 0) then error("Batch size cannot be negative.") end
	
	local matrixArray = {...}
	
	local numberOfMatrices = #matrixArray

	local numberOfData = #matrixArray[1]

	for matrixIndex = 1, numberOfMatrices, 1 do

		if (numberOfData ~= #matrixArray[matrixIndex]) then error("All matrices or vectors must contain same number of data.") end

	end
	
	if (batchSize > numberOfData) then error("Batch size is greater than the number of data.") end
	
	local numberOfBatches = math.ceil(numberOfData / batchSize)
	
	local miniBatchMatrixArray = {}
	
	for matrixIndex = 1, numberOfMatrices, 1 do
		
		local matrices = breakMatrixToMultipleSmallerMatrices(matrixArray[matrixIndex], batchSize)
		
		table.insert(miniBatchMatrixArray, matrices)
		
	end
	
	local costArray = {}
	
	local Model = self.Model
	
	local isOutputPrinted = self.isOutputPrinted
	
	for currentBatchNumber = 1, numberOfBatches, 1 do
		
		local currentMatrixBatchArray = {}
		
		for matrixIndex = 1, numberOfMatrices, 1 do
			
			table.insert(currentMatrixBatchArray, miniBatchMatrixArray[matrixIndex][currentBatchNumber])
			
		end

		local miniBatchCostArray = Model:train(table.unpack(currentMatrixBatchArray))
		
		local cost = miniBatchCostArray[#miniBatchCostArray]
		
		table.insert(costArray, cost)
		
		if (isOutputPrinted) then print("Batch: " .. currentBatchNumber .. "\t\t\tFinal cost: " .. cost) end
		
	end
	
	return costArray

end

function ModelTrainingModifier:stochasticTrain(...)
	
	local matrixArray = {...}

	local numberOfMatrices = #matrixArray

	local numberOfData = #matrixArray[1]

	for matrixIndex = 1, numberOfMatrices, 1 do

		if (numberOfData ~= #matrixArray[matrixIndex]) then error("All matrices or vectors must contain same number of data.") end

	end
	
	local costArray = {}
	
	local Model = self.Model
	
	local isOutputPrinted = self.isOutputPrinted
	
	local originalMaximumNumberOfIterations = Model.maximumNumberOfIterations
	
	Model.maximumNumberOfIterations = 1
	
	for dataIndex = 1, numberOfData, 1 do
		
		local currentMatrixBatchArray = {}

		for matrixIndex = 1, numberOfMatrices, 1 do

			table.insert(currentMatrixBatchArray, {matrixArray[matrixIndex][dataIndex]})
			
		end
		
		local stochasticCostArray = Model:train(table.unpack(currentMatrixBatchArray))
		
		local cost = stochasticCostArray[#stochasticCostArray]
		
		table.insert(costArray, cost)
		
		if (isOutputPrinted) then print("Data number: " .. dataIndex .. "\t\tFinal cost: " .. cost) end
		
	end
	
	Model.maximumNumberOfIterations = originalMaximumNumberOfIterations
	
	return costArray

end

function ModelTrainingModifier:train(...)
	
	local trainingMode = self.mode
	
	if (trainingMode == "Batch") then
		
		return self:batchTrain(...)
		
	elseif (trainingMode == "MiniBatch") then
		
		return self:miniBatchTrain(...)
		
	elseif (trainingMode == "Stochastic") then
		
		return self:stochasticTrain(...)
		
	else
		
		error("The selected gradient descent method cannot be found.")
		
	end
	
end

function ModelTrainingModifier:update(...)

	return self.Model:update(...)

end

function ModelTrainingModifier:predict(...)
	
	return self.Model:predict(...)
	
end

function ModelTrainingModifier:setModel(Model)
	
	self.Model = Model
	
end

function ModelTrainingModifier:getModel()

	return self.Model

end

function ModelTrainingModifier:getModelParameters(...)

	return self.Model:getModelParameters(...)

end

function ModelTrainingModifier:setModelParameters(...)

	self.Model:setModelParameters(...)

end

return ModelTrainingModifier]]></ProtectedString>
									<string name="ScriptGuid">{A9595163-FC3E-4B60-8517-45E3FF8EEEFA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ModelTrainingModifier</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX82783A8EE61047A7881B0C4490E8A675">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

local ModelChecker = {}

ModelChecker.__index = ModelChecker

setmetatable(ModelChecker, BaseInstance)

local defaultMaximumNumberOfIterations = 100

local defaultMaximumGeneralizationError = math.huge

local function calculateError(predictedLabelMatrix, trueLabelMatrix, numberOfData)
	
	local errorMatrix = AqwamTensorLibrary:subtract(predictedLabelMatrix, trueLabelMatrix)

	errorMatrix = AqwamTensorLibrary:power(errorMatrix, 2)

	local errorVector = AqwamTensorLibrary:sum(errorMatrix, 2)

	local totalError = AqwamTensorLibrary:sum(errorVector)
	
	local calculatedError = totalError/(2 * numberOfData)
	
	return calculatedError, errorVector
	
end

function ModelChecker.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewModelChecker = BaseInstance.new(parameterDictionary)
	
	setmetatable(NewModelChecker, ModelChecker)
	
	NewModelChecker.modelType = parameterDictionary.modelType
	
	NewModelChecker.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations
	
	NewModelChecker.maximumGeneralizationError = parameterDictionary.maximumGeneralizationError or defaultMaximumGeneralizationError
	
	NewModelChecker.Model = parameterDictionary.Model
	
	return NewModelChecker
	
end

function ModelChecker:setModel(Model)
	
	self.Model = Model
	
end

function ModelChecker:getModel()
	
	return self.Model
	
end

function ModelChecker:setClassesList(classesList)

	self.ClassesList = classesList

end

function ModelChecker:convertLabelVectorToLogisticMatrix(labelVector)

	if (typeof(labelVector) == "number") then

		labelVector = {{labelVector}}

	end

	local logisticMatrix = AqwamTensorLibrary:createTensor({#labelVector, #self.ClassesList}, 0)

	local label

	local labelPosition

	for row = 1, #labelVector, 1 do

		label = labelVector[row][1]

		labelPosition = table.find(self.ClassesList, label)

		logisticMatrix[row][labelPosition] = 1

	end

	return logisticMatrix

end

function ModelChecker:testClassification(testFeatureMatrix, testLabelVector)
	
	local Model = self.Model

	if (not Model) then error("No model!") end
	
	local testLabelMatrix
	
	if (#testLabelVector[1] == 1) then

		testLabelMatrix = self:convertLabelVectorToLogisticMatrix(testLabelVector)

	else

		testLabelMatrix = testLabelVector

	end
	
	local numberOfData = #testFeatureMatrix
	
	local predictedTestLabelMatrix = Model:predict(testFeatureMatrix, true)
	
	local calculatedError, errorVector = calculateError(predictedTestLabelMatrix, testLabelMatrix, numberOfData)

	return calculatedError, errorVector, predictedTestLabelMatrix

end

function ModelChecker:testRegression(testFeatureMatrix, testLabelVector)
	
	local Model = self.Model

	if (not Model) then error("No model.") end

	local numberOfData = #testFeatureMatrix
	
	local predictedLabelVector = Model:predict(testFeatureMatrix)

	local calculatedError, errorVector = calculateError(predictedLabelVector, testLabelVector, numberOfData)

	return calculatedError, errorVector, predictedLabelVector

end

function ModelChecker:validateClassification(trainFeatureMatrix, trainLabelVector, validationFeatureMatrix, validationLabelVector)
	
	local Model = self.Model
	
	if (not Model) then error("No model.") end

	local trainError

	local validationError
	
	local predictedTrainLabelMatrix
	
	local predictedValidationLabelMatrix
	
	local trainLabelMatrix
	
	local validationLabelMatrix
	
	local generalizationError
	
	local numberOfIterations = 0

	local trainErrorArray = {}

	local validationErrorArray = {}
	
	local numberOfTrainData = #trainFeatureMatrix 
	
	local numberOfValidationData = #validationFeatureMatrix
	
	if (#trainLabelVector[1] == 1) then

		trainLabelMatrix = self:convertLabelVectorToLogisticMatrix(trainLabelVector)

	else

		trainLabelMatrix = validationLabelVector

	end
	
	if (#validationLabelVector[1] == 1) then
		
		validationLabelMatrix = self:convertLabelVectorToLogisticMatrix(validationLabelVector)
		
	else
		
		validationLabelMatrix = validationLabelVector
		
	end

	repeat

		Model:train(trainFeatureMatrix, trainLabelMatrix)
		
		predictedTrainLabelMatrix = Model:predict(trainFeatureMatrix, true)
		
		predictedValidationLabelMatrix = Model:predict(validationFeatureMatrix, true)
		
		trainError = calculateError(predictedTrainLabelMatrix, trainLabelMatrix, numberOfTrainData)
	
		validationError = calculateError(predictedValidationLabelMatrix, validationLabelMatrix, numberOfValidationData)
		
		generalizationError = validationError - trainError

		table.insert(validationErrorArray, validationError)

		table.insert(trainErrorArray, trainError)

		numberOfIterations = numberOfIterations + 1

	until (numberOfIterations >= self.maximumNumberOfIterations) or (generalizationError >= self.maximumGeneralizationError)

	return trainErrorArray, validationErrorArray

end

function ModelChecker:validateRegression(trainFeatureMatrix, trainLabelVector, validationFeatureMatrix, validationLabelVector)
	
	local Model = self.Model

	if (not Model) then error("No model.") end
	
	local trainError
	
	local validationError
	
	local validationCostVector
	
	local predictedLabelVector
	
	local generalizationError
	
	local numberOfIterations = 0

	local trainErrorArray = {}

	local validationErrorArray = {}
	
	local numberOfTrainData = #trainFeatureMatrix
	
	local numberOfValidationData = #validationFeatureMatrix
	
	local predictedTrainLabelVector
	
	local predictedValidationLabelVector
	
	repeat
		
		Model:train(trainFeatureMatrix, trainLabelVector)

		predictedTrainLabelVector = Model:predict(trainFeatureMatrix)

		predictedValidationLabelVector = Model:predict(validationFeatureMatrix)

		trainError = calculateError(predictedTrainLabelVector, trainLabelVector, numberOfTrainData)

		validationError = calculateError(predictedValidationLabelVector, validationLabelVector, numberOfValidationData)

		generalizationError = validationError - trainError
		
		table.insert(trainErrorArray, trainError)

		table.insert(validationErrorArray, validationError)

		numberOfIterations = numberOfIterations + 1
		
	until (numberOfIterations >= self.maximumNumberOfIterations) or (generalizationError >= self.maximumGeneralizationError)
	
	return trainErrorArray, validationErrorArray
	
end

function ModelChecker:test(testFeatureMatrix, testLabelVector)
	
	local calculatedError

	local errorVector
	
	local predictedLabelMatrix
	
	local modelType = self.modelType

	if (modelType == "Regression") then

		calculatedError, errorVector, predictedLabelMatrix = self:testRegression(testFeatureMatrix, testLabelVector)

	elseif (modelType == "Classification") then

		calculatedError, errorVector, predictedLabelMatrix = self:testClassification(testFeatureMatrix, testLabelVector)
		
	else
		
		error("Invalid model type.")

	end

	return calculatedError, errorVector, predictedLabelMatrix

end

function ModelChecker:validate(trainFeatureMatrix, trainLabelVector, validationFeatureMatrix, validationLabelVector)
	
	local trainErrorArray
	
	local validationErrorArray
	
	local modelType = self.modelType
	
	if (modelType == "Regression") then
		
		trainErrorArray, validationErrorArray = self:validateRegression(trainFeatureMatrix, trainLabelVector, validationFeatureMatrix, validationLabelVector)
		
	elseif (modelType == "Classification") then
		
		trainErrorArray, validationErrorArray = self:validateClassification(trainFeatureMatrix, trainLabelVector, validationFeatureMatrix, validationLabelVector)
		
	else
		
		error("Invalid model type.")
		
	end
	
	return trainErrorArray, validationErrorArray
	
end

return ModelChecker
]]></ProtectedString>
									<string name="ScriptGuid">{32E21955-F47B-4CD0-A30D-19D9F327BBFF}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ModelChecker</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF1E776E0546A43F3972D00955A6AD83A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

OnlineLearning = {}

OnlineLearning.__index = OnlineLearning

setmetatable(OnlineLearning, BaseInstance)

local defaultBatchSize = 1

local defaultWaitInterval = 0.1

local defaultShowFinalCost = true

local defaultIdleDuration = 30

local defaultShowIdleWarning = true

local defaultShowModelDivergenceWarning = true

local modelDivergedWarningText = "The model diverged! Reverting to previous model parameters! Please repeat the experiment again or change the argument values if this warning occurs often."

local onlineLearningNotActiveText = "Online Learning is not active."

local onlineLearningActiveText = "Online Learning is already active."

function OnlineLearning.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewOnlineLearning = BaseInstance.new(parameterDictionary)

	setmetatable(NewOnlineLearning, OnlineLearning)
	
	local Model = parameterDictionary.Model
	
	local isOutputRequired = parameterDictionary.isOutputRequired

	if (not Model) then error("Please set a model.") end

	if (not isOutputRequired) then error("Please set whether or not the model requires a output.") end

	NewOnlineLearning.Model = Model
	
	NewOnlineLearning.isOutputRequired = isOutputRequired or {}
	
	NewOnlineLearning.batchSize = parameterDictionary.batchSize or defaultBatchSize
	
	NewOnlineLearning.waitInterval = parameterDictionary.waitInterval or defaultWaitInterval
	
	NewOnlineLearning.showFinalCost = NewOnlineLearning:getValueOrDefaultValue(parameterDictionary.showFinalCost, defaultShowFinalCost)
	
	NewOnlineLearning.idleDuration = parameterDictionary.idleDuration or defaultIdleDuration
	
	NewOnlineLearning.showIdleWarning = NewOnlineLearning:getValueOrDefaultValue(parameterDictionary.showIdleWarning, defaultShowIdleWarning)
	
	NewOnlineLearning.showModelDivergenceWarning = NewOnlineLearning:getValueOrDefaultValue(parameterDictionary.showModelDivergenceWarning, defaultShowModelDivergenceWarning)

	NewOnlineLearning.inputQueue = parameterDictionary.inputQueue or {}

	NewOnlineLearning.outputQueue = parameterDictionary.outputQueue or {}

	NewOnlineLearning.costArrayQueue = parameterDictionary.costArrayQueue or {}

	NewOnlineLearning.isOnlineLearningRunning = false

	return NewOnlineLearning

end

function OnlineLearning:generateDataset(minimumBatchSize)
	
	local isOutputRequired = self.isOutputRequired
	
	local inputQueue = self.inputQueue

	local outputQueue = self.outputQueue
	
	local input = {}
	
	local output = {}
	
	for data = 1, minimumBatchSize, 1 do

		table.insert(input,inputQueue [1][1])

		table.remove(inputQueue, 1)

		if (isOutputRequired) then
			
			table.insert(output, outputQueue[1][1]) 

			table.remove(outputQueue, 1)
			
		end
		
	end
	
	if (isOutputRequired) then
		
		return input, output
		
	else
		
		return input, nil
		
	end
	
end

function OnlineLearning:autoRemoveCostArrayAfterCertainDuration()
	
	task.spawn(function()

		for frame = 1, 70 do task.wait() end -- to allow cost to be fetched. Otherwise it will remove it before it can be fetched!

		table.remove(self.costArrayQueue, 1)

	end)
	
end

function OnlineLearning:restorePreviousModelParametersIfCostIsInfinity(cost)
	
	if (cost == math.huge) then

		self.Model:setModelParameters(self.PreviousModelParameters)

		if (self.showModelDivergenceWarning) then warn(modelDivergedWarningText) end

	end
	
end

function OnlineLearning:start()

	if (self.isOnlineLearningRunning) then error(onlineLearningActiveText) end

	self.isOnlineLearningRunning = true
	
	local Model = self.Model
	
	local isOutputRequired = self.isOutputRequired
	
	local batchSize = self.batchSize
	
	local showFinalCost = self.showFinalCost
	
	local idleDuration = self.idleDuration
	
	local showIdleWarning = self.showIdleWarning
	
	local inputQueue = self.inputQueue
	
	local outputQueue = self.outputQueue
	
	local costArrayQueue = self.costArrayQueue

	local waitInterval = self.waitInterval

	local waitDuration = 0

	local waitWarningIssued = false

	local infinityCostWarningIssued = false

	local areBatchesFilled

	local costArray

	local cost

	local trainCoroutine = coroutine.create(function()

		repeat

			task.wait(waitInterval)

			waitDuration = waitDuration + waitInterval

			areBatchesFilled = (#inputQueue >= batchSize) and (not isOutputRequired or (#outputQueue >= batchSize))

			if (waitDuration >= idleDuration) and (not waitWarningIssued) and (showIdleWarning) then 

				warn("The online learning model has been idle for more than " .. idleDuration .. " seconds. Leaving the thread running may use unnecessary resource.") 

				waitWarningIssued = true
				
				continue

			elseif (not areBatchesFilled) then continue

			elseif (not self.isOnlineLearningRunning) then break end

			self.PreviousModelParameters = Model:getModelParameters()
			
			local minimumBatchSize = math.min(batchSize, #inputQueue)
			
			local input, output = self:generateDataset(minimumBatchSize)
			
			local costArray = Model:train(input, output)

			cost = costArray[#costArray]
			
			self:restorePreviousModelParametersIfCostIsInfinity(cost)

			table.insert(costArrayQueue, costArray)

			if (showFinalCost) then print("Final Cost: " .. cost) end
			
			self:autoRemoveCostArrayAfterCertainDuration()
			
			waitDuration = 0

		until (not self.isOnlineLearningRunning)

		self.inputQueue = {}

		self.outputQueue = {}

		self.costArrayQueue = {}
		
		self.PreviousModelParameters = nil

		waitDuration = nil

		infinityCostWarningIssued = nil

	end)

	coroutine.resume(trainCoroutine)

	return trainCoroutine

end

function OnlineLearning:stop()

	self.IsOnlineLearningRunning = false

end

function OnlineLearning:addInput(input)

	if (not self.isOnlineLearningRunning) then error(onlineLearningNotActiveText) end
	
	if (type(input) == "number") then input = {{input}} end

	table.insert(self.inputQueue, input)

end

function OnlineLearning:addOutput(output)

	if (not self.isOnlineLearningRunning) then error(onlineLearningNotActiveText) end
	
	if (type(output) == "number") then output = {{output}} end

	table.insert(self.outputQueue, output)

end

function OnlineLearning:returnCostArray()

	if (not self.isOnlineLearningRunning) then error(onlineLearningNotActiveText) end

	return self.costArrayQueue[1]

end

return OnlineLearning
]]></ProtectedString>
									<string name="ScriptGuid">{9BADA874-D9A5-4685-BDA5-13A9FE8B0D5E}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">OnlineLearning</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX90055C2574944B569869C60F2E6C8234">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

DatasetCreator = {}

DatasetCreator.__index = DatasetCreator

setmetatable(DatasetCreator, BaseInstance)

local defaultTrainDataRatio = 0.7

local defaultValidationDataRatio = 0

local defaultTestDataRatio = 0.3

local defaultIsDatasetRandomized = false

local defaultDatasetRandomizationProbability = 0.95

local function getBooleanOrDefaultOption(boolean, defaultBoolean)

	if (type(boolean) == "nil") then return defaultBoolean end

	return boolean

end

local function deepCopyTable(original, copies)

	copies = copies or {}

	local originalType = type(original)

	local copy

	if (originalType == 'table') then

		if copies[original] then

			copy = copies[original]

		else

			copy = {}

			copies[original] = copy

			for originalKey, originalValue in next, original, nil do

				copy[deepCopyTable(originalKey, copies)] = deepCopyTable(originalValue, copies)

			end

			setmetatable(copy, deepCopyTable(getmetatable(original), copies))

		end

	else -- number, string, boolean, etc

		copy = original

	end

	return copy

end

local function returnNilIfTableIsEmpty(tableToCheck)
	
	if (#tableToCheck >= 1) then 
		
		return tableToCheck
		
	else
		
		return nil	
		
	end
	
end

local function checkNumberOfData(featureMatrix, labelVectorOrMatrix)
	
	if (type(labelVectorOrMatrix) ~= "nil") then

		if (#featureMatrix ~= #labelVectorOrMatrix) then error("The feature matrix and the label vector / matrix do not contain the same number of data.") end

	end
	
	return #featureMatrix
	
end

function DatasetCreator.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewDatasetCreator = BaseInstance.new(parameterDictionary)

	setmetatable(NewDatasetCreator, DatasetCreator)
	
	NewDatasetCreator:setName("DatasetCreator")

	NewDatasetCreator:setClassName("DatasetCreator")
	
	NewDatasetCreator.trainDataRatio = parameterDictionary.trainDataRatio or defaultTrainDataRatio
	
	NewDatasetCreator.validationDataRatio = parameterDictionary.validationDataRatio or defaultValidationDataRatio
	
	NewDatasetCreator.testDataRatio = parameterDictionary.testDataRatio or defaultTestDataRatio
	
	NewDatasetCreator.datasetRandomizationProbability = parameterDictionary.datasetRandomizationProbability or defaultDatasetRandomizationProbability
	
	return NewDatasetCreator
	
end

function DatasetCreator:setDatasetSplitPercentages(trainDataRatio, validationDataRatio, testDataRatio)
	
	trainDataRatio = trainDataRatio or self.trainDataRatio
	
	validationDataRatio = validationDataRatio or self.validationDataRatio
	
	testDataRatio = testDataRatio or self.testDataRatio
	
	local ratioSum = trainDataRatio + validationDataRatio + testDataRatio
	
	if (ratioSum > 1) then error("The sum of the ratios exceeds 1.") end
	
	self.trainDataRatio = trainDataRatio

	self.validationDataRatio = validationDataRatio

	self.testDataRatio = testDataRatio
	
end

function DatasetCreator:setDatasetRandomizationProbability(datasetRandomizationProbability)
	
	self.datasetRandomizationProbability = datasetRandomizationProbability or self.datasetRandomizationProbability
	
end

function DatasetCreator:randomizeDataset(featureMatrix, labelVectorOrMatrix)
	
	local numberOfData = checkNumberOfData(featureMatrix, labelVectorOrMatrix)
	
	local datasetRandomizationProbability = self.datasetRandomizationProbability
	
	local randomizedFeatureMatrix = deepCopyTable(featureMatrix)
	
	local randomizedLabelVectorOrMatrix = deepCopyTable(labelVectorOrMatrix)
	
	for index = 1, numberOfData, 1 do
		
		if (datasetRandomizationProbability < math.random()) then
			
			local randomIndex = math.random(0, index)

			randomIndex = math.ceil(randomIndex)

			local temporaryRandomFeatureVector = randomizedFeatureMatrix[index]

			table.remove(randomizedFeatureMatrix, index)

			table.insert(randomizedFeatureMatrix, randomIndex, temporaryRandomFeatureVector)

			if (type(labelVectorOrMatrix) == "nil") then 
				
				local temporaryRandomLabelVector = randomizedLabelVectorOrMatrix[index]

				table.remove(randomizedLabelVectorOrMatrix, index)

				table.insert(randomizedLabelVectorOrMatrix, randomIndex, temporaryRandomLabelVector)
				
			end
			
		end
		
	end
	
	return randomizedFeatureMatrix, randomizedLabelVectorOrMatrix
	
end

function DatasetCreator:splitDataset(datasetMatrix)

	local numberOfData = checkNumberOfData(datasetMatrix)
	
	local datasetCopy = deepCopyTable(datasetMatrix)

	local numberOfTrainData = math.floor(self.trainDataRatio * numberOfData)
	
	local numberOfValidationData = math.floor(self.validationDataRatio * numberOfData)
	
	local numberOfTestData = math.floor(self.testDataRatio * numberOfData)

	local trainDataMaximumValue = numberOfTrainData
	
	local trainValidationDataMaximumValue = numberOfTrainData + numberOfValidationData
	
	local trainValidationTestDataMaximumValue = trainValidationDataMaximumValue + numberOfTestData

	local trainDatasetMatrix = {}
	
	local validationDatasetMatrix = {}
	
	local testDatasetMatrix = {}

	for index = 1, numberOfData, 1 do

		if (index < trainDataMaximumValue) then 

			table.insert(trainDatasetMatrix, datasetCopy[index])

		elseif (index < trainValidationDataMaximumValue) then

			table.insert(validationDatasetMatrix, datasetCopy[index])

		elseif (index < trainValidationTestDataMaximumValue) then

			table.insert(testDatasetMatrix, datasetCopy[index])

		elseif (numberOfTrainData > 0) then

			table.insert(trainDatasetMatrix, datasetCopy[index])

		elseif (numberOfValidationData > 0) then

			table.insert(validationDatasetMatrix, datasetCopy[index])

		elseif (numberOfTestData > 0) then

			table.insert(testDatasetMatrix, datasetCopy[index])

		end

	end

	trainDatasetMatrix = returnNilIfTableIsEmpty(trainDatasetMatrix)
	
	validationDatasetMatrix = returnNilIfTableIsEmpty(validationDatasetMatrix)
	
	testDatasetMatrix = returnNilIfTableIsEmpty(testDatasetMatrix)

	table.clear(datasetCopy)
	
	datasetCopy = nil

	return trainDatasetMatrix, validationDatasetMatrix, testDatasetMatrix
	
end

return DatasetCreator
]]></ProtectedString>
									<string name="ScriptGuid">{051DFDA2-BBC5-4AC9-9E37-29169E3C42A1}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DatasetCreator</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4630C1D5551D4D7FB7CA59C6E3D56F92">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

local ModelParametersMerger = {}

ModelParametersMerger.__index = ModelParametersMerger

setmetatable(ModelParametersMerger, BaseInstance)

local defaultSplitMode = "Accuracy"

local defaultMergeMode = "Average"

function ModelParametersMerger.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewModelParametersMerger = BaseInstance.new(parameterDictionary)

	setmetatable(NewModelParametersMerger, ModelParametersMerger)
	
	NewModelParametersMerger:setName("ModelParametersMerger")
	
	NewModelParametersMerger:setClassName("ModelParametersMerger")

	NewModelParametersMerger.Model = parameterDictionary.Model

	NewModelParametersMerger.modelType = parameterDictionary.modelType
	
	ModelParametersMerger.splitMode = parameterDictionary.splitMode or defaultSplitMode

	NewModelParametersMerger.mergeMode = parameterDictionary.mergeMode or defaultMergeMode

	NewModelParametersMerger.featureMatrix = parameterDictionary.featureMatrix

	NewModelParametersMerger.labelVector = parameterDictionary.labelVector
	
	NewModelParametersMerger.splitAmountArray = parameterDictionary.splitAmountArray

	return NewModelParametersMerger

end

function ModelParametersMerger:setCustomSplitAmountArray(splitAmountArray)
	
	self.splitAmountArray = splitAmountArray or self.splitAmountArray
	
end

function ModelParametersMerger:setData(featureMatrix, labelVector)

	if (featureMatrix) and (labelVector) then

		if (#featureMatrix ~= #labelVector) then error("Feature matrix and the label vector does not contain the same number of rows.") end

	end

	self.featureMatrix = featureMatrix or self.featureMatrix

	self.labelVector = labelVector or self.labelVector

end

local function checkDepth(array, depth)

	depth = depth or 0

	local valueType = typeof(array)

	if (valueType == "table") then

		return checkDepth(array[1], depth + 1)

	else

		return depth

	end

end

local function checkIfIsTableOfMatrices(array)

	local depth = checkDepth(array)

	local isTableOfMatrices = (depth == 3)

	return isTableOfMatrices

end

local function generateModelParametersTableWithMatricesOfZeroValues(ModelParameters)

	local NewModelParameters = {}

	for i, matrix in ipairs(ModelParameters) do

		local numberOfRows = #matrix

		local numberOfColumns = #matrix[1]

		local newMatrix = AqwamTensorLibrary:createTensor({numberOfRows, numberOfColumns})

		table.insert(NewModelParameters, newMatrix)

	end

	return NewModelParameters

end

local function calculateTotalFromArray(array)

	local total = 0

	for i, value in ipairs(array) do total = total + value end

	return total

end

local function convertValueArrayToPercentageArray(array)

	local percentage

	local total = calculateTotalFromArray(array)

	local percentageArray = {}

	for i, value in ipairs(array) do

		if (total == 0) then

			percentage = 0

		else

			percentage = math.abs(value / total)

		end

		table.insert(percentageArray, percentage)

	end
	
	return percentageArray

end

local function generateErrorArrayForRegression(Model, ModelParametersArray, featureMatrix, labelVector)

	local errorArray = {}

	for i, ModelParameters in ipairs(ModelParametersArray) do

		Model:setModelParameters(ModelParameters)

		local predictVector = Model:predict(featureMatrix)

		local errorVector = AqwamTensorLibrary:subtract(labelVector, predictVector)

		local absoluteErrorVector = AqwamTensorLibrary:applyFunction(math.abs, errorVector)

		local errorValue = AqwamTensorLibrary:sum(absoluteErrorVector)

		table.insert(errorArray, errorValue)

	end

	return errorArray

end

local function generateErrorArrayForClustering(Model, ModelParametersArray, featureMatrix)

	local errorArray = {}

	for i, ModelParameters in ipairs(ModelParametersArray) do

		Model:setModelParameters(ModelParameters)

		local _, distanceVector = Model:predict(featureMatrix)

		local errorValue = AqwamTensorLibrary:sum(distanceVector)

		table.insert(errorArray, errorValue)

	end

	return errorArray

end

local function convertErrorArrayToAccuracyArray(errorArray)

	local accuracyArray = {}

	local errorPercentageArray = convertValueArrayToPercentageArray(errorArray)

	for i, errorPercentage in ipairs(errorPercentageArray) do

		local accuracy = 1 - errorPercentage

		table.insert(accuracyArray, accuracy)

	end

	return accuracyArray

end

local function generateAccuracyArrayForClassification(Model, ModelParametersArray, featureMatrix, labelVector)

	local accuracyArray = {}

	local totalLabel = #labelVector

	for i, ModelParameters in ipairs(ModelParametersArray) do

		local accuracy = 0

		local totalCorrect = 0

		Model:setModelParameters(ModelParameters)
		
		local predictedlabelVector = Model:predict(featureMatrix)

		for j = 1, totalLabel, 1 do

			if (predictedlabelVector[j][1] == labelVector[j][1]) then totalCorrect += 1 end

		end

		accuracy = totalCorrect / totalLabel

		table.insert(accuracyArray, accuracy)

	end

	return accuracyArray

end

local function checkIfAllValuesAreZeroesInArray(array)

	local allZeroes = true

	for i, accuracyPercentage in ipairs(array) do

		array = (accuracyPercentage == 0)

		if (not allZeroes) then break end

	end

	return allZeroes

end

local function generateAccuracyArray(Model, modelType, ModelParametersArray, featureMatrix, labelVector)
	
	if (not Model) then error("No model.") end
	
	if (not modelType) then error("No model type.") end
	
	local accuracyArray
	
	if (modelType == "Regression") then

		local errorArray = generateErrorArrayForRegression(Model, ModelParametersArray, featureMatrix, labelVector)

		accuracyArray = convertErrorArrayToAccuracyArray(errorArray)

	elseif (modelType == "Classification") then

		accuracyArray = generateAccuracyArrayForClassification(Model, ModelParametersArray, featureMatrix, labelVector)

	elseif (modelType == "Clustering") then

		local errorArray = generateErrorArrayForClustering(Model, ModelParametersArray, featureMatrix)

		accuracyArray = convertErrorArrayToAccuracyArray(errorArray)

	else

		error("Invalid model type!")

	end
	
	return accuracyArray
	
end

local function getIndexOfHighestAccuracy(accuracyArray)
	
	local index
	
	local highestAccuracy = -math.huge

	for i, accuracy in ipairs(accuracyArray)  do

		if (accuracy > highestAccuracy) then 

			highestAccuracy = accuracy 

			index = i

		end

	end
	
	return index
	
end

local function getSplitAmountArrayFromAccuracyArray(splitMode, accuracyArray)
	
	local splitAmountArray
	
	local numberOfModelParameters = #accuracyArray
	
	if (splitMode == "Best") then
		
		local areAllZeroes = checkIfAllValuesAreZeroesInArray(accuracyArray)

		local bestModelParametersIndex

		if (areAllZeroes == true) then 

			bestModelParametersIndex = Random.new():NextInteger(1, numberOfModelParameters)

		else

			bestModelParametersIndex = getIndexOfHighestAccuracy(accuracyArray)

		end

		splitAmountArray = table.create(numberOfModelParameters, 0)

		splitAmountArray[bestModelParametersIndex] = 1
		
	elseif (splitMode == "Ratio") then
		
		splitAmountArray = convertValueArrayToPercentageArray(accuracyArray)
		
	elseif (splitMode == "Equal") then
		
		local average = 1 / numberOfModelParameters

		splitAmountArray = table.create(numberOfModelParameters, average)
		
	elseif (splitMode == "Ignore") then
		
		splitAmountArray = {}
		
	else

		error("Invalid split mode.")
		
	end
	
	return splitAmountArray
	
end

local function applyFunctionToEachMatricesInModelParameters(functionToApply, ModelParameters)

	for k, matrix in ipairs(ModelParameters) do

		ModelParameters[k] =  AqwamTensorLibrary:applyFunction(functionToApply, matrix)

	end

	return ModelParameters

end

local function calculateWeightedAverageModelParametersTable(ModelParametersArray, splitAmountArray)
	
	local totalSplitAmount = calculateTotalFromArray(splitAmountArray)

	local NewModelParametersTable = generateModelParametersTableWithMatricesOfZeroValues(ModelParametersArray[1])

	for i, ModelParametersTable in ipairs(ModelParametersArray) do

		for j, matrix in ipairs(ModelParametersTable) do

			local calculatedMatrix = AqwamTensorLibrary:multiply(splitAmountArray[i], matrix)

			NewModelParametersTable[j] = AqwamTensorLibrary:add(NewModelParametersTable[j], calculatedMatrix)

		end

	end
	
	for i, matrix in ipairs(NewModelParametersTable) do
		
		NewModelParametersTable[i] = AqwamTensorLibrary:divide(NewModelParametersTable[i], totalSplitAmount)
		
	end

	return NewModelParametersTable

end

local function calculateWeightedAverageModelParameters(ModelParametersArray, splitAmountArray)
	
	local totalSplitAmount = calculateTotalFromArray(splitAmountArray)

	local FirstModelParameters = ModelParametersArray[1]

	local NewModelParameters = AqwamTensorLibrary:createTensor({#FirstModelParameters, #FirstModelParameters[1]})

	for j, splitAmount in ipairs(splitAmountArray) do

		local matrix = ModelParametersArray[j]

		local calculatedMatrix = AqwamTensorLibrary:multiply(splitAmount, matrix)

		NewModelParameters = AqwamTensorLibrary:add(NewModelParameters, calculatedMatrix)

	end
	
	NewModelParameters = AqwamTensorLibrary:divide(NewModelParameters, totalSplitAmount)

	return NewModelParameters

end

local function calculateAverageModelParametersTable(ModelParametersArray)
	
	local NewModelParametersTable = generateModelParametersTableWithMatricesOfZeroValues(ModelParametersArray[1])
	
	local numberOfModelParameters = #ModelParametersArray
	
	for i, ModelParametersTable in ipairs(ModelParametersArray) do

		for j, matrix in ipairs(ModelParametersTable) do

			NewModelParametersTable[j] = AqwamTensorLibrary:add(NewModelParametersTable[j], matrix)

		end

	end
	
	for i, matrix in ipairs(NewModelParametersTable) do

		NewModelParametersTable[i] = AqwamTensorLibrary:divide(NewModelParametersTable[i], numberOfModelParameters)

	end
	
	return NewModelParametersTable
	
end

local function createAverageModelParameters(ModelParametersArray)

	local NewModelParameters = AqwamTensorLibrary:add(table.unpack(ModelParametersArray))
	
	local numberOfModelParameters = #ModelParametersArray

	NewModelParameters = AqwamTensorLibrary:divide(NewModelParameters, numberOfModelParameters)

	return NewModelParameters

end

local function mergeModelParameters(mergeMode, ModelParametersArray, splitAmountArray)
	
	local NewModelParameters
	
	local numberOfModelParameters = #ModelParametersArray
	
	local isTableOfMatrices = checkIfIsTableOfMatrices(ModelParametersArray[1])
	
	if (isTableOfMatrices) and (mergeMode == "WeightedAverage") then

		NewModelParameters = calculateWeightedAverageModelParametersTable(ModelParametersArray, splitAmountArray)

	elseif (not isTableOfMatrices) and (mergeMode == "WeightedAverage") then

		NewModelParameters = calculateWeightedAverageModelParameters(ModelParametersArray, splitAmountArray)
		
	elseif (isTableOfMatrices)  and (mergeMode == "Average") then
		
		NewModelParameters = calculateAverageModelParametersTable(ModelParametersArray)
		
	elseif (not isTableOfMatrices) and (mergeMode == "Average") then
		
		NewModelParameters = createAverageModelParameters(ModelParametersArray)
		
	else
		
		error("Invalid merge mode.")

	end
	
	return NewModelParameters
	
end

function ModelParametersMerger:merge(...)
	
	local ModelParametersArray = {...}

	if (#ModelParametersArray <= 0) then error("No model parameters set.") end
	
	local splitAmountArray = self.splitAmountArray
	
	if (not splitAmountArray) then
		
		local accuracyArray = generateAccuracyArray(self.Model, self.modelType, ModelParametersArray, self.featureMatrix, self.labelVector) 

		splitAmountArray = getSplitAmountArrayFromAccuracyArray(self.splitMode, accuracyArray)
		
	else
		
		warn("Using the existing split amount array.")
		
	end
	
	local NewModelParameters = mergeModelParameters(self.mergeMode, ModelParametersArray, splitAmountArray)

	return NewModelParameters

end

return ModelParametersMerger]]></ProtectedString>
									<string name="ScriptGuid">{402183A7-CE2C-43C7-A4B6-91A5BF656CA2}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ModelParametersMerger</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFB123017690E42D5847E8A046153290F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local DataPredictLibrary = script.Parent.Parent

local Models = DataPredictLibrary.Models

local Optimizers = DataPredictLibrary.Optimizers

local Regularizers = DataPredictLibrary.Regularizers

local ValueSchedulers = DataPredictLibrary.ValueSchedulers

local AqwamTensorLibrary = require(DataPredictLibrary.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(Models.IterativeMethodBaseModel)

OneVsAll = {}

OneVsAll.__index = OneVsAll

setmetatable(OneVsAll, IterativeMethodBaseModel)

local defaultModelName = "LogisticRegression"

local defaultMaximumNumberOfIterations = 500

local defaultUseNegativeOneBinaryLabel = false

function OneVsAll.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations
	
	local NewOneVsAll = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewOneVsAll, OneVsAll)
	
	NewOneVsAll:setName("OneVsAll")
	
	NewOneVsAll:setClassName("OneVsAll")
	
	NewOneVsAll.modelName = parameterDictionary.modelName or defaultModelName
	
	NewOneVsAll.useNegativeOneBinaryLabel = NewOneVsAll:getValueOrDefaultValue(parameterDictionary.useNegativeOneBinaryLabel, defaultUseNegativeOneBinaryLabel)
	
	NewOneVsAll.ClassesList = parameterDictionary.ClassesList or {}
	
	NewOneVsAll.ModelArray = parameterDictionary.ModelArray or {}
	
	return NewOneVsAll
	
end

function OneVsAll:generateModel(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or 1

	parameterDictionary.isOutputPrinted = self:getValueOrDefaultValue(parameterDictionary.isOutputPrinted, false)
	
	local SelectedModel = require(Models[self.modelName])
	
	local numberOfClasses = #self.ClassesList
	
	local ModelArray = {}

	for i = 1, numberOfClasses, 1 do
		
		ModelArray[i] = SelectedModel.new(parameterDictionary)

	end

	self.ModelArray = ModelArray
	
	return ModelArray
	
end

function OneVsAll:setModel(parameterDictionary)
	
	local ModelArray = self.ModelArray
	
	if (#ModelArray == 0) then 
		
		self:generateModel(parameterDictionary) 
		
	else
		
		for parameterKey, parameterValue in parameterDictionary do

			for _, Model in ipairs(ModelArray) do Model[parameterKey] = parameterValue end

		end
		
	end
	
end

function OneVsAll:setOptimizer(parameterDictionary)
	
	if (not parameterDictionary) then return end
	
	local ModelArray = self.ModelArray
	
	if (#ModelArray == 0) then ModelArray = self:generateModel() end
	
	local optimizerName = parameterDictionary.optimizerName
	
	if (not optimizerName) then error("No optimizer name.") end
	
	local ClassesList = self.ClassesList
	
	local SelectedOptimizer = require(Optimizers[optimizerName] or ValueSchedulers[optimizerName])
	
	local valueSchedulerName = parameterDictionary.valueSchedulerName
	
	local SelectedValueScheduler

	if (valueSchedulerName) then SelectedValueScheduler = require(ValueSchedulers[valueSchedulerName]) end
	
	for m, Model in ipairs(ModelArray) do 

		local success = pcall(function()
			
			if (SelectedValueScheduler) then parameterDictionary.LearningRateValueScheduler = SelectedValueScheduler.new(parameterDictionary) end
				
			local OptimizerObject = SelectedOptimizer.new(parameterDictionary)

			Model:setOptimizer(OptimizerObject)
				
		end)

		if (not success) then warn("The model for \"" .. ClassesList[m] .. "\" class does not have setOptimizer() function. No optimizer have been set to the model.") end

	end
		
end

function OneVsAll:setRegularizer(parameterDictionary)
	
	if (not parameterDictionary) then return end
	
	local ModelArray = self.ModelArray
	
	if (#ModelArray == 0) then ModelArray = self:generateModel() end
	
	local regularizerName = parameterDictionary.regularizerName
	
	if (not regularizerName) then error("No regularizer name.") end
	
	local ClassesList = self.ClassesList
	
	local SelectedRegularizer = require(Regularizers[regularizerName])
	
	local RegularizerObject = SelectedRegularizer.new(parameterDictionary)
	
	for m, Model in ipairs(ModelArray) do 
		
		local success = pcall(function() Model:setRegularizer(RegularizerObject) end)
		
		if (not success) then warn("The model for \"" .. ClassesList[m] .. "\" class does not have setRegularizer() function. No optimizer have been set to the model.") end
	
	end
	
end

function OneVsAll:setClassesList(ClassesList)

	self.ClassesList = ClassesList

end

function OneVsAll:getClassesList()

	return self.ClassesList

end

local function checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList)

	for i = 1, #labelVector, 1 do

		if table.find(ClassesList, labelVector[i][1]) then continue end

		return true

	end

	return false

end

local function createClassesList(labelVector)

	local ClassesList = {}

	local value

	for i = 1, #labelVector, 1 do

		value = labelVector[i][1]

		if not table.find(ClassesList, value) then

			table.insert(ClassesList, value)

		end

	end

	return ClassesList

end

function OneVsAll:processLabelVector(labelVector)
	
	local ClassesList = self.ClassesList

	if (#ClassesList == 0) then

		ClassesList = createClassesList(labelVector)

		table.sort(ClassesList, function(a,b) return a < b end)

	else

		if checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList) then error("A value does not exist in the classes list is present in the label vector.") end

	end
	
	self.ClassesList = ClassesList
	
	return ClassesList

end

local function convertToBinaryLabelVector(labelVector, selectedClass, useNegativeOneBinaryLabel)

	local newLabelVector = {}
	
	local labelValue
	
	for i, unwrappedLabelTable in ipairs(labelVector) do
		
		if (unwrappedLabelTable[1] == selectedClass) then
			
			labelValue = 1
			
		else
			
			labelValue = (useNegativeOneBinaryLabel and -1) or 0
			
		end
		
		newLabelVector[i] = {labelValue}
		
	end

	return newLabelVector

end

function OneVsAll:train(featureMatrix, labelVector)
	
	local ClassesList = self.ClassesList
	
	local ModelArray = self.ModelArray
	
	if (#ClassesList == 0) then ClassesList = self:processLabelVector(labelVector) end
	
	if (#ModelArray == 0) then ModelArray = self:generateModel() end
	
	if (#ModelArray ~= #ClassesList) then error("The number of models does not match with number of classes.") end
	
	local useNegativeOneBinaryLabel = self.useNegativeOneBinaryLabel
	
	local binaryLabelVectorTable = {}
	
	for i, class in ipairs(ClassesList) do

		local binaryLabelVector = convertToBinaryLabelVector(labelVector, class, useNegativeOneBinaryLabel)

		table.insert(binaryLabelVectorTable, binaryLabelVector)

	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local isOutputPrinted = self.isOutputPrinted
	
	local numberOfIterations = 0
	
	local costArray = {}
	
	local modelCostArray
	
	local totalCost
	
	local cost
	
	repeat
		
		numberOfIterations = numberOfIterations + 1
		
		totalCost = 0
		
		for m, Model in ipairs(ModelArray) do
			
			local binaryLabelVector = binaryLabelVectorTable[m]

			modelCostArray = Model:train(featureMatrix, binaryLabelVector)

			totalCost = totalCost + modelCostArray[#modelCostArray]

		end
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function() return totalCost end)
		
		if (cost) then

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end
				
	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(totalCost) or self:checkIfConverged(totalCost)
	
	return costArray
	
end

local function getModelNumberWithHighestValue(featureVector, ModelArray)
	
	local selectedModelNumber = 0

	local highestValue = -math.huge

	for m, Model in ipairs(ModelArray) do 

		local value = Model:predict(featureVector, true)[1][1]

		if (value > highestValue) then

			selectedModelNumber = m

			highestValue = value

		end

	end
	
	return selectedModelNumber, highestValue
	
end

function OneVsAll:predict(featureMatrix)
	
	local ModelArray = self.ModelArray
	
	if (#ModelArray == 0) then ModelArray = self:generateModel() end
	
	local ClassesList = self.ClassesList
	
	local numberOfData = #featureMatrix
	
	local selectedModelNumberVector = AqwamTensorLibrary:createTensor({numberOfData, 1})
	
	local highestValueVector = AqwamTensorLibrary:createTensor({numberOfData, 1})
	
	for i = 1, #featureMatrix, 1 do
		
		local featureVector = {featureMatrix[i]}
		
		local selectedModelNumber, highestValue = getModelNumberWithHighestValue(featureVector, ModelArray)
		
		selectedModelNumberVector[i][1] = ClassesList[selectedModelNumber]
		
		highestValueVector[i][1] = highestValue
		
	end
	
	return selectedModelNumberVector, highestValueVector
	
end

function OneVsAll:getModelParametersArray(doNotDeepCopy)
	
	local ModelArray = self.ModelArray
	
	if (#ModelArray == 0) then ModelArray = self:generateModel() end
	
	local ModelParametersArray = {}
	
	for _, Model in ipairs(ModelArray) do 
		
		local ModelParameters = Model:getModelParameters(doNotDeepCopy)
		
		table.insert(ModelParametersArray, ModelParameters) 
		
	end
	
	return ModelParametersArray
	
end

function OneVsAll:setModelParametersArray(ModelParametersArray, doNotDeepCopy)
	
	local ModelArray = self.ModelArray
	
	if (#ModelArray == 0) then ModelArray = self:generateModel() end
	
	if (not ModelParametersArray) then return end
	
	if (#ModelParametersArray ~= #ModelArray) then error("The number of model parameters does not match with the number of models.") end
	
	for m, Model in ipairs(ModelArray) do 
		
		local ModelParameters = ModelParametersArray[m]

		Model:setModelParameters(ModelParameters, doNotDeepCopy)

	end
	
end

function OneVsAll:clearModelParameters()
	
	local ModelArray = self.ModelArray
	
	if (#ModelArray == 0) then ModelArray = self:generateModel() end
	
	for _, Model in ipairs(ModelArray) do Model:clearModelParameters() end

end

return OneVsAll]]></ProtectedString>
									<string name="ScriptGuid">{B7460B73-692D-49F2-92DE-F7889E2BEFF7}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">OneVsAll</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDB21EEB88620499CB6EF9B443FA4B0FD">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)
	
	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

ConfusionMatrixCreator = {}

ConfusionMatrixCreator.__index = ConfusionMatrixCreator

setmetatable(ConfusionMatrixCreator, BaseInstance)

local function areNumbersOnlyInList(list)

	for i, value in ipairs(list) do

		if (typeof(value) ~= "number") then return false end

	end

	return true

end

local function createClassesList(labelVector)

	local ClassesList = {}

	local value

	for i = 1, #labelVector, 1 do

		value = labelVector[i][1]

		if not table.find(ClassesList, value) then

			table.insert(ClassesList, value)

		end

	end

	return ClassesList

end

local function checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList)

	for i = 1, #labelVector, 1 do

		if table.find(ClassesList, labelVector[i][1]) then continue end

		return true

	end

	return false

end

local function checkClassesList(ClassesList, trueLabelVector, predictedLabelVector)

	if (#ClassesList == 0) then

		ClassesList = createClassesList(trueLabelVector)

		local areNumbersOnly = areNumbersOnlyInList(ClassesList)

		if (areNumbersOnly) then table.sort(ClassesList, function(a,b) return a < b end) end

	else

		if checkIfAnyLabelVectorIsNotRecognized(trueLabelVector, ClassesList) then error("A value does not exist in the classes list is present in the true label vector.") end
		
		if checkIfAnyLabelVectorIsNotRecognized(predictedLabelVector, ClassesList) then error("A value does not exist in the classes list is present in the predicted label vector.") end
		
	end
	
	return ClassesList

end

function ConfusionMatrixCreator.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewConfusionMatrixCreator = BaseInstance.new(parameterDictionary)
	
	setmetatable(NewConfusionMatrixCreator, ConfusionMatrixCreator)
	
	NewConfusionMatrixCreator:setName("ConfusionMatrixCreator")
	
	NewConfusionMatrixCreator:setClassName("ConfusionMatrixCreator")
	
	NewConfusionMatrixCreator.ClassesList = parameterDictionary.ClassesList or {}
	
	return NewConfusionMatrixCreator
	
end

function ConfusionMatrixCreator:createConfusionMatrix(trueLabelVector, predictedLabelVector)
	
	if (#trueLabelVector ~= #predictedLabelVector) then error("The number of data are not equal!") end
	
	if (#trueLabelVector[1] ~= 1) or (#predictedLabelVector[1] ~= 1) then error("Both vector must only have one column!") end
	
	local ClassesList = checkClassesList(self.ClassesList, trueLabelVector, predictedLabelVector)
	
	self.ClassesList = ClassesList
	
	local numberOfClasses = #ClassesList
	
	local confusionMatrix = AqwamTensorLibrary:createTensor({numberOfClasses, numberOfClasses}, 0)
	
	local numberOfUnknownClassifications = 0
	
	for i = 1, #trueLabelVector, 1 do -- row: true value, column: predictedLabel
		
		local trueLabel = trueLabelVector[i][1]
			
		local predictedLabel = predictedLabelVector[i][1]
			
		local trueClassIndex = table.find(ClassesList, trueLabel)
			
		local predictedClassIndex = table.find(ClassesList, predictedLabel)
		
		if (trueClassIndex) and (predictedClassIndex) then
			
			confusionMatrix[trueClassIndex][predictedClassIndex] = confusionMatrix[trueClassIndex][predictedClassIndex] + 1
			
		else
			
			numberOfUnknownClassifications = numberOfUnknownClassifications + 1
			
		end
			
	end
	
	return confusionMatrix, numberOfUnknownClassifications
	
end

function ConfusionMatrixCreator:printConfusionMatrix(trueLabelVector, predictedLabelVector)
	
	local confusionMatrix, numberOfUnknownClassifications = self:createConfusionMatrix(trueLabelVector, predictedLabelVector)
	
	local ClassesList = self.ClassesList
	
	local numberOfClasses = #ClassesList
	
	local maxClassLabelLengthArray = {}
	
	local indicatorString = "True \\ Predicted"
	
	local maxColumnValueLength = string.len(indicatorString)

	for i, classLabel in ipairs(ClassesList) do
		
		local length = string.len(tostring(classLabel))
		
		maxClassLabelLengthArray[i] = length
		
		maxColumnValueLength = math.max(maxColumnValueLength, length)
		
	end

	for column = 1, #confusionMatrix[1], 1 do
		
		for row = 1, #confusionMatrix, 1 do
			
			maxClassLabelLengthArray[column] = math.max(maxClassLabelLengthArray[column], string.len(tostring(confusionMatrix[row][column]))) 

		end
		
	end
	
	local text =  "\n\n+" .. string.rep("-", maxColumnValueLength + 2) .. "+"
	
	for i, classLabel in ipairs(ClassesList) do

		local cellWidth = string.len(classLabel)

		local padding = maxClassLabelLengthArray[i] + 2

		text = text .. string.rep("-", padding)

		text = text .. "+"

	end
	
	text = text .. "\n|" .. tostring(" ", maxColumnValueLength - 1) .. indicatorString .. " |"
	
	for i, classLabel in ipairs(ClassesList) do
		
		local cellText = tostring(classLabel) 
		
		local cellWidth = string.len(classLabel)
		
		local padding = maxClassLabelLengthArray[i] - cellWidth + 1
		
		text = text .. string.rep(" ", padding) .. cellText

		text = text .. " |"

	end
	
	text = text .. "\n+".. string.rep("-", maxColumnValueLength  + 2) .. "+"
	
	for i, classLabel in ipairs(ClassesList) do

		local cellWidth = string.len(classLabel)

		local padding = maxClassLabelLengthArray[i] + 2

		text = text .. string.rep("-", padding)

		text = text .. "+"

	end
	
	text = text .. "\n" 

	for row = 1, numberOfClasses, 1 do
		
		local cellRowHeaderText = tostring(ClassesList[row]) 

		local cellWidth = string.len(cellRowHeaderText)

		local columnRowPadding = maxColumnValueLength - cellWidth + 1

		text = text .. "|" .. string.rep(" ", columnRowPadding) .. cellRowHeaderText .. " |"

		for column = 1, numberOfClasses, 1 do

			local cellValue = confusionMatrix[row][column]

			local cellText = tostring(cellValue) 

			local cellWidth = string.len(cellText)

			local padding = maxClassLabelLengthArray[column] - cellWidth + 1

			text = text .. string.rep(" ", padding) .. cellText
			
			text = text .. " |"

		end

		text = text .. "\n"

	end
	
	text = text .. "+" .. string.rep("-", maxColumnValueLength + 2) .. "+"
	
	for i, classLabel in ipairs(ClassesList) do

		local cellWidth = string.len(classLabel)

		local padding = maxClassLabelLengthArray[i] + 2

		text = text .. string.rep("-", padding)

		text = text .. "+"

	end
	
	text = text .. "\n\n"
	
	print(text)
	
	return confusionMatrix, numberOfUnknownClassifications
	
end

return ConfusionMatrixCreator]]></ProtectedString>
									<string name="ScriptGuid">{90605C8A-4B60-4692-AF72-7D79AF578B33}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ConfusionMatrixCreator</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX239A8FCD7A3F4C55A247BA39AB82C8B3">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local DataPredictLibrary = script.Parent.Parent

local Models = DataPredictLibrary.Models

local Optimizers = DataPredictLibrary.Optimizers

local Regularizers = DataPredictLibrary.Regularizers

local ValueSchedulers = DataPredictLibrary.ValueSchedulers

local AqwamTensorLibrary = require(DataPredictLibrary.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(Models.IterativeMethodBaseModel)

OneVsOne = {}

OneVsOne.__index = OneVsOne

setmetatable(OneVsOne, IterativeMethodBaseModel)

local defaultModelName = "LogisticRegression"

local defaultMaximumNumberOfIterations = 500

local defaultUseNegativeOneBinaryLabel = false

local defaultMode = "Value"

local function isTableEmpty(t)
	
	for _ in pairs(t) do return false end
	
	return true
end

function OneVsOne.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations
	
	local NewOneVsOne = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewOneVsOne, OneVsOne)
	
	NewOneVsOne:setName("OneVsOne")
	
	NewOneVsOne:setClassName("OneVsOne")
	
	NewOneVsOne.modelName = parameterDictionary.modelName or defaultModelName
	
	NewOneVsOne.useNegativeOneBinaryLabel = NewOneVsOne:getValueOrDefaultValue(parameterDictionary.useNegativeOneBinaryLabel, defaultUseNegativeOneBinaryLabel)
	
	NewOneVsOne.mode = NewOneVsOne:getValueOrDefaultValue(parameterDictionary.mode, defaultMode)
	
	NewOneVsOne.ClassesList = parameterDictionary.ClassesList or {}
	
	NewOneVsOne.ModelArray = parameterDictionary.ModelArray or {}
	
	return NewOneVsOne
	
end

function OneVsOne:generateModel(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or 1

	parameterDictionary.isOutputPrinted = self:getValueOrDefaultValue(parameterDictionary.isOutputPrinted, false)
	
	local SelectedModel = require(Models[self.modelName])
	
	local ClassesList = self.ClassesList
	
	local numberOfClasses = #ClassesList
	
	local ModelArray = {}

	for i = 1, numberOfClasses, 1 do
		
		for j = i + 1, numberOfClasses, 1 do
			
			local classArray = {ClassesList[i], ClassesList[j]}
			
			local ModelObject = SelectedModel.new(parameterDictionary)
			
			ModelArray[classArray] = ModelObject
			
		end

	end

	self.ModelArray = ModelArray
	
	return ModelArray
	
end

function OneVsOne:setModel(parameterDictionary)
	
	local ModelArray = self.ModelArray
	
	if (isTableEmpty(ModelArray)) then 
		
		self:generateModel(parameterDictionary) 
		
	else
		
		for parameterKey, parameterValue in parameterDictionary do

			for _, Model in pairs(ModelArray) do Model[parameterKey] = parameterValue end

		end
		
	end
	
end

function OneVsOne:setOptimizer(parameterDictionary)
	
	if (not parameterDictionary) then return end
	
	local ModelArray = self.ModelArray
	
	if (isTableEmpty(ModelArray)) then ModelArray = self:generateModel() end
	
	local optimizerName = parameterDictionary.optimizerName
	
	if (not optimizerName) then error("No optimizer name.") end
	
	local SelectedOptimizer = require(Optimizers[optimizerName] or ValueSchedulers[optimizerName])
	
	local valueSchedulerName = parameterDictionary.valueSchedulerName
	
	local SelectedValueScheduler
	
	if (valueSchedulerName) then SelectedValueScheduler = require(ValueSchedulers[valueSchedulerName]) end
		
	for classArray, Model in pairs(ModelArray) do 

		local success = pcall(function()
			
			if (SelectedValueScheduler) then parameterDictionary.LearningRateValueScheduler = SelectedValueScheduler.new(parameterDictionary) end
				
			local OptimizerObject = SelectedOptimizer.new(parameterDictionary)

			Model:setOptimizer(OptimizerObject)
				
		end)

		if (not success) then 
			
			warn("The model for \"" .. classArray[1] .. " - " ..  classArray[2] .. "\" class pair does not have setOptimizer() function. No optimizer have been set to the model.") 
			
		end

	end
		
end

function OneVsOne:setRegularizer(parameterDictionary)
	
	if (not parameterDictionary) then return end
	
	local ModelArray = self.ModelArray
	
	if (isTableEmpty(ModelArray)) then ModelArray = self:generateModel() end
	
	local regularizerName = parameterDictionary.regularizerName
	
	if (not regularizerName) then error("No regularizer name.") end
	
	local SelectedRegularizer = require(Regularizers[regularizerName])
	
	local RegularizerObject = SelectedRegularizer.new(parameterDictionary)
	
	for classArray, Model in pairs(ModelArray) do 
		
		local success = pcall(function() Model:setRegularizer(RegularizerObject) end)
		
		if (not success) then 

			warn("The model for \"" .. classArray[1] .. " - " ..  classArray[2] .. "\" class pair does not have setRegularizer() function. No optimizer have been set to the model.") 

		end
	
	end
	
end

function OneVsOne:setClassesList(ClassesList)

	self.ClassesList = ClassesList

end

function OneVsOne:getClassesList()

	return self.ClassesList

end

local function checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList)

	for i = 1, #labelVector, 1 do

		if table.find(ClassesList, labelVector[i][1]) then continue end

		return true

	end

	return false

end

local function createClassesList(labelVector)

	local ClassesList = {}

	local value

	for i = 1, #labelVector, 1 do

		value = labelVector[i][1]

		if not table.find(ClassesList, value) then

			table.insert(ClassesList, value)

		end

	end

	return ClassesList

end

function OneVsOne:processLabelVector(labelVector)
	
	local ClassesList = self.ClassesList

	if (#ClassesList == 0) then

		ClassesList = createClassesList(labelVector)

		table.sort(ClassesList, function(a,b) return a < b end)

	else

		if checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList) then error("A value does not exist in the classes list is present in the label vector.") end

	end
	
	self.ClassesList = ClassesList
	
	return ClassesList

end

local function convertToBinaryLabelVector(featureMatrix, labelVector, positiveClass, negativeClass, useNegativeOneBinaryLabel)
	
	local newFeatureMatrix = {}
	
	local newLabelVector = {}
	
	local labelValueDictionary = {}
	
	labelValueDictionary[positiveClass] = 1
	
	labelValueDictionary[negativeClass] = useNegativeOneBinaryLabel and -1 or 0
	
	local featureIndex = 1
	
	local labelValue

	for i, unwrappedLabelTable in ipairs(labelVector) do
		
		labelValue = unwrappedLabelTable[1]
		
		if (labelValue == positiveClass) or (labelValue == negativeClass) then
			
			newFeatureMatrix[featureIndex] = featureMatrix[i]
			
			newLabelVector[featureIndex] = {labelValueDictionary[labelValue]}
			
			featureIndex = featureIndex + 1
			
		end

	end

	return newFeatureMatrix, newLabelVector

end

function OneVsOne:train(featureMatrix, labelVector)
	
	local ClassesList = self.ClassesList

	local ModelArray = self.ModelArray

	if (#ClassesList == 0) then ClassesList = self:processLabelVector(labelVector) end

	if (isTableEmpty(ModelArray)) then ModelArray = self:generateModel() end
	
	self:processLabelVector(labelVector)
	
	local useNegativeOneBinaryLabel = self.useNegativeOneBinaryLabel
	
	local binaryLabelVectorTable = {}
	
	for classArray, _ in pairs(ModelArray) do

		local binaryFeatureMatrix, binaryLabelVector = convertToBinaryLabelVector(featureMatrix, labelVector,  classArray[1], classArray[2], useNegativeOneBinaryLabel)
		
		binaryLabelVectorTable[classArray] = {binaryFeatureMatrix, binaryLabelVector}

	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local isOutputPrinted = self.isOutputPrinted
	
	local numberOfIterations = 0
	
	local costArray = {}
	
	local modelCostArray
	
	local totalCost
	
	local cost
	
	repeat
		
		numberOfIterations = numberOfIterations + 1
		
		totalCost = 0
		
		for classArray, Model in pairs(ModelArray) do
			
			local datasetArray = binaryLabelVectorTable[classArray]
			
			local binaryFeatureMatrix = datasetArray[1]
			
			local binaryLabelVector = datasetArray[2]

			modelCostArray = Model:train(binaryFeatureMatrix, binaryLabelVector)

			totalCost = totalCost + modelCostArray[#modelCostArray]

		end
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function() return totalCost end)
		
		if (cost) then

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end
				
	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(totalCost) or self:checkIfConverged(totalCost)
	
	return costArray
	
end

local function getClassWithHighestValue(featureVector, ModelArray, thresholdValue)
	
	local selectedClass
	
	local highestValue = -math.huge
	
	local predictedClass

	for classArray, Model in pairs(ModelArray) do 

		local value = Model:predict(featureVector, true)[1][1]
		
		predictedClass = nil
		
		if (value > thresholdValue) then
			
			predictedClass = classArray[1]
			
		elseif (value < thresholdValue) then
			
			predictedClass = classArray[2]
			
		end
		
		if (predictedClass) then
			
			local absoluteValue = math.abs(value)

			if (absoluteValue > highestValue) then

				selectedClass = predictedClass

				highestValue = absoluteValue

			end
			
		end

	end

	return selectedClass, highestValue
	
end

local function getClassWithHighestVote(featureVector, ModelArray, thresholdValue)
	
	local highestVote = -math.huge
	
	local classVoteDictionary = {}
	
	local classToVote
	
	local selectedClass
	
	for classArray, Model in pairs(ModelArray) do 

		local value = Model:predict(featureVector, true)[1][1]
		
		classToVote = nil

		if (value > thresholdValue) then
			
			classToVote = classArray[1]
			
		elseif (value < thresholdValue) then
			
			classToVote = classArray[2]

		end
		
		if (classToVote) then

			classVoteDictionary[classToVote] = (classVoteDictionary[classToVote] or 0) + 1
			
		end

	end
	
	for class, classVote in pairs(classVoteDictionary) do
		
		if (classVote > highestVote) then
			
			selectedClass = class
			
			highestVote = classVote
			
		end
		
	end
	
	return selectedClass, highestVote
	
end

local function getClassWithHighestSoftVote(featureVector, ModelArray, thresholdValue)
	
	local highestValue = -math.huge

	local classValueDictionary = {}
	
	local selectedClass

	for classArray, Model in pairs(ModelArray) do 

		local value = Model:predict(featureVector, true)[1][1]

		local positiveClassValue
		local negativeClassValue

		if (thresholdValue == 0) then
			
			-- Handles useNegativeOneBinaryLabel = true.
			
			-- Convert raw decision value to [0, 1] using sigmoid.
			
			positiveClassValue = 1 / (1 + math.exp(-value))
			
			negativeClassValue = 1 - positiveClassValue

		elseif (thresholdValue == 0.5) then
			
			-- Handles normal probabilistic models with [0, 1] output.
			
			-- Center around threshold instead of hard voting.
			
			if (value > thresholdValue) then
				
				positiveClassValue = value
				
				negativeClassValue = 1 - value
				
			elseif (value < thresholdValue) then
				
				-- small stabilization when below threshold.
				
				positiveClassValue = 1 - value
				
				negativeClassValue = value
				
			else
				
				positiveClassValue = 0
				
				negativeClassValue = 0
				
			end
			
		else
			
			error("Unknown threshold value.")
			
		end
		
		local positiveClass = classArray[1]
		local negativeClass = classArray[2]

		classValueDictionary[positiveClass] = (classValueDictionary[positiveClass] or 0) + positiveClassValue
		classValueDictionary[negativeClass] = (classValueDictionary[negativeClass] or 0) + negativeClassValue

	end

	for class, value in pairs(classValueDictionary) do
		
		if (value > highestValue) then
			
			selectedClass = class
			
			highestValue = value
			
		end
		
	end

	return selectedClass, highestValue
end

local predictionFunctionList = {
	
	["Value"] = getClassWithHighestValue,
	
	["Vote"] = getClassWithHighestVote,
	
	["SoftVote"] = getClassWithHighestSoftVote
	
}

function OneVsOne:predict(featureMatrix)
	
	local ModelArray = self.ModelArray
	
	if (isTableEmpty(ModelArray)) then ModelArray = self:generateModel() end
	
	local predictionFunction = predictionFunctionList[self.mode]
	
	if (not predictionFunction) then error("Unknown mode.") end
	
	local thresholdValue = (self.useNegativeOneBinaryLabel and 0) or 0.5
	
	local numberOfData = #featureMatrix
	
	local selectedClassVector = AqwamTensorLibrary:createTensor({numberOfData, 1})
	
	local classScoreVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, thresholdValue)
	
	for i = 1, #featureMatrix, 1 do
		
		local featureVector = {featureMatrix[i]}
		
		local selectedClass, classScore = predictionFunction(featureVector, ModelArray, thresholdValue)
		
		selectedClassVector[i][1] = selectedClass
		
		classScoreVector[i][1] = classScore
		
	end
	
	return selectedClassVector, classScoreVector
	
end

function OneVsOne:getModelParametersArray(doNotDeepCopy)
	
	local ModelArray = self.ModelArray
	
	if (isTableEmpty(ModelArray)) then ModelArray = self:generateModel() end
	
	local ModelParametersArray = {}
	
	for _, Model in pairs(ModelArray) do 
		
		local ModelParameters = Model:getModelParameters(doNotDeepCopy)
		
		table.insert(ModelParametersArray, ModelParameters) 
		
	end
	
	return ModelParametersArray
	
end

function OneVsOne:setModelParametersArray(ModelParametersArray, doNotDeepCopy)
	
	local ModelArray = self.ModelArray
	
	if (isTableEmpty(ModelArray)) then ModelArray = self:generateModel() end
	
	if (ModelParametersArray == nil) then return nil end
	
	if (#ModelParametersArray ~= #ModelArray) then error("The number of model parameters does not match with the number of models.") end
	
	for classArray, Model in pairs(ModelArray) do 
		
		local ModelParameters = ModelParametersArray[classArray]

		Model:setModelParameters(ModelParameters, doNotDeepCopy)

	end
	
end

function OneVsOne:clearModelParameters()
	
	local ModelArray = self.ModelArray
	
	if (isTableEmpty(ModelArray)) then ModelArray = self:generateModel() end
	
	for _, Model in pairs(ModelArray) do Model:clearModelParameters() end

end

return OneVsOne]]></ProtectedString>
									<string name="ScriptGuid">{D825CB66-EE73-4271-9F86-08425149934B}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">OneVsOne</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEC9A540E21554B2DB8BB0EEE3AA331A9">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

local NormalModelModifier = {}

NormalModelModifier.__index = NormalModelModifier

setmetatable(NormalModelModifier, BaseInstance)

local defaultNoiseValue = 1e-16

function NormalModelModifier.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewNormalModelModifier = BaseInstance.new(parameterDictionary)
	
	setmetatable(NewNormalModelModifier, NormalModelModifier)
	
	NewNormalModelModifier:setName("NormalModelModifier")
	
	NewNormalModelModifier:setClassName("NormalModelModifier")
	
	NewNormalModelModifier.Model = parameterDictionary.Model
	
	NewNormalModelModifier.noiseValue = parameterDictionary.noiseValue or defaultNoiseValue
	
	return NewNormalModelModifier
	
end

function NormalModelModifier:train(featureMatrix, labelMatrix)
	
	local noiseValue = self.noiseValue
	
	local numberOfData = #featureMatrix
	
	local numberOfFeatures = #featureMatrix[1]
	
	local smallestDimensionSize = math.min(numberOfData, numberOfFeatures)
	
	local newFeatureMatrix = {}
	
	local newLabelMatrix
	
	if (labelMatrix) then
		
		newLabelMatrix = {}
		
		for dataIndex, unwrappedFeatureVector in ipairs(featureMatrix) do
			
			if (dataIndex > smallestDimensionSize) then break end
			
			newFeatureMatrix[dataIndex] = unwrappedFeatureVector
			
			newLabelMatrix[dataIndex] = labelMatrix[dataIndex]
			
		end
		
	else
		
		for dataIndex, unwrappedFeatureVector in ipairs(featureMatrix) do

			if (dataIndex > smallestDimensionSize) then break end

			newFeatureMatrix[dataIndex] = unwrappedFeatureVector

		end
		
	end
	
	-- This step helps to break collinearity in our feature matrix.
	
	if (noiseValue ~= 0) then
		
		local noiseMatrix = AqwamTensorLibrary:createRandomUniformTensor({smallestDimensionSize, smallestDimensionSize}, -noiseValue, noiseValue)

		newFeatureMatrix = AqwamTensorLibrary:add(newFeatureMatrix, noiseMatrix)

	end
	
	return self.Model:train(newFeatureMatrix, newLabelMatrix)
	
end

function NormalModelModifier:update(...)

	return self.Model:update(...)

end

function NormalModelModifier:predict(...)
	
	return self.Model:predict(...)
	
end

function NormalModelModifier:setModel(Model)
	
	self.Model = Model
	
end

function NormalModelModifier:getModel()

	return self.Model

end

function NormalModelModifier:getModelParameters(...)

	return self.Model:getModelParameters(...)

end

function NormalModelModifier:setModelParameters(...)

	self.Model:setModelParameters(...)

end

return NormalModelModifier]]></ProtectedString>
									<string name="ScriptGuid">{F3E7D04C-7B9F-4D6C-9E6C-8A84168A14CA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">NormalModelModifier</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX1083C14385C64FF084AF41BB617E7A6F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Models</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXA13AD007455A49ACB3FF4BB4E39F2E36">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

BisectingClusterModel = {}

BisectingClusterModel.__index = BisectingClusterModel

setmetatable(BisectingClusterModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultNumberOfClusters = 2

local defaultDistanceFunction = "Euclidean"

local defaultSplitCriterion = "LargestCluster"

local function assignToCluster(distanceMatrix) -- Number of columns -> number of clusters
	
	local numberOfDistances = #distanceMatrix
	
	local clusterNumberVector = AqwamTensorLibrary:createTensor({numberOfDistances, 1})

	local clusterDistanceVector = AqwamTensorLibrary:createTensor({numberOfDistances, 1}) 

	for dataIndex, distanceVector in ipairs(distanceMatrix) do

		local closestClusterNumber

		local shortestDistance = math.huge

		for i, distance in ipairs(distanceVector) do

			if (distance < shortestDistance) then

				closestClusterNumber = i

				shortestDistance = distance

			end

		end

		clusterNumberVector[dataIndex][1] = closestClusterNumber

		clusterDistanceVector[dataIndex][1] = shortestDistance

	end

	return clusterNumberVector, clusterDistanceVector
	
end

local function createDistanceMatrix(distanceFunction, matrix1, matrix2)

	local numberOfData1 = #matrix1

	local numberOfData2 = #matrix2

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData1, numberOfData2})

	for matrix1Index = 1, numberOfData1, 1 do

		for matrix2Index = 1, numberOfData2, 1 do

			distanceMatrix[matrix1Index][matrix2Index] = distanceFunction({matrix1[matrix1Index]}, {matrix2[matrix2Index]})

		end

	end

	return distanceMatrix

end

local function extractSubsetMatrix(matrix, indexArray)
	
	local subMatrix = {}
	
	local index = 1
	
	for _, clusterIndex in ipairs(indexArray) do
		
		subMatrix[index] = matrix[clusterIndex]
		
		index = index + 1
		
	end
	
	return subMatrix
	
end

local function calculateCentroidVector(featureMatrix, indexArray)
	
	local numberOfIndices = #indexArray
	
	if (numberOfIndices == 0) then return nil end
	
	local numberOfFeatures = #featureMatrix[1]
	
	local unwrappedCentroidVector = table.create(numberOfFeatures, 0)
	
	local unwrappedFeatureVector
	
	for _, index in ipairs(indexArray) do
		
		unwrappedFeatureVector = featureMatrix[index]
		
		for featureIndex, value in ipairs(unwrappedFeatureVector) do
			
			unwrappedCentroidVector[featureIndex] = unwrappedCentroidVector[featureIndex] + value
			
		end
		
	end
	
	for featureIndex, value in ipairs(unwrappedCentroidVector) do
		
		unwrappedCentroidVector[featureIndex] = value / numberOfIndices
		
	end
		
	return {unwrappedCentroidVector}
		
end

local function calculateSumOfSquaredError(featureMatrix, indexArray, centroidVector, distanceFunction)
	
	local numberOfIndices = #indexArray
	
	if (numberOfIndices == 0) then return 0 end
	
	local sumOfSquaredErrorValue = 0
	
	local featureVector
	
	local distance
	
	for _, index in ipairs(indexArray) do
		
		featureVector = {featureMatrix[index]}
		
		distance = distanceFunction(featureVector, centroidVector)

		sumOfSquaredErrorValue = sumOfSquaredErrorValue + math.pow(distance, 2)
		
	end
	
	sumOfSquaredErrorValue = sumOfSquaredErrorValue / numberOfIndices
	
	return sumOfSquaredErrorValue
	
end

function BisectingClusterModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations
	
	local NewBisectingClusterModel = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewBisectingClusterModel, BisectingClusterModel)
	
	NewBisectingClusterModel:setName("BisectingCluster")
	
	NewBisectingClusterModel.Model = parameterDictionary.Model

	NewBisectingClusterModel.numberOfClusters = parameterDictionary.numberOfClusters or defaultNumberOfClusters
	
	NewBisectingClusterModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction
	
	NewBisectingClusterModel.splitCriterion = parameterDictionary.splitCriterion or defaultSplitCriterion
	
	return NewBisectingClusterModel
	
end

function BisectingClusterModel:train(featureMatrix)
	
	local Model = self.Model
	
	if (not Model) then error("No model") end
	
	local numberOfClusters = self.numberOfClusters
	
	local distanceFunction = self.distanceFunction
	
	local splitCriterion = self.splitCriterion
	
	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]

	if (not distanceFunctionToApply) then error("Unknown distance function.") end
	
	local secondaryNumberOfClusters = Model.numberOfClusters

	local numberOfIterations = 0
	
	local costArray = {}
	
	local cost

	local distanceMatrix
	
	local clusterIndexToSplit
	
	local numberOfData
	
	local clusterFeatureMatrix
	
	local maximumCriterion
	
	local criterion
	
	local clusterInformationDictionary
	
	local clusterIndexVector
	
	local sumOfSquaredErrorValue
	
	local leftSumOfSquaredErrorValue
	
	local rightSumOfSquaredErrorValue
	
	local dataIndexArray
	
	local leftDataIndexArray
	
	local rightDataIndexArray
	
	local targetDataIndexArray
	
	local clusterIndex
	
	local centroidVector
	
	local leftCentroidVector
	
	local rightCentroidVector
	
	local clusterInformationDictionaryArray
	
	dataIndexArray = {}
	
	for i, _ in ipairs(featureMatrix) do dataIndexArray[i] = i end
	
	centroidVector = calculateCentroidVector(featureMatrix, dataIndexArray)
	
	sumOfSquaredErrorValue = calculateSumOfSquaredError(featureMatrix, dataIndexArray, centroidVector, distanceFunctionToApply)
	
	clusterInformationDictionaryArray = {{dataIndexArray = dataIndexArray, sumOfSquaredErrorValue = sumOfSquaredErrorValue}}
	
	Model.numberOfClusters = 2
	
	repeat
		
		numberOfIterations = numberOfIterations + 1
		
		self:iterationWait()
		
		clusterIndexToSplit = 1
		
		maximumCriterion = -math.huge
		
		for i, clusterInformationDictionary in ipairs(clusterInformationDictionaryArray) do
			
			dataIndexArray = clusterInformationDictionary.dataIndexArray
			
			numberOfData = #dataIndexArray
			
			criterion = ((splitCriterion == "LargestCluster") and numberOfData) or clusterInformationDictionary.sumOfSquaredErrorValue
			
			if (criterion > maximumCriterion) and (numberOfData >= 2) then
				
				maximumCriterion = criterion
				
				clusterIndexToSplit = i
				
			end
			
		end
		
		clusterInformationDictionary = clusterInformationDictionaryArray[clusterIndexToSplit]
		
		dataIndexArray = clusterInformationDictionary.dataIndexArray
		
		clusterFeatureMatrix = extractSubsetMatrix(featureMatrix, dataIndexArray)
		
		Model:train(clusterFeatureMatrix)
		
		clusterIndexVector = Model:predict(clusterFeatureMatrix)
		
		leftDataIndexArray = {}
		
		rightDataIndexArray = {}
		
		for dataIndex, unwrappedClusterIndex in ipairs(clusterIndexVector) do
			
			clusterIndex = unwrappedClusterIndex[1]
			
			targetDataIndexArray = ((clusterIndex == 1) and leftDataIndexArray) or rightDataIndexArray
			
			table.insert(targetDataIndexArray, dataIndexArray[dataIndex])
			
		end
		
		leftCentroidVector = calculateCentroidVector(featureMatrix, leftDataIndexArray)
		
		rightCentroidVector = calculateCentroidVector(featureMatrix, rightDataIndexArray)

		leftSumOfSquaredErrorValue = calculateSumOfSquaredError(featureMatrix, leftDataIndexArray, leftCentroidVector, distanceFunctionToApply)
		
		rightSumOfSquaredErrorValue = calculateSumOfSquaredError(featureMatrix, rightDataIndexArray, rightCentroidVector, distanceFunctionToApply)

		table.remove(clusterInformationDictionaryArray, clusterIndexToSplit)

		table.insert(clusterInformationDictionaryArray, {dataIndexArray = leftDataIndexArray, sumOfSquaredErrorValue = leftSumOfSquaredErrorValue})

		table.insert(clusterInformationDictionaryArray, {dataIndexArray = rightDataIndexArray, sumOfSquaredErrorValue = rightSumOfSquaredErrorValue})
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return (leftSumOfSquaredErrorValue + rightSumOfSquaredErrorValue)

		end)
		
		if (cost) then

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end
		
	until (#clusterInformationDictionaryArray == numberOfClusters) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	local centroidMatrix = {}
	
	local index = 1
	
	for _, clusterInformationDictionary in ipairs(clusterInformationDictionaryArray) do
		
		dataIndexArray = clusterInformationDictionary.dataIndexArray
		
		if (#dataIndexArray ~= 0) then
			
			centroidMatrix[index] = calculateCentroidVector(featureMatrix, dataIndexArray)[1]
			
			index = index + 1
			
		end
		
	end
	
	self.ModelParameters = centroidMatrix
	
	Model.numberOfClusters = secondaryNumberOfClusters
	
	return costArray
	
end

function BisectingClusterModel:predict(featureMatrix, returnOriginalOutput)
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
	
	local centroidMatrix = self.ModelParameters
	
	if (not centroidMatrix) then
		
		local numberOfClusters = self.numberOfClusters
		
		if (numberOfClusters == 1) then
			
			centroidMatrix = AqwamTensorLibrary:mean(featureMatrix, 1)
			
		else
			
			centroidMatrix = self:initializeMatrixBasedOnMode({numberOfClusters, #featureMatrix[1]})
			
		end
		
		self.ModelParameters = centroidMatrix

	end
	
	local distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, centroidMatrix)
	
	if (returnOriginalOutput) then return distanceMatrix end

	local clusterNumberVector, clusterDistanceVector = assignToCluster(distanceMatrix)

	return clusterNumberVector, clusterDistanceVector
	
end

return BisectingClusterModel]]></ProtectedString>
									<string name="ScriptGuid">{60AC48AA-BC6B-4A88-A401-A0607816359E}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BisectingCluster</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAF56DB8B94F04F109DAC3AA05FD1371E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GradientMethodBaseModel = require(script.Parent.GradientMethodBaseModel)

SupportVectorMachineGradientVariantModel = {}

SupportVectorMachineGradientVariantModel.__index = SupportVectorMachineGradientVariantModel

setmetatable(SupportVectorMachineGradientVariantModel, GradientMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultLearningRate = 0.3

local defaultCValue = 1

local function hingeFunction(value)
	
	return math.max(0, value)
	
end

local function misclassificationMaskFunction(value)
	
	return (value < 1) and 1 or 0
	
end

local function seperatorFunction(x) 

	return ((x > 0) and 1) or ((x < 0) and -1) or 0

end

function SupportVectorMachineGradientVariantModel:calculateCost(hypothesisVector, labelVector)

	if (type(hypothesisVector) == "number") then hypothesisVector = {{hypothesisVector}} end
	
	local oneVector = AqwamTensorLibrary:createTensor({#labelVector, 1}, 1)
	
	local marginVector = AqwamTensorLibrary:multiply(labelVector, hypothesisVector)
	
	local hingeVector = AqwamTensorLibrary:subtract(oneVector, marginVector)
	
	local costVector = AqwamTensorLibrary:applyFunction(hingeFunction, hingeVector)

	local totalCost = AqwamTensorLibrary:sum(costVector)
	
	local Regularizer = self.Regularizer

	if (Regularizer) then totalCost = totalCost + Regularizer:calculateCost(self.ModelParameters) end

	local averageCost = (self.cValue * totalCost) / #labelVector

	return averageCost

end

function SupportVectorMachineGradientVariantModel:calculateHypothesisVector(featureMatrix, saveFeatureMatrix)

	local hypothesisVector = AqwamTensorLibrary:dotProduct(featureMatrix, self.ModelParameters)

	if (saveFeatureMatrix) then self.featureMatrix = featureMatrix end

	return hypothesisVector

end

function SupportVectorMachineGradientVariantModel:calculateCostFunctionDerivativeMatrix(lossMatrix)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local featureMatrix = self.featureMatrix

	if (not featureMatrix) then error("Feature matrix not found.") end

	local costFunctionDerivativeMatrix = AqwamTensorLibrary:dotProduct(AqwamTensorLibrary:transpose(featureMatrix), lossMatrix)

	if (self.areGradientsSaved) then self.costFunctionDerivativeMatrix = costFunctionDerivativeMatrix end

	return costFunctionDerivativeMatrix

end

function SupportVectorMachineGradientVariantModel:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (type(costFunctionDerivativeMatrix) == "number") then costFunctionDerivativeMatrix = {{costFunctionDerivativeMatrix}} end
	
	local ModelParameters = self.ModelParameters
	
	local Regularizer = self.Regularizer
	
	local Optimizer = self.Optimizer
	
	local learningRate = self.learningRate

	if (Regularizer) then

		local regularizationDerivatives = Regularizer:calculate(ModelParameters)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:add(costFunctionDerivativeMatrix, regularizationDerivatives)

	end

	costFunctionDerivativeMatrix = AqwamTensorLibrary:divide(costFunctionDerivativeMatrix, numberOfData)

	if (Optimizer) then 

		costFunctionDerivativeMatrix = Optimizer:calculate(learningRate, costFunctionDerivativeMatrix, ModelParameters) 

	else

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrix)

	end

	self.ModelParameters = AqwamTensorLibrary:subtract(ModelParameters, costFunctionDerivativeMatrix)

end

function SupportVectorMachineGradientVariantModel:update(lossMatrix, clearAllMatrices)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local numberOfData = #lossMatrix

	local costFunctionDerivativeMatrix = self:calculateCostFunctionDerivativeMatrix(lossMatrix)

	self:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (clearAllMatrices) then 

		self.featureMatrix = nil 

		self.costFunctionDerivativeMatrix = nil

	end

end

function SupportVectorMachineGradientVariantModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewSupportVectorMachineGradientVariantModel = GradientMethodBaseModel.new(parameterDictionary)

	setmetatable(NewSupportVectorMachineGradientVariantModel, SupportVectorMachineGradientVariantModel)
	
	NewSupportVectorMachineGradientVariantModel:setName("SupportVectorMachineGradientVariant")

	NewSupportVectorMachineGradientVariantModel.learningRate = parameterDictionary.learningRate or defaultLearningRate
	
	NewSupportVectorMachineGradientVariantModel.cValue = parameterDictionary.cValue or defaultCValue

	NewSupportVectorMachineGradientVariantModel.Optimizer = parameterDictionary.Optimizer

	NewSupportVectorMachineGradientVariantModel.Regularizer = parameterDictionary.Regularizer

	return NewSupportVectorMachineGradientVariantModel

end

function SupportVectorMachineGradientVariantModel:setOptimizer(Optimizer)

	self.Optimizer = Optimizer

end

function SupportVectorMachineGradientVariantModel:setRegularizer(Regularizer)

	self.Regularizer = Regularizer

end

function SupportVectorMachineGradientVariantModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (#featureMatrix[1] ~= #ModelParameters) then error("The number of features are not the same as the model parameters.") end

	else

		self.ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local cValue = self.cValue

	local Optimizer = self.Optimizer

	local costArray = {}

	local numberOfIterations = 0
	
	local cost

	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		local hypothesisVector = self:calculateHypothesisVector(featureMatrix, true)

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return self:calculateCost(hypothesisVector, labelVector)

		end)

		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end

		local marginVector = AqwamTensorLibrary:multiply(labelVector, hypothesisVector)
		
		local misclassifiedMaskVector = AqwamTensorLibrary:applyFunction(misclassificationMaskFunction, marginVector)
		
		local lossVector = AqwamTensorLibrary:multiply(-cValue, labelVector, misclassifiedMaskVector)

		self:update(lossVector, true)

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	if (Optimizer) and (self.autoResetOptimizers) then Optimizer:reset() end

	return costArray

end

function SupportVectorMachineGradientVariantModel:predict(featureMatrix, returnOriginalOutput)
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then
		
		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})
		
		self.ModelParameters = ModelParameters
		
	end

	local predictedVector = AqwamTensorLibrary:dotProduct(featureMatrix, ModelParameters)
	
	if (returnOriginalOutput) then return predictedVector end

	return AqwamTensorLibrary:applyFunction(seperatorFunction, predictedVector)

end

return SupportVectorMachineGradientVariantModel]]></ProtectedString>
									<string name="ScriptGuid">{A212A047-4FD0-4518-A189-A5511D2DDD9E}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">SupportVectorMachineGradientVariant</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9AFC81D0F526482686F4640B59F1C89C">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

OneClassSupportVectorMachineModel = {}

OneClassSupportVectorMachineModel.__index = OneClassSupportVectorMachineModel

setmetatable(OneClassSupportVectorMachineModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultCvalue = 1

local defaultBeta = 0.9

local defaultKernelFunction = "Linear"

local defaultGamma = 1

local defaultDegree = 3

local defaultSigma = 1

local defaultR = 0

local seperatorFunction = function (x) 

	return ((x > 0) and 1) or ((x < 0) and -1) or 0

end

local function createDistanceMatrix(distanceFunction, matrix1, matrix2)

	local numberOfData1 = #matrix1

	local numberOfData2 = #matrix2

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData1, numberOfData2})
	
	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]

	for i = 1, numberOfData1, 1 do

		for j = 1, numberOfData2, 1 do

			distanceMatrix[i][j] = distanceFunctionToApply({matrix1[i]}, {matrix2[j]})

		end

	end

	return distanceMatrix

end

local mappingList = {

	["Linear"] = function(featureMatrix)

		return featureMatrix

	end,

	["Polynomial"] = function(featureMatrix, kernelParameters)

		local degree = kernelParameters.degree

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local scaledFeatureMatrix = AqwamTensorLibrary:multiply(featureMatrix, gamma)

		local addedFeatureMatrix = AqwamTensorLibrary:add(scaledFeatureMatrix, r)

		return AqwamTensorLibrary:power(addedFeatureMatrix, degree)

	end,

	["RadialBasisFunction"] = function(featureMatrix, kernelParameters)

		local sigma = kernelParameters.sigma

		local squaredFeatureMatrix = AqwamTensorLibrary:power(featureMatrix, 2)

		local squaredSigmaVector = AqwamTensorLibrary:power(sigma, 2)

		local multipliedSquaredSigmaVector = AqwamTensorLibrary:multiply(-2, squaredSigmaVector)

		local zMatrix = AqwamTensorLibrary:divide(squaredFeatureMatrix, multipliedSquaredSigmaVector)

		return AqwamTensorLibrary:applyFunction(math.exp, zMatrix)

	end,

	["Sigmoid"] = function(featureMatrix, kernelParameters)

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local kernelMappingMatrixPart1 = AqwamTensorLibrary:multiply(gamma, featureMatrix)

		local kernelMappingMatrixPart2 = AqwamTensorLibrary:add(kernelMappingMatrixPart1, r)

		local kernelMappingMatrix = AqwamTensorLibrary:applyFunction(math.tanh, kernelMappingMatrixPart2)

		return kernelMappingMatrix

	end,

	["Cosine"] = function(featureMatrix, kernelParameters)

		local zeroMatrix = AqwamTensorLibrary:createTensor({1, #featureMatrix[1]}, 0)

		local distanceMatrix = createDistanceMatrix("Euclidean", featureMatrix, zeroMatrix)

		local kernelMappingMatrix = AqwamTensorLibrary:divide(featureMatrix, distanceMatrix)

		return kernelMappingMatrix

	end,

}

local kernelFunctionList = {

	["Linear"] = function(featureMatrix)

		local kernelMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, AqwamTensorLibrary:transpose(featureMatrix))

		return kernelMatrix

	end,

	["Polynomial"] = function(featureMatrix, kernelParameters)

		local degree = kernelParameters.degree

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local dotProductedFeatureMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, AqwamTensorLibrary:transpose(featureMatrix))

		local scaledDotProductedFeatureMatrix = AqwamTensorLibrary:multiply(dotProductedFeatureMatrix, gamma)

		local addedFeatureMatrix = AqwamTensorLibrary:add(scaledDotProductedFeatureMatrix, r)

		local kernelMatrix = AqwamTensorLibrary:power(addedFeatureMatrix, degree)

		return kernelMatrix

	end,

	["RadialBasisFunction"] = function(featureMatrix, kernelParameters)

		local sigma = kernelParameters.sigma

		local distanceMatrix = createDistanceMatrix("Euclidean", featureMatrix, featureMatrix)

		local squaredDistanceMatrix = AqwamTensorLibrary:power(distanceMatrix, 2)

		local sigmaSquaredVector = AqwamTensorLibrary:power(sigma, 2)

		local multipliedSigmaSquaredVector = AqwamTensorLibrary:multiply(-2, sigmaSquaredVector)

		local zMatrix = AqwamTensorLibrary:divide(squaredDistanceMatrix, multipliedSigmaSquaredVector)

		local kernelMatrix = AqwamTensorLibrary:applyFunction(math.exp, zMatrix)

		return kernelMatrix

	end,

	["Sigmoid"] = function(featureMatrix, kernelParameters)

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local dotProductedFeatureMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, AqwamTensorLibrary:transpose(featureMatrix))

		local kernelMatrixPart1 = AqwamTensorLibrary:multiply(gamma, dotProductedFeatureMatrix)

		local kernelMatrixPart2 = AqwamTensorLibrary:add(kernelMatrixPart1, r)

		local kernelMatrix = AqwamTensorLibrary:applyFunction(math.tanh, kernelMatrixPart2)

		return kernelMatrix

	end,

	["Cosine"] = function(featureMatrix, kernelParameters)

		local zeroMatrix = AqwamTensorLibrary:createTensor({1, #featureMatrix[1]}, 0)

		local distanceMatrix = createDistanceMatrix("Euclidean", featureMatrix, zeroMatrix)

		local kernelMappingMatrix = AqwamTensorLibrary:divide(featureMatrix, distanceMatrix)

		local kernelMatrix = AqwamTensorLibrary:dotProduct(kernelMappingMatrix, AqwamTensorLibrary:transpose(kernelMappingMatrix))

		return kernelMatrix

	end,

}

local function calculateCost(modelParameters, individualKernelMatrix, kernelMatrix, labelVector, cValue)

	-- The dotProduct() only takes two arguments here to reduce computational time

	local predictedVector = AqwamTensorLibrary:dotProduct(individualKernelMatrix, modelParameters)

	local costVector = AqwamTensorLibrary:subtract(predictedVector, labelVector)

	costVector = AqwamTensorLibrary:multiply(-cValue, costVector)

	local transposedCostVector = AqwamTensorLibrary:transpose(costVector)

	local transposedLabelVector = AqwamTensorLibrary:transpose(labelVector)

	local costPart1 = AqwamTensorLibrary:dotProduct(transposedCostVector, kernelMatrix)

	costPart1 = AqwamTensorLibrary:dotProduct(costPart1, kernelMatrix)

	costPart1 = AqwamTensorLibrary:dotProduct(costPart1, costVector)[1][1]

	costPart1 = costPart1 / 2

	local costPart2 = AqwamTensorLibrary:dotProduct(transposedCostVector, kernelMatrix)

	costPart2 = AqwamTensorLibrary:dotProduct(costPart2, labelVector)[1][1]

	local costPart3 = AqwamTensorLibrary:dotProduct(transposedLabelVector, labelVector)[1][1]

	costPart3 = costPart3 / 2

	local costPart4 = AqwamTensorLibrary:dotProduct(transposedCostVector, kernelMatrix)

	costPart4 = AqwamTensorLibrary:dotProduct(costPart4, costVector)[1][1]

	costPart4 = costPart4 / (2 * cValue)

	local cost = costPart1 - costPart2 + costPart3 + costPart4

	return cost

end

local function calculateModelParameters(modelParameters, individualKernelMatrix, labelVector, cValue)

	local predictionVector = AqwamTensorLibrary:dotProduct(individualKernelMatrix, modelParameters) -- m x 1
	
	local errorVector = AqwamTensorLibrary:subtract(predictionVector, labelVector) -- m x 1
	
	local transposedIndividualKernelMatrix = AqwamTensorLibrary:transpose(individualKernelMatrix)
	
	local dotProductErrorVector = AqwamTensorLibrary:dotProduct(transposedIndividualKernelMatrix, errorVector) -- n x m, m x 1
	
	local NewModelParameters = AqwamTensorLibrary:multiply(-cValue, dotProductErrorVector)

	return NewModelParameters

end

function OneClassSupportVectorMachineModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewSupportVectorMachine = IterativeMethodBaseModel.new(parameterDictionary)

	setmetatable(NewSupportVectorMachine, OneClassSupportVectorMachineModel)
	
	NewSupportVectorMachine:setName("SupportVectorMachine")
	
	NewSupportVectorMachine.cValue = parameterDictionary.cValue or defaultCvalue
	
	NewSupportVectorMachine.beta = parameterDictionary.beta or defaultBeta

	NewSupportVectorMachine.kernelFunction = parameterDictionary.kernelFunction or defaultKernelFunction

	NewSupportVectorMachine.kernelParameters = {
		
		degree = parameterDictionary.degree or defaultDegree,
		
		gamma = parameterDictionary.gamma or defaultGamma,
		
		sigma = parameterDictionary.sigma or defaultSigma,
		
		r = parameterDictionary.r or defaultR
	
	}

	return NewSupportVectorMachine
end

function OneClassSupportVectorMachineModel:setCValue(cValue)

	self.cValue = cValue or self.cValue

end

function OneClassSupportVectorMachineModel:train(featureMatrix, labelVector)
	
	local numberOfData = #featureMatrix
	
	labelVector = labelVector or AqwamTensorLibrary:createTensor({numberOfData, 1}, 1)

	if (numberOfData ~= #labelVector) then

		error("The feature matrix and the label vector do not contain the same number of rows.")

	end
	
	local numberOfFeatures = #featureMatrix[1]
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (numberOfFeatures ~= #ModelParameters) then

			error("The number of features is not the same as the model parameters.")

		end

	else

		ModelParameters = self:initializeMatrixBasedOnMode({numberOfFeatures, 1})

	end

	local maximumNumberOfIterations = self.maximumNumberOfIterations

	local kernelFunction = self.kernelFunction

	local kernelParameters = self.kernelParameters
	
	local cValue = self.cValue
	
	local beta = self.beta
	
	local etaMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfFeatures}, 1)
	
	local zeroLabelVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 0)

	local mappedFeatureMatrix = mappingList[kernelFunction](featureMatrix, kernelParameters)

	local kernelMatrix = kernelFunctionList[kernelFunction](featureMatrix, kernelParameters)
	
	local nNormal = math.floor(beta * numberOfData)
	
	local numberOfIterations = 0

	local costArray = {}

	local cost
	
	local weightedKernelMatrix
	
	local predictedVector
	
	local slackVector
	
	local sortedIndexArray
	
	local isLessThanOrEqualToNormal
	
	local etaValueToSet
	
	local etaUnwrappedVector
	
	repeat
		
		numberOfIterations = numberOfIterations + 1

		self:iterationWait()
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()
			
			return calculateCost(ModelParameters, mappedFeatureMatrix, kernelMatrix, labelVector, cValue)
			
		end)

		if cost then
			
			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)
			
		end
		
		weightedKernelMatrix = AqwamTensorLibrary:multiply(mappedFeatureMatrix, etaMatrix)

		ModelParameters = calculateModelParameters(ModelParameters, weightedKernelMatrix, labelVector, cValue)
		
		predictedVector = AqwamTensorLibrary:dotProduct(mappedFeatureMatrix, ModelParameters)
		
		slackVector = AqwamTensorLibrary:subtract(labelVector, predictedVector)
		
		slackVector = AqwamTensorLibrary:applyFunction(math.max, zeroLabelVector, slackVector)
		
		sortedIndexArray = {}
		
		for i = 1, numberOfData, 1 do sortedIndexArray[i] = i end
		
		table.sort(sortedIndexArray, function(a, b) return slackVector[a][1] < slackVector[b][1] end)
		
		for i, sortedIndex in ipairs(sortedIndexArray) do
			
			isLessThanOrEqualToNormal = (i <= nNormal)
			
			etaValueToSet = (isLessThanOrEqualToNormal and 1) or 0
			
			etaUnwrappedVector = etaMatrix[sortedIndex]
			
			for j = 1, numberOfFeatures, 1 do
				
				etaUnwrappedVector[j] = etaValueToSet
				
			end
			
		end

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	self.ModelParameters = ModelParameters

	return costArray

end

function OneClassSupportVectorMachineModel:predict(featureMatrix, returnOriginalOutput)
	
	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

		self.ModelParameters = ModelParameters

	end

	local mappedFeatureMatrix = mappingList[self.kernelFunction](featureMatrix, self.kernelParameters)

	local originalPredictedVector = AqwamTensorLibrary:dotProduct(mappedFeatureMatrix, ModelParameters)

	if (returnOriginalOutput) then return originalPredictedVector end

	local predictedVector = AqwamTensorLibrary:applyFunction(seperatorFunction, originalPredictedVector)

	return predictedVector

end

return OneClassSupportVectorMachineModel]]></ProtectedString>
									<string name="ScriptGuid">{8F14371F-91DE-40E6-8E71-CFDCF0BE8EBD}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">OneClassSupportVectorMachine</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5C162671C83A4AE7A7BC0F0813707C8F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularExpectedStateActionRewardStateActionModel = {}

TabularExpectedStateActionRewardStateActionModel.__index = TabularExpectedStateActionRewardStateActionModel

setmetatable(TabularExpectedStateActionRewardStateActionModel, TabularReinforcementLearningBaseModel)

local defaultEpsilon = 0.5

function TabularExpectedStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularExpectedStateActionRewardStateActionModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewTabularExpectedStateActionRewardStateActionModel, TabularExpectedStateActionRewardStateActionModel)
	
	NewTabularExpectedStateActionRewardStateActionModel:setName("TabularExpectedStateActionRewardStateAction")
	
	NewTabularExpectedStateActionRewardStateActionModel.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	NewTabularExpectedStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace

	NewTabularExpectedStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local learningRate = NewTabularExpectedStateActionRewardStateActionModel.learningRate
		
		local discountFactor = NewTabularExpectedStateActionRewardStateActionModel.discountFactor
		
		local epsilon = NewTabularExpectedStateActionRewardStateActionModel.epsilon
		
		local EligibilityTrace = NewTabularExpectedStateActionRewardStateActionModel.EligibilityTrace
		
		local Optimizer = NewTabularExpectedStateActionRewardStateActionModel.Optimizer
		
		local ModelParameters = NewTabularExpectedStateActionRewardStateActionModel.ModelParameters
		
		local StatesList = NewTabularExpectedStateActionRewardStateActionModel:getStatesList()

		local ActionsList = NewTabularExpectedStateActionRewardStateActionModel:getActionsList()
		
		local numberOfActions = #ActionsList

		local expectedQValue = 0

		local numberOfGreedyActions = 0

		local actionIndex = table.find(ActionsList, action)
		
		local previousVector = NewTabularExpectedStateActionRewardStateActionModel:predict({{previousStateValue}}, true)
		
		local targetVector = NewTabularExpectedStateActionRewardStateActionModel:predict({{currentStateValue}}, true)
		
		local maxQValue = AqwamTensorLibrary:findMaximumValue(targetVector)
		
		local stateIndex = table.find(StatesList, previousStateValue)
		
		local actionIndex = table.find(ActionsList, action)

		local unwrappedTargetVector = targetVector[1]

		for i = 1, numberOfActions, 1 do

			if (unwrappedTargetVector[i] == maxQValue) then

				numberOfGreedyActions = numberOfGreedyActions + 1

			end

		end

		local nonGreedyActionProbability = epsilon / numberOfActions

		local greedyActionProbability = ((1 - epsilon) / numberOfGreedyActions) + nonGreedyActionProbability

		for _, qValue in ipairs(unwrappedTargetVector) do

			if (qValue == maxQValue) then

				expectedQValue = expectedQValue + (qValue * greedyActionProbability)

			else

				expectedQValue = expectedQValue + (qValue * nonGreedyActionProbability)

			end

		end
		
		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * expectedQValue)

		local lastValue = previousVector[1][actionIndex]

		local temporalDifferenceError = targetValue - lastValue
		
		if (EligibilityTrace) then
			
			local numberOfStates = #StatesList
			
			local dimensionSizeArray = {numberOfStates, numberOfActions}

			local temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)

			temporalDifferenceErrorMatrix[stateIndex][actionIndex] = temporalDifferenceError

			EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray)

			temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix)

			temporalDifferenceError = temporalDifferenceErrorMatrix[stateIndex][actionIndex]

		end
		
		local gradientValue = temporalDifferenceError

		if (Optimizer) then

			gradientValue = Optimizer:calculate(learningRate, {{gradientValue}})

			gradientValue = gradientValue[1][1]

		else

			gradientValue = learningRate * gradientValue

		end

		ModelParameters[stateIndex][actionIndex] = ModelParameters[stateIndex][actionIndex] + gradientValue
		
		return temporalDifferenceError

	end)
	
	NewTabularExpectedStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewTabularExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularExpectedStateActionRewardStateActionModel:setResetFunction(function() 
		
		local EligibilityTrace = NewTabularExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularExpectedStateActionRewardStateActionModel

end

return TabularExpectedStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{4648FF30-D23F-4ED4-A1B5-E113F15A1BB2}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularExpectedStateActionRewardStateAction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD63D8F2DF94F4A619767DA7C0C5CAE0B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularMonteCarloControlModel = {}

TabularMonteCarloControlModel.__index = TabularMonteCarloControlModel

setmetatable(TabularMonteCarloControlModel, TabularReinforcementLearningBaseModel)

local function calculateRewardToGo(rewardValueHistory, discountFactor)

	local rewardToGoArray = {}

	local discountedReward = 0

	for h = #rewardValueHistory, 1, -1 do

		discountedReward = rewardValueHistory[h] + (discountFactor * discountedReward)

		table.insert(rewardToGoArray, 1, discountedReward)

	end

	return rewardToGoArray

end

function TabularMonteCarloControlModel.new(parameterDictionary)

	local NewTabularMonteCarloControlModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularMonteCarloControlModel, TabularMonteCarloControlModel)
	
	NewTabularMonteCarloControlModel:setName("TabularMonteCarloControl")
	
	local stateValueHistory = {}
	
	local actionHistory = {}
	
	local rewardValueHistory = {}
	
	NewTabularMonteCarloControlModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		table.insert(stateValueHistory, previousStateValue)
		
		table.insert(actionHistory, action)
		
		table.insert(rewardValueHistory, rewardValue)

	end)
	
	NewTabularMonteCarloControlModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local learningRate = NewTabularMonteCarloControlModel.learningRate
		
		local Optimizer = NewTabularMonteCarloControlModel.Optimizer
		
		local ModelParameters = NewTabularMonteCarloControlModel.ModelParameters
		
		local StatesList = NewTabularMonteCarloControlModel:getStatesList()
		
		local ActionsList = NewTabularMonteCarloControlModel:getActionsList()
		
		local numberOfStates = #StatesList
		
		local numberOfActions = #ActionsList
		
		local dimensionSizeArray = {numberOfStates, numberOfActions}
		
		local returnMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)
		
		local countMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)
		
		local rewardToGoArray = calculateRewardToGo(rewardValueHistory, NewTabularMonteCarloControlModel.discountFactor)
		
		local learningRateComplement = 1 - learningRate
		
		for h, state in ipairs(stateValueHistory) do
			
			local action = actionHistory[h]
			
			local averageRewardToGo = rewardToGoArray[h]
			
			local stateIndex = table.find(StatesList, state)
			
			local actionIndex = table.find(ActionsList, action)
			
			returnMatrix[stateIndex][actionIndex] = returnMatrix[stateIndex][actionIndex] + averageRewardToGo
			
			countMatrix[stateIndex][actionIndex] = countMatrix[stateIndex][actionIndex] + 1
			
		end
		
		for stateIndex, unwrappedReturnsVector in ipairs(returnMatrix) do
			
			for actionIndex, returnValue in ipairs(unwrappedReturnsVector) do
				
				local count = countMatrix[stateIndex][actionIndex]

				if (count ~= 0) then
					
					local gradientValue = (returnValue / count)
					
					if (Optimizer) then
						
						gradientValue = Optimizer:calculate(learningRate, {{gradientValue}})
						
						gradientValue = gradientValue[1][1]
						
					else
						
						gradientValue = learningRate * gradientValue
						
					end

					ModelParameters[stateIndex][actionIndex] = (learningRateComplement * ModelParameters[stateIndex][actionIndex]) + gradientValue

				end
				
			end
			
		end
		
		table.clear(stateValueHistory)
		
		table.clear(actionHistory)
		
		table.clear(rewardValueHistory)
		
	end)
	
	NewTabularMonteCarloControlModel:setResetFunction(function()
		
		table.clear(stateValueHistory)
		
		table.clear(actionHistory)
		
		table.clear(rewardValueHistory)
		
	end)
	
	return NewTabularMonteCarloControlModel

end

return TabularMonteCarloControlModel]]></ProtectedString>
									<string name="ScriptGuid">{8CB60954-C4D6-4D97-846A-347BDE991864}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularMonteCarloControl</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX61934C7D2CEE40159682E5B6F6E63CA8">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularOffPolicyMonteCarloControlModel = {}

TabularOffPolicyMonteCarloControlModel.__index = TabularOffPolicyMonteCarloControlModel

setmetatable(TabularOffPolicyMonteCarloControlModel, TabularReinforcementLearningBaseModel)

local defaultTargetPolicyFunction = "StableSoftmax"

local targetPolicyFunctionList = {

	["Greedy"] = function (actionVector)

		local targetActionVector = AqwamTensorLibrary:createTensor({1, #actionVector[1]}, 0)

		local highestActionValue = -math.huge

		local indexWithHighestActionValue

		for i, actionValue in ipairs(actionVector[1]) do

			if (actionValue > highestActionValue) then

				highestActionValue = actionValue

				indexWithHighestActionValue = i

			end

		end

		targetActionVector[1][indexWithHighestActionValue] = highestActionValue

		return targetActionVector

	end,

	["Softmax"] = function (actionVector) -- Apparently Lua doesn't really handle very small values such as math.exp(-1000), so I added a more stable computation exp(a) / exp(b) -> exp (a - b).

		local exponentActionVector = AqwamTensorLibrary:applyFunction(math.exp, actionVector)

		local exponentActionSumVector = AqwamTensorLibrary:sum(exponentActionVector, 2)

		local targetActionVector = AqwamTensorLibrary:divide(exponentActionVector, exponentActionSumVector)

		return targetActionVector

	end,

	["StableSoftmax"] = function (actionVector)

		local highestActionValue = AqwamTensorLibrary:findMaximumValue(actionVector)

		local subtractedZVector = AqwamTensorLibrary:subtract(actionVector, highestActionValue)

		local exponentActionVector = AqwamTensorLibrary:applyFunction(math.exp, subtractedZVector)

		local exponentActionSumVector = AqwamTensorLibrary:sum(exponentActionVector, 2)

		local targetActionVector = AqwamTensorLibrary:divide(exponentActionVector, exponentActionSumVector)

		return targetActionVector

	end,

}

function TabularOffPolicyMonteCarloControlModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularOffPolicyMonteCarloControlModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewTabularOffPolicyMonteCarloControlModel, TabularOffPolicyMonteCarloControlModel)

	NewTabularOffPolicyMonteCarloControlModel:setName("TabularOffPolicyMonteCarloControl")

	NewTabularOffPolicyMonteCarloControlModel.targetPolicyFunction = parameterDictionary.targetPolicyFunction or defaultTargetPolicyFunction

	local stateValueHistory = {}

	local actionVectorHistory = {}

	local rewardValueHistory = {}

	NewTabularOffPolicyMonteCarloControlModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)

		local actionVector = NewTabularOffPolicyMonteCarloControlModel:predict({{previousStateValue}}, true)

		table.insert(stateValueHistory, previousStateValue)

		table.insert(actionVectorHistory, actionVector)

		table.insert(rewardValueHistory, rewardValue)

	end)

	NewTabularOffPolicyMonteCarloControlModel:setEpisodeUpdateFunction(function(terminalStateValue)

		local targetPolicyFunction = targetPolicyFunctionList[NewTabularOffPolicyMonteCarloControlModel.targetPolicyFunction]
		
		local learningRate = NewTabularOffPolicyMonteCarloControlModel.learningRate

		local discountFactor = NewTabularOffPolicyMonteCarloControlModel.discountFactor
		
		local Optimizer = NewTabularOffPolicyMonteCarloControlModel.Optimizer

		local ModelParameters = NewTabularOffPolicyMonteCarloControlModel.ModelParameters
		
		local StatesList = NewTabularOffPolicyMonteCarloControlModel:getStatesList()

		local ActionsList = NewTabularOffPolicyMonteCarloControlModel:getActionsList()

		local numberOfActions = #actionVectorHistory[1]

		local outputDimensionSizeArray = {1, numberOfActions}

		local cVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 0) 

		local weightVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 1)

		local discountedReward = 0
		
		for h = #actionVectorHistory, 1, -1 do

			discountedReward = rewardValueHistory[h] + (discountFactor * discountedReward)

			cVector = AqwamTensorLibrary:add(cVector, weightVector)

			local actionVector = actionVectorHistory[h]

			local lossVectorPart1 = AqwamTensorLibrary:divide(weightVector, cVector)

			local lossVectorPart2 = AqwamTensorLibrary:subtract(discountedReward, actionVector)

			local lossVector = AqwamTensorLibrary:multiply(lossVectorPart1, lossVectorPart2)

			local targetActionVector = targetPolicyFunction(actionVector)

			local actionRatioVector = AqwamTensorLibrary:divide(targetActionVector, actionVector)

			weightVector = AqwamTensorLibrary:multiply(weightVector, actionRatioVector)
			
			local stateIndex = table.find(StatesList, stateValueHistory[h])
			
			if (Optimizer) then

				lossVector = Optimizer:calculate(learningRate, lossVector)

			else

				lossVector = AqwamTensorLibrary:multiply(learningRate, lossVector)

			end
			
			ModelParameters[stateIndex] = AqwamTensorLibrary:add({ModelParameters[stateIndex]}, lossVector)[1]

		end

		table.clear(stateValueHistory)

		table.clear(actionVectorHistory)

		table.clear(rewardValueHistory)

	end)

	NewTabularOffPolicyMonteCarloControlModel:setResetFunction(function()

		table.clear(stateValueHistory)

		table.clear(actionVectorHistory)

		table.clear(rewardValueHistory)

	end)

	return NewTabularOffPolicyMonteCarloControlModel

end

return TabularOffPolicyMonteCarloControlModel]]></ProtectedString>
									<string name="ScriptGuid">{0D010787-C102-4604-90C4-3B8695992D84}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularOffPolicyMonteCarloControl</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX74FF2B1B4B2045148333088FDF2BA19C">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularStateActionRewardStateActionModel = {}

TabularStateActionRewardStateActionModel.__index = TabularStateActionRewardStateActionModel

setmetatable(TabularStateActionRewardStateActionModel, TabularReinforcementLearningBaseModel)

function TabularStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularStateActionRewardStateActionModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularStateActionRewardStateActionModel, TabularStateActionRewardStateActionModel)
	
	NewTabularStateActionRewardStateActionModel:setName("TabularStateActionRewardStateAction")
	
	NewTabularStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewTabularStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local learningRate = NewTabularStateActionRewardStateActionModel.learningRate
		
		local discountFactor = NewTabularStateActionRewardStateActionModel.discountFactor
		
		local EligibilityTrace = NewTabularStateActionRewardStateActionModel.EligibilityTrace
		
		local Optimizer = NewTabularStateActionRewardStateActionModel.Optimizer
		
		local ModelParameters = NewTabularStateActionRewardStateActionModel.ModelParameters
		
		local StatesList = NewTabularStateActionRewardStateActionModel:getStatesList()
		
		local previousQVector = NewTabularStateActionRewardStateActionModel:predict({{previousStateValue}}, true)

		local currentQVector = NewTabularStateActionRewardStateActionModel:predict({{currentStateValue}}, true)

		local discountedQVector = AqwamTensorLibrary:multiply(discountFactor, currentQVector, (1 - terminalStateValue))

		local targetVector = AqwamTensorLibrary:add(rewardValue, discountedQVector)
		
		local stateIndex = table.find(StatesList, previousStateValue)

		local temporalDifferenceErrorVector = AqwamTensorLibrary:subtract(targetVector, previousQVector)
		
		if (EligibilityTrace) then
			
			local ActionsList = NewTabularStateActionRewardStateActionModel:getActionsList()

			local numberOfStates = #StatesList
			
			local numberOfActions = #ActionsList
			
			local actionIndex = table.find(ActionsList, action)

			local dimensionSizeArray = {numberOfStates, numberOfActions}

			local temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)

			temporalDifferenceErrorMatrix[stateIndex] = temporalDifferenceErrorVector[1]

			EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray)

			temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix)

			temporalDifferenceErrorVector = {temporalDifferenceErrorMatrix[stateIndex]}

		end
		
		local gradientTensor = temporalDifferenceErrorVector
		
		if (Optimizer) then

			gradientTensor = Optimizer:calculate(learningRate, gradientTensor)

		else

			gradientTensor = AqwamTensorLibrary:multiply(learningRate, gradientTensor)

		end
		
		ModelParameters[stateIndex] = AqwamTensorLibrary:add({ModelParameters[stateIndex]}, gradientTensor)[1]
		
		return temporalDifferenceErrorVector

	end)
	
	NewTabularStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewTabularStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularStateActionRewardStateActionModel:setResetFunction(function()
		
		local EligibilityTrace = NewTabularStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularStateActionRewardStateActionModel

end

return TabularStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{8FD61447-4EB3-4105-91BD-52B832D2040A}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularStateActionRewardStateAction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDCCBE6A83C1745C3A5A946C9C61D0310">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularQLearningModel = {}

TabularQLearningModel.__index = TabularQLearningModel

setmetatable(TabularQLearningModel, TabularReinforcementLearningBaseModel)

function TabularQLearningModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularQLearningModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularQLearningModel, TabularQLearningModel)
	
	NewTabularQLearningModel:setName("TabularQLearning")
	
	NewTabularQLearningModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewTabularQLearningModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local learningRate = NewTabularQLearningModel.learningRate
		
		local discountFactor = NewTabularQLearningModel.discountFactor
		
		local EligibilityTrace = NewTabularQLearningModel.EligibilityTrace
		
		local Optimizer = NewTabularQLearningModel.Optimizer

		local ModelParameters = NewTabularQLearningModel.ModelParameters
		
		local StatesList = NewTabularQLearningModel:getStatesList()

		local ActionsList = NewTabularQLearningModel:getActionsList()

		local _, maxQValue = NewTabularQLearningModel:predict({{currentStateValue}})

		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * maxQValue[1][1])
		
		local stateIndex = table.find(StatesList, previousStateValue)

		local actionIndex = table.find(ActionsList, action)

		local lastValue = ModelParameters[stateIndex][actionIndex]

		local temporalDifferenceError = targetValue - lastValue
		
		if (EligibilityTrace) then
			
			local numberOfStates = #StatesList

			local numberOfActions = #ActionsList
			
			local dimensionSizeArray = {numberOfStates, numberOfActions}
			
			local temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)
			
			temporalDifferenceErrorMatrix[stateIndex][actionIndex] = temporalDifferenceError

			EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray)

			temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix)
			
			temporalDifferenceError = temporalDifferenceErrorMatrix[stateIndex][actionIndex]

		end
		
		local gradientValue = temporalDifferenceError
		
		if (Optimizer) then
			
			gradientValue = Optimizer:calculate(learningRate, {{gradientValue}})
			
			gradientValue = gradientValue[1][1]
			
		else
			
			gradientValue = learningRate * gradientValue
			
		end
		
		ModelParameters[stateIndex][actionIndex] = ModelParameters[stateIndex][actionIndex] + gradientValue
		
		return temporalDifferenceError

	end)
	
	NewTabularQLearningModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewTabularQLearningModel.EligibilityTrace
		
		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularQLearningModel:setResetFunction(function()
		
		local EligibilityTrace = NewTabularQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularQLearningModel

end

return TabularQLearningModel]]></ProtectedString>
									<string name="ScriptGuid">{CA764926-7A94-48E9-9F4D-7AAF9ECBC9BA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularQLearning</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6F6BD27B41C5421BA48A7845C23015EC">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseModel = require(script.Parent.BaseModel)

TabularReinforcementLearningBaseModel = {}

TabularReinforcementLearningBaseModel.__index = TabularReinforcementLearningBaseModel

setmetatable(TabularReinforcementLearningBaseModel, BaseModel)

local defaultLearningRate = 0.1

local defaultDiscountFactor = 0.95

function TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewTabularReinforcementLearningBaseModel = BaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularReinforcementLearningBaseModel, TabularReinforcementLearningBaseModel)
	
	NewTabularReinforcementLearningBaseModel:setName("TabularReinforcementLearningBaseModel")

	NewTabularReinforcementLearningBaseModel:setClassName("TabularReinforcementLearningModel")
	
	NewTabularReinforcementLearningBaseModel.learningRate = parameterDictionary.learningRate or defaultLearningRate

	NewTabularReinforcementLearningBaseModel.discountFactor = parameterDictionary.discountFactor or defaultDiscountFactor
	
	NewTabularReinforcementLearningBaseModel.Optimizer = parameterDictionary.Optimizer
	
	NewTabularReinforcementLearningBaseModel.StatesList = parameterDictionary.StatesList or {}
	
	NewTabularReinforcementLearningBaseModel.ActionsList = parameterDictionary.ActionsList or {}
	
	NewTabularReinforcementLearningBaseModel.ModelParameters = parameterDictionary.ModelParameters
	
	return NewTabularReinforcementLearningBaseModel
	
end

function TabularReinforcementLearningBaseModel:setLearningRate(learningRate)

	self.learningRate = learningRate

end

function TabularReinforcementLearningBaseModel:getLearningRate()

	return self.learningRate

end

function TabularReinforcementLearningBaseModel:setDiscountFactor(discountFactor)
	
	self.discountFactor = discountFactor
	
end

function TabularReinforcementLearningBaseModel:getDiscountFactor()
	
	return self.discountFactor
	
end

function TabularReinforcementLearningBaseModel:setOptimizer(Optimizer)

	self.Optimizer = Optimizer

end

function TabularReinforcementLearningBaseModel:getOptimizer()

	return self.Optimizer

end

function TabularReinforcementLearningBaseModel:predict(stateVector, returnOriginalOutput)
	
	local StatesList = self.StatesList
	
	local ActionsList = self.ActionsList
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then
		
		ModelParameters = self:initializeMatrixBasedOnMode({#StatesList, #ActionsList})
		
		self.ModelParameters = ModelParameters
		
	end
	
	local resultTensor = {}
	
	for i, wrappedState in ipairs(stateVector) do
		
		local state = wrappedState[1]
		
		local stateIndex = table.find(StatesList, state)
		
		if (not stateIndex) then error("State \"" .. state ..  "\" does not exist in the states list.") end
		
		resultTensor[i] = ModelParameters[stateIndex]
		
	end
	
	if (returnOriginalOutput) then return resultTensor end
	
	local outputVector = {}
	
	local maximumValueVector = {}
	
	for i, resultVector in ipairs(resultTensor) do
		
		local maximumValue = math.max(table.unpack(resultVector))
		
		local actionIndex = table.find(resultVector, maximumValue)
		
		local action = ActionsList[actionIndex] 
		
		if (not action) then error("Action for action index " .. actionIndex ..  "  does not exist in the actions list.") end
		
		outputVector[i] = {action}
		
		maximumValueVector[i] = {maximumValue}
		
	end

	return outputVector, maximumValueVector

end

function TabularReinforcementLearningBaseModel:setStatesList(StatesList)
	
	self.StatesList = StatesList
	
end

function TabularReinforcementLearningBaseModel:getStatesList()
	
	return self.StatesList
	
end

function TabularReinforcementLearningBaseModel:setActionsList(ActionsList)
	
	self.ActionsList = ActionsList
	
end

function TabularReinforcementLearningBaseModel:getActionsList()
	
	return self.ActionsList
	
end

function TabularReinforcementLearningBaseModel:setCategoricalUpdateFunction(categoricalUpdateFunction)

	self.categoricalUpdateFunction = categoricalUpdateFunction

end

function TabularReinforcementLearningBaseModel:categoricalUpdate(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)

	if (not self.ModelParameters) then self.ModelParameters = self:initializeMatrixBasedOnMode({#self.StatesList, #self.ActionsList}) end
	
	self.categoricalUpdateFunction(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)

end

function TabularReinforcementLearningBaseModel:setEpisodeUpdateFunction(episodeUpdateFunction)

	self.episodeUpdateFunction = episodeUpdateFunction

end

function TabularReinforcementLearningBaseModel:episodeUpdate(terminalStateValue)
	
	if (not self.ModelParameters) then self.ModelParameters = self:initializeMatrixBasedOnMode({#self.StatesList, #self.ActionsList}) end

	return self.episodeUpdateFunction(terminalStateValue)

end

function TabularReinforcementLearningBaseModel:setResetFunction(resetFunction)

	self.resetFunction = resetFunction

end

function TabularReinforcementLearningBaseModel:reset()
	
	self.resetFunction()

end

return TabularReinforcementLearningBaseModel]]></ProtectedString>
									<string name="ScriptGuid">{01033DCA-F58F-4D1E-8F8E-37946375CCDB}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularReinforcementLearningBaseModel</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3813B6BA6AC94E8295E7A9CC2562473D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

KNearestNeighboursRegressorModel = {}

KNearestNeighboursRegressorModel.__index = KNearestNeighboursRegressorModel

setmetatable(KNearestNeighboursRegressorModel, BaseModel)

local defaultKValue = 3

local defaultDistanceFunction = "Euclidean"

local defaultUseWeightedDistance = false

local defaultMaximumNumberOfData = math.huge

local function createDistanceMatrix(distanceFunction, featureMatrix, storedFeatureMatrix)

	local numberOfData = #featureMatrix

	local numberOfStoredData = #storedFeatureMatrix

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfStoredData}, 0)

	local calculateDistance = distanceFunctionDictionary[distanceFunction]

	for datasetIndex = 1, numberOfData, 1 do

		for storedDatasetIndex = 1, numberOfStoredData, 1 do

			distanceMatrix[datasetIndex][storedDatasetIndex] = calculateDistance({featureMatrix[datasetIndex]}, {storedFeatureMatrix[storedDatasetIndex]})

		end

	end

	return distanceMatrix

end

local function deepCopyTable(original, copies)

	copies = copies or {}

	local originalType = type(original)

	local copy

	if (originalType == 'table') then

		if copies[original] then

			copy = copies[original]

		else

			copy = {}

			copies[original] = copy

			for originalKey, originalValue in next, original, nil do

				copy[deepCopyTable(originalKey, copies)] = deepCopyTable(originalValue, copies)

			end

			setmetatable(copy, deepCopyTable(getmetatable(original), copies))

		end

	else -- number, string, boolean, etc

		copy = original

	end

	return copy

end

local function merge(distanceVector, labelVector, left, mid, right)

	local subArrayOne = mid - left + 1
	local subArrayTwo = right - mid

	local leftDistanceVector = {}
	local rightDistanceVector = {}

	local leftLabelVector = {}
	local rightLabelVector = {}

	for i = 1, subArrayOne do

		leftDistanceVector[i] = distanceVector[1][left + i - 1]
		leftLabelVector[i] = labelVector[left + i - 1][1]

	end

	for j = 1, subArrayTwo do

		rightDistanceVector[j] = distanceVector[1][mid + j]
		rightLabelVector[j] = labelVector[mid + j][1]

	end

	local indexOfSubArrayOne = 1
	local indexOfSubArrayTwo = 1
	local indexOfMergedArray = left

	while indexOfSubArrayOne <= subArrayOne and indexOfSubArrayTwo <= subArrayTwo do

		if leftDistanceVector[indexOfSubArrayOne] <= rightDistanceVector[indexOfSubArrayTwo] then

			distanceVector[1][indexOfMergedArray] = leftDistanceVector[indexOfSubArrayOne]
			labelVector[indexOfMergedArray][1] = leftLabelVector[indexOfSubArrayOne]
			indexOfSubArrayOne = indexOfSubArrayOne + 1

		else

			distanceVector[1][indexOfMergedArray] = rightDistanceVector[indexOfSubArrayTwo]
			labelVector[indexOfMergedArray][1] = rightLabelVector[indexOfSubArrayTwo]
			indexOfSubArrayTwo = indexOfSubArrayTwo + 1

		end

		indexOfMergedArray = indexOfMergedArray + 1

	end

	while (indexOfSubArrayOne <= subArrayOne) do

		distanceVector[1][indexOfMergedArray] = leftDistanceVector[indexOfSubArrayOne]
		labelVector[indexOfMergedArray][1] = leftLabelVector[indexOfSubArrayOne]
		indexOfSubArrayOne = indexOfSubArrayOne + 1
		indexOfMergedArray = indexOfMergedArray + 1

	end

	while (indexOfSubArrayTwo <= subArrayTwo) do

		distanceVector[1][indexOfMergedArray] = rightDistanceVector[indexOfSubArrayTwo]
		labelVector[indexOfMergedArray][1] = rightLabelVector[indexOfSubArrayTwo]
		indexOfSubArrayTwo = indexOfSubArrayTwo + 1
		indexOfMergedArray = indexOfMergedArray + 1

	end

end

local function mergeSort(distanceVector, labelVector, startingValue, endValue)

	if (startingValue >= endValue) then return end

	local mid = math.floor(startingValue + (endValue - startingValue) / 2)

	mergeSort(distanceVector, labelVector, startingValue, mid)
	mergeSort(distanceVector, labelVector, mid + 1, endValue)
	merge(distanceVector, labelVector, startingValue, mid, endValue)

end

local function getAverageValue(sortedLabelVectorLowestToHighest, distanceVector, kValue, useWeightedDistance)

	local sum = 0

	local totalWeight = 0

	local minimumNumberOfkValue = math.min(#sortedLabelVectorLowestToHighest, kValue)

	for k = 1, minimumNumberOfkValue, 1 do

		local label = sortedLabelVectorLowestToHighest[k][1]

		local distance = distanceVector[1][k]

		local weight

		if (useWeightedDistance) then

			weight = ((distance == 0) and math.huge) or (1 / distance)

		else

			weight = 1

		end

		sum = sum + (label * weight)
		
		totalWeight = totalWeight + weight

	end

	local averageValue = sum / totalWeight

	return averageValue

end

function KNearestNeighboursRegressorModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewKNearestNeighboursRegressorModel = BaseModel.new(parameterDictionary)

	setmetatable(NewKNearestNeighboursRegressorModel, KNearestNeighboursRegressorModel)
	
	NewKNearestNeighboursRegressorModel:setName("KNearestNeighboursRegressor")

	NewKNearestNeighboursRegressorModel.kValue = parameterDictionary.kValue or defaultKValue

	NewKNearestNeighboursRegressorModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction

	NewKNearestNeighboursRegressorModel.useWeightedDistance = NewKNearestNeighboursRegressorModel:getValueOrDefaultValue(parameterDictionary.useWeightedDistance, defaultUseWeightedDistance)
	
	NewKNearestNeighboursRegressorModel.maximumNumberOfData = parameterDictionary.maximumNumberOfData or defaultMaximumNumberOfData
	
	return NewKNearestNeighboursRegressorModel

end

function KNearestNeighboursRegressorModel:train(featureMatrix, labelVector)

	local numberOfData = #featureMatrix

	if (numberOfData ~= #labelVector) then error("The number of data in feature matrix and the label vector are not the same.") end

	local maximumNumberOfData = self.maximumNumberOfData

	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		local storedFeatureMatrix = ModelParameters[1]

		local storedLabelVector = ModelParameters[2]

		featureMatrix = AqwamTensorLibrary:concatenate(featureMatrix, storedFeatureMatrix, 1)

		labelVector = AqwamTensorLibrary:concatenate(labelVector, storedLabelVector, 1)

		numberOfData = #featureMatrix

		if (numberOfData > maximumNumberOfData) then

			local newFeatureMatrix = {}

			local newLabelVector = {}

			local dataShiftIndex = (numberOfData - maximumNumberOfData)

			for dataIndex = 1, maximumNumberOfData, 1 do

				newFeatureMatrix[dataIndex] = featureMatrix[dataIndex + dataShiftIndex]

				newLabelVector[dataIndex] = labelVector[dataIndex + dataShiftIndex]

			end

			featureMatrix = newFeatureMatrix

			labelVector = newLabelVector

			numberOfData = maximumNumberOfData

		end

	end

	if (numberOfData < self.kValue) and (self.isOutputPrinted) then warn("Number of data is less than the K value. Please add more data before doing any predictions.") end

	self.ModelParameters = {featureMatrix, labelVector}

end

function KNearestNeighboursRegressorModel:predict(featureMatrix, returnOriginalOutput)
	
	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then return AqwamTensorLibrary:createTensor({#featureMatrix, 1}, math.huge) end

	local storedFeatureMatrix = ModelParameters[1]

	local storedLabelVector = ModelParameters[2]

	local kValue = self.kValue

	local distanceFunction = self.distanceFunction

	local useWeightedDistance = self.useWeightedDistance

	local distanceMatrix = createDistanceMatrix(distanceFunction, featureMatrix, storedFeatureMatrix)

	if (returnOriginalOutput) then return distanceMatrix end
	
	local numberOfOtherData = #storedFeatureMatrix

	local predictedLabelVector = {}

	for i, unwrappedDistanceVector in ipairs(distanceMatrix) do

		local sortedDistanceVector = {deepCopyTable(unwrappedDistanceVector)}

		local sortedLabelVectorLowestToHighest = deepCopyTable(storedLabelVector)

		mergeSort(sortedDistanceVector, sortedLabelVectorLowestToHighest, 1, numberOfOtherData)

		local averageValue = getAverageValue(sortedLabelVectorLowestToHighest, sortedDistanceVector, kValue, useWeightedDistance)

		predictedLabelVector[i] = {averageValue}

	end

	return predictedLabelVector

end

return KNearestNeighboursRegressorModel]]></ProtectedString>
									<string name="ScriptGuid">{E6854A10-9FF0-4D49-B22A-08A3095CF350}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">KNearestNeighboursRegressor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE9A4E4CB2F3043E0B141BF9C2E8CA310">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

SupportVectorRegressionModel = {}

SupportVectorRegressionModel.__index = SupportVectorRegressionModel

setmetatable(SupportVectorRegressionModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultCvalue = 1

local defaultEpsilon = 1

local defaultKernelFunction = "Linear"

local defaultGamma = 1

local defaultDegree = 3

local defaultSigma = 1

local defaultR = 0

local seperatorFunction = function (x) 

	return ((x > 0) and 1) or ((x < 0) and -1) or 0

end

local function createDistanceMatrix(distanceFunction, matrix1, matrix2)

	local numberOfData1 = #matrix1

	local numberOfData2 = #matrix2

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData1, numberOfData2})

	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]

	for i = 1, numberOfData1, 1 do

		for j = 1, numberOfData2, 1 do

			distanceMatrix[i][j] = distanceFunctionToApply({matrix1[i]}, {matrix2[j]})

		end

	end

	return distanceMatrix

end

local mappingList = {

	["Linear"] = function(featureMatrix)

		return featureMatrix

	end,

	["Polynomial"] = function(featureMatrix, kernelParameters)

		local degree = kernelParameters.degree

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local scaledFeatureMatrix = AqwamTensorLibrary:multiply(featureMatrix, gamma)

		local addedFeatureMatrix = AqwamTensorLibrary:add(scaledFeatureMatrix, r)

		return AqwamTensorLibrary:power(addedFeatureMatrix, degree)

	end,

	["RadialBasisFunction"] = function(featureMatrix, kernelParameters)

		local sigma = kernelParameters.sigma

		local squaredFeatureMatrix = AqwamTensorLibrary:power(featureMatrix, 2)

		local squaredSigmaVector = AqwamTensorLibrary:power(sigma, 2)

		local multipliedSquaredSigmaVector = AqwamTensorLibrary:multiply(-2, squaredSigmaVector)

		local zMatrix = AqwamTensorLibrary:divide(squaredFeatureMatrix, multipliedSquaredSigmaVector)

		return AqwamTensorLibrary:applyFunction(math.exp, zMatrix)

	end,

	["Sigmoid"] = function(featureMatrix, kernelParameters)

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local kernelMappingMatrixPart1 = AqwamTensorLibrary:multiply(gamma, featureMatrix)

		local kernelMappingMatrixPart2 = AqwamTensorLibrary:add(kernelMappingMatrixPart1, r)

		local kernelMappingMatrix = AqwamTensorLibrary:applyFunction(math.tanh, kernelMappingMatrixPart2)

		return kernelMappingMatrix

	end,

	["Cosine"] = function(featureMatrix, kernelParameters)

		local zeroMatrix = AqwamTensorLibrary:createTensor({1, #featureMatrix[1]}, 0)

		local distanceMatrix = createDistanceMatrix("Euclidean", featureMatrix, zeroMatrix)

		local kernelMappingMatrix = AqwamTensorLibrary:divide(featureMatrix, distanceMatrix)

		return kernelMappingMatrix

	end,

}

local kernelFunctionList = {

	["Linear"] = function(featureMatrix)

		local kernelMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, AqwamTensorLibrary:transpose(featureMatrix))

		return kernelMatrix

	end,

	["Polynomial"] = function(featureMatrix, kernelParameters)

		local degree = kernelParameters.degree

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local dotProductedFeatureMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, AqwamTensorLibrary:transpose(featureMatrix))

		local scaledDotProductedFeatureMatrix = AqwamTensorLibrary:multiply(dotProductedFeatureMatrix, gamma)

		local addedFeatureMatrix = AqwamTensorLibrary:add(scaledDotProductedFeatureMatrix, r)

		local kernelMatrix = AqwamTensorLibrary:power(addedFeatureMatrix, degree)

		return kernelMatrix

	end,

	["RadialBasisFunction"] = function(featureMatrix, kernelParameters)

		local sigma = kernelParameters.sigma

		local distanceMatrix = createDistanceMatrix("Euclidean", featureMatrix, featureMatrix)

		local squaredDistanceMatrix = AqwamTensorLibrary:power(distanceMatrix, 2)

		local sigmaSquaredVector = AqwamTensorLibrary:power(sigma, 2)

		local multipliedSigmaSquaredVector = AqwamTensorLibrary:multiply(-2, sigmaSquaredVector)

		local zMatrix = AqwamTensorLibrary:divide(squaredDistanceMatrix, multipliedSigmaSquaredVector)

		local kernelMatrix = AqwamTensorLibrary:applyFunction(math.exp, zMatrix)

		return kernelMatrix

	end,

	["Sigmoid"] = function(featureMatrix, kernelParameters)

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local dotProductedFeatureMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, AqwamTensorLibrary:transpose(featureMatrix))

		local kernelMatrixPart1 = AqwamTensorLibrary:multiply(gamma, dotProductedFeatureMatrix)

		local kernelMatrixPart2 = AqwamTensorLibrary:add(kernelMatrixPart1, r)

		local kernelMatrix = AqwamTensorLibrary:applyFunction(math.tanh, kernelMatrixPart2)

		return kernelMatrix

	end,

	["Cosine"] = function(featureMatrix, kernelParameters)

		local zeroMatrix = AqwamTensorLibrary:createTensor({1, #featureMatrix[1]}, 0)

		local distanceMatrix = createDistanceMatrix("Euclidean", featureMatrix, zeroMatrix)

		local kernelMappingMatrix = AqwamTensorLibrary:divide(featureMatrix, distanceMatrix)

		local kernelMatrix = AqwamTensorLibrary:dotProduct(kernelMappingMatrix, AqwamTensorLibrary:transpose(kernelMappingMatrix))

		return kernelMatrix

	end,

}

local function calculateCost(modelParameters, individualKernelMatrix, kernelMatrix, labelVector, cValue, epsilon)

	-- The dotProduct() only takes two arguments here to reduce computational time

	local predictedVector = AqwamTensorLibrary:dotProduct(individualKernelMatrix, modelParameters)

	local errorVector = AqwamTensorLibrary:subtract(predictedVector, labelVector)
	
	local positiveSlackVariableVector = AqwamTensorLibrary:applyFunction(function(errorValue) return math.max(0, errorValue - epsilon) end, errorVector)

	local negativeSlackVariableVector = AqwamTensorLibrary:applyFunction(function(errorValue) return math.max(0, -errorValue - epsilon) end, errorVector)

	local costVector = AqwamTensorLibrary:add(positiveSlackVariableVector, negativeSlackVariableVector)

	costVector = AqwamTensorLibrary:multiply(-cValue, costVector)

	local transposedCostVector = AqwamTensorLibrary:transpose(costVector)

	local transposedLabelVector = AqwamTensorLibrary:transpose(labelVector)

	local costPart1 = AqwamTensorLibrary:dotProduct(transposedCostVector, kernelMatrix)

	costPart1 = AqwamTensorLibrary:dotProduct(costPart1, kernelMatrix)

	costPart1 = AqwamTensorLibrary:dotProduct(costPart1, costVector)[1][1]

	costPart1 = costPart1 / 2

	local costPart2 = AqwamTensorLibrary:dotProduct(transposedCostVector, kernelMatrix)

	costPart2 = AqwamTensorLibrary:dotProduct(costPart2, labelVector)[1][1]

	local costPart3 = AqwamTensorLibrary:dotProduct(transposedLabelVector, labelVector)[1][1]

	costPart3 = costPart3 / 2

	local costPart4 = AqwamTensorLibrary:dotProduct(transposedCostVector, kernelMatrix)

	costPart4 = AqwamTensorLibrary:dotProduct(costPart4, costVector)[1][1]

	costPart4 = costPart4 / (2 * cValue)

	local cost = costPart1 - costPart2 + costPart3 + costPart4

	return cost

end

local function calculateModelParameters(modelParameters, individualKernelMatrix, labelVector, cValue, epsilon)

	local predictionVector = AqwamTensorLibrary:dotProduct(individualKernelMatrix, modelParameters) -- m x 1

	local errorVector = AqwamTensorLibrary:subtract(predictionVector, labelVector) -- m x 1
	
	local positiveSlackVariableVector = AqwamTensorLibrary:applyFunction(function(errorValue) return math.max(0, errorValue - epsilon) end, errorVector)

	local negativeSlackVariableVector = AqwamTensorLibrary:applyFunction(function(errorValue) return math.max(0, -errorValue - epsilon) end, errorVector)
	
	local slackVariableVector = AqwamTensorLibrary:add(positiveSlackVariableVector, negativeSlackVariableVector)
	
	local transposedIndividualKernelMatrix = AqwamTensorLibrary:transpose(individualKernelMatrix)

	local dotProductErrorVector = AqwamTensorLibrary:dotProduct(transposedIndividualKernelMatrix, slackVariableVector) -- n x m, m x 1

	local NewModelParameters = AqwamTensorLibrary:multiply(-cValue, dotProductErrorVector)

	return NewModelParameters

end

function SupportVectorRegressionModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewSupportVectorRegression = IterativeMethodBaseModel.new(parameterDictionary)

	setmetatable(NewSupportVectorRegression, SupportVectorRegressionModel)

	NewSupportVectorRegression:setName("SupportVectorRegression")

	NewSupportVectorRegression.cValue = parameterDictionary.cValue or defaultCvalue
	
	NewSupportVectorRegression.epsilon = parameterDictionary.epsilon or defaultEpsilon

	NewSupportVectorRegression.kernelFunction = parameterDictionary.kernelFunction or defaultKernelFunction

	NewSupportVectorRegression.kernelParameters = {

		degree = parameterDictionary.degree or defaultDegree,

		gamma = parameterDictionary.gamma or defaultGamma,

		sigma = parameterDictionary.sigma or defaultSigma,

		r = parameterDictionary.r or defaultR

	}

	return NewSupportVectorRegression
end

function SupportVectorRegressionModel:setCValue(cValue)

	self.cValue = cValue or self.cValue

end

function SupportVectorRegressionModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector do not contain the same number of rows.") end

	local numberOfFeatures = #featureMatrix[1]

	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (numberOfFeatures ~= #ModelParameters) then error("The number of features is not the same as the model parameters.") end

	else

		ModelParameters = self:initializeMatrixBasedOnMode({numberOfFeatures, 1})

	end

	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local cValue = self.cValue
	
	local epsilon = self.epsilon
	
	local kernelFunction = self.kernelFunction
	
	local kernelParameters = self.kernelParameters
	
	local ModelParameters = self.ModelParameters

	local mappedFeatureMatrix = mappingList[kernelFunction](featureMatrix, kernelParameters)

	local kernelMatrix = kernelFunctionList[kernelFunction](featureMatrix, kernelParameters)

	local costArray = {}

	local numberOfIterations = 0
	
	local cost

	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return calculateCost(ModelParameters, mappedFeatureMatrix, kernelMatrix, labelVector, cValue, epsilon)

		end)

		if cost then

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end

		ModelParameters = calculateModelParameters(ModelParameters, mappedFeatureMatrix, labelVector, cValue, epsilon)

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	self.ModelParameters = ModelParameters

	return costArray

end

function SupportVectorRegressionModel:predict(featureMatrix)
	
	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

		self.ModelParameters = ModelParameters

	end

	local mappedFeatureMatrix = mappingList[self.kernelFunction](featureMatrix, self.kernelParameters)

	local predictedVector = AqwamTensorLibrary:dotProduct(mappedFeatureMatrix, ModelParameters)

	return predictedVector

end

return SupportVectorRegressionModel]]></ProtectedString>
									<string name="ScriptGuid">{C2CFFDE4-9EBE-4BA0-A83C-420B9B7466A4}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">SupportVectorRegression</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX06896DE3F11745D4A84A3BA63A3DD7D7">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GradientMethodBaseModel = require(script.Parent.GradientMethodBaseModel)

PoissonLinearRegressionModel = {}

PoissonLinearRegressionModel.__index = PoissonLinearRegressionModel

setmetatable(PoissonLinearRegressionModel, GradientMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultLearningRate = 0.3

local defaultEpsilon = 1e-16

function PoissonLinearRegressionModel:calculateCost(hypothesisVector, labelVector)

	if (type(hypothesisVector) == "number") then hypothesisVector = {{hypothesisVector}} end
	
	hypothesisVector = AqwamTensorLibrary:add(hypothesisVector, self.epsilon)

	local logPredictedCountVector = AqwamTensorLibrary:applyFunction(math.log, hypothesisVector)
	
	local observedTimesLogPredictedVector = AqwamTensorLibrary:multiply(labelVector, logPredictedCountVector)
	
	local costVector = AqwamTensorLibrary:subtract(hypothesisVector, observedTimesLogPredictedVector)

	local totalCost = AqwamTensorLibrary:sum(costVector)
	
	local Regularizer = self.Regularizer

	if (Regularizer) then totalCost = totalCost + Regularizer:calculateCost(self.ModelParameters) end

	local averageCost = totalCost / #labelVector

	return averageCost

end

function PoissonLinearRegressionModel:calculateHypothesisVector(featureMatrix, saveFeatureMatrix)
	
	local exponentTermVector = AqwamTensorLibrary:dotProduct(featureMatrix, self.ModelParameters)

	local hypothesisVector = AqwamTensorLibrary:applyFunction(math.exp, exponentTermVector)

	if (saveFeatureMatrix) then self.featureMatrix = featureMatrix end

	return hypothesisVector

end

function PoissonLinearRegressionModel:calculateCostFunctionDerivativeMatrix(lossMatrix)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local featureMatrix = self.featureMatrix

	if (not featureMatrix) then error("Feature matrix not found.") end

	local costFunctionDerivativeMatrix = AqwamTensorLibrary:dotProduct(AqwamTensorLibrary:transpose(featureMatrix), lossMatrix)

	if (self.areGradientsSaved) then self.costFunctionDerivativeMatrix = costFunctionDerivativeMatrix end

	return costFunctionDerivativeMatrix

end

function PoissonLinearRegressionModel:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (type(costFunctionDerivativeMatrix) == "number") then costFunctionDerivativeMatrix = {{costFunctionDerivativeMatrix}} end
	
	local ModelParameters = self.ModelParameters
	
	local Regularizer = self.Regularizer
	
	local Optimizer = self.Optimizer
	
	local learningRate = self.learningRate

	if (Regularizer) then

		local regularizationDerivatives = Regularizer:calculate(ModelParameters)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:add(costFunctionDerivativeMatrix, regularizationDerivatives)

	end

	costFunctionDerivativeMatrix = AqwamTensorLibrary:divide(costFunctionDerivativeMatrix, numberOfData)

	if (Optimizer) then 

		costFunctionDerivativeMatrix = Optimizer:calculate(learningRate, costFunctionDerivativeMatrix, ModelParameters) 

	else

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrix)

	end

	self.ModelParameters = AqwamTensorLibrary:subtract(ModelParameters, costFunctionDerivativeMatrix)

end

function PoissonLinearRegressionModel:update(lossMatrix, clearAllMatrices)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local numberOfData = #lossMatrix

	local costFunctionDerivativeMatrix = self:calculateCostFunctionDerivativeMatrix(lossMatrix)

	self:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (clearAllMatrices) then 

		self.featureMatrix = nil 

		self.costFunctionDerivativeMatrix = nil

	end

end

function PoissonLinearRegressionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewPoissonLinearRegressionModel = GradientMethodBaseModel.new(parameterDictionary)

	setmetatable(NewPoissonLinearRegressionModel, PoissonLinearRegressionModel)
	
	NewPoissonLinearRegressionModel:setName("PoissonLinearRegression")

	NewPoissonLinearRegressionModel.learningRate = parameterDictionary.learningRate or defaultLearningRate
	
	NewPoissonLinearRegressionModel.epsilon = parameterDictionary.epsilon or defaultEpsilon

	NewPoissonLinearRegressionModel.Optimizer = parameterDictionary.Optimizer

	NewPoissonLinearRegressionModel.Regularizer = parameterDictionary.Regularizer

	return NewPoissonLinearRegressionModel

end

function PoissonLinearRegressionModel:setOptimizer(Optimizer)

	self.Optimizer = Optimizer

end

function PoissonLinearRegressionModel:setRegularizer(Regularizer)

	self.Regularizer = Regularizer

end

function PoissonLinearRegressionModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (#featureMatrix[1] ~= #ModelParameters) then error("The number of features are not the same as the model parameters.") end

	else

		self.ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations

	local Optimizer = self.Optimizer

	local costArray = {}

	local numberOfIterations = 0
	
	local cost

	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		local hypothesisVector = self:calculateHypothesisVector(featureMatrix, true)

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return self:calculateCost(hypothesisVector, labelVector)

		end)

		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end

		local lossVector = AqwamTensorLibrary:subtract(hypothesisVector, labelVector)

		self:update(lossVector, true)

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	if (Optimizer) and (self.autoResetOptimizers) then Optimizer:reset() end

	return costArray

end

function PoissonLinearRegressionModel:predict(featureMatrix)
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then
		
		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})
		
		self.ModelParameters = ModelParameters
		
	end

	local exponentTermVector = AqwamTensorLibrary:dotProduct(featureMatrix, ModelParameters)
	
	local predictedVector = AqwamTensorLibrary:applyFunction(math.exp, exponentTermVector)

	return predictedVector

end

return PoissonLinearRegressionModel]]></ProtectedString>
									<string name="ScriptGuid">{2FC79F69-42FA-4D18-B832-2DF11994AFC9}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">PoissonLinearRegression</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8B6E62598D364ECD8DCA24B1AB0C0AF3">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

UnscentedKalmanFilterDataPredictVariantModel = {}

UnscentedKalmanFilterDataPredictVariantModel.__index = UnscentedKalmanFilterDataPredictVariantModel

setmetatable(UnscentedKalmanFilterDataPredictVariantModel, BaseModel)

local defaultAlpha = 1e-3

local defaultBeta = 2

local defaultKappa = 0

local defaultNoiseValue = 1 -- Do not use very small value for this. It will cause the Mahalanobis distance to have very large values.

local defaultLossFunction = "L2"

local defaultUseJosephForm = true

local defaultEpsilon = 1e-5

local function defaultStateTransitionFunction(stateMatrix, deltaTime)
	
	return stateMatrix
	
end

local function defaultObservationFunction(stateMatrix)

	return stateMatrix
	
end

function UnscentedKalmanFilterDataPredictVariantModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewUKFModel = BaseModel.new(parameterDictionary)
	
	setmetatable(NewUKFModel, UnscentedKalmanFilterDataPredictVariantModel)
	
	NewUKFModel:setName("UnscentedKalmanFilterDataPredictVariant")
	
	NewUKFModel.alpha = parameterDictionary.alpha or defaultAlpha
	
	NewUKFModel.beta = parameterDictionary.beta or defaultBeta
	
	NewUKFModel.kappa = parameterDictionary.kappa or defaultKappa

	NewUKFModel.noiseValue = parameterDictionary.noiseValue or defaultNoiseValue
	
	NewUKFModel.lossFunction = parameterDictionary.lossFunction or defaultLossFunction
	
	NewUKFModel.useJosephForm = NewUKFModel:getValueOrDefaultValue(parameterDictionary.useJosephForm, defaultUseJosephForm)
	
	NewUKFModel.epsilon = parameterDictionary.epsilon or defaultEpsilon

	NewUKFModel.stateTransitionFunction = parameterDictionary.stateTransitionFunction or defaultStateTransitionFunction
	
	NewUKFModel.observationFunction = parameterDictionary.observationFunction or defaultObservationFunction

	NewUKFModel.processNoiseCovarianceMatrix = parameterDictionary.processNoiseCovarianceMatrix
	
	NewUKFModel.observationNoiseCovarianceMatrix = parameterDictionary.observationNoiseCovarianceMatrix

	return NewUKFModel
end

local function generateSigmaPoints(meanStateMatrix, covarianceMatrix, alpha, kappa)

	local numberOfStates = #meanStateMatrix
	
	local lambdaValue = math.pow(alpha, 2) * (numberOfStates + kappa) - numberOfStates

	local scaledCovarianceMatrix = AqwamTensorLibrary:multiply(covarianceMatrix, (numberOfStates + lambdaValue))

	local squareRootCovarianceMatrix = AqwamTensorLibrary:applyFunction(math.sqrt, scaledCovarianceMatrix)

	local sigmaPointMatrixArray = {}
	
	table.insert(sigmaPointMatrixArray, meanStateMatrix)
	
	local columnVector 
	
	local sigmaPlus
	
	local sigmaMinus

	for i = 1, numberOfStates, 1 do

		columnVector = AqwamTensorLibrary:extract(squareRootCovarianceMatrix, {1, i}, {numberOfStates, i})

		sigmaPlus = AqwamTensorLibrary:add(meanStateMatrix, columnVector)
		
		sigmaMinus = AqwamTensorLibrary:subtract(meanStateMatrix, columnVector)

		table.insert(sigmaPointMatrixArray, sigmaPlus)
		
		table.insert(sigmaPointMatrixArray, sigmaMinus)
		
	end

	return sigmaPointMatrixArray, lambdaValue
	
end

local function calculateWeightedMeanMatrix(matrixArray, weightArray)
	
	local numberOfMatrices = #matrixArray
	
	local weightedMeanMatrix = AqwamTensorLibrary:multiply(matrixArray[1], weightArray[1])
	
	local meanMatrix

	for i = 2, numberOfMatrices do
		
		meanMatrix = AqwamTensorLibrary:multiply(matrixArray[i], weightArray[i])
		
		weightedMeanMatrix = AqwamTensorLibrary:add(weightedMeanMatrix, meanMatrix)
		
	end

	return weightedMeanMatrix
	
end

local function calculateWeightedCovariance(matrixArray, weightArray, meanMatrix)
	
	local weightedCovarianceMatrix
	
	local covarianceMatrixPart1
	
	local transposedCovarianceMatrixPart1
	
	local covarianceMatrixPart2
	
	local covarianceMatrix
	
	for i, matrix in ipairs(matrixArray) do
		
		covarianceMatrixPart1 = AqwamTensorLibrary:subtract(matrix, meanMatrix)
		
		transposedCovarianceMatrixPart1 = AqwamTensorLibrary:transpose(covarianceMatrixPart1)
		
		covarianceMatrixPart2 = AqwamTensorLibrary:dotProduct(covarianceMatrixPart1, transposedCovarianceMatrixPart1)
		
		covarianceMatrix = AqwamTensorLibrary:multiply(weightArray[i], covarianceMatrixPart2)
		
		if (i == 1) then
			
			weightedCovarianceMatrix = covarianceMatrix
			
		else
			
			weightedCovarianceMatrix = AqwamTensorLibrary:add(weightedCovarianceMatrix, covarianceMatrix)
			
		end
		
	end

	return weightedCovarianceMatrix
	
end

local function calculateCrossVariance(stateSigmaMatrixArray, meanStateMatrix, observationSigmaArray, meanObsMatrix, weightArray)
	
	local numberOfSigmaPoints = #stateSigmaMatrixArray

	local crossCovarianceMatrix

	local stateDeviationMatrix

	local observationDeviationMatrix

	local transposedObservationDeviationMatrix

	local weightedCrossMatrixPart1 

	local weightedCrossMatrix

	for i = 1, numberOfSigmaPoints do

		stateDeviationMatrix = AqwamTensorLibrary:subtract(stateSigmaMatrixArray[i], meanStateMatrix)

		observationDeviationMatrix = AqwamTensorLibrary:subtract(observationSigmaArray[i], meanObsMatrix)

		transposedObservationDeviationMatrix = AqwamTensorLibrary:transpose(observationDeviationMatrix)

		weightedCrossMatrixPart1 = AqwamTensorLibrary:dotProduct(stateDeviationMatrix, transposedObservationDeviationMatrix)

		weightedCrossMatrix = AqwamTensorLibrary:multiply(weightArray[i], weightedCrossMatrixPart1)

		if (i == 1) then

			crossCovarianceMatrix = weightedCrossMatrix

		else

			crossCovarianceMatrix = AqwamTensorLibrary:add(crossCovarianceMatrix, weightedCrossMatrix)

		end

	end

	return crossCovarianceMatrix
	
end

local function calculateJacobianApproximation(functionHandle, stateMatrix, epsilon)
	
	local numberOfStates = #stateMatrix
	
	local jacobianMatrix = AqwamTensorLibrary:createTensor({numberOfStates, numberOfStates}, 0)

	local multipliedEpsilon = 2 * epsilon
	
	local deltaMatrix
	
	local statePlusMatrix
	
	local stateMinusMatrix
	
	local outputPlusMatrix
	
	local outputMinusMatrix
	
	local differenceMatrix
	
	local derivativeColumnMatrix

	for i = 1, numberOfStates do
		
		deltaMatrix = AqwamTensorLibrary:createTensor({numberOfStates, 1}, 0)
		
		deltaMatrix[i][1] = epsilon

		statePlusMatrix = AqwamTensorLibrary:add(stateMatrix, deltaMatrix)
		
		stateMinusMatrix = AqwamTensorLibrary:subtract(stateMatrix, deltaMatrix)

		outputPlusMatrix = functionHandle(statePlusMatrix)
		
		outputMinusMatrix = functionHandle(stateMinusMatrix)

		differenceMatrix = AqwamTensorLibrary:subtract(outputPlusMatrix, outputMinusMatrix)
		
		derivativeColumnMatrix = AqwamTensorLibrary:divide(differenceMatrix, multipliedEpsilon)
		
		for j = 1, numberOfStates do
			
			jacobianMatrix[j][i] = derivativeColumnMatrix[j][1]
			
		end
		
	end

	return AqwamTensorLibrary:transpose(jacobianMatrix)
	
end

function UnscentedKalmanFilterDataPredictVariantModel:train(previousStateMatrix, currentStateMatrix)
	
	local numberOfData = #previousStateMatrix

	if (numberOfData ~= #currentStateMatrix) then error("The number of data in the previous state vector is not equal to the number of data in the current state vector.") end

	local numberOfStates = #previousStateMatrix[1]

	if (numberOfStates ~= #currentStateMatrix[1]) then error("The number of states in the previous state vector is not equal to the number of states in the current state vector.") end

	local numberOfStatesDimensionSizeArray = {numberOfStates, numberOfStates}
	
	previousStateMatrix = AqwamTensorLibrary:transpose(previousStateMatrix)

	currentStateMatrix = AqwamTensorLibrary:transpose(currentStateMatrix)
	
	local alpha = self.alpha

	local beta = self.beta

	local kappa = self.kappa

	local noiseValue = self.noiseValue

	local lossFunction = self.lossFunction

	local useJosephForm = self.useJosephForm
	
	local epsilon = self.epsilon
	
	local stateTransitionFunction = self.stateTransitionFunction
	
	local observationFunction = self.observationFunction
	
	local processNoiseCovarianceMatrix = self.processNoiseCovarianceMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)
	
	local observationNoiseCovarianceMatrix = self.observationNoiseCovarianceMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)

	local ModelParameters = self.ModelParameters or {}
	
	local priorMeanStateMatrix = ModelParameters[1] or previousStateMatrix
	
	local priorCovarianceMatrix = ModelParameters[2] or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)

	local sigmaPointMatrixArray, lambdaValue = generateSigmaPoints(priorMeanStateMatrix, priorCovarianceMatrix, alpha, kappa)
	
	local numberOfSigmaPoints = #sigmaPointMatrixArray

	local weightMeanArray = {}
	
	local weightCovarianceArray = {}

	weightMeanArray[1] = lambdaValue / (numberOfStates + lambdaValue)
	
	weightCovarianceArray[1] = weightMeanArray[1] + (1 - alpha^2 + beta)

	for i = 2, numberOfSigmaPoints, 1 do
		
		weightMeanArray[i] = 1 / (2 * (numberOfStates + lambdaValue))
		
		weightCovarianceArray[i] = weightMeanArray[i]
		
	end

	local predictedSigmaPointMatrixArray = {}
	
	for i, sigmaPointMatrix in ipairs(sigmaPointMatrixArray) do
		
		predictedSigmaPointMatrixArray[i] = stateTransitionFunction(sigmaPointMatrix)
		
	end

	local predictedMeanStateMatrix = calculateWeightedMeanMatrix(predictedSigmaPointMatrixArray, weightMeanArray)
	
	local predictedCovarianceMatrix = calculateWeightedCovariance(predictedSigmaPointMatrixArray, weightCovarianceArray, predictedMeanStateMatrix)
	
	predictedCovarianceMatrix = AqwamTensorLibrary:add(predictedCovarianceMatrix, processNoiseCovarianceMatrix)

	local predictedObservationSigmaPointsArray = {}
	
	for i, predictedSigmaPointMatrix in ipairs(predictedSigmaPointMatrixArray) do
		
		predictedObservationSigmaPointsArray[i] = observationFunction(predictedSigmaPointMatrix)
		
	end

	local predictedMeanObservationMatrix = calculateWeightedMeanMatrix(predictedObservationSigmaPointsArray, weightMeanArray)
	
	local innovationCovarianceMatrix = calculateWeightedCovariance(predictedObservationSigmaPointsArray, weightCovarianceArray, predictedMeanObservationMatrix)
	
	innovationCovarianceMatrix = AqwamTensorLibrary:add(innovationCovarianceMatrix, observationNoiseCovarianceMatrix)

	local crossCovarianceMatrix = calculateCrossVariance(predictedSigmaPointMatrixArray, predictedMeanStateMatrix, predictedObservationSigmaPointsArray, predictedMeanObservationMatrix, weightCovarianceArray)

	local inverseInnovationCovarianceMatrix = AqwamTensorLibrary:inverse(innovationCovarianceMatrix)
	
	local kalmanGainMatrix = AqwamTensorLibrary:dotProduct(crossCovarianceMatrix, inverseInnovationCovarianceMatrix)

	local innovationMatrix = AqwamTensorLibrary:subtract(currentStateMatrix, predictedMeanObservationMatrix)
	
	local posteriorStateMatrixPart1 = AqwamTensorLibrary:dotProduct(kalmanGainMatrix, innovationMatrix)
	
	local posteriorMeanStateMatrix = AqwamTensorLibrary:add(posteriorStateMatrixPart1, predictedMeanStateMatrix)

	local identityMatrix = AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray)
	
	local jacobianApproximationMatrix = calculateJacobianApproximation(observationFunction, predictedMeanStateMatrix, epsilon)
	
	local KHMatrix = AqwamTensorLibrary:dotProduct(kalmanGainMatrix, jacobianApproximationMatrix)
	
	local identityMinusKHMatrix = AqwamTensorLibrary:subtract(identityMatrix, KHMatrix)

	local posteriorCovarianceMatrix = AqwamTensorLibrary:dotProduct(identityMinusKHMatrix, predictedCovarianceMatrix)

	if (useJosephForm) then
		
		local transposedIdentityMinusKHMatrix = AqwamTensorLibrary:transpose(identityMinusKHMatrix)
		
		local josephFormMatrixPart1 = AqwamTensorLibrary:dotProduct(posteriorCovarianceMatrix, transposedIdentityMinusKHMatrix)
		
		local transposedKalmanGainMatrix = AqwamTensorLibrary:transpose(kalmanGainMatrix)
		
		local josephFormMatrixPart2 = AqwamTensorLibrary:dotProduct(kalmanGainMatrix, observationNoiseCovarianceMatrix, transposedKalmanGainMatrix)
		
		posteriorCovarianceMatrix = AqwamTensorLibrary:add(josephFormMatrixPart1, josephFormMatrixPart2)
		
	end
	
	local meanCorrectionMatrix = AqwamTensorLibrary:mean(posteriorStateMatrixPart1, 2)

	self.ModelParameters = {posteriorMeanStateMatrix, posteriorCovarianceMatrix, meanCorrectionMatrix}

	-- Returning this as a cost like other models.
	
	local lossMatrix = innovationMatrix

	if (lossFunction == "L1") then

		lossMatrix = AqwamTensorLibrary:applyFunction(math.abs, lossMatrix)

	elseif (lossFunction == "L2") then

		lossMatrix = AqwamTensorLibrary:power(lossMatrix, 2)

	elseif (lossFunction  == "Mahalanobis") then

		local transposedInnovationMatrix = AqwamTensorLibrary:transpose(innovationMatrix)

		lossMatrix = AqwamTensorLibrary:dotProduct(transposedInnovationMatrix, inverseInnovationCovarianceMatrix, innovationMatrix)

	else

		error("Invalid loss function.")

	end

	local cost = AqwamTensorLibrary:sum(lossMatrix)

	cost = cost / numberOfData

	return {cost}
	
end

function UnscentedKalmanFilterDataPredictVariantModel:predict(stateMatrix)
	
	local ModelParameters = self.ModelParameters or {}

	local meanCorrectionMatrix = ModelParameters[3]

	stateMatrix = AqwamTensorLibrary:transpose(stateMatrix)

	local nextStateMatrix = self.stateTransitionFunction(stateMatrix)

	if (meanCorrectionMatrix) then nextStateMatrix = AqwamTensorLibrary:add(nextStateMatrix, meanCorrectionMatrix) end

	nextStateMatrix = AqwamTensorLibrary:transpose(nextStateMatrix)

	return nextStateMatrix
	
end

return UnscentedKalmanFilterDataPredictVariantModel]]></ProtectedString>
									<string name="ScriptGuid">{2E0CA349-D22A-4187-9F15-9EA68B201FE0}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UnscentedKalmanFilterDataPredictVariant</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5C32AE330A014E95987ACF0121F6775B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

LocalOutlierFactor = {}

LocalOutlierFactor.__index = LocalOutlierFactor

setmetatable(LocalOutlierFactor, BaseModel)

local defaultKValue = 3

local defaultDistanceFunction = "Euclidean"

local defaultMaximumNumberOfData = math.huge

local function createDistanceMatrix(distanceFunction, featureMatrix)

	local numberOfData = #featureMatrix

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfData}, 0)

	local calculateDistance = distanceFunctionDictionary[distanceFunction]
	
	for i, primaryUnwrappedFeatureVector in ipairs(featureMatrix) do
		
		for j, secondaryUnwrappedFeatureVector in ipairs(featureMatrix) do

			distanceMatrix[i][j] = calculateDistance({primaryUnwrappedFeatureVector}, {secondaryUnwrappedFeatureVector})

		end
		
	end

	return distanceMatrix

end

local function deepCopyTable(original, copies)

	copies = copies or {}

	local originalType = type(original)

	local copy

	if (originalType == 'table') then

		if copies[original] then

			copy = copies[original]

		else

			copy = {}

			copies[original] = copy

			for originalKey, originalValue in next, original, nil do

				copy[deepCopyTable(originalKey, copies)] = deepCopyTable(originalValue, copies)

			end

			setmetatable(copy, deepCopyTable(getmetatable(original), copies))

		end

	else -- number, string, boolean, etc

		copy = original

	end

	return copy

end

local function merge(unwrappedDistanceVector, left, mid, right)

	local subArrayOne = mid - left + 1
	local subArrayTwo = right - mid

	local unwrappedLeftDistanceVector = {}
	local unwrappedRightDistanceVector = {}

	for i = 1, subArrayOne do

		unwrappedLeftDistanceVector[i] = unwrappedDistanceVector[left + i - 1]

	end

	for j = 1, subArrayTwo do

		unwrappedRightDistanceVector[j] = unwrappedDistanceVector[mid + j]

	end

	local indexOfSubArrayOne = 1
	local indexOfSubArrayTwo = 1
	local indexOfMergedArray = left

	while indexOfSubArrayOne <= subArrayOne and indexOfSubArrayTwo <= subArrayTwo do

		if unwrappedLeftDistanceVector[indexOfSubArrayOne] <= unwrappedRightDistanceVector[indexOfSubArrayTwo] then

			unwrappedDistanceVector[indexOfMergedArray] = unwrappedLeftDistanceVector[indexOfSubArrayOne]
			indexOfSubArrayOne = indexOfSubArrayOne + 1

		else

			unwrappedDistanceVector[indexOfMergedArray] = unwrappedRightDistanceVector[indexOfSubArrayTwo]
			indexOfSubArrayTwo = indexOfSubArrayTwo + 1

		end

		indexOfMergedArray = indexOfMergedArray + 1

	end

	while (indexOfSubArrayOne <= subArrayOne) do

		unwrappedDistanceVector[indexOfMergedArray] = unwrappedLeftDistanceVector[indexOfSubArrayOne]
		indexOfSubArrayOne = indexOfSubArrayOne + 1
		indexOfMergedArray = indexOfMergedArray + 1

	end

	while (indexOfSubArrayTwo <= subArrayTwo) do

		unwrappedDistanceVector[indexOfMergedArray] = unwrappedRightDistanceVector[indexOfSubArrayTwo]
		indexOfSubArrayTwo = indexOfSubArrayTwo + 1
		indexOfMergedArray = indexOfMergedArray + 1

	end

end

local function mergeSort(distanceVector, startingValue, endValue)

	if (startingValue >= endValue) then return end

	local mid = math.floor(startingValue + (endValue - startingValue) / 2)

	mergeSort(distanceVector, startingValue, mid)
	mergeSort(distanceVector, mid + 1, endValue)
	merge(distanceVector, startingValue, mid, endValue)

end

function LocalOutlierFactor.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewLocalOutlierFactor = BaseModel.new(parameterDictionary)

	setmetatable(NewLocalOutlierFactor, LocalOutlierFactor)
	
	NewLocalOutlierFactor:setName("LocalOutlierFactor")

	NewLocalOutlierFactor.kValue = parameterDictionary.kValue or defaultKValue

	NewLocalOutlierFactor.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction
	
	NewLocalOutlierFactor.maximumNumberOfData = parameterDictionary.maximumNumberOfData or defaultMaximumNumberOfData
	
	return NewLocalOutlierFactor

end

function LocalOutlierFactor:train(featureMatrix)

	local numberOfData = #featureMatrix

	local maximumNumberOfData = self.maximumNumberOfData

	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		local storedFeatureMatrix = ModelParameters[1]

		local storedLabelVector = ModelParameters[2]

		featureMatrix = AqwamTensorLibrary:concatenate(featureMatrix, storedFeatureMatrix, 1)

		numberOfData = #featureMatrix

		if (numberOfData > maximumNumberOfData) then

			local newFeatureMatrix = {}

			local newLabelVector = {}

			local dataShiftIndex = (numberOfData - maximumNumberOfData)

			for dataIndex = 1, maximumNumberOfData, 1 do

				newFeatureMatrix[dataIndex] = featureMatrix[dataIndex + dataShiftIndex]

			end

			featureMatrix = newFeatureMatrix

			numberOfData = maximumNumberOfData

		end

	end

	if (numberOfData <= self.kValue) and (self.isOutputPrinted) then warn("Number of data is less than or equal to the K value. Please add more data before doing any predictions.") end

	self.ModelParameters = featureMatrix

end

function LocalOutlierFactor:score()
	
	local featureMatrix = self.ModelParameters

	if (not featureMatrix) then return {{math.huge}} end

	local kValue = self.kValue

	local distanceFunction = self.distanceFunction
	
	local numberOfData = #featureMatrix
	
	local numberOfDataMinusOne = numberOfData - 1
	
	local distanceMatrix = createDistanceMatrix(distanceFunction, featureMatrix)
	
	local nearestNeighbourIndexArrayArray = {}
	
	local numberOfNearestNeighboursVector = {}
	
	local reachabilityDistanceMatrix = {}
	
	for i, unwrappedDistanceVector in ipairs(distanceMatrix) do

		local sortedUnwrappedDistanceVector = deepCopyTable(unwrappedDistanceVector)
		
		-- Ignores the distance to itself. It is removed before sorting to reduce computational resources.
		
		table.remove(sortedUnwrappedDistanceVector, i)

		mergeSort(sortedUnwrappedDistanceVector, 1, numberOfDataMinusOne)
		
		local kDistance = sortedUnwrappedDistanceVector[kValue]
		
		local nearestNeighbourIndexArray = {}
		
		local unwrappedReachabilityDistanceVector = {}
		
		local numberOfNearestNeighbours = 0
		
		for j, distance in ipairs(unwrappedDistanceVector) do
			
			unwrappedReachabilityDistanceVector[j] = math.max(kDistance, distance)
			
			if (distance <= kDistance) then table.insert(nearestNeighbourIndexArray, j) end
			
		end
		
		reachabilityDistanceMatrix[i] = unwrappedReachabilityDistanceVector
		
		nearestNeighbourIndexArrayArray[i] = nearestNeighbourIndexArray
		
		numberOfNearestNeighboursVector[i] = {#nearestNeighbourIndexArray}

	end
	
	local sumReachabilityDistanceVector = AqwamTensorLibrary:sum(reachabilityDistanceMatrix, 2)
	
	local localReachabilityDensityVector = AqwamTensorLibrary:divide(numberOfNearestNeighboursVector, sumReachabilityDistanceVector)
	
	local localOutlierFactorVectorDivisor = AqwamTensorLibrary:multiply(numberOfNearestNeighboursVector, localReachabilityDensityVector)
	
	local localOutlierFactorVectorNumerator = {}

	for i, nearestNeighboursIndexArray in ipairs(nearestNeighbourIndexArrayArray) do
		
		local sumRatio = 0
		
		for _, nearestNeighbourIndex in ipairs(nearestNeighboursIndexArray) do
			
			sumRatio = sumRatio + localReachabilityDensityVector[nearestNeighbourIndex][1]
			
		end
		
		localOutlierFactorVectorNumerator[i] = {sumRatio}
		
	end
	
	local localOutlierFactorVector = AqwamTensorLibrary:divide(localOutlierFactorVectorNumerator, localOutlierFactorVectorDivisor)
	
	return localOutlierFactorVector

end

return LocalOutlierFactor]]></ProtectedString>
									<string name="ScriptGuid">{C24D9C7D-2F76-4CEA-B194-396D20D4C8CA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalOutlierFactor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEFD3EAEF173348EAB649135D613F2603">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningActorCriticBaseModel = require(script.Parent.DeepReinforcementLearningActorCriticBaseModel)

TwinDelayedDeepDeterministicPolicyGradientModel = {}

TwinDelayedDeepDeterministicPolicyGradientModel.__index = TwinDelayedDeepDeterministicPolicyGradientModel

setmetatable(TwinDelayedDeepDeterministicPolicyGradientModel, DeepReinforcementLearningActorCriticBaseModel)

local defaultAveragingRate = 0.995

local defaultNoiseClippingFactor = 0.5

local defaultPolicyDelayAmount = 3

local function rateAverageModelParameters(averagingRate, TargetModelParameters, PrimaryModelParameters)

	local averagingRateComplement = 1 - averagingRate

	for layer = 1, #TargetModelParameters, 1 do

		local TargetModelParametersPart = AqwamTensorLibrary:multiply(averagingRate, TargetModelParameters[layer])

		local PrimaryModelParametersPart = AqwamTensorLibrary:multiply(averagingRateComplement, PrimaryModelParameters[layer])

		TargetModelParameters[layer] = AqwamTensorLibrary:add(TargetModelParametersPart, PrimaryModelParametersPart)

	end

	return TargetModelParameters

end

function TwinDelayedDeepDeterministicPolicyGradientModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewTwinDelayedDeepDeterministicPolicyGradient = DeepReinforcementLearningActorCriticBaseModel.new(parameterDictionary)
	
	setmetatable(NewTwinDelayedDeepDeterministicPolicyGradient, TwinDelayedDeepDeterministicPolicyGradientModel)
	
	NewTwinDelayedDeepDeterministicPolicyGradient:setName("TwinDelayedDeepDeterministicPolicyGradient")
	
	NewTwinDelayedDeepDeterministicPolicyGradient.noiseClippingFactor = parameterDictionary.noiseClippingFactor or defaultNoiseClippingFactor

	NewTwinDelayedDeepDeterministicPolicyGradient.policyDelayAmount = parameterDictionary.policyDelayAmount or defaultPolicyDelayAmount
	
	NewTwinDelayedDeepDeterministicPolicyGradient.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate
	
	NewTwinDelayedDeepDeterministicPolicyGradient.CriticModelParametersArray = parameterDictionary.CriticModelParametersArray or {}
	
	local TargetCriticModelParametersArray = {}
	
	local currentNumberOfUpdate = 0
	
	NewTwinDelayedDeepDeterministicPolicyGradient:setDiagonalGaussianUpdateFunction(function(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)
		
		if (not actionNoiseVector) then actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]}) end
		
		local ActorModel = NewTwinDelayedDeepDeterministicPolicyGradient.ActorModel
		
		local CriticModel = NewTwinDelayedDeepDeterministicPolicyGradient.CriticModel
		
		local averagingRate = NewTwinDelayedDeepDeterministicPolicyGradient.averagingRate
		
		local noiseClippingFactor = NewTwinDelayedDeepDeterministicPolicyGradient.noiseClippingFactor
		
		local CriticModelParametersArray = NewTwinDelayedDeepDeterministicPolicyGradient.CriticModelParametersArray
		
		local noiseClipFunction = function(value) return math.clamp(value, -noiseClippingFactor, noiseClippingFactor) end
		
		local currentActionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]})
		
		local clippedCurrentActionNoiseVector = AqwamTensorLibrary:applyFunction(noiseClipFunction, currentActionNoiseVector)
		
		local previousActionVector = AqwamTensorLibrary:multiply(actionStandardDeviationVector, actionNoiseVector)

		previousActionVector = AqwamTensorLibrary:add(previousActionVector, actionMeanVector)

		local previousActionArray = previousActionVector[1] 

		local lowestActionValue = math.min(table.unpack(previousActionArray))

		local highestActionValue = math.max(table.unpack(previousActionArray))
		
		local currentActionMeanVector = ActorModel:forwardPropagate(currentFeatureVector, true)
		
		local ActorModelParameters = ActorModel:getModelParameters(true)
		
		local targetActionVectorPart1 = AqwamTensorLibrary:add(currentActionMeanVector, clippedCurrentActionNoiseVector)
		
		local actionClipFunction = function(value)
			
			if (lowestActionValue ~= lowestActionValue) or (highestActionValue ~= highestActionValue) then
				
				error("Received nan values.")
			
			elseif (lowestActionValue < highestActionValue) then
				
				return math.clamp(value, lowestActionValue, highestActionValue) 
				
			elseif (lowestActionValue > highestActionValue) then
				
				return math.clamp(value, highestActionValue, lowestActionValue)
				
			else
				
				return lowestActionValue
				
			end
			
		end
		
		local targetActionVector = AqwamTensorLibrary:applyFunction(actionClipFunction, targetActionVectorPart1)
		
		local targetCriticActionInputVector = AqwamTensorLibrary:concatenate(currentFeatureVector, targetActionVector, 2)
		
		local currentCriticValueArray = {}
		
		for i = 1, 2, 1 do 

			CriticModel:setModelParameters(TargetCriticModelParametersArray[i])

			currentCriticValueArray[i] = CriticModel:forwardPropagate(targetCriticActionInputVector)[1][1] 

			local CriticModelParameters = CriticModel:getModelParameters(true)

			TargetCriticModelParametersArray[i] = CriticModelParameters

		end

		local minimumCurrentCriticValue = math.min(table.unpack(currentCriticValueArray))
		
		local yValuePart1 = NewTwinDelayedDeepDeterministicPolicyGradient.discountFactor * (1 - terminalStateValue) * minimumCurrentCriticValue
		
		local yValue = rewardValue + yValuePart1
		
		local temporalDifferenceErrorVector = AqwamTensorLibrary:createTensor({1, 2}, 0)

		local previousCriticActionMeanInputVector = AqwamTensorLibrary:concatenate(previousFeatureVector, actionMeanVector, 2)
		
		for i = 1, 2, 1 do 

			CriticModel:setModelParameters(CriticModelParametersArray[i], true)

			local previousCriticValue = CriticModel:forwardPropagate(previousCriticActionMeanInputVector, true)[1][1] 

			local criticLoss = previousCriticValue - yValue

			temporalDifferenceErrorVector[1][i] = -criticLoss -- We perform gradient descent here, so the critic loss is negated so that it can be used as temporal difference value.

			CriticModel:update(criticLoss, true)

			CriticModelParametersArray[i] = CriticModel:getModelParameters(true)

		end
		
		currentNumberOfUpdate = currentNumberOfUpdate + 1
		
		if ((currentNumberOfUpdate % NewTwinDelayedDeepDeterministicPolicyGradient.policyDelayAmount) == 0) then
			
			local actionVector = AqwamTensorLibrary:multiply(actionStandardDeviationVector, actionNoiseVector)

			actionVector = AqwamTensorLibrary:add(actionVector, actionMeanVector)

			local previousCriticActionInputVector = AqwamTensorLibrary:concatenate(previousFeatureVector, actionVector, 2)
			
			CriticModel:setModelParameters(CriticModelParametersArray[1], true)

			local currentQValue = CriticModel:forwardPropagate(previousCriticActionInputVector, true)[1][1]

			ActorModel:forwardPropagate(previousFeatureVector, true)

			ActorModel:update(-currentQValue, true)

			for i = 1, 2, 1 do TargetCriticModelParametersArray[i] = rateAverageModelParameters(averagingRate, TargetCriticModelParametersArray[i], CriticModelParametersArray[i]) end
			
			local TargetActorModelParameters = ActorModel:getModelParameters(true)

			TargetActorModelParameters = rateAverageModelParameters(averagingRate, TargetActorModelParameters, ActorModelParameters)

			ActorModel:setModelParameters(TargetActorModelParameters, true)
			
		end

		return temporalDifferenceErrorVector
		
	end)
	
	NewTwinDelayedDeepDeterministicPolicyGradient:setEpisodeUpdateFunction(function() 
		
		currentNumberOfUpdate = 0
		
	end)
	
	NewTwinDelayedDeepDeterministicPolicyGradient:setResetFunction(function() 
		
		currentNumberOfUpdate = 0
		
	end)
	
	return NewTwinDelayedDeepDeterministicPolicyGradient
	
end

function TwinDelayedDeepDeterministicPolicyGradientModel:setCrtiticModelParameters1(CriticModelParameters1, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.CriticModelParametersArray[1] = CriticModelParameters1

	else

		self.CriticModelParametersArray[1] = self:deepCopyTable(CriticModelParameters1)

	end

end

function TwinDelayedDeepDeterministicPolicyGradientModel:setCriticModelParameters2(CriticModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.CriticModelParametersArray[2] = CriticModelParameters2

	else

		self.CriticModelParametersArray[2] = self:deepCopyTable(CriticModelParameters2)

	end

end

function TwinDelayedDeepDeterministicPolicyGradientModel:getCriticModelParameters1(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.CriticModelParametersArray[1]

	else

		return self:deepCopyTable(self.CriticModelParametersArray[1])

	end

end

function TwinDelayedDeepDeterministicPolicyGradientModel:getCriticModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.CriticModelParametersArray[2]

	else

		return self:deepCopyTable(self.CriticModelParametersArray[2])

	end

end

return TwinDelayedDeepDeterministicPolicyGradientModel]]></ProtectedString>
									<string name="ScriptGuid">{561BC17C-3C40-4284-9163-5F569EDEADDC}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TwinDelayedDeepDeterministicPolicyGradient</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF96142E78E2C45CA9DC03849F658E4AC">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningActorCriticBaseModel = require(script.Parent.DeepReinforcementLearningActorCriticBaseModel)

DeepDeterministicPolicyGradientModel = {}

DeepDeterministicPolicyGradientModel.__index = DeepDeterministicPolicyGradientModel

setmetatable(DeepDeterministicPolicyGradientModel, DeepReinforcementLearningActorCriticBaseModel)

local defaultAveragingRate = 0.995

local function rateAverageModelParameters(averagingRate, TargetModelParameters, PrimaryModelParameters)

	local averagingRateComplement = 1 - averagingRate

	for layer = 1, #TargetModelParameters, 1 do

		local TargetModelParametersPart = AqwamTensorLibrary:multiply(averagingRate, TargetModelParameters[layer])

		local PrimaryModelParametersPart = AqwamTensorLibrary:multiply(averagingRateComplement, PrimaryModelParameters[layer])

		TargetModelParameters[layer] = AqwamTensorLibrary:add(TargetModelParametersPart, PrimaryModelParametersPart)

	end

	return TargetModelParameters

end

function DeepDeterministicPolicyGradientModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewDeepDeterministicPolicyGradientModel = DeepReinforcementLearningActorCriticBaseModel.new(parameterDictionary)
	
	setmetatable(NewDeepDeterministicPolicyGradientModel, DeepDeterministicPolicyGradientModel)
	
	NewDeepDeterministicPolicyGradientModel:setName("DeepDeterministicPolicyGradient")
	
	NewDeepDeterministicPolicyGradientModel.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate
	
	NewDeepDeterministicPolicyGradientModel:setDiagonalGaussianUpdateFunction(function(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)
		
		if (not actionNoiseVector) then actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]}) end
		
		local ActorModel = NewDeepDeterministicPolicyGradientModel.ActorModel
		
		local CriticModel = NewDeepDeterministicPolicyGradientModel.CriticModel
		
		local averagingRate = NewDeepDeterministicPolicyGradientModel.averagingRate
		
		local currentActionMeanVector = ActorModel:forwardPropagate(currentFeatureVector, true)
		
		local ActorModelParameters = ActorModel:getModelParameters(true)
		
		local targetCriticActionMeanInputVector = AqwamTensorLibrary:concatenate(currentFeatureVector, currentActionMeanVector, 2)
		
		local targetQValue = CriticModel:forwardPropagate(targetCriticActionMeanInputVector, true)[1][1]
		
		local CriticModelParameters = CriticModel:getModelParameters(true)
	
		local yValue = rewardValue + (NewDeepDeterministicPolicyGradientModel.discountFactor * (1 - terminalStateValue) * targetQValue)
		
		local actionVector = AqwamTensorLibrary:multiply(actionStandardDeviationVector, actionNoiseVector)
		
		actionVector = AqwamTensorLibrary:add(actionVector, actionMeanVector)
		
		local previousCriticActionInputVector = AqwamTensorLibrary:concatenate(previousFeatureVector, actionVector, 2)
		
		local currentQValue = CriticModel:forwardPropagate(previousCriticActionInputVector, true)[1][1]

		local negatedtemporalDifferenceError = (currentQValue - yValue)
		
		local temporalDifferenceError = -negatedtemporalDifferenceError
		
		ActorModel:forwardPropagate(previousFeatureVector, true)

		ActorModel:update(negatedtemporalDifferenceError, true)
		
		local previousCriticActionMeanInputVector = AqwamTensorLibrary:concatenate(previousFeatureVector, actionMeanVector, 2)
		
		CriticModel:forwardPropagate(previousCriticActionMeanInputVector, true)
		
		CriticModel:update(temporalDifferenceError, true)
		
		local TargetActorModelParameters = ActorModel:getModelParameters(true)
		
		local TargetCriticModelParameters = CriticModel:getModelParameters(true)
		
		TargetActorModelParameters = rateAverageModelParameters(averagingRate, TargetActorModelParameters, ActorModelParameters)
		
		TargetCriticModelParameters = rateAverageModelParameters(averagingRate, TargetCriticModelParameters, CriticModelParameters)
		
		ActorModel:setModelParameters(TargetActorModelParameters, true)
		
		CriticModel:setModelParameters(TargetCriticModelParameters, true)

		return temporalDifferenceError
		
	end)
	
	NewDeepDeterministicPolicyGradientModel:setEpisodeUpdateFunction(function(terminalStateValue) end)
	
	NewDeepDeterministicPolicyGradientModel:setResetFunction(function() end)
	
	return NewDeepDeterministicPolicyGradientModel
	
end

return DeepDeterministicPolicyGradientModel]]></ProtectedString>
									<string name="ScriptGuid">{E42027D7-6BDD-4888-8565-19D7708CEB72}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepDeterministicPolicyGradient</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD15D97C70F784AFF9E4CEFA172EDB21A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningActorCriticBaseModel = require(script.Parent.DeepReinforcementLearningActorCriticBaseModel)

SoftActorCriticModel = {}

SoftActorCriticModel.__index = SoftActorCriticModel

setmetatable(SoftActorCriticModel, DeepReinforcementLearningActorCriticBaseModel)

local defaultAlpha = 0.1

local defaultAveragingRate = 0.995

local function rateAverageModelParameters(averagingRate, TargetModelParameters, PrimaryModelParameters)

	local averagingRateComplement = 1 - averagingRate

	for layer = 1, #TargetModelParameters, 1 do

		local TargetModelParametersPart = AqwamTensorLibrary:multiply(averagingRate, TargetModelParameters[layer])

		local PrimaryModelParametersPart = AqwamTensorLibrary:multiply(averagingRateComplement, PrimaryModelParameters[layer])

		TargetModelParameters[layer] = AqwamTensorLibrary:add(TargetModelParametersPart, PrimaryModelParametersPart)

	end

	return TargetModelParameters

end

local function calculateCategoricalProbability(valueTensor)

	local highestActionValue = AqwamTensorLibrary:findMaximumValue(valueTensor)

	local subtractedZTensor = AqwamTensorLibrary:subtract(valueTensor, highestActionValue)

	local exponentActionTensor = AqwamTensorLibrary:applyFunction(math.exp, subtractedZTensor)

	local exponentActionSumTensor = AqwamTensorLibrary:sum(exponentActionTensor, 2)

	local targetActionTensor = AqwamTensorLibrary:divide(exponentActionTensor, exponentActionSumTensor)

	return targetActionTensor

end

local function calculateDiagonalGaussianProbability(actionMeanTensor, actionStandardDeviationTensor, actionNoiseTensor)

	local actionTensorPart1 = AqwamTensorLibrary:multiply(actionStandardDeviationTensor, actionNoiseTensor)

	local actionTensor = AqwamTensorLibrary:add(actionMeanTensor, actionTensorPart1)

	local zScoreTensorPart1 = AqwamTensorLibrary:subtract(actionTensor, actionMeanTensor)

	local zScoreTensor = AqwamTensorLibrary:divide(zScoreTensorPart1, actionStandardDeviationTensor)

	local squaredZScoreTensor = AqwamTensorLibrary:power(zScoreTensor, 2)

	local logActionProbabilityTensorPart1 = AqwamTensorLibrary:logarithm(actionStandardDeviationTensor)

	local logActionProbabilityTensorPart2 = AqwamTensorLibrary:multiply(2, logActionProbabilityTensorPart1)

	local logActionProbabilityTensorPart3 = AqwamTensorLibrary:add(squaredZScoreTensor, logActionProbabilityTensorPart2)

	local logActionProbabilityTensorPart4 = AqwamTensorLibrary:add(logActionProbabilityTensorPart3, math.log(2 * math.pi))

	local logActionProbabilityTensor = AqwamTensorLibrary:multiply(-0.5, logActionProbabilityTensorPart4)

	return logActionProbabilityTensor

end

function SoftActorCriticModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewSoftActorCritic = DeepReinforcementLearningActorCriticBaseModel.new(parameterDictionary)
	
	setmetatable(NewSoftActorCritic, SoftActorCriticModel)
	
	NewSoftActorCritic:setName("SoftActorCritic")
	
	NewSoftActorCritic.alpha = parameterDictionary.alpha or defaultAlpha
	
	NewSoftActorCritic.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate
	
	NewSoftActorCritic.CriticModelParametersArray = parameterDictionary.CriticModelParametersArray or {}
	
	NewSoftActorCritic:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local ActorModel = NewSoftActorCritic.ActorModel
		
		local CriticModel = NewSoftActorCritic.CriticModel

		local previousActionVector = ActorModel:forwardPropagate(previousFeatureVector, true)
		
		local currentActionVector = ActorModel:forwardPropagate(currentFeatureVector, true)

		local previousActionProbabilityVector = calculateCategoricalProbability(previousActionVector)
		
		local currentActionProbabilityVector = calculateCategoricalProbability(currentActionVector)

		local previousLogActionProbabilityVector = AqwamTensorLibrary:logarithm(previousActionProbabilityVector)
		
		local currentLogActionProbabilityVector = AqwamTensorLibrary:logarithm(currentActionProbabilityVector)
		
		return NewSoftActorCritic:update(previousFeatureVector, previousLogActionProbabilityVector, currentLogActionProbabilityVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
	end)
	
	NewSoftActorCritic:setDiagonalGaussianUpdateFunction(function(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)
		
		if (not actionNoiseVector) then actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]}) end
		
		local currentActionMeanVector = NewSoftActorCritic.ActorModel:forwardPropagate(currentFeatureVector, true)
		
		local dimensionSizeArray = AqwamTensorLibrary:getDimensionSizeArray(actionNoiseVector)
		
		local currentActionNoiseVector = AqwamTensorLibrary:createRandomUniformTensor(dimensionSizeArray)
		
		local previousLogActionProbabilityVector = calculateDiagonalGaussianProbability(actionMeanVector, actionStandardDeviationVector, actionNoiseVector)
		
		local currentLogActionProbabilityVector = calculateDiagonalGaussianProbability(currentActionMeanVector, actionStandardDeviationVector, currentActionNoiseVector)
		
		return NewSoftActorCritic:update(previousFeatureVector, previousLogActionProbabilityVector, currentLogActionProbabilityVector, nil, rewardValue, currentFeatureVector, terminalStateValue)
		
	end)
	
	NewSoftActorCritic:setEpisodeUpdateFunction(function(terminalStateValue) end)
	
	NewSoftActorCritic:setResetFunction(function() end)
	
	return NewSoftActorCritic
	
end

function SoftActorCriticModel:update(previousFeatureVector, previousLogActionProbabilityVector, currentLogActionProbabilityVector, action, rewardValue, currentFeatureVector, terminalStateValue)
	
	local CriticModelParametersArray = self.CriticModelParametersArray
	
	local CriticModel = self.CriticModel

	local ActorModel = self.ActorModel

	local alpha = self.alpha
	
	local averagingRate = self.averagingRate
	
	local PreviousCriticModelParametersArray = {}
	
	local previousLogActionProbabilityValue
	
	if (action) then
		
		local ClassesList = ActorModel:getClassesList()
		
		local actionIndex = table.find(ClassesList, action)
		
		previousLogActionProbabilityValue = previousLogActionProbabilityVector[1][actionIndex]
		
	else
		
		previousLogActionProbabilityValue = AqwamTensorLibrary:sum(previousLogActionProbabilityVector)
		
	end

	local currentCriticValueArray = {}

	for i = 1, 2, 1 do 

		CriticModel:setModelParameters(CriticModelParametersArray[i])

		currentCriticValueArray[i] = CriticModel:forwardPropagate(currentFeatureVector)[1][1] 
		
		local CriticModelParameters = CriticModel:getModelParameters(true)
		
		PreviousCriticModelParametersArray[i] = CriticModelParameters

	end

	local minimumCurrentCriticValue = math.min(table.unpack(currentCriticValueArray))
	
	local yValuePart1 = (1 - terminalStateValue) * (minimumCurrentCriticValue - (alpha * previousLogActionProbabilityValue))

	local yValue = rewardValue + (self.discountFactor * yValuePart1)

	local temporalDifferenceErrorVector = AqwamTensorLibrary:createTensor({1, 2}, 0)
	
	local previousCriticValueArray = {}

	for i = 1, 2, 1 do 

		CriticModel:setModelParameters(PreviousCriticModelParametersArray[i], true)

		local previousCriticValue = CriticModel:forwardPropagate(previousFeatureVector, true)[1][1] 

		local criticLoss = previousCriticValue - yValue

		temporalDifferenceErrorVector[1][i] = -criticLoss -- We perform gradient descent here, so the critic loss is negated so that it can be used as temporal difference value.
		
		previousCriticValueArray[i] = previousCriticValue

		CriticModel:update(criticLoss, true)
		
		local TargetModelParameters = CriticModel:getModelParameters(true)
		
		CriticModelParametersArray[i] = rateAverageModelParameters(averagingRate, TargetModelParameters, PreviousCriticModelParametersArray[i])

	end
	
	local minimumCurrentCriticValue = math.min(table.unpack(previousCriticValueArray))

	local actorLossVector = AqwamTensorLibrary:multiply(alpha, previousLogActionProbabilityVector)

	actorLossVector = AqwamTensorLibrary:subtract(minimumCurrentCriticValue, actorLossVector)
	
	actorLossVector = AqwamTensorLibrary:unaryMinus(actorLossVector)

	ActorModel:forwardPropagate(previousFeatureVector, true)

	ActorModel:update(actorLossVector, true)
	
	return temporalDifferenceErrorVector
	
end

function SoftActorCriticModel:setCrtiticModelParameters1(CriticModelParameters1, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.CriticModelParametersArray[1] = CriticModelParameters1

	else

		self.CriticModelParametersArray[1] = self:deepCopyTable(CriticModelParameters1)

	end

end

function SoftActorCriticModel:setCriticModelParameters2(CriticModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.CriticModelParametersArray[2] = CriticModelParameters2

	else

		self.CriticModelParametersArray[2] = self:deepCopyTable(CriticModelParameters2)

	end

end

function SoftActorCriticModel:getCriticModelParameters1(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.CriticModelParametersArray[1]

	else

		return self:deepCopyTable(self.CriticModelParametersArray[1])

	end

end

function SoftActorCriticModel:getCriticModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.CriticModelParametersArray[2]

	else

		return self:deepCopyTable(self.CriticModelParametersArray[2])

	end

end

return SoftActorCriticModel]]></ProtectedString>
									<string name="ScriptGuid">{A5CB553A-5A8D-4ED3-A284-DBAC9D5B9618}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">SoftActorCritic</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAC6F4D86823A4133B616D6E166F88A1A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GenerativeAdversarialNetworkBaseModel = require(script.Parent.GenerativeAdversarialNetworkBaseModel)

ConditionalWassersteinGenerativeAdversarialNetworkModel = {}

ConditionalWassersteinGenerativeAdversarialNetworkModel.__index = ConditionalWassersteinGenerativeAdversarialNetworkModel

setmetatable(ConditionalWassersteinGenerativeAdversarialNetworkModel, GenerativeAdversarialNetworkBaseModel)

local defaultGeneratorMaximumNumberOfIterations = 50

local defaultDiscriminatorMaximumNumberOfIterations = 100

local defaultSampleSize = 3

local function sampleGroup(matrix1, matrix2, matrix3, sampleSize)

	local matrix1Batch = {}
	
	local matrix2Batch = {}
	
	local matrix3Batch = {}

	local numberOfData = #matrix1

	for sample = 1, sampleSize, 1 do

		local randomIndex = Random.new():NextInteger(1, numberOfData)

		table.insert(matrix1Batch, matrix1[randomIndex])
		
		table.insert(matrix2Batch, matrix2[randomIndex])
		
		table.insert(matrix3Batch, matrix3[randomIndex])

	end

	return matrix1Batch, matrix2Batch, matrix3Batch

end

local function samplePair(matrix, matrix2, sampleSize)

	local matrix1Batch = {}
	
	local matrix2Batch = {}

	local numberOfData = #matrix

	for sample = 1, sampleSize, 1 do

		local randomIndex = Random.new():NextInteger(1, numberOfData)

		table.insert(matrix1Batch, matrix[randomIndex])
		
		table.insert(matrix2Batch, matrix2[randomIndex])


	end

	return matrix1Batch, matrix2Batch

end

function ConditionalWassersteinGenerativeAdversarialNetworkModel.new(parameterDictionary)
	
	local NewConditionalWassersteinGenerativeAdversarialNetworkModel = GenerativeAdversarialNetworkBaseModel.new(parameterDictionary)
	
	setmetatable(NewConditionalWassersteinGenerativeAdversarialNetworkModel, ConditionalWassersteinGenerativeAdversarialNetworkModel)
	
	NewConditionalWassersteinGenerativeAdversarialNetworkModel:setName("ConditionalWassersteinGenerativeAdversarialNetwork")
	
	NewConditionalWassersteinGenerativeAdversarialNetworkModel.generatorMaximumNumberOfIterations = parameterDictionary.generatorMaximumNumberOfIterations or defaultGeneratorMaximumNumberOfIterations
	
	NewConditionalWassersteinGenerativeAdversarialNetworkModel.discriminatorMaximumNumberOfIterations = parameterDictionary.discriminatorMaximumNumberOfIterations or defaultDiscriminatorMaximumNumberOfIterations
	
	NewConditionalWassersteinGenerativeAdversarialNetworkModel.sampleSize = parameterDictionary.sampleSize or defaultSampleSize
	
	return NewConditionalWassersteinGenerativeAdversarialNetworkModel
	
end

function ConditionalWassersteinGenerativeAdversarialNetworkModel:train(realFeatureMatrix, noiseFeatureMatrix, labelMatrix)
	
	local DiscriminatorModel = self.DiscriminatorModel
	
	local GeneratorModel = self.GeneratorModel
	
	if (not DiscriminatorModel) then error("No discriminator neural network.") end
	
	if (not GeneratorModel) then error("No generator neural network.") end
	
	local numberOfFeaturesInLabelMatrix = #labelMatrix[1]
	
	local discriminatorNumberOfLayers = GeneratorModel:getNumberOfLayers()

	local generatorNumberOfLayers = GeneratorModel:getNumberOfLayers()
	
	local discriminatorInputNumberOfFeatures, discriminatorInputHasBias = DiscriminatorModel:getLayer(1)
	
	local generatorInputNumberOfFeatures, generatorInputHasBias = GeneratorModel:getLayer(1)
	
	local discriminatorOutputNumberOfFeatures, discriminatorOutputHasBias = DiscriminatorModel:getLayer(discriminatorNumberOfLayers)

	local generatorOutputNumberOfFeatures, generatorOutputHasBias = GeneratorModel:getLayer(generatorNumberOfLayers)
	
	discriminatorInputNumberOfFeatures = discriminatorInputNumberOfFeatures + ((discriminatorInputHasBias and 1) or 0)

	generatorInputNumberOfFeatures = generatorInputNumberOfFeatures + ((generatorInputHasBias and 1) or 0)
	
	discriminatorOutputNumberOfFeatures = discriminatorOutputNumberOfFeatures + ((discriminatorOutputHasBias and 1) or 0)
	
	generatorOutputNumberOfFeatures = generatorOutputNumberOfFeatures + ((generatorOutputHasBias and 1) or 0)
	
	if ((generatorOutputNumberOfFeatures + numberOfFeaturesInLabelMatrix) ~= discriminatorInputNumberOfFeatures) then error("The number of neurons at the discriminator's input layer must equal to the total of number of neurons at the generator's output layer and the number of features in label matrix.") end
	
	if (discriminatorOutputNumberOfFeatures ~= 1) then error("The number of neurons at the discriminator's output layer must be equal to 1.") end
	
	if (#realFeatureMatrix ~= #noiseFeatureMatrix) or (#realFeatureMatrix ~= #labelMatrix) then error("All matrices must contain same number of data.") end
	
	if ((#noiseFeatureMatrix[1] + numberOfFeaturesInLabelMatrix)  ~= generatorInputNumberOfFeatures) then error("The total number of columns in noise feature matrix and label matrix must contain the same number as the number of neurons in generator's input layer.") end
	
	if ((#realFeatureMatrix[1] + numberOfFeaturesInLabelMatrix) ~= discriminatorInputNumberOfFeatures) then error("The total number of columns in real feature matrix and label matrix must contain the same number as the number of neurons in discriminator's input layer.") end

	local discriminatorInputMatrix = AqwamTensorLibrary:createTensor({1, discriminatorInputNumberOfFeatures}, 1)

	local generatorInputMatrix = AqwamTensorLibrary:createTensor({1, generatorInputNumberOfFeatures}, 1)
	
	local functionToApplyToDiscriminator = function (discriminatorRealLabel, discriminatorGeneratedLabel) return -(discriminatorRealLabel - discriminatorGeneratedLabel) end
	
	local concatenatedNoiseFeatureMatrix = AqwamTensorLibrary:concatenate(noiseFeatureMatrix, labelMatrix, 2)
	
	local concatenatedRealFeatureMatrix = AqwamTensorLibrary:concatenate(realFeatureMatrix, labelMatrix,2)
	
	local generatorNumberOfIterations = 0
	
	local discriminatorNumberOfIterations = 0
	
	local generatorMaximumNumberOfIterations = self.generatorMaximumNumberOfIterations
	
	local discriminatorMaximumNumberOfIterations = self.discriminatorMaximumNumberOfIterations
	
	local sampleSize = self.sampleSize
	
	local isOutputPrinted = self.isOutputPrinted
	
	local meanDiscriminatorLossValue = 0

	repeat
		
		repeat

			task.wait()

			local realFeatureMatrixBatch, noiseFeatureMatrixBatch, labelMatrixBatch = sampleGroup(concatenatedRealFeatureMatrix, concatenatedNoiseFeatureMatrix, labelMatrix, sampleSize)

			local generatedLabelMatrixBatch = GeneratorModel:predict(noiseFeatureMatrixBatch, true)

			local concatenatedAndGeneratedLabelMatrix = AqwamTensorLibrary:concatenate(generatedLabelMatrixBatch, labelMatrixBatch, 2)

			local discriminatorGeneratedLabelMatrix = DiscriminatorModel:predict(concatenatedAndGeneratedLabelMatrix, true)

			local discriminatorRealLabelMatrix = DiscriminatorModel:predict(realFeatureMatrixBatch, true)

			local meanDiscriminatorGeneratedLabelMatrix = AqwamTensorLibrary:mean(discriminatorGeneratedLabelMatrix, 1)

			local meanDiscriminatorRealLabelMatrix = AqwamTensorLibrary:mean(discriminatorRealLabelMatrix, 1)

			local discriminatorLossMatrix = AqwamTensorLibrary:applyFunction(functionToApplyToDiscriminator, meanDiscriminatorRealLabelMatrix, meanDiscriminatorGeneratedLabelMatrix)

			DiscriminatorModel:forwardPropagate(discriminatorInputMatrix, true)

			DiscriminatorModel:update(discriminatorLossMatrix, true)

			discriminatorMaximumNumberOfIterations = discriminatorMaximumNumberOfIterations + 1
			
			meanDiscriminatorLossValue = discriminatorLossMatrix[1][1]

			if (isOutputPrinted) then print("Generator Iteration: " .. generatorNumberOfIterations .."\t\tDiscriminator Iteration: " .. discriminatorMaximumNumberOfIterations .. "\t\tDiscriminator Cost: " .. meanDiscriminatorLossValue) end

		until (discriminatorNumberOfIterations >= discriminatorMaximumNumberOfIterations) or self:checkIfTargetCostReached(meanDiscriminatorLossValue) or self:checkIfConverged(meanDiscriminatorLossValue) 

		local finalNoiseFeatureMatrixBatch, finalLabelMatrixBatch = samplePair(concatenatedNoiseFeatureMatrix, labelMatrix, sampleSize)

		local finalGeneratedLabelMatrix = GeneratorModel:predict(finalNoiseFeatureMatrixBatch, true)

		local finalConcatenatedAndGeneratedLabelMatrix = AqwamTensorLibrary:concatenate(finalGeneratedLabelMatrix, finalLabelMatrixBatch)

		local generatorLossMatrix = DiscriminatorModel:predict(finalConcatenatedAndGeneratedLabelMatrix, true)

		local meanGeneratorLossVector = AqwamTensorLibrary:mean(generatorLossMatrix, 1)

		meanGeneratorLossVector = AqwamTensorLibrary:multiply(-1, meanGeneratorLossVector)

		meanGeneratorLossVector = AqwamTensorLibrary:createTensor({1, generatorOutputNumberOfFeatures}, meanGeneratorLossVector[1][1])

		GeneratorModel:forwardPropagate(generatorInputMatrix, true)

		GeneratorModel:update(meanGeneratorLossVector, true)
		
		generatorNumberOfIterations = generatorNumberOfIterations + 1
		
	until (generatorNumberOfIterations >= generatorMaximumNumberOfIterations)
	
end

function ConditionalWassersteinGenerativeAdversarialNetworkModel:evaluate(featureMatrix, labelMatrix)

	local DiscriminatorModel = self.DiscriminatorModel

	if (not DiscriminatorModel) then error("No discriminator neural network.") end

	if (#featureMatrix ~= #labelMatrix) then error("The feature matrix and the label matrix must contain same number of data.") end

	local concatenatedMatrices = AqwamTensorLibrary:concatenate(featureMatrix, labelMatrix, 2)

	return DiscriminatorModel:predict(concatenatedMatrices, true)

end

function ConditionalWassersteinGenerativeAdversarialNetworkModel:generate(noiseFeatureMatrix, labelMatrix)

	local GeneratorModel =  self.GeneratorModel

	if (not GeneratorModel) then error("No generator neural network.") end

	if (#noiseFeatureMatrix ~= #labelMatrix) then error("The noise feature matrix and the label matrix must contain same number of data.") end

	local concatenatedMatrices = AqwamTensorLibrary:concatenate(noiseFeatureMatrix, labelMatrix, 2)

	return GeneratorModel:predict(concatenatedMatrices, true)

end

return ConditionalWassersteinGenerativeAdversarialNetworkModel]]></ProtectedString>
									<string name="ScriptGuid">{111A0885-9AE6-4461-919E-05E4A586C9B2}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ConditionalWassersteinGenerativeAdversarialNetwork</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX977382DE3E994D5E8D0DFB4983CFB860">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GenerativeAdversarialNetworkBaseModel = require(script.Parent.GenerativeAdversarialNetworkBaseModel)

WassersteinGenerativeAdversarialNetworkModel = {}

WassersteinGenerativeAdversarialNetworkModel.__index = WassersteinGenerativeAdversarialNetworkModel

setmetatable(WassersteinGenerativeAdversarialNetworkModel, GenerativeAdversarialNetworkBaseModel)

local defaultGeneratorMaximumNumberOfIterations = 50

local defaultDiscriminatorMaximumNumberOfIterations = 100

local defaultSampleSize = 3

local function sample(matrix, sampleSize)

	local matrixBatch = {}

	local numberOfData = #matrix

	for sample = 1, sampleSize, 1 do

		local randomIndex = Random.new():NextInteger(1, numberOfData)

		table.insert(matrixBatch, matrix[randomIndex])

	end

	return matrixBatch

end

function WassersteinGenerativeAdversarialNetworkModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewWassersteinGenerativeAdversarialNetworkModel = GenerativeAdversarialNetworkBaseModel.new(parameterDictionary)
	
	setmetatable(NewWassersteinGenerativeAdversarialNetworkModel, WassersteinGenerativeAdversarialNetworkModel)
	
	NewWassersteinGenerativeAdversarialNetworkModel:setName("WassersteinGenerativeAdversarialNetwork")
	
	NewWassersteinGenerativeAdversarialNetworkModel.generatorMaximumNumberOfIterations = parameterDictionary.generatorMaximumNumberOfIterations or defaultGeneratorMaximumNumberOfIterations

	NewWassersteinGenerativeAdversarialNetworkModel.discriminatorMaximumNumberOfIterations = parameterDictionary.discriminatorMaximumNumberOfIterations or defaultDiscriminatorMaximumNumberOfIterations
	
	NewWassersteinGenerativeAdversarialNetworkModel.sampleSize = parameterDictionary.sampleSize or defaultSampleSize
	
	return NewWassersteinGenerativeAdversarialNetworkModel
	
end

function WassersteinGenerativeAdversarialNetworkModel:train(realFeatureMatrix, noiseFeatureMatrix)
	
	local DiscriminatorModel = self.DiscriminatorModel
	
	local GeneratorModel = self.GeneratorModel
	
	if (not DiscriminatorModel) then error("No discriminator neural network.") end
	
	if (not GeneratorModel) then error("No generator neural network.") end
	
	local discriminatorNumberOfLayers = GeneratorModel:getNumberOfLayers()

	local generatorNumberOfLayers = GeneratorModel:getNumberOfLayers()
	
	local discriminatorInputNumberOfFeatures, discriminatorInputHasBias = DiscriminatorModel:getLayer(1)
	
	local generatorInputNumberOfFeatures, generatorInputHasBias = GeneratorModel:getLayer(1)
	
	local discriminatorOutputNumberOfFeatures, discriminatorOutputHasBias = DiscriminatorModel:getLayer(discriminatorNumberOfLayers)

	local generatorOutputNumberOfFeatures, generatorOutputHasBias = GeneratorModel:getLayer(generatorNumberOfLayers)
	
	discriminatorInputNumberOfFeatures = discriminatorInputNumberOfFeatures + ((discriminatorInputHasBias and 1) or 0)

	generatorInputNumberOfFeatures = generatorInputNumberOfFeatures + ((generatorInputHasBias and 1) or 0)
	
	discriminatorOutputNumberOfFeatures = discriminatorOutputNumberOfFeatures + ((discriminatorOutputHasBias and 1) or 0)
	
	generatorOutputNumberOfFeatures = generatorOutputNumberOfFeatures + ((generatorOutputHasBias and 1) or 0)
	
	if (generatorOutputNumberOfFeatures ~= discriminatorInputNumberOfFeatures) then error("The generator's output layer and the discriminator's input layer must contain the same number of neurons.") end
	
	if (discriminatorOutputNumberOfFeatures ~= 1) then error("The number of neurons at the discriminator's output layer must be equal to 1.") end
	
	if (#noiseFeatureMatrix[1] ~= generatorInputNumberOfFeatures) then error("The number of columns in noise feature matrix must contain the same number as the number of neurons in generator's input layer.") end
	
	if (#realFeatureMatrix[1] ~= discriminatorInputNumberOfFeatures) then error("The number of columns in real feature matrix must contain the same number as the number of neurons in discriminator's input layer.") end
	
	local discriminatorInputMatrix = AqwamTensorLibrary:createTensor({1, discriminatorInputNumberOfFeatures}, 1)

	local generatorInputMatrix = AqwamTensorLibrary:createTensor({1, generatorInputNumberOfFeatures}, 1)
	
	local functionToApplyToDiscriminator = function (discriminatorRealLabel, discriminatorGeneratedLabel) return -(discriminatorRealLabel - discriminatorGeneratedLabel) end
	
	local generatorNumberOfIterations = 0

	local discriminatorNumberOfIterations = 0

	local generatorMaximumNumberOfIterations = self.generatorMaximumNumberOfIterations

	local discriminatorMaximumNumberOfIterations = self.discriminatorMaximumNumberOfIterations
	
	local sampleSize = self.sampleSize
	
	local isOutputPrinted = self.isOutputPrinted
	
	local meanDiscriminatorLossValue = 0
	
	repeat
		
		repeat

			task.wait()

			local realFeatureMatrixBatch = sample(realFeatureMatrix, sampleSize)

			local noiseFeatureMatrixBatch = sample(noiseFeatureMatrix, sampleSize)

			local generatedLabelMatrixBatch = GeneratorModel:predict(noiseFeatureMatrix, true)

			local discriminatorGeneratedLabelMatrix = DiscriminatorModel:predict(generatedLabelMatrixBatch, true)

			local discriminatorRealLabelMatrix = DiscriminatorModel:predict(realFeatureMatrixBatch, true)

			local meanDiscriminatorGeneratedLabelMatrix = AqwamTensorLibrary:mean(discriminatorGeneratedLabelMatrix, 1)

			local meanDiscriminatorRealLabelMatrix = AqwamTensorLibrary:mean(discriminatorRealLabelMatrix, 1)

			local discriminatorLossMatrix = AqwamTensorLibrary:applyFunction(functionToApplyToDiscriminator, meanDiscriminatorRealLabelMatrix, meanDiscriminatorGeneratedLabelMatrix)

			DiscriminatorModel:forwardPropagate(discriminatorInputMatrix, true)

			DiscriminatorModel:update(discriminatorLossMatrix, true)

			discriminatorNumberOfIterations = discriminatorNumberOfIterations + 1
			
			meanDiscriminatorLossValue = discriminatorLossMatrix[1][1]

			if (isOutputPrinted) then print("Generator Iteration: " .. generatorNumberOfIterations .."\t\tDiscriminator Iteration: " .. discriminatorMaximumNumberOfIterations .. "\t\tDiscriminator Cost: " .. meanDiscriminatorLossValue) end

		until (discriminatorNumberOfIterations >= discriminatorMaximumNumberOfIterations) or self:checkIfTargetCostReached(meanDiscriminatorLossValue) or self:checkIfConverged(meanDiscriminatorLossValue) 

		local finalNoiseFeatureMatrixBatch = sample(noiseFeatureMatrix, sampleSize)

		local finalGeneratedLabelMatrix = GeneratorModel:predict(finalNoiseFeatureMatrixBatch, true)

		local generatorLossMatrix = DiscriminatorModel:predict(finalGeneratedLabelMatrix, true)

		local meanGeneratorLossVector = AqwamTensorLibrary:mean(generatorLossMatrix, 1)

		meanGeneratorLossVector = AqwamTensorLibrary:multiply(-1, meanGeneratorLossVector)

		meanGeneratorLossVector = AqwamTensorLibrary:createTensor({1, generatorOutputNumberOfFeatures}, meanGeneratorLossVector[1][1])

		GeneratorModel:forwardPropagate(generatorInputMatrix, true)

		GeneratorModel:update(meanGeneratorLossVector, true)
		
		generatorNumberOfIterations = generatorNumberOfIterations + 1
		
	until (generatorNumberOfIterations >= generatorMaximumNumberOfIterations)
	
end

function WassersteinGenerativeAdversarialNetworkModel:evaluate(featureMatrix)

	local DiscriminatorModel = self.DiscriminatorModel

	if (not DiscriminatorModel) then error("No discriminator neural network.") end

	return DiscriminatorModel:predict(featureMatrix, true)

end

function WassersteinGenerativeAdversarialNetworkModel:generate(noiseFeatureMatrix)

	local GeneratorModel =  self.GeneratorModel

	if (not GeneratorModel) then error("No generator neural network.") end

	return GeneratorModel:predict(noiseFeatureMatrix, true)

end

return WassersteinGenerativeAdversarialNetworkModel]]></ProtectedString>
									<string name="ScriptGuid">{D87BD7A5-669C-467B-B323-F08D41308C9B}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">WassersteinGenerativeAdversarialNetwork</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD465844054FB4006BB040794230B4D84">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GenerativeAdversarialNetworkBaseModel = require(script.Parent.GenerativeAdversarialNetworkBaseModel)

ConditionalGenerativeAdversarialNetworkModel = {}

ConditionalGenerativeAdversarialNetworkModel.__index = ConditionalGenerativeAdversarialNetworkModel

setmetatable(ConditionalGenerativeAdversarialNetworkModel, GenerativeAdversarialNetworkBaseModel)

function ConditionalGenerativeAdversarialNetworkModel.new(parameterDictionary)
	
	local NewConditionalGenerativeAdversarialNetworkModel = GenerativeAdversarialNetworkBaseModel.new(parameterDictionary)
	
	setmetatable(NewConditionalGenerativeAdversarialNetworkModel, ConditionalGenerativeAdversarialNetworkModel)
	
	NewConditionalGenerativeAdversarialNetworkModel:setName("ConditionalGenerativeAdversarialNetwork")
	
	return NewConditionalGenerativeAdversarialNetworkModel
	
end

function ConditionalGenerativeAdversarialNetworkModel:train(realFeatureMatrix, noiseFeatureMatrix, labelMatrix)
	
	local DiscriminatorModel = self.DiscriminatorModel
	
	local GeneratorModel = self.GeneratorModel
	
	if (not DiscriminatorModel) then error("No discriminator neural network.") end
	
	if (not GeneratorModel) then error("No generator neural network.") end
	
	local numberOfFeaturesInLabelMatrix = #labelMatrix[1]
	
	local discriminatorNumberOfLayers = GeneratorModel:getNumberOfLayers()

	local generatorNumberOfLayers = GeneratorModel:getNumberOfLayers()
	
	local discriminatorInputNumberOfFeatures, discriminatorInputHasBias = DiscriminatorModel:getLayer(1)
	
	local generatorInputNumberOfFeatures, generatorInputHasBias = GeneratorModel:getLayer(1)
	
	local discriminatorOutputNumberOfFeatures, discriminatorOutputHasBias = DiscriminatorModel:getLayer(discriminatorNumberOfLayers)

	local generatorOutputNumberOfFeatures, generatorOutputHasBias = GeneratorModel:getLayer(generatorNumberOfLayers)
	
	discriminatorInputNumberOfFeatures = discriminatorInputNumberOfFeatures + ((discriminatorInputHasBias and 1) or 0)

	generatorInputNumberOfFeatures = generatorInputNumberOfFeatures + ((generatorInputHasBias and 1) or 0)
	
	discriminatorOutputNumberOfFeatures = discriminatorOutputNumberOfFeatures + ((discriminatorOutputHasBias and 1) or 0)
	
	generatorOutputNumberOfFeatures = generatorOutputNumberOfFeatures + ((generatorOutputHasBias and 1) or 0)
	
	if ((generatorOutputNumberOfFeatures + numberOfFeaturesInLabelMatrix) ~= discriminatorInputNumberOfFeatures) then error("The number of neurons at the discriminator's input layer must equal to the total of number of neurons at the generator's output layer and the number of features in label matrix.") end
	
	if (discriminatorOutputNumberOfFeatures ~= 1) then error("The number of neurons at the discriminator's output layer must be equal to 1.") end
	
	if (#realFeatureMatrix ~= #noiseFeatureMatrix) or (#realFeatureMatrix ~= #labelMatrix) then error("All matrices must contain same number of data.") end
	
	if ((#noiseFeatureMatrix[1] + numberOfFeaturesInLabelMatrix)  ~= generatorInputNumberOfFeatures) then error("The total number of columns in noise feature matrix and label matrix must contain the same number as the number of neurons in generator's input layer.") end
	
	if ((#realFeatureMatrix[1] + numberOfFeaturesInLabelMatrix) ~= discriminatorInputNumberOfFeatures) then error("The total number of columns in real feature matrix and label matrix must contain the same number as the number of neurons in discriminator's input layer.") end

	local discriminatorInputMatrix = AqwamTensorLibrary:createTensor({1, discriminatorInputNumberOfFeatures}, 1)

	local generatorInputMatrix = AqwamTensorLibrary:createTensor({1, generatorInputNumberOfFeatures}, 1)
	
	local functionToApplyToDiscriminator = function (discriminatorRealLabel, discriminatorGeneratedLabel) return -(math.log(discriminatorRealLabel) + math.log(1 - discriminatorGeneratedLabel)) end
	
	local functionToApplyToGenerator = function (discriminatorGeneratedLabel) return math.log(1 - discriminatorGeneratedLabel) end
	
	local concatenatedNoiseFeatureMatrix = AqwamTensorLibrary:concatenate(noiseFeatureMatrix, labelMatrix, 2)
	
	local concatenatedRealFeatureMatrix = AqwamTensorLibrary:concatenate(realFeatureMatrix, labelMatrix, 2)
	
	local numberOfIterations = 0
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local isOutputPrinted = self.isOutputPrinted
	
	local meanDiscriminatorLossValue = 0

	repeat
		
		task.wait()
		
		local generatedLabelMatrix = GeneratorModel:predict(concatenatedNoiseFeatureMatrix, true)
		
		local concatenatedAndGeneratedLabelMatrix = AqwamTensorLibrary:concatenate(generatedLabelMatrix, labelMatrix, 2)
		
		local discriminatorGeneratedLabelMatrix = DiscriminatorModel:predict(concatenatedAndGeneratedLabelMatrix, true)
		
		local discriminatorRealLabelMatrix = DiscriminatorModel:predict(concatenatedRealFeatureMatrix, true)
		
		local discriminatorLossMatrix = AqwamTensorLibrary:applyFunction(functionToApplyToDiscriminator, discriminatorRealLabelMatrix, discriminatorGeneratedLabelMatrix)
		
		local generatorLossMatrix = AqwamTensorLibrary:applyFunction(functionToApplyToGenerator, discriminatorGeneratedLabelMatrix)
		
		local meanDiscriminatorLossMatrix = AqwamTensorLibrary:mean(discriminatorLossMatrix, 1)
		
		local meanGeneratorLossMatrix = AqwamTensorLibrary:mean(generatorLossMatrix, 1)
		
		meanGeneratorLossMatrix = AqwamTensorLibrary:createTensor({1, generatorOutputNumberOfFeatures}, meanGeneratorLossMatrix[1][1])
		
		DiscriminatorModel:forwardPropagate(discriminatorInputMatrix, true)
		
		DiscriminatorModel:update(meanDiscriminatorLossMatrix, true)
		
		GeneratorModel:forwardPropagate(generatorInputMatrix, true)
		
		GeneratorModel:update(meanGeneratorLossMatrix, true)
		
		numberOfIterations = numberOfIterations + 1
			
		meanDiscriminatorLossValue = meanDiscriminatorLossMatrix[1][1]
		
		if (isOutputPrinted) then print("Iteration: " .. numberOfIterations .. "\t\tDiscriminator Cost: " .. meanDiscriminatorLossValue) end
		
	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(meanDiscriminatorLossValue) or self:checkIfConverged(meanDiscriminatorLossValue) 
	
end

function ConditionalGenerativeAdversarialNetworkModel:evaluate(featureMatrix, labelMatrix)
	
	local DiscriminatorModel = self.DiscriminatorModel

	if (not DiscriminatorModel) then error("No discriminator neural network.") end
	
	if (#featureMatrix ~= #labelMatrix) then error("The feature matrix and the label matrix must contain same number of data.") end
	
	local concatenatedMatrices = AqwamTensorLibrary:concatenate(featureMatrix, labelMatrix, 2)
	
	return DiscriminatorModel:predict(concatenatedMatrices, true)
	
end

function ConditionalGenerativeAdversarialNetworkModel:generate(noiseFeatureMatrix, labelMatrix)
	
	local GeneratorModel =  self.GeneratorModel

	if (not GeneratorModel) then error("No generator neural network.") end
	
	if (#noiseFeatureMatrix ~= #labelMatrix) then error("The noise feature matrix and the label matrix must contain same number of data.") end

	local concatenatedMatrices = AqwamTensorLibrary:concatenate(noiseFeatureMatrix, labelMatrix, 2)
	
	return GeneratorModel:predict(concatenatedMatrices, true)
	
end

return ConditionalGenerativeAdversarialNetworkModel]]></ProtectedString>
									<string name="ScriptGuid">{9A60A96C-68AB-47C2-8775-8EA7DA199BA9}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ConditionalGenerativeAdversarialNetwork</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA62B8298D3594C5ABF821212ED063322">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict-Neural/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local GenerativeAdversarialNetworkBaseModel = {}

GenerativeAdversarialNetworkBaseModel.__index = GenerativeAdversarialNetworkBaseModel

setmetatable(GenerativeAdversarialNetworkBaseModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 1000

function GenerativeAdversarialNetworkBaseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations
	
	local NewGenerativeAdversarialNetworkBaseModel = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewGenerativeAdversarialNetworkBaseModel, GenerativeAdversarialNetworkBaseModel)
	
	NewGenerativeAdversarialNetworkBaseModel:setName("GenerativeAdversarialNetworkBaseModel")
	
	NewGenerativeAdversarialNetworkBaseModel:setClassName("GenerativeAdversarialNetworkModel")
	
	NewGenerativeAdversarialNetworkBaseModel.DiscriminatorModel = parameterDictionary.DiscriminatorModel
	
	NewGenerativeAdversarialNetworkBaseModel.GeneratorModel = parameterDictionary.GeneratorModel
	
	return NewGenerativeAdversarialNetworkBaseModel
	
end

function GenerativeAdversarialNetworkBaseModel:setDiscriminatorModel(DiscriminatorModel)

	self.DiscriminatorModel = DiscriminatorModel

end

function GenerativeAdversarialNetworkBaseModel:setGeneratorModel(GeneratorModel)

	self.GeneratorModel = GeneratorModel

end

function GenerativeAdversarialNetworkBaseModel:getDiscriminatorModel()

	return self.DiscriminatorModel

end

function GenerativeAdversarialNetworkBaseModel:getGeneratorModel()

	return self.GeneratorModel

end

return GenerativeAdversarialNetworkBaseModel]]></ProtectedString>
									<string name="ScriptGuid">{A6B9C9E7-8683-4431-ABB3-49493AC35015}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">GenerativeAdversarialNetworkBaseModel</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX971C7DEF173D4977B3743584C0DE03C9">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibraryLinker = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GenerativeAdversarialNetworkBaseModel = require(script.Parent.GenerativeAdversarialNetworkBaseModel)

GenerativeAdversarialNetworkModel = {}

GenerativeAdversarialNetworkModel.__index = GenerativeAdversarialNetworkModel

setmetatable(GenerativeAdversarialNetworkModel, GenerativeAdversarialNetworkBaseModel)

function GenerativeAdversarialNetworkModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewGenerativeAdversarialNetworkModel = GenerativeAdversarialNetworkBaseModel.new(parameterDictionary)
	
	setmetatable(NewGenerativeAdversarialNetworkModel, GenerativeAdversarialNetworkModel)
	
	NewGenerativeAdversarialNetworkModel:setName("GenerativeAdversarialNetwork")
	
	NewGenerativeAdversarialNetworkModel.GeneratorModel = parameterDictionary.GeneratorModel
	
	NewGenerativeAdversarialNetworkModel.DiscriminatorModel = parameterDictionary.GeneratorModel
	
	return NewGenerativeAdversarialNetworkModel
	
end

function GenerativeAdversarialNetworkModel:train(realFeatureMatrix, noiseFeatureMatrix)
	
	local DiscriminatorModel = self.DiscriminatorModel
	
	local GeneratorModel = self.GeneratorModel
	
	if (not DiscriminatorModel) then error("No discriminator neural network.") end
	
	if (not GeneratorModel) then error("No generator neural network.") end
	
	local discriminatorNumberOfLayers = GeneratorModel:getNumberOfLayers()

	local generatorNumberOfLayers = GeneratorModel:getNumberOfLayers()
	
	local discriminatorInputNumberOfFeatures, discriminatorInputHasBias = DiscriminatorModel:getLayer(1)
	
	local generatorInputNumberOfFeatures, generatorInputHasBias = GeneratorModel:getLayer(1)
	
	local discriminatorOutputNumberOfFeatures, discriminatorOutputHasBias = DiscriminatorModel:getLayer(discriminatorNumberOfLayers)

	local generatorOutputNumberOfFeatures, generatorOutputHasBias = GeneratorModel:getLayer(generatorNumberOfLayers)
	
	discriminatorInputNumberOfFeatures = discriminatorInputNumberOfFeatures + ((discriminatorInputHasBias and 1) or 0)

	generatorInputNumberOfFeatures = generatorInputNumberOfFeatures + ((generatorInputHasBias and 1) or 0)
	
	discriminatorOutputNumberOfFeatures = discriminatorOutputNumberOfFeatures + ((discriminatorOutputHasBias and 1) or 0)
	
	generatorOutputNumberOfFeatures = generatorOutputNumberOfFeatures + ((generatorOutputHasBias and 1) or 0)
	
	if (generatorOutputNumberOfFeatures ~= discriminatorInputNumberOfFeatures) then error("The generator's output layer and the discriminator's input layer must contain the same number of neurons.") end
	
	if (discriminatorOutputNumberOfFeatures ~= 1) then error("The number of neurons at the discriminator's output layer must be equal to 1.") end
	
	if (#realFeatureMatrix ~= #noiseFeatureMatrix) then error("Both feature matrices must contain same number of data.") end
	
	if (#noiseFeatureMatrix[1] ~= generatorInputNumberOfFeatures) then error("The number of columns in noise feature matrix must contain the same number as the number of neurons in generator's input layer.") end
	
	if (#realFeatureMatrix[1] ~= discriminatorInputNumberOfFeatures) then error("The number of columns in real feature matrix must contain the same number as the number of neurons in discriminator's input layer.") end

	local discriminatorInputMatrix = AqwamTensorLibraryLinker:createTensor({1, discriminatorInputNumberOfFeatures}, 1)

	local generatorInputMatrix = AqwamTensorLibraryLinker:createTensor({1, generatorInputNumberOfFeatures}, 1)
	
	local functionToApplyToDiscriminator = function (discriminatorRealLabel, discriminatorGeneratedLabel) return -(math.log(discriminatorRealLabel) + math.log(1 - discriminatorGeneratedLabel)) end
	
	local functionToApplyToGenerator = function (discriminatorGeneratedLabel) return math.log(1 - discriminatorGeneratedLabel) end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local isOutputPrinted = self.isOutputPrinted
	
	local numberOfIterations = 0
	
	local meanDiscriminatorLossValue = 0

	repeat
		
		task.wait()
		
		local generatedLabelMatrix = GeneratorModel:predict(noiseFeatureMatrix, true)
		
		local discriminatorGeneratedLabelMatrix = DiscriminatorModel:predict(generatedLabelMatrix, true)
		
		local discriminatorRealLabelMatrix = DiscriminatorModel:predict(realFeatureMatrix, true)
		
		local discriminatorLossMatrix = AqwamTensorLibraryLinker:applyFunction(functionToApplyToDiscriminator, discriminatorRealLabelMatrix, discriminatorGeneratedLabelMatrix)
		
		local generatorLossMatrix = AqwamTensorLibraryLinker:applyFunction(functionToApplyToGenerator, discriminatorGeneratedLabelMatrix)
		
		local meanDiscriminatorLossMatrix = AqwamTensorLibraryLinker:mean(discriminatorLossMatrix, 1)
		
		local meanGeneratorLossMatrix = AqwamTensorLibraryLinker:mean(generatorLossMatrix, 1)
		
		meanGeneratorLossMatrix = AqwamTensorLibraryLinker:createTensor({1, generatorOutputNumberOfFeatures}, meanGeneratorLossMatrix[1][1])
		
		DiscriminatorModel:forwardPropagate(discriminatorInputMatrix, true)
		
		DiscriminatorModel:update(meanDiscriminatorLossMatrix, true)
		
		GeneratorModel:forwardPropagate(generatorInputMatrix, true)
		
		GeneratorModel:update(meanGeneratorLossMatrix, true)
		
		numberOfIterations = numberOfIterations + 1
		
		meanDiscriminatorLossValue =  meanDiscriminatorLossMatrix[1][1]
		
		if (isOutputPrinted) then print("Iteration: " .. numberOfIterations .. "\t\tDiscriminator Cost: " .. meanDiscriminatorLossValue) end
		
	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(meanDiscriminatorLossValue) or self:checkIfConverged(meanDiscriminatorLossValue) 
	
end

function GenerativeAdversarialNetworkModel:evaluate(featureMatrix)
	
	local DiscriminatorModel = self.DiscriminatorModel
	
	if (not DiscriminatorModel) then error("No discriminator neural network.") end
	
	return DiscriminatorModel:predict(featureMatrix, true)
	
end

function GenerativeAdversarialNetworkModel:generate(noiseFeatureMatrix)
	
	local GeneratorModel =  self.GeneratorModel
	
	if (not GeneratorModel) then error("No generator neural network.") end
	
	return GeneratorModel:predict(noiseFeatureMatrix, true)
	
end

return GenerativeAdversarialNetworkModel]]></ProtectedString>
									<string name="ScriptGuid">{5682030F-1C46-4708-8A7D-8EFFC99A8671}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">GenerativeAdversarialNetwork</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX72D082DB0B4343EB870BFA0DEB412117">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningActorCriticBaseModel = require(script.Parent.DeepReinforcementLearningActorCriticBaseModel)

ProximalPolicyOptimizationClipModel = {}

ProximalPolicyOptimizationClipModel.__index = ProximalPolicyOptimizationClipModel

setmetatable(ProximalPolicyOptimizationClipModel, DeepReinforcementLearningActorCriticBaseModel)

local defaultClipRatio = 0.3

local defaultLambda = 0

local function calculateCategoricalProbability(valueVector)

	local highestActionValue = AqwamTensorLibrary:findMaximumValue(valueVector)

	local subtractedZVector = AqwamTensorLibrary:subtract(valueVector, highestActionValue)

	local exponentValueVector = AqwamTensorLibrary:applyFunction(math.exp, subtractedZVector)

	local exponentValueSumVector = AqwamTensorLibrary:sum(exponentValueVector, 2)

	local targetActionVector = AqwamTensorLibrary:divide(exponentValueVector, exponentValueSumVector)

	return targetActionVector

end

local function calculateDiagonalGaussianProbability(meanVector, standardDeviationVector, noiseVector)

	local valueVectorPart1 = AqwamTensorLibrary:multiply(standardDeviationVector, noiseVector)

	local valueVector = AqwamTensorLibrary:add(meanVector, valueVectorPart1)

	local zScoreVectorPart1 = AqwamTensorLibrary:subtract(valueVector, meanVector)

	local zScoreVector = AqwamTensorLibrary:divide(zScoreVectorPart1, standardDeviationVector)

	local squaredZScoreVector = AqwamTensorLibrary:power(zScoreVector, 2)

	local logValueVectorPart1 = AqwamTensorLibrary:logarithm(standardDeviationVector)

	local logValueVectorPart2 = AqwamTensorLibrary:multiply(2, logValueVectorPart1)

	local logValueVectorPart3 = AqwamTensorLibrary:add(squaredZScoreVector, logValueVectorPart2)

	local logValueVector = AqwamTensorLibrary:add(logValueVectorPart3, math.log(2 * math.pi))

	return logValueVector

end

local function calculateRewardToGo(rewardHistory, discountFactor)

	local rewardToGoArray = {}

	local discountedReward = 0

	for h = #rewardHistory, 1, -1 do

		discountedReward = rewardHistory[h] + (discountFactor * discountedReward)

		table.insert(rewardToGoArray, 1, discountedReward)

	end

	return rewardToGoArray

end

function ProximalPolicyOptimizationClipModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewProximalPolicyOptimizationClipModel = DeepReinforcementLearningActorCriticBaseModel.new(parameterDictionary)

	setmetatable(NewProximalPolicyOptimizationClipModel, ProximalPolicyOptimizationClipModel)

	NewProximalPolicyOptimizationClipModel:setName("ProximalPolicyOptimizationClip")

	NewProximalPolicyOptimizationClipModel.clipRatio = parameterDictionary.clipRatio or defaultClipRatio

	NewProximalPolicyOptimizationClipModel.lambda = parameterDictionary.lambda or defaultLambda

	NewProximalPolicyOptimizationClipModel.CurrentActorModelParameters = parameterDictionary.CurrentActorModelParameters

	NewProximalPolicyOptimizationClipModel.OldActorModelParameters = parameterDictionary.OldActorModelParameters

	local featureVectorHistory = {}

	local ratioActionProbabiltyVectorHistory = {}

	local rewardValueHistory = {}

	local criticValueHistory = {}

	local advantageValueHistory = {}

	NewProximalPolicyOptimizationClipModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

		local ActorModel = NewProximalPolicyOptimizationClipModel.ActorModel

		local CriticModel = NewProximalPolicyOptimizationClipModel.CriticModel

		NewProximalPolicyOptimizationClipModel.CurrentActorModelParameters = ActorModel:getModelParameters(true)

		ActorModel:setModelParameters(NewProximalPolicyOptimizationClipModel.OldActorModelParameters, true)

		local oldPolicyActionVector = ActorModel:forwardPropagate(previousFeatureVector)

		NewProximalPolicyOptimizationClipModel.OldActorModelParameters = ActorModel:getModelParameters(true)

		local oldPolicyActionProbabilityVector = calculateCategoricalProbability(oldPolicyActionVector)

		ActorModel:setModelParameters(NewProximalPolicyOptimizationClipModel.CurrentActorModelParameters, true)

		local currentPolicyActionVector = ActorModel:forwardPropagate(previousFeatureVector)

		local currentPolicyActionProbabilityVector = calculateCategoricalProbability(currentPolicyActionVector)

		local ratioActionProbabiltyVector = AqwamTensorLibrary:divide(currentPolicyActionProbabilityVector, oldPolicyActionProbabilityVector)

		local previousCriticValue = CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		local currentCriticValue = CriticModel:forwardPropagate(currentFeatureVector)[1][1]

		local advantageValue = rewardValue + (NewProximalPolicyOptimizationClipModel.discountFactor * (1 - terminalStateValue) * currentCriticValue) - previousCriticValue

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(ratioActionProbabiltyVectorHistory, ratioActionProbabiltyVector)

		table.insert(rewardValueHistory, rewardValue)

		table.insert(criticValueHistory, previousCriticValue)

		table.insert(advantageValueHistory, advantageValue)

		return advantageValue

	end)

	NewProximalPolicyOptimizationClipModel:setDiagonalGaussianUpdateFunction(function(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

		if (not actionNoiseVector) then actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]}) end

		local ActorModel = NewProximalPolicyOptimizationClipModel.ActorModel

		local CriticModel = NewProximalPolicyOptimizationClipModel.CriticModel

		NewProximalPolicyOptimizationClipModel.CurrentActorModelParameters = ActorModel:getModelParameters(true)

		ActorModel:setModelParameters(NewProximalPolicyOptimizationClipModel.OldActorModelParameters, true)

		local oldPolicyActionMeanVector = ActorModel:forwardPropagate(previousFeatureVector)

		NewProximalPolicyOptimizationClipModel.OldActorModelParameters = ActorModel:getModelParameters(true)

		local oldPolicyActionProbabilityVector = calculateDiagonalGaussianProbability(oldPolicyActionMeanVector, actionStandardDeviationVector, actionNoiseVector)

		local currentPolicyActionProbabilityVector = calculateDiagonalGaussianProbability(actionMeanVector, actionStandardDeviationVector, actionNoiseVector)

		local ratioActionProbabiltyVector = AqwamTensorLibrary:divide(currentPolicyActionProbabilityVector, oldPolicyActionProbabilityVector)

		local previousCriticValue = CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		local currentCriticValue = CriticModel:forwardPropagate(currentFeatureVector)[1][1]

		local advantageValue = rewardValue + (NewProximalPolicyOptimizationClipModel.discountFactor * (1 - terminalStateValue) * currentCriticValue) - previousCriticValue

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(ratioActionProbabiltyVectorHistory, ratioActionProbabiltyVector)

		table.insert(rewardValueHistory, rewardValue)

		table.insert(criticValueHistory, previousCriticValue)

		table.insert(advantageValueHistory, advantageValue)

		return advantageValue

	end)

	NewProximalPolicyOptimizationClipModel:setEpisodeUpdateFunction(function(terminalStateValue)

		local ActorModel = NewProximalPolicyOptimizationClipModel.ActorModel

		local CriticModel = NewProximalPolicyOptimizationClipModel.CriticModel

		local discountFactor = NewProximalPolicyOptimizationClipModel.discountFactor

		local lambda = NewProximalPolicyOptimizationClipModel.lambda

		if (lambda ~= 0) then

			local generalizedAdvantageEstimationValue = 0

			local generalizedAdvantageEstimationHistory = {}

			for t = #advantageValueHistory, 1, -1 do

				generalizedAdvantageEstimationValue = advantageValueHistory[t] + (discountFactor * lambda * generalizedAdvantageEstimationValue)

				table.insert(generalizedAdvantageEstimationHistory, 1, generalizedAdvantageEstimationValue) -- Insert at the beginning to maintain order

			end

			advantageValueHistory = generalizedAdvantageEstimationHistory

		end

		local rewardToGoArray = calculateRewardToGo(rewardValueHistory, discountFactor)

		NewProximalPolicyOptimizationClipModel.OldActorModelParameters = NewProximalPolicyOptimizationClipModel.CurrentActorModelParameters

		ActorModel:setModelParameters(NewProximalPolicyOptimizationClipModel.CurrentActorModelParameters, true)
		
		local clipRatio = NewProximalPolicyOptimizationClipModel.clipRatio 

		local lowerClipRatioValue = 1 - clipRatio

		local upperClipRatioValue = 1 + clipRatio
		
		local ratioValueModifierFunction = function(ratioValue) -- This is for the gradient of Proximal Policy Optimization clipped loss.

			return ((ratioValue >= lowerClipRatioValue) and (ratioValue <= upperClipRatioValue) and ratioValue) or 0

		end

		for h, featureVector in ipairs(featureVectorHistory) do

			local ratioActionProbabilityVector = AqwamTensorLibrary:applyFunction(ratioValueModifierFunction, ratioActionProbabiltyVectorHistory[h])

			local actorLossVector = AqwamTensorLibrary:multiply(advantageValueHistory[h], ratioActionProbabilityVector)

			local criticLoss = criticValueHistory[h] - rewardToGoArray[h]

			actorLossVector = AqwamTensorLibrary:unaryMinus(actorLossVector)

			ActorModel:forwardPropagate(featureVector, true)

			CriticModel:forwardPropagate(featureVector, true)

			ActorModel:update(actorLossVector, true)

			CriticModel:update(criticLoss, true)

		end

		NewProximalPolicyOptimizationClipModel.CurrentActorModelParameters = ActorModel:getModelParameters(true)

		table.clear(featureVectorHistory)

		table.clear(ratioActionProbabiltyVectorHistory)

		table.clear(rewardValueHistory)

		table.clear(criticValueHistory)

		table.clear(advantageValueHistory)

	end)

	NewProximalPolicyOptimizationClipModel:setResetFunction(function()

		table.clear(featureVectorHistory)

		table.clear(ratioActionProbabiltyVectorHistory)

		table.clear(rewardValueHistory)

		table.clear(criticValueHistory)

		table.clear(advantageValueHistory)

	end)

	return NewProximalPolicyOptimizationClipModel

end

return ProximalPolicyOptimizationClipModel]]></ProtectedString>
									<string name="ScriptGuid">{27581F70-4C26-4EBC-A220-223CB68EA6E8}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ProximalPolicyOptimizationClip</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC4108FDAE33743EDBD7C04BD08352520">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningActorCriticBaseModel = require(script.Parent.DeepReinforcementLearningActorCriticBaseModel)

ProximalPolicyOptimizationModel = {}

ProximalPolicyOptimizationModel.__index = ProximalPolicyOptimizationModel

setmetatable(ProximalPolicyOptimizationModel, DeepReinforcementLearningActorCriticBaseModel)

local defaultClipRatio = 0.3

local defaultLambda = 0

local function calculateCategoricalProbability(valueVector)

	local highestActionValue = AqwamTensorLibrary:findMaximumValue(valueVector)

	local subtractedZVector = AqwamTensorLibrary:subtract(valueVector, highestActionValue)

	local exponentValueVector = AqwamTensorLibrary:applyFunction(math.exp, subtractedZVector)

	local exponentValueSumVector = AqwamTensorLibrary:sum(exponentValueVector, 2)

	local targetActionVector = AqwamTensorLibrary:divide(exponentValueVector, exponentValueSumVector)

	return targetActionVector

end

local function calculateDiagonalGaussianProbability(meanVector, standardDeviationVector, noiseVector)

	local valueVectorPart1 = AqwamTensorLibrary:multiply(standardDeviationVector, noiseVector)

	local valueVector = AqwamTensorLibrary:add(meanVector, valueVectorPart1)

	local zScoreVectorPart1 = AqwamTensorLibrary:subtract(valueVector, meanVector)

	local zScoreVector = AqwamTensorLibrary:divide(zScoreVectorPart1, standardDeviationVector)

	local squaredZScoreVector = AqwamTensorLibrary:power(zScoreVector, 2)

	local logValueVectorPart1 = AqwamTensorLibrary:logarithm(standardDeviationVector)

	local logValueVectorPart2 = AqwamTensorLibrary:multiply(2, logValueVectorPart1)

	local logValueVectorPart3 = AqwamTensorLibrary:add(squaredZScoreVector, logValueVectorPart2)

	local logValueVector = AqwamTensorLibrary:add(logValueVectorPart3, math.log(2 * math.pi))

	return logValueVector

end

local function calculateRewardToGo(rewardHistory, discountFactor)

	local rewardToGoArray = {}

	local discountedReward = 0

	for h = #rewardHistory, 1, -1 do

		discountedReward = rewardHistory[h] + (discountFactor * discountedReward)

		table.insert(rewardToGoArray, 1, discountedReward)

	end

	return rewardToGoArray

end

function ProximalPolicyOptimizationModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewProximalPolicyOptimizationModel = DeepReinforcementLearningActorCriticBaseModel.new(parameterDictionary)

	setmetatable(NewProximalPolicyOptimizationModel, ProximalPolicyOptimizationModel)

	NewProximalPolicyOptimizationModel:setName("ProximalPolicyOptimization")

	NewProximalPolicyOptimizationModel.lambda = parameterDictionary.lambda or defaultLambda

	NewProximalPolicyOptimizationModel.CurrentActorModelParameters = parameterDictionary.CurrentActorModelParameters

	NewProximalPolicyOptimizationModel.OldActorModelParameters = parameterDictionary.OldActorModelParameters

	local featureVectorHistory = {}

	local ratioActionProbabiltyVectorHistory = {}

	local rewardValueHistory = {}

	local criticValueHistory = {}

	local advantageValueHistory = {}

	NewProximalPolicyOptimizationModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

		local ActorModel = NewProximalPolicyOptimizationModel.ActorModel

		local CriticModel = NewProximalPolicyOptimizationModel.CriticModel

		NewProximalPolicyOptimizationModel.CurrentActorModelParameters = ActorModel:getModelParameters(true)

		ActorModel:setModelParameters(NewProximalPolicyOptimizationModel.OldActorModelParameters, true)

		local oldPolicyActionVector = ActorModel:forwardPropagate(previousFeatureVector)

		NewProximalPolicyOptimizationModel.OldActorModelParameters = ActorModel:getModelParameters(true)

		local oldPolicyActionProbabilityVector = calculateCategoricalProbability(oldPolicyActionVector)

		ActorModel:setModelParameters(NewProximalPolicyOptimizationModel.CurrentActorModelParameters, true)

		local currentPolicyActionVector = ActorModel:forwardPropagate(previousFeatureVector)

		local currentPolicyActionProbabilityVector = calculateCategoricalProbability(currentPolicyActionVector)

		local ratioActionProbabiltyVector = AqwamTensorLibrary:divide(currentPolicyActionProbabilityVector, oldPolicyActionProbabilityVector)

		local previousCriticValue = CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		local currentCriticValue = CriticModel:forwardPropagate(currentFeatureVector)[1][1]

		local advantageValue = rewardValue + (NewProximalPolicyOptimizationModel.discountFactor * (1 - terminalStateValue) * currentCriticValue) - previousCriticValue

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(ratioActionProbabiltyVectorHistory, ratioActionProbabiltyVector)

		table.insert(rewardValueHistory, rewardValue)

		table.insert(criticValueHistory, previousCriticValue)

		table.insert(advantageValueHistory, advantageValue)

		return advantageValue

	end)

	NewProximalPolicyOptimizationModel:setDiagonalGaussianUpdateFunction(function(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

		if (not actionNoiseVector) then actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]}) end

		local ActorModel = NewProximalPolicyOptimizationModel.ActorModel

		local CriticModel = NewProximalPolicyOptimizationModel.CriticModel

		NewProximalPolicyOptimizationModel.CurrentActorModelParameters = ActorModel:getModelParameters(true)

		ActorModel:setModelParameters(NewProximalPolicyOptimizationModel.OldActorModelParameters, true)

		local oldPolicyActionMeanVector = ActorModel:forwardPropagate(previousFeatureVector)

		NewProximalPolicyOptimizationModel.OldActorModelParameters = ActorModel:getModelParameters(true)

		local oldPolicyActionProbabilityVector = calculateDiagonalGaussianProbability(oldPolicyActionMeanVector, actionStandardDeviationVector, actionNoiseVector)

		local currentPolicyActionProbabilityVector = calculateDiagonalGaussianProbability(actionMeanVector, actionStandardDeviationVector, actionNoiseVector)

		local ratioActionProbabiltyVector = AqwamTensorLibrary:divide(currentPolicyActionProbabilityVector, oldPolicyActionProbabilityVector)

		local previousCriticValue = CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		local currentCriticValue = CriticModel:forwardPropagate(currentFeatureVector)[1][1]

		local advantageValue = rewardValue + (NewProximalPolicyOptimizationModel.discountFactor * (1 - terminalStateValue) * currentCriticValue) - previousCriticValue

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(ratioActionProbabiltyVectorHistory, ratioActionProbabiltyVector)

		table.insert(rewardValueHistory, rewardValue)

		table.insert(criticValueHistory, previousCriticValue)

		table.insert(advantageValueHistory, advantageValue)

		return advantageValue

	end)

	NewProximalPolicyOptimizationModel:setEpisodeUpdateFunction(function(terminalStateValue)

		local ActorModel = NewProximalPolicyOptimizationModel.ActorModel

		local CriticModel = NewProximalPolicyOptimizationModel.CriticModel

		local discountFactor = NewProximalPolicyOptimizationModel.discountFactor

		local lambda = NewProximalPolicyOptimizationModel.lambda

		if (lambda ~= 0) then

			local generalizedAdvantageEstimationValue = 0

			local generalizedAdvantageEstimationHistory = {}

			for t = #advantageValueHistory, 1, -1 do

				generalizedAdvantageEstimationValue = advantageValueHistory[t] + (discountFactor * lambda * generalizedAdvantageEstimationValue)

				table.insert(generalizedAdvantageEstimationHistory, 1, generalizedAdvantageEstimationValue) -- Insert at the beginning to maintain order

			end

			advantageValueHistory = generalizedAdvantageEstimationHistory

		end

		local rewardToGoArray = calculateRewardToGo(rewardValueHistory, discountFactor)

		NewProximalPolicyOptimizationModel.OldActorModelParameters = NewProximalPolicyOptimizationModel.CurrentActorModelParameters

		ActorModel:setModelParameters(NewProximalPolicyOptimizationModel.CurrentActorModelParameters, true)

		for h, featureVector in ipairs(featureVectorHistory) do

			local ratioActionProbabilityVector = ratioActionProbabiltyVectorHistory[h]

			local advantageValue = advantageValueHistory[h]

			local actorLossVector = AqwamTensorLibrary:multiply(ratioActionProbabilityVector, advantageValue)

			local criticLoss = criticValueHistory[h] - rewardToGoArray[h]

			actorLossVector = AqwamTensorLibrary:unaryMinus(actorLossVector)

			ActorModel:forwardPropagate(featureVector, true)

			CriticModel:forwardPropagate(featureVector, true)

			ActorModel:update(actorLossVector, true)

			CriticModel:update(criticLoss, true)

		end

		NewProximalPolicyOptimizationModel.CurrentActorModelParameters = ActorModel:getModelParameters(true)

		table.clear(featureVectorHistory)

		table.clear(ratioActionProbabiltyVectorHistory)

		table.clear(rewardValueHistory)

		table.clear(criticValueHistory)

		table.clear(advantageValueHistory)

	end)

	NewProximalPolicyOptimizationModel:setResetFunction(function()

		table.clear(featureVectorHistory)

		table.clear(ratioActionProbabiltyVectorHistory)

		table.clear(rewardValueHistory)

		table.clear(criticValueHistory)

		table.clear(advantageValueHistory)

	end)

	return NewProximalPolicyOptimizationModel

end

return ProximalPolicyOptimizationModel]]></ProtectedString>
									<string name="ScriptGuid">{69437090-7690-471E-A90E-9AEDFB984C35}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ProximalPolicyOptimization</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF9EE69D7E3534C5E852CBCAFBA24513D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningActorCriticBaseModel = require(script.Parent.DeepReinforcementLearningActorCriticBaseModel)

AdvantageActorCriticModel = {}

AdvantageActorCriticModel.__index = AdvantageActorCriticModel

setmetatable(AdvantageActorCriticModel, DeepReinforcementLearningActorCriticBaseModel)

local defaultLambda = 0

local function calculateProbability(valueVector)

	local maximumValue = AqwamTensorLibrary:findMaximumValue(valueVector)

	local zValueVector = AqwamTensorLibrary:subtract(valueVector, maximumValue)

	local exponentVector = AqwamTensorLibrary:exponent(zValueVector)

	local sumExponentValue = AqwamTensorLibrary:sum(exponentVector)

	local probabilityVector = AqwamTensorLibrary:divide(exponentVector, sumExponentValue)

	return probabilityVector

end

function AdvantageActorCriticModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewAdvantageActorCriticModel = DeepReinforcementLearningActorCriticBaseModel.new(parameterDictionary)

	setmetatable(NewAdvantageActorCriticModel, AdvantageActorCriticModel)

	AdvantageActorCriticModel:setName("AdvantageActorCritic")

	NewAdvantageActorCriticModel.lambda = parameterDictionary.lambda or defaultLambda

	local featureVectorHistory = {}

	local advantageValueHistory = {}

	local actionProbabilityVectorHistory = {}

	NewAdvantageActorCriticModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

		local CriticModel = NewAdvantageActorCriticModel.CriticModel

		local actionVector = NewAdvantageActorCriticModel.ActorModel:forwardPropagate(previousFeatureVector)

		local previousCriticValue = CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		local currentCriticValue = CriticModel:forwardPropagate(currentFeatureVector)[1][1]

		local actionProbabilityVector = calculateProbability(actionVector)

		local advantageValue = rewardValue + (NewAdvantageActorCriticModel.discountFactor * (1 - terminalStateValue) * currentCriticValue) - previousCriticValue

		local logActionProbabilityVector = AqwamTensorLibrary:logarithm(actionProbabilityVector)

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(actionProbabilityVectorHistory, logActionProbabilityVector)

		table.insert(advantageValueHistory, advantageValue)

		return advantageValue

	end)

	NewAdvantageActorCriticModel:setDiagonalGaussianUpdateFunction(function(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

		if (not actionNoiseVector) then actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]}) end

		local CriticModel = NewAdvantageActorCriticModel.CriticModel

		local actionVectorPart1 = AqwamTensorLibrary:multiply(actionStandardDeviationVector, actionNoiseVector)

		local actionVector = AqwamTensorLibrary:add(actionMeanVector, actionVectorPart1)

		local zScoreVectorPart1 = AqwamTensorLibrary:subtract(actionVector, actionMeanVector)

		local zScoreVector = AqwamTensorLibrary:divide(zScoreVectorPart1, actionStandardDeviationVector)

		local squaredZScoreVector = AqwamTensorLibrary:power(zScoreVector, 2)

		local logActionProbabilityVectorPart1 = AqwamTensorLibrary:logarithm(actionStandardDeviationVector)

		local logActionProbabilityVectorPart2 = AqwamTensorLibrary:multiply(2, logActionProbabilityVectorPart1)

		local logActionProbabilityVectorPart3 = AqwamTensorLibrary:add(squaredZScoreVector, logActionProbabilityVectorPart2)

		local logActionProbabilityVectorPart4 = AqwamTensorLibrary:add(logActionProbabilityVectorPart3, math.log(2 * math.pi))

		local logActionProbabilityVector = AqwamTensorLibrary:multiply(-0.5, logActionProbabilityVectorPart4)

		local previousCriticValue = CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		local currentCriticValue = CriticModel:forwardPropagate(currentFeatureVector)[1][1]

		local advantageValue = rewardValue + (NewAdvantageActorCriticModel.discountFactor * (1 - terminalStateValue) * currentCriticValue) - previousCriticValue

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(actionProbabilityVectorHistory, logActionProbabilityVector)

		table.insert(advantageValueHistory, advantageValue)

		return advantageValue

	end)

	NewAdvantageActorCriticModel:setEpisodeUpdateFunction(function()

		local ActorModel = NewAdvantageActorCriticModel.ActorModel

		local CriticModel = NewAdvantageActorCriticModel.CriticModel

		local lambda = NewAdvantageActorCriticModel.lambda

		if (lambda ~= 0) then

			local generalizedAdvantageEstimationValue = 0

			local generalizedAdvantageEstimationHistory = {}

			local discountFactor = NewAdvantageActorCriticModel.discountFactor

			for t = #advantageValueHistory, 1, -1 do

				generalizedAdvantageEstimationValue = advantageValueHistory[t] + (discountFactor * lambda * generalizedAdvantageEstimationValue)

				table.insert(generalizedAdvantageEstimationHistory, 1, generalizedAdvantageEstimationValue)

			end

			advantageValueHistory = generalizedAdvantageEstimationHistory

		end

		for h, featureVector in ipairs(featureVectorHistory) do

			local advantageValue = advantageValueHistory[h]

			local actorLossVector = AqwamTensorLibrary:multiply(actionProbabilityVectorHistory[h], advantageValue)

			actorLossVector = AqwamTensorLibrary:unaryMinus(actorLossVector)

			CriticModel:forwardPropagate(featureVector, true)

			ActorModel:forwardPropagate(featureVector, true)

			CriticModel:update(advantageValue, true)

			ActorModel:update(actorLossVector, true)

		end

		table.clear(featureVectorHistory)

		table.clear(actionProbabilityVectorHistory)

		table.clear(advantageValueHistory)

	end)

	NewAdvantageActorCriticModel:setResetFunction(function()

		table.clear(featureVectorHistory)

		table.clear(actionProbabilityVectorHistory)

		table.clear(advantageValueHistory)

	end)

	return NewAdvantageActorCriticModel

end

return AdvantageActorCriticModel]]></ProtectedString>
									<string name="ScriptGuid">{C0BB2BF1-A636-4C23-A788-2709C794DCED}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AdvantageActorCritic</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3D4E8F458FBE409F9209651729D9C8D1">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningActorCriticBaseModel = require(script.Parent.DeepReinforcementLearningActorCriticBaseModel)

ActorCriticModel = {}

ActorCriticModel.__index = ActorCriticModel

setmetatable(ActorCriticModel, DeepReinforcementLearningActorCriticBaseModel)

local function calculateProbability(valueVector)

	local maximumValue = AqwamTensorLibrary:findMaximumValue(valueVector)

	local zValueVector = AqwamTensorLibrary:subtract(valueVector, maximumValue)

	local exponentVector = AqwamTensorLibrary:exponent(zValueVector)

	local sumExponentValue = AqwamTensorLibrary:sum(exponentVector)

	local probabilityVector = AqwamTensorLibrary:divide(exponentVector, sumExponentValue)

	return probabilityVector

end

local function calculateRewardToGo(rewardHistory, discountFactor)

	local rewardToGoArray = {}

	local discountedReward = 0

	for h = #rewardHistory, 1, -1 do

		discountedReward = rewardHistory[h] + (discountFactor * discountedReward)

		table.insert(rewardToGoArray, 1, discountedReward)

	end

	return rewardToGoArray

end

function ActorCriticModel.new(parameterDictionary)

	local NewActorCriticModel = DeepReinforcementLearningActorCriticBaseModel.new(parameterDictionary)

	setmetatable(NewActorCriticModel, ActorCriticModel)

	NewActorCriticModel:setName("ActorCritic")

	local featureVectorHistory = {}

	local actionProbabilityVectorHistory = {}

	local rewardValueHistory = {}

	local criticValueHistory = {}

	NewActorCriticModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

		local actionVector = NewActorCriticModel.ActorModel:forwardPropagate(previousFeatureVector, true)

		local criticValue = NewActorCriticModel.CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		local actionProbabilityVector = calculateProbability(actionVector)

		local logActionProbabilityVector = AqwamTensorLibrary:logarithm(actionProbabilityVector)

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(actionProbabilityVectorHistory, logActionProbabilityVector)

		table.insert(rewardValueHistory, rewardValue)

		table.insert(criticValueHistory, criticValue)

	end)

	NewActorCriticModel:setDiagonalGaussianUpdateFunction(function(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

		if (not actionNoiseVector) then actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]}) end

		local actionVectorPart1 = AqwamTensorLibrary:multiply(actionStandardDeviationVector, actionNoiseVector)

		local actionVector = AqwamTensorLibrary:add(actionMeanVector, actionVectorPart1)

		local zScoreVectorPart1 = AqwamTensorLibrary:subtract(actionVector, actionMeanVector)

		local zScoreVector = AqwamTensorLibrary:divide(zScoreVectorPart1, actionStandardDeviationVector)

		local squaredZScoreVector = AqwamTensorLibrary:power(zScoreVector, 2)

		local logActionProbabilityVectorPart1 = AqwamTensorLibrary:logarithm(actionStandardDeviationVector)

		local logActionProbabilityVectorPart2 = AqwamTensorLibrary:multiply(2, logActionProbabilityVectorPart1)

		local logActionProbabilityVectorPart3 = AqwamTensorLibrary:add(squaredZScoreVector, logActionProbabilityVectorPart2)

		local logActionProbabilityVectorPart4 = AqwamTensorLibrary:add(logActionProbabilityVectorPart3, math.log(2 * math.pi))

		local logActionProbabilityVector = AqwamTensorLibrary:multiply(-0.5, logActionProbabilityVectorPart4)

		local criticValue = NewActorCriticModel.CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(actionProbabilityVectorHistory, logActionProbabilityVector)

		table.insert(rewardValueHistory, rewardValue)

		table.insert(criticValueHistory, criticValue)

	end)

	NewActorCriticModel:setEpisodeUpdateFunction(function(terminalStateValue)

		local ActorModel = NewActorCriticModel.ActorModel

		local CriticModel = NewActorCriticModel.CriticModel

		local rewardToGoHistory = calculateRewardToGo(rewardValueHistory, NewActorCriticModel.discountFactor)

		for h, featureVector in ipairs(featureVectorHistory) do

			local criticLoss = rewardToGoHistory[h] - criticValueHistory[h]

			local actorLossVector = AqwamTensorLibrary:multiply(actionProbabilityVectorHistory[h], criticLoss)

			actorLossVector = AqwamTensorLibrary:unaryMinus(actorLossVector)

			CriticModel:forwardPropagate(featureVector, true)

			ActorModel:forwardPropagate(featureVector, true)

			CriticModel:update(criticLoss, true)

			ActorModel:update(actorLossVector, true)

		end

		table.clear(featureVectorHistory)

		table.clear(actionProbabilityVectorHistory)

		table.clear(rewardValueHistory)

		table.clear(criticValueHistory)

	end)

	NewActorCriticModel:setResetFunction(function()

		table.clear(featureVectorHistory)

		table.clear(actionProbabilityVectorHistory)

		table.clear(rewardValueHistory)

		table.clear(criticValueHistory)

	end)

	return NewActorCriticModel

end

return ActorCriticModel]]></ProtectedString>
									<string name="ScriptGuid">{FD27C265-B571-4FB0-8CEB-4F42B83A0746}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ActorCritic</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC541E0796C714955B73EC67215341435">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningActorCriticBaseModel = require(script.Parent.DeepReinforcementLearningActorCriticBaseModel)

VanillaPolicyGradientModel = {}

VanillaPolicyGradientModel.__index = VanillaPolicyGradientModel

setmetatable(VanillaPolicyGradientModel, DeepReinforcementLearningActorCriticBaseModel)

local function calculateProbability(valueVector)

	local highestActionValue = AqwamTensorLibrary:findMaximumValue(valueVector)

	local subtractedZVector = AqwamTensorLibrary:subtract(valueVector, highestActionValue)

	local exponentActionVector = AqwamTensorLibrary:applyFunction(math.exp, subtractedZVector)

	local exponentActionSumVector = AqwamTensorLibrary:sum(exponentActionVector, 2)

	local targetActionVector = AqwamTensorLibrary:divide(exponentActionVector, exponentActionSumVector)

	return targetActionVector

end

local function calculateRewardToGo(rewardHistory, discountFactor)

	local rewardToGoArray = {}

	local discountedReward = 0

	for h = #rewardHistory, 1, -1 do

		discountedReward = rewardHistory[h] + (discountFactor * discountedReward)

		table.insert(rewardToGoArray, 1, discountedReward)

	end

	return rewardToGoArray

end

function VanillaPolicyGradientModel.new(parameterDictionary)

	local NewVanillaPolicyGradientModel = DeepReinforcementLearningActorCriticBaseModel.new(parameterDictionary)

	setmetatable(NewVanillaPolicyGradientModel, VanillaPolicyGradientModel)

	NewVanillaPolicyGradientModel:setName("VanillaPolicyGradient")

	local featureVectorHistory = {}

	local actionProbabilityVectorHistory = {}

	local rewardValueHistory = {}

	local advantageValueHistory = {}

	NewVanillaPolicyGradientModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

		local CriticModel = NewVanillaPolicyGradientModel.CriticModel

		local actionVector = NewVanillaPolicyGradientModel.ActorModel:forwardPropagate(previousFeatureVector)

		local actionProbabilityVector = calculateProbability(actionVector)

		local previousCriticValue = CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		local currentCriticValue = CriticModel:forwardPropagate(currentFeatureVector)[1][1]

		local advantageValue = rewardValue + (NewVanillaPolicyGradientModel.discountFactor * currentCriticValue) - previousCriticValue

		local logActionProbabilityVector = AqwamTensorLibrary:logarithm(actionProbabilityVector)

		local actorLossVector = AqwamTensorLibrary:multiply(logActionProbabilityVector, advantageValue)

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(actionProbabilityVectorHistory, logActionProbabilityVector)

		table.insert(rewardValueHistory, rewardValue)

		table.insert(advantageValueHistory, advantageValue)

		return advantageValue

	end)

	NewVanillaPolicyGradientModel:setDiagonalGaussianUpdateFunction(function(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)
		
		if (not actionNoiseVector) then actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]}) end

		local CriticModel = NewVanillaPolicyGradientModel.CriticModel

		local actionVectorPart1 = AqwamTensorLibrary:multiply(actionStandardDeviationVector, actionNoiseVector)

		local actionVector = AqwamTensorLibrary:add(actionMeanVector, actionVectorPart1)

		local zScoreVectorPart1 = AqwamTensorLibrary:subtract(actionVector, actionMeanVector)

		local zScoreVector = AqwamTensorLibrary:divide(zScoreVectorPart1, actionStandardDeviationVector)

		local squaredZScoreVector = AqwamTensorLibrary:power(zScoreVector, 2)

		local logActionProbabilityVectorPart1 = AqwamTensorLibrary:logarithm(actionStandardDeviationVector)

		local logActionProbabilityVectorPart2 = AqwamTensorLibrary:multiply(2, logActionProbabilityVectorPart1)

		local logActionProbabilityVectorPart3 = AqwamTensorLibrary:add(squaredZScoreVector, logActionProbabilityVectorPart2)

		local logActionProbabilityVector = AqwamTensorLibrary:add(logActionProbabilityVectorPart3, math.log(2 * math.pi))

		local previousCriticValue = CriticModel:forwardPropagate(previousFeatureVector)[1][1]

		local currentCriticValue = CriticModel:forwardPropagate(currentFeatureVector)[1][1]

		local advantageValue = rewardValue + (NewVanillaPolicyGradientModel.discountFactor * currentCriticValue) - previousCriticValue

		local actorLossVector = AqwamTensorLibrary:multiply(logActionProbabilityVector, advantageValue)

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(actionProbabilityVectorHistory, logActionProbabilityVector)

		table.insert(rewardValueHistory, rewardValue)

		table.insert(advantageValueHistory, advantageValue)

		return advantageValue

	end)

	NewVanillaPolicyGradientModel:setEpisodeUpdateFunction(function(terminalStateValue)

		local ActorModel = NewVanillaPolicyGradientModel.ActorModel

		local CriticModel = NewVanillaPolicyGradientModel.CriticModel

		for h, featureVector in ipairs(featureVectorHistory) do

			local advantageValue = advantageValueHistory[h]

			local actorLossVector = AqwamTensorLibrary:multiply(actionProbabilityVectorHistory[h], advantageValue)

			actorLossVector = AqwamTensorLibrary:unaryMinus(actorLossVector)

			CriticModel:forwardPropagate(featureVector, true)

			ActorModel:forwardPropagate(featureVector, true)

			CriticModel:update(advantageValue, true)

			ActorModel:update(actorLossVector, true)

		end

		table.clear(featureVectorHistory)

		table.clear(actionProbabilityVectorHistory)

		table.clear(rewardValueHistory)

		table.clear(advantageValueHistory)

	end)

	NewVanillaPolicyGradientModel:setResetFunction(function()

		table.clear(featureVectorHistory)

		table.clear(actionProbabilityVectorHistory)

		table.clear(rewardValueHistory)

		table.clear(advantageValueHistory)

	end)

	return NewVanillaPolicyGradientModel

end

return VanillaPolicyGradientModel]]></ProtectedString>
									<string name="ScriptGuid">{232F148C-5425-4A7F-9EC4-774AEBCED9DC}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">VanillaPolicyGradient</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD17529F09494422F8071BB7F26511CEF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

REINFORCEModel = {}

REINFORCEModel.__index = REINFORCEModel

setmetatable(REINFORCEModel, DeepReinforcementLearningBaseModel)

local function calculateProbability(valueVector)

	local maximumValue = AqwamTensorLibrary:findMaximumValue(valueVector)

	local zValueVector = AqwamTensorLibrary:subtract(valueVector, maximumValue)

	local exponentVector = AqwamTensorLibrary:exponent(zValueVector)

	local sumExponentValue = AqwamTensorLibrary:sum(exponentVector)

	local probabilityVector = AqwamTensorLibrary:divide(exponentVector, sumExponentValue)

	return probabilityVector

end

local function calculateRewardToGo(rewardValueHistory, discountFactor)

	local rewardToGoArray = {}

	local discountedReward = 0

	for h = #rewardValueHistory, 1, -1 do

		discountedReward = rewardValueHistory[h] + (discountFactor * discountedReward)

		table.insert(rewardToGoArray, 1, discountedReward)

	end

	return rewardToGoArray

end

function REINFORCEModel.new(parameterDictionary)

	local NewREINFORCEModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewREINFORCEModel, REINFORCEModel)
	
	NewREINFORCEModel:setName("REINFORCE")
	
	local featureVectorArray = {}
	
	local actionProbabilityVectorHistory = {}
	
	local rewardValueHistory = {}
	
	NewREINFORCEModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

		local actionVector = NewREINFORCEModel.Model:forwardPropagate(previousFeatureVector)
		
		local actionProbabilityVector = calculateProbability(actionVector)
		
		local logActionProbabilityVector = AqwamTensorLibrary:logarithm(actionProbabilityVector)
		
		table.insert(featureVectorArray, previousFeatureVector)

		table.insert(actionProbabilityVectorHistory, logActionProbabilityVector)
		
		table.insert(rewardValueHistory, rewardValue)

	end)
	
	NewREINFORCEModel:setDiagonalGaussianUpdateFunction(function(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)
		
		if (not actionNoiseVector) then actionNoiseVector = AqwamTensorLibrary:createRandomNormalTensor({1, #actionMeanVector[1]}) end

		local actionVectorPart1 = AqwamTensorLibrary:multiply(actionStandardDeviationVector, actionNoiseVector)

		local actionVector = AqwamTensorLibrary:add(actionMeanVector, actionVectorPart1)

		local zScoreVectorPart1 = AqwamTensorLibrary:subtract(actionVector, actionMeanVector)

		local zScoreVector = AqwamTensorLibrary:divide(zScoreVectorPart1, actionStandardDeviationVector)

		local squaredZScoreVector = AqwamTensorLibrary:power(zScoreVector, 2)

		local logActionProbabilityVectorPart1 = AqwamTensorLibrary:logarithm(actionStandardDeviationVector)

		local logActionProbabilityVectorPart2 = AqwamTensorLibrary:multiply(2, logActionProbabilityVectorPart1)

		local logActionProbabilityVectorPart3 = AqwamTensorLibrary:add(squaredZScoreVector, logActionProbabilityVectorPart2)

		local logActionProbabilityVectorPart4 = AqwamTensorLibrary:add(logActionProbabilityVectorPart3, math.log(2 * math.pi))
		
		local logActionProbabilityVector = AqwamTensorLibrary:multiply(-0.5, logActionProbabilityVectorPart4)
		
		table.insert(featureVectorArray, previousFeatureVector)

		table.insert(actionProbabilityVectorHistory, logActionProbabilityVector)

		table.insert(rewardValueHistory, rewardValue)

	end)
	
	NewREINFORCEModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local Model = NewREINFORCEModel.Model
		
		local rewardToGoArray = calculateRewardToGo(rewardValueHistory, NewREINFORCEModel.discountFactor)
		
		for h, actionProbabilityVector in ipairs(actionProbabilityVectorHistory) do
			
			local lossVector = AqwamTensorLibrary:multiply(actionProbabilityVector, rewardToGoArray[h])
			
			lossVector = AqwamTensorLibrary:unaryMinus(lossVector)
			
			Model:forwardPropagate(featureVectorArray[h], true)

			Model:update(lossVector, true)
			
		end
		
		table.clear(featureVectorArray)

		table.clear(actionProbabilityVectorHistory)
		
		table.clear(rewardValueHistory)
		
	end)
	
	NewREINFORCEModel:setResetFunction(function()
		
		table.clear(featureVectorArray)

		table.clear(actionProbabilityVectorHistory)
		
		table.clear(rewardValueHistory)
		
	end)
	
	return NewREINFORCEModel

end

return REINFORCEModel]]></ProtectedString>
									<string name="ScriptGuid">{57ECCE0C-7A47-497D-A125-14873753055C}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">REINFORCE</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF383A6E9174240259869378CD5CBDB5F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepMonteCarloControlModel = {}

DeepMonteCarloControlModel.__index = DeepMonteCarloControlModel

setmetatable(DeepMonteCarloControlModel, DeepReinforcementLearningBaseModel)

local function calculateRewardToGo(rewardValueHistory, discountFactor)

	local rewardToGoArray = {}

	local discountedReward = 0

	for h = #rewardValueHistory, 1, -1 do

		discountedReward = rewardValueHistory[h] + (discountFactor * discountedReward)

		table.insert(rewardToGoArray, 1, discountedReward)

	end

	return rewardToGoArray

end

function DeepMonteCarloControlModel.new(parameterDictionary)

	local NewDeepMonteCarloControlModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewDeepMonteCarloControlModel, DeepMonteCarloControlModel)
	
	NewDeepMonteCarloControlModel:setName("DeepMonteCarloControl")
	
	local featureVectorHistory = {}
	
	local rewardValueHistory = {}
	
	NewDeepMonteCarloControlModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		table.insert(featureVectorHistory, previousFeatureVector)
		
		table.insert(rewardValueHistory, rewardValue)

	end)
	
	NewDeepMonteCarloControlModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local Model = NewDeepMonteCarloControlModel.Model
		
		local rewardToGoArray = calculateRewardToGo(rewardValueHistory, NewDeepMonteCarloControlModel.discountFactor)
		
		for h, featureVector in ipairs(featureVectorHistory) do
			
			local averageRewardToGo = rewardToGoArray[h] / h
			
			Model:forwardPropagate(featureVector, true)

			Model:update(averageRewardToGo, true)
			
		end
		
		table.clear(featureVectorHistory)
		
		table.clear(rewardValueHistory)
		
	end)
	
	NewDeepMonteCarloControlModel:setResetFunction(function()
		
		table.clear(featureVectorHistory)
		
		table.clear(rewardValueHistory)
		
	end)
	
	return NewDeepMonteCarloControlModel

end

return DeepMonteCarloControlModel]]></ProtectedString>
									<string name="ScriptGuid">{249CDE33-4E72-4F59-BE6C-E7708EEEB3D8}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepMonteCarloControl</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA861C70DB043424AA65EA69FA64C1C69">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepOffPolicyMonteCarloControlModel = {}

DeepOffPolicyMonteCarloControlModel.__index = DeepOffPolicyMonteCarloControlModel

setmetatable(DeepOffPolicyMonteCarloControlModel, DeepReinforcementLearningBaseModel)

local defaultTargetPolicyFunction = "StableSoftmax"

local targetPolicyFunctionList = {

	["Greedy"] = function (actionVector)

		local targetActionVector = AqwamTensorLibrary:createTensor({1, #actionVector[1]}, 0)

		local highestActionValue = -math.huge

		local indexWithHighestActionValue

		for i, actionValue in ipairs(actionVector[1]) do

			if (actionValue > highestActionValue) then

				highestActionValue = actionValue

				indexWithHighestActionValue = i

			end

		end

		targetActionVector[1][indexWithHighestActionValue] = highestActionValue

		return targetActionVector

	end,

	["Softmax"] = function (actionVector) -- Apparently Lua doesn't really handle very small values such as math.exp(-1000), so I added a more stable computation exp(a) / exp(b) -> exp (a - b).

		local exponentActionVector = AqwamTensorLibrary:applyFunction(math.exp, actionVector)

		local exponentActionSumVector = AqwamTensorLibrary:sum(exponentActionVector, 2)

		local targetActionVector = AqwamTensorLibrary:divide(exponentActionVector, exponentActionSumVector)

		return targetActionVector

	end,

	["StableSoftmax"] = function (actionVector)

		local highestActionValue = AqwamTensorLibrary:findMaximumValue(actionVector)

		local subtractedZVector = AqwamTensorLibrary:subtract(actionVector, highestActionValue)

		local exponentActionVector = AqwamTensorLibrary:applyFunction(math.exp, subtractedZVector)

		local exponentActionSumVector = AqwamTensorLibrary:sum(exponentActionVector, 2)

		local targetActionVector = AqwamTensorLibrary:divide(exponentActionVector, exponentActionSumVector)

		return targetActionVector

	end,

}

function DeepOffPolicyMonteCarloControlModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewDeepOffPolicyMonteCarloControlModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewDeepOffPolicyMonteCarloControlModel, DeepOffPolicyMonteCarloControlModel)

	NewDeepOffPolicyMonteCarloControlModel:setName("DeepOffPolicyMonteCarloControl")

	NewDeepOffPolicyMonteCarloControlModel.targetPolicyFunction = parameterDictionary.targetPolicyFunction or defaultTargetPolicyFunction

	local featureVectorHistory = {}

	local actionVectorHistory = {}

	local rewardValueHistory = {}

	NewDeepOffPolicyMonteCarloControlModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

		local actionVector = NewDeepOffPolicyMonteCarloControlModel.Model:forwardPropagate(previousFeatureVector)

		table.insert(featureVectorHistory, previousFeatureVector)

		table.insert(actionVectorHistory, actionVector)

		table.insert(rewardValueHistory, rewardValue)

	end)

	NewDeepOffPolicyMonteCarloControlModel:setEpisodeUpdateFunction(function(terminalStateValue)

		local Model = NewDeepOffPolicyMonteCarloControlModel.Model

		local targetPolicyFunction = targetPolicyFunctionList[NewDeepOffPolicyMonteCarloControlModel.targetPolicyFunction]

		local discountFactor = NewDeepOffPolicyMonteCarloControlModel.discountFactor

		local numberOfActions = #actionVectorHistory[1]

		local outputDimensionSizeArray = {1, numberOfActions}

		local cVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 0) 

		local weightVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 1)

		local discountedReward = 0

		for h = #actionVectorHistory, 1, -1 do

			discountedReward = rewardValueHistory[h] + (discountFactor * discountedReward)

			cVector = AqwamTensorLibrary:add(cVector, weightVector)

			local actionVector = actionVectorHistory[h]

			local lossVectorPart1 = AqwamTensorLibrary:divide(weightVector, cVector)

			local lossVectorPart2 = AqwamTensorLibrary:subtract(discountedReward, actionVector)

			local lossVector = AqwamTensorLibrary:multiply(lossVectorPart1, lossVectorPart2, -1) -- The original non-deep off-policy Monte-Carlo Control version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the loss vector by multiplying it with -1 to make the neural network to perform gradient ascent.

			local targetActionVector = targetPolicyFunction(actionVector)

			local actionRatioVector = AqwamTensorLibrary:divide(targetActionVector, actionVector)

			weightVector = AqwamTensorLibrary:multiply(weightVector, actionRatioVector)

			Model:forwardPropagate(featureVectorHistory[h], true)

			Model:update(lossVector, true)

		end

		table.clear(featureVectorHistory)

		table.clear(actionVectorHistory)

		table.clear(rewardValueHistory)

	end)

	NewDeepOffPolicyMonteCarloControlModel:setResetFunction(function()

		table.clear(featureVectorHistory)

		table.clear(actionVectorHistory)

		table.clear(rewardValueHistory)

	end)

	return NewDeepOffPolicyMonteCarloControlModel

end

return DeepOffPolicyMonteCarloControlModel]]></ProtectedString>
									<string name="ScriptGuid">{F1882451-F0B7-4F75-B0CF-FA6DE482EBC8}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepOffPolicyMonteCarloControl</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1407102FBC6E4D72A954884C9A0AA3A5">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepDoubleExpectedStateActionRewardStateActionModel = {}

DeepDoubleExpectedStateActionRewardStateActionModel.__index = DeepDoubleExpectedStateActionRewardStateActionModel

setmetatable(DeepDoubleExpectedStateActionRewardStateActionModel, DeepReinforcementLearningBaseModel)

local defaultAveragingRate = 0.01

local defaultEpsilon = 0.5

local function rateAverageModelParameters(averagingRate, TargetModelParameters, PrimaryModelParameters)

	local averagingRateComplement = 1 - averagingRate

	for layer = 1, #TargetModelParameters, 1 do

		local PrimaryModelParametersPart = AqwamTensorLibrary:multiply(averagingRate, PrimaryModelParameters[layer])
		
		local TargetModelParametersPart = AqwamTensorLibrary:multiply(averagingRateComplement, TargetModelParameters[layer])

		TargetModelParameters[layer] = AqwamTensorLibrary:add(PrimaryModelParametersPart, TargetModelParametersPart)

	end

	return TargetModelParameters

end

function DeepDoubleExpectedStateActionRewardStateActionModel.new(parameterDictionary)

	local NewDeepDoubleExpectedStateActionRewardStateActionModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewDeepDoubleExpectedStateActionRewardStateActionModel, DeepDoubleExpectedStateActionRewardStateActionModel)
	
	NewDeepDoubleExpectedStateActionRewardStateActionModel.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate
	
	NewDeepDoubleExpectedStateActionRewardStateActionModel.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	NewDeepDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace

	NewDeepDoubleExpectedStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepDoubleExpectedStateActionRewardStateActionModel.Model
		
		local discountFactor = NewDeepDoubleExpectedStateActionRewardStateActionModel.discountFactor
		
		local epsilon = NewDeepDoubleExpectedStateActionRewardStateActionModel.epsilon
		
		local averagingRate = NewDeepDoubleExpectedStateActionRewardStateActionModel.averagingRate
		
		local EligibilityTrace = NewDeepDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace
		
		local PrimaryModelParameters = Model:getModelParameters(true)

		if (not PrimaryModelParameters) then 
			
			Model:generateLayers()
			
			PrimaryModelParameters = Model:getModelParameters(true)
			
		end

		local expectedQValue = 0

		local numberOfGreedyActions = 0
		
		local ClassesList = Model:getClassesList()

		local numberOfClasses = #ClassesList

		local actionIndex = table.find(ClassesList, action)

		local previousVector = Model:forwardPropagate(previousFeatureVector)

		local targetVector = Model:forwardPropagate(currentFeatureVector)
		
		local maxQValue = AqwamTensorLibrary:findMaximumValue(targetVector)
		
		local unwrappedTargetVector = targetVector[1]

		for i = 1, numberOfClasses, 1 do

			if (unwrappedTargetVector[i] == maxQValue) then

				numberOfGreedyActions = numberOfGreedyActions + 1

			end

		end

		local nonGreedyActionProbability = epsilon / numberOfClasses

		local greedyActionProbability = ((1 - epsilon) / numberOfGreedyActions) + nonGreedyActionProbability

		for _, qValue in ipairs(unwrappedTargetVector) do

			if (qValue == maxQValue) then

				expectedQValue = expectedQValue + (qValue * greedyActionProbability)

			else

				expectedQValue = expectedQValue + (qValue * nonGreedyActionProbability)

			end

		end

		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * expectedQValue)

		local lastValue = previousVector[1][actionIndex]

		local temporalDifferenceError = targetValue - lastValue
		
		local outputDimensionSizeArray = {1, numberOfClasses}

		local temporalDifferenceErrorVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 0)

		temporalDifferenceErrorVector[1][actionIndex] = temporalDifferenceError
		
		if (EligibilityTrace) then

			EligibilityTrace:increment(1, actionIndex, discountFactor, outputDimensionSizeArray)

			temporalDifferenceErrorVector = EligibilityTrace:calculate(temporalDifferenceErrorVector)

		end
		
		local negatedTemporalDifferenceErrorVector = AqwamTensorLibrary:unaryMinus(temporalDifferenceErrorVector) -- The original non-deep expected SARSA version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.
		
		Model:forwardPropagate(previousFeatureVector, true)

		Model:update(negatedTemporalDifferenceErrorVector, true)

		local TargetModelParameters = Model:getModelParameters(true)

		TargetModelParameters = rateAverageModelParameters(NewDeepDoubleExpectedStateActionRewardStateActionModel.averagingRate, TargetModelParameters, PrimaryModelParameters)

		Model:setModelParameters(TargetModelParameters, true)
		
		return temporalDifferenceError

	end)
	
	NewDeepDoubleExpectedStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewDeepDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewDeepDoubleExpectedStateActionRewardStateActionModel:setResetFunction(function() 
		
		local EligibilityTrace = NewDeepDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewDeepDoubleExpectedStateActionRewardStateActionModel

end

return DeepDoubleExpectedStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{F0938539-25CF-44C9-9C07-B05806DB3D4D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepDoubleExpectedStateActionRewardStateActionV2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5048D678F3D94377867392C143D6AB9C">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepDoubleExpectedStateActionRewardStateActionModel = {}

DeepDoubleExpectedStateActionRewardStateActionModel.__index = DeepDoubleExpectedStateActionRewardStateActionModel

setmetatable(DeepDoubleExpectedStateActionRewardStateActionModel, DeepReinforcementLearningBaseModel)

local defaultEpsilon = 0.5

function DeepDoubleExpectedStateActionRewardStateActionModel.new(parameterDictionary)

	local NewDeepDoubleExpectedStateActionRewardStateActionModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewDeepDoubleExpectedStateActionRewardStateActionModel, DeepDoubleExpectedStateActionRewardStateActionModel)
	
	NewDeepDoubleExpectedStateActionRewardStateActionModel:setName("DeepExpectedStateActionRewardStateActionV1")
	
	NewDeepDoubleExpectedStateActionRewardStateActionModel.epsilon = parameterDictionary.epsilon or defaultEpsilon

	NewDeepDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewDeepDoubleExpectedStateActionRewardStateActionModel.ModelParametersArray = parameterDictionary.ModelParametersArray or {}

	NewDeepDoubleExpectedStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepDoubleExpectedStateActionRewardStateActionModel.Model

		local randomProbability = math.random()

		local updateSecondModel = (randomProbability >= 0.5)

		local selectedModelNumberForTargetVector = (updateSecondModel and 1) or 2

		local selectedModelNumberForUpdate = (updateSecondModel and 2) or 1

		local temporalDifferenceErrorVector, temporalDifferenceError = NewDeepDoubleExpectedStateActionRewardStateActionModel:generateTemporalDifferenceErrorVector(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)
		
		local negatedTemporalDifferenceErrorVector = AqwamTensorLibrary:unaryMinus(temporalDifferenceErrorVector) -- The original non-deep expected SARSA version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.
		
		Model:forwardPropagate(previousFeatureVector, true)

		Model:update(negatedTemporalDifferenceErrorVector, true)

		NewDeepDoubleExpectedStateActionRewardStateActionModel:saveModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		return temporalDifferenceError

	end)
	
	NewDeepDoubleExpectedStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewDeepDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewDeepDoubleExpectedStateActionRewardStateActionModel:setResetFunction(function() 
		
		local EligibilityTrace = NewDeepDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewDeepDoubleExpectedStateActionRewardStateActionModel

end

function DeepDoubleExpectedStateActionRewardStateActionModel:saveModelParametersFromModelParametersArray(index)

	self.ModelParametersArray[index] = self.Model:getModelParameters()

end

function DeepDoubleExpectedStateActionRewardStateActionModel:loadModelParametersFromModelParametersArray(index)

	local Model = self.Model

	local ModelParametersArray = self.ModelParametersArray

	if (not ModelParametersArray[index]) then

		Model:generateLayers()

		self:saveModelParametersFromModelParametersArray(index)

	end

	local CurrentModelParameters = ModelParametersArray[index]

	Model:setModelParameters(CurrentModelParameters, true)

end

function DeepDoubleExpectedStateActionRewardStateActionModel:generateTemporalDifferenceErrorVector(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)
	
	local Model = self.Model
	
	local discountFactor = self.discountFactor
	
	local epsilon = self.epsilon
	
	local EligibilityTrace = self.EligibilityTrace

	local expectedQValue = 0

	local numberOfGreedyActions = 0
	
	local ClassesList = Model:getClassesList()

	local numberOfClasses = #ClassesList

	local actionIndex = table.find(ClassesList, action)
	
	self:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)

	local previousVector = Model:forwardPropagate(previousFeatureVector)
	
	self:loadModelParametersFromModelParametersArray(selectedModelNumberForTargetVector)

	local targetVector = Model:forwardPropagate(currentFeatureVector)

	local maxQValue = AqwamTensorLibrary:findMaximumValue(targetVector)

	local unwrappedTargetVector = targetVector[1]

	for i = 1, numberOfClasses, 1 do

		if (unwrappedTargetVector[i] == maxQValue) then

			numberOfGreedyActions = numberOfGreedyActions + 1

		end

	end

	local nonGreedyActionProbability = epsilon / numberOfClasses

	local greedyActionProbability = ((1 - epsilon) / numberOfGreedyActions) + nonGreedyActionProbability

	for _, qValue in ipairs(unwrappedTargetVector) do

		if (qValue == maxQValue) then

			expectedQValue = expectedQValue + (qValue * greedyActionProbability)

		else

			expectedQValue = expectedQValue + (qValue * nonGreedyActionProbability)

		end

	end

	local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * expectedQValue)
	
	local lastValue = previousVector[1][actionIndex]

	local temporalDifferenceError = targetValue - lastValue
	
	local outputDimensionSizeArray = {1, numberOfClasses}

	local temporalDifferenceErrorVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 0)
	
	temporalDifferenceErrorVector[1][actionIndex] = temporalDifferenceError
	
	if (EligibilityTrace) then

		EligibilityTrace:increment(1, actionIndex, discountFactor, outputDimensionSizeArray)

		temporalDifferenceErrorVector = EligibilityTrace:calculate(temporalDifferenceErrorVector)

	end

	return temporalDifferenceErrorVector, temporalDifferenceError

end

function DeepDoubleExpectedStateActionRewardStateActionModel:setModelParameters1(ModelParameters1, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[1] = ModelParameters1

	else

		self.ModelParametersArray[1] = self:deepCopyTable(ModelParameters1)

	end

end

function DeepDoubleExpectedStateActionRewardStateActionModel:setModelParameters2(ModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[2] = ModelParameters2

	else

		self.ModelParametersArray[2] = self:deepCopyTable(ModelParameters2)

	end

end

function DeepDoubleExpectedStateActionRewardStateActionModel:getModelParameters1(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[1]

	else

		return self:deepCopyTable(self.ModelParametersArray[1])

	end

end

function DeepDoubleExpectedStateActionRewardStateActionModel:getModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[2]

	else

		return self:deepCopyTable(self.ModelParametersArray[2])

	end

end

return DeepDoubleExpectedStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{AD284633-44BE-46F9-AD8A-5F4997B03CAA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepDoubleExpectedStateActionRewardStateActionV1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2DD5BBC98DDB4C21BAAA0C6A24FD704A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepExpectedStateActionRewardStateActionModel = {}

DeepExpectedStateActionRewardStateActionModel.__index = DeepExpectedStateActionRewardStateActionModel

setmetatable(DeepExpectedStateActionRewardStateActionModel, DeepReinforcementLearningBaseModel)

local defaultEpsilon = 0.5

function DeepExpectedStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewDeepExpectedStateActionRewardStateActionModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewDeepExpectedStateActionRewardStateActionModel, DeepExpectedStateActionRewardStateActionModel)
	
	NewDeepExpectedStateActionRewardStateActionModel:setName("DeepExpectedStateActionRewardStateAction")
	
	NewDeepExpectedStateActionRewardStateActionModel.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	NewDeepExpectedStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace

	NewDeepExpectedStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepExpectedStateActionRewardStateActionModel.Model
		
		local discountFactor = NewDeepExpectedStateActionRewardStateActionModel.discountFactor
		
		local epsilon = NewDeepExpectedStateActionRewardStateActionModel.epsilon
		
		local EligibilityTrace = NewDeepExpectedStateActionRewardStateActionModel.EligibilityTrace

		local expectedQValue = 0

		local numberOfGreedyActions = 0
		
		local ClassesList = Model:getClassesList()

		local numberOfClasses = #ClassesList

		local actionIndex = table.find(ClassesList, action)
		
		local previousVector = Model:forwardPropagate(previousFeatureVector)
		
		local targetVector = Model:forwardPropagate(currentFeatureVector)
		
		local maxQValue = AqwamTensorLibrary:findMaximumValue(targetVector)

		local unwrappedTargetVector = targetVector[1]

		for i = 1, numberOfClasses, 1 do

			if (unwrappedTargetVector[i] == maxQValue) then

				numberOfGreedyActions = numberOfGreedyActions + 1

			end

		end

		local nonGreedyActionProbability = epsilon / numberOfClasses

		local greedyActionProbability = ((1 - epsilon) / numberOfGreedyActions) + nonGreedyActionProbability

		for _, qValue in ipairs(unwrappedTargetVector) do

			if (qValue == maxQValue) then

				expectedQValue = expectedQValue + (qValue * greedyActionProbability)

			else

				expectedQValue = expectedQValue + (qValue * nonGreedyActionProbability)

			end

		end
		
		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * expectedQValue)

		local lastValue = previousVector[1][actionIndex]

		local temporalDifferenceError = targetValue - lastValue
		
		local outputDimensionSizeArray = {1, numberOfClasses}

		local temporalDifferenceErrorVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 0)
		
		temporalDifferenceErrorVector[1][actionIndex] = temporalDifferenceError
		
		if (EligibilityTrace) then

			EligibilityTrace:increment(1, actionIndex, discountFactor, outputDimensionSizeArray)

			temporalDifferenceErrorVector = EligibilityTrace:calculate(temporalDifferenceErrorVector)

		end
		
		local negatedTemporalDifferenceErrorVector = AqwamTensorLibrary:unaryMinus(temporalDifferenceErrorVector) -- The original non-deep expected SARSA version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.

		Model:forwardPropagate(previousFeatureVector, true)
		
		Model:update(negatedTemporalDifferenceErrorVector, true)
		
		return temporalDifferenceErrorVector

	end)
	
	NewDeepExpectedStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewDeepExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewDeepExpectedStateActionRewardStateActionModel:setResetFunction(function() 
		
		local EligibilityTrace = NewDeepExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewDeepExpectedStateActionRewardStateActionModel

end

return DeepExpectedStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{2FFCBE9A-2899-42C7-B5B2-1FDA306C2B45}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepExpectedStateActionRewardStateAction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAE19F66569A348728EFFD01038434F4A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepDoubleStateActionRewardStateActionModel = {}

DeepDoubleStateActionRewardStateActionModel.__index = DeepDoubleStateActionRewardStateActionModel

setmetatable(DeepDoubleStateActionRewardStateActionModel, DeepReinforcementLearningBaseModel)

function DeepDoubleStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewDeepDoubleStateActionRewardStateActionModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewDeepDoubleStateActionRewardStateActionModel, DeepDoubleStateActionRewardStateActionModel)
	
	NewDeepDoubleStateActionRewardStateActionModel:setName("DeepDoubleStateActionRewardStateActionV1")
	
	NewDeepDoubleStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace

	NewDeepDoubleStateActionRewardStateActionModel.ModelParametersArray = parameterDictionary.ModelParametersArray or {}

	NewDeepDoubleStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepDoubleStateActionRewardStateActionModel.Model

		local randomProbability = math.random()

		local updateSecondModel = (randomProbability >= 0.5)

		local selectedModelNumberForTargetVector = (updateSecondModel and 1) or 2

		local selectedModelNumberForUpdate = (updateSecondModel and 2) or 1

		local temporalDifferenceErrorVector = NewDeepDoubleStateActionRewardStateActionModel:generateTemporalDifferenceErrorVector(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)
		
		local negatedTemporalDifferenceErrorVector = AqwamTensorLibrary:unaryMinus(temporalDifferenceErrorVector) -- The original non-deep SARSA version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.
		
		NewDeepDoubleStateActionRewardStateActionModel:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		Model:forwardPropagate(previousFeatureVector, true)
		
		Model:update(negatedTemporalDifferenceErrorVector, true)

		NewDeepDoubleStateActionRewardStateActionModel:saveModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		return temporalDifferenceErrorVector

	end)
	
	NewDeepDoubleStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewDeepDoubleStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewDeepDoubleStateActionRewardStateActionModel:setResetFunction(function() 
		
		local EligibilityTrace = NewDeepDoubleStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewDeepDoubleStateActionRewardStateActionModel

end

function DeepDoubleStateActionRewardStateActionModel:saveModelParametersFromModelParametersArray(index)

	self.ModelParametersArray[index] = self.Model:getModelParameters()

end

function DeepDoubleStateActionRewardStateActionModel:loadModelParametersFromModelParametersArray(index)

	local Model = self.Model

	local ModelParametersArray = self.ModelParametersArray

	if (not ModelParametersArray[index]) then

		Model:generateLayers()

		self:saveModelParametersFromModelParametersArray(index)

	end

	local CurrentModelParameters = ModelParametersArray[index]

	Model:setModelParameters(CurrentModelParameters, true)

end

function DeepDoubleStateActionRewardStateActionModel:generateTemporalDifferenceErrorVector(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)
	
	local Model = self.Model
	
	local discountFactor = self.discountFactor
	
	local EligibilityTrace = self.EligibilityTrace
	
	self:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
	
	local previousVector = Model:forwardPropagate(previousFeatureVector)
	
	self:loadModelParametersFromModelParametersArray(selectedModelNumberForTargetVector)

	local qVector = Model:forwardPropagate(currentFeatureVector)

	local discountedQVector = AqwamTensorLibrary:multiply(discountFactor, qVector, (1 - terminalStateValue))

	local targetVector = AqwamTensorLibrary:add(rewardValue, discountedQVector)
	
	local temporalDifferenceErrorVector = AqwamTensorLibrary:subtract(targetVector, previousVector)
	
	if (EligibilityTrace) then
		
		local ClassesList = Model:getClassesList()

		local actionIndex = table.find(ClassesList, action)

		EligibilityTrace:increment(1, actionIndex, discountFactor, {1, #ClassesList})

		temporalDifferenceErrorVector = EligibilityTrace:calculate(temporalDifferenceErrorVector)

	end

	return temporalDifferenceErrorVector

end

function DeepDoubleStateActionRewardStateActionModel:setModelParameters1(ModelParameters1, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[1] = ModelParameters1

	else

		self.ModelParametersArray[1] = self:deepCopyTable(ModelParameters1)

	end

end

function DeepDoubleStateActionRewardStateActionModel:setModelParameters2(ModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[2] = ModelParameters2

	else

		self.ModelParametersArray[2] = self:deepCopyTable(ModelParameters2)

	end

end

function DeepDoubleStateActionRewardStateActionModel:getModelParameters1(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[1]

	else

		return self:deepCopyTable(self.ModelParametersArray[1])

	end

end

function DeepDoubleStateActionRewardStateActionModel:getModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[2]

	else

		return self:deepCopyTable(self.ModelParametersArray[2])

	end

end

return DeepDoubleStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{B24ACDD4-1D7A-4963-864E-1062339AFF71}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepDoubleStateActionRewardStateActionV1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC6B6EA19F8104257B1CA597E2A99DDCE">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepDoubleStateActionRewardStateActionModel = {}

DeepDoubleStateActionRewardStateActionModel.__index = DeepDoubleStateActionRewardStateActionModel

setmetatable(DeepDoubleStateActionRewardStateActionModel, DeepReinforcementLearningBaseModel)

local defaultAveragingRate = 0.01

local function rateAverageModelParameters(averagingRate, TargetModelParameters, PrimaryModelParameters)

	local averagingRateComplement = 1 - averagingRate

	for layer = 1, #TargetModelParameters, 1 do

		local PrimaryModelParametersPart = AqwamTensorLibrary:multiply(averagingRate, PrimaryModelParameters[layer])

		local TargetModelParametersPart = AqwamTensorLibrary:multiply(averagingRateComplement, TargetModelParameters[layer])

		TargetModelParameters[layer] = AqwamTensorLibrary:add(PrimaryModelParametersPart, TargetModelParametersPart)

	end

	return TargetModelParameters

end

function DeepDoubleStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewDeepDoubleStateActionRewardStateActionModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewDeepDoubleStateActionRewardStateActionModel, DeepDoubleStateActionRewardStateActionModel)
	
	NewDeepDoubleStateActionRewardStateActionModel:setName("DeepDoubleStateActionRewardStateActionV2")

	NewDeepDoubleStateActionRewardStateActionModel.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate

	NewDeepDoubleStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace

	NewDeepDoubleStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepDoubleStateActionRewardStateActionModel.Model
		
		local discountFactor = NewDeepDoubleStateActionRewardStateActionModel.discountFactor

		local EligibilityTrace = NewDeepDoubleStateActionRewardStateActionModel.EligibilityTrace
		
		local PrimaryModelParameters = Model:getModelParameters(true)

		if (PrimaryModelParameters) then 
			
			Model:generateLayers()
			
			PrimaryModelParameters = Model:getModelParameters(true)
			
		end
		
		local qVector = Model:forwardPropagate(currentFeatureVector, true)

		local discountedQVector = AqwamTensorLibrary:multiply(discountFactor, qVector, (1 - terminalStateValue))

		local targetVector = AqwamTensorLibrary:add(rewardValue, discountedQVector)

		local previousQVector = Model:forwardPropagate(previousFeatureVector)

		local temporalDifferenceErrorVector = AqwamTensorLibrary:subtract(targetVector, previousQVector)
		
		if (EligibilityTrace) then

			local ClassesList = Model:getClassesList()

			local actionIndex = table.find(ClassesList, action)

			EligibilityTrace:increment(1, actionIndex, discountFactor, {1, #ClassesList})

			temporalDifferenceErrorVector = EligibilityTrace:calculate(temporalDifferenceErrorVector)

		end
		
		local negatedTemporalDifferenceErrorVector = AqwamTensorLibrary:unaryMinus(temporalDifferenceErrorVector) -- The original non-deep SARSA version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.

		Model:forwardPropagate(previousFeatureVector, true)

		Model:update(negatedTemporalDifferenceErrorVector, true)
		
		local TargetModelParameters = Model:getModelParameters(true)

		TargetModelParameters = rateAverageModelParameters(NewDeepDoubleStateActionRewardStateActionModel.averagingRate, TargetModelParameters, PrimaryModelParameters)

		Model:setModelParameters(TargetModelParameters, true)
		
		return temporalDifferenceErrorVector

	end)
	
	NewDeepDoubleStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewDeepDoubleStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewDeepDoubleStateActionRewardStateActionModel:setResetFunction(function()
		
		local EligibilityTrace = NewDeepDoubleStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewDeepDoubleStateActionRewardStateActionModel

end

return DeepDoubleStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{B8E1AF70-1B61-4845-A36C-98F924FCAC77}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepDoubleStateActionRewardStateActionV2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA97FCEE870C6448AA216ECB45DA4836E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepStateActionRewardStateActionModel = {}

DeepStateActionRewardStateActionModel.__index = DeepStateActionRewardStateActionModel

setmetatable(DeepStateActionRewardStateActionModel, DeepReinforcementLearningBaseModel)

function DeepStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewDeepStateActionRewardStateActionModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewDeepStateActionRewardStateActionModel, DeepStateActionRewardStateActionModel)
	
	NewDeepStateActionRewardStateActionModel:setName("DeepStateActionRewardStateAction")
	
	NewDeepStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace

	NewDeepStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepStateActionRewardStateActionModel.Model
		
		local discountFactor = NewDeepStateActionRewardStateActionModel.discountFactor
		
		local EligibilityTrace = NewDeepStateActionRewardStateActionModel.EligibilityTrace

		local qVector = Model:forwardPropagate(currentFeatureVector)

		local discountedQVector = AqwamTensorLibrary:multiply(discountFactor, qVector, (1 - terminalStateValue))

		local targetQVector = AqwamTensorLibrary:add(rewardValue, discountedQVector)

		local previousQVector = Model:forwardPropagate(previousFeatureVector)

		local temporalDifferenceErrorVector = AqwamTensorLibrary:subtract(targetQVector, previousQVector)
		
		if (EligibilityTrace) then

			local ClassesList = Model:getClassesList()

			local actionIndex = table.find(ClassesList, action)

			EligibilityTrace:increment(1, actionIndex, discountFactor, {1, #ClassesList})

			temporalDifferenceErrorVector = EligibilityTrace:calculate(temporalDifferenceErrorVector)

		end
		
		local negatedTemporalDifferenceErrorVector = AqwamTensorLibrary:unaryMinus(temporalDifferenceErrorVector) -- The original non-deep SARSA version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.
		
		Model:forwardPropagate(previousFeatureVector, true)

		Model:update(negatedTemporalDifferenceErrorVector, true)
		
		return temporalDifferenceErrorVector

	end)
	
	NewDeepStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewDeepStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)
	
	NewDeepStateActionRewardStateActionModel:setResetFunction(function() 
		
		local EligibilityTrace = NewDeepStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewDeepStateActionRewardStateActionModel

end

function DeepStateActionRewardStateActionModel:setParameters(discountFactor)

	self.discountFactor = discountFactor or self.discountFactor

end

return DeepStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{B01EAB04-52F1-4FFB-81F4-5ABC3D1FD6CD}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepStateActionRewardStateAction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF63FAD1AA13D408683F9BF635D0587E8">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepClippedDoubleQLearningModel = {}

DeepClippedDoubleQLearningModel.__index = DeepClippedDoubleQLearningModel

setmetatable(DeepClippedDoubleQLearningModel, DeepReinforcementLearningBaseModel)

function DeepClippedDoubleQLearningModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewDeepClippedDoubleQLearningModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewDeepClippedDoubleQLearningModel, DeepClippedDoubleQLearningModel)
	
	NewDeepClippedDoubleQLearningModel:setName("DeepClippedDoubleQLearning")
	
	NewDeepClippedDoubleQLearningModel.EligibilityTrace = parameterDictionary.EligibilityTrace

	NewDeepClippedDoubleQLearningModel.ModelParametersArray = {}
	
	NewDeepClippedDoubleQLearningModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepClippedDoubleQLearningModel.Model
		
		local discountFactor = NewDeepClippedDoubleQLearningModel.discountFactor
		
		local EligibilityTrace = NewDeepClippedDoubleQLearningModel.EligibilityTrace
		
		local ModelParametersArray = NewDeepClippedDoubleQLearningModel.ModelParametersArray

		local maxQValueArray = {}

		for i = 1, 2, 1 do

			Model:setModelParameters(ModelParametersArray[i], true)

			local _, maxQValue = Model:predict(currentFeatureVector)

			table.insert(maxQValueArray, maxQValue[1][1])
			
			ModelParametersArray[i] = Model:getModelParameters(true)

		end

		local maxQValue = math.min(table.unpack(maxQValueArray))

		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * maxQValue)
		
		local ClassesList = Model:getClassesList()

		local actionIndex = table.find(ClassesList, action)
		
		local numberOfClasses = #ClassesList
		
		local outputDimensionSizeArray = {1, numberOfClasses}
		
		local temporalDifferenceErrorVector = AqwamTensorLibrary:createTensor({1, 2})
		
		if (EligibilityTrace) then
			
			EligibilityTrace:increment(1, actionIndex, discountFactor, outputDimensionSizeArray)

		end

		for i = 1, 2, 1 do

			Model:setModelParameters(ModelParametersArray[i], true)

			local previousVector = Model:forwardPropagate(previousFeatureVector, true)

			local lastValue = previousVector[1][actionIndex]
			
			local temporalDifferenceError = targetValue - lastValue
			
			local lossVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 0)

			lossVector[1][actionIndex] = temporalDifferenceError
			
			temporalDifferenceErrorVector[1][i] = temporalDifferenceError
			
			if (EligibilityTrace) then lossVector = EligibilityTrace:calculate(lossVector) end
			
			local negatedLossVector = AqwamTensorLibrary:unaryMinus(lossVector) -- The original non-deep Q-Learning version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.
			
			Model:update(negatedLossVector, true)
			
			ModelParametersArray[i] = Model:getModelParameters(true)

		end
		
		return temporalDifferenceErrorVector

	end)
	
	NewDeepClippedDoubleQLearningModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewDeepClippedDoubleQLearningModel.EligibilityTrace
		
		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewDeepClippedDoubleQLearningModel:setResetFunction(function() 
		
		local EligibilityTrace = NewDeepClippedDoubleQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewDeepClippedDoubleQLearningModel

end

function DeepClippedDoubleQLearningModel:setModelParameters1(ModelParameters1, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[1] = ModelParameters1

	else

		self.ModelParametersArray[1] = self:deepCopyTable(ModelParameters1)

	end

end

function DeepClippedDoubleQLearningModel:setModelParameters2(ModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[2] = ModelParameters2

	else

		self.ModelParametersArray[2] = self:deepCopyTable(ModelParameters2)

	end

end

function DeepClippedDoubleQLearningModel:getModelParameters1(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[1]

	else

		return self:deepCopyTable(self.ModelParametersArray[1])

	end

end

function DeepClippedDoubleQLearningModel:getModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[2]

	else

		return self:deepCopyTable(self.ModelParametersArray[2])

	end

end

return DeepClippedDoubleQLearningModel]]></ProtectedString>
									<string name="ScriptGuid">{5E9ACD37-ABCB-4789-89BB-1959E8D0D856}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepClippedDoubleQLearning</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX56907B3E4BD0442094FEB9D054616526">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepDoubleQLearningModel = {}

DeepDoubleQLearningModel.__index = DeepDoubleQLearningModel

setmetatable(DeepDoubleQLearningModel, DeepReinforcementLearningBaseModel)

local defaultAveragingRate = 0.01

local function rateAverageModelParameters(averagingRate, TargetModelParameters, PrimaryModelParameters)

	local averagingRateComplement = 1 - averagingRate

	for layer = 1, #TargetModelParameters, 1 do

		local PrimaryModelParametersPart = AqwamTensorLibrary:multiply(averagingRate, PrimaryModelParameters[layer])

		local TargetModelParametersPart = AqwamTensorLibrary:multiply(averagingRateComplement, TargetModelParameters[layer])

		TargetModelParameters[layer] = AqwamTensorLibrary:add(PrimaryModelParametersPart, TargetModelParametersPart)

	end

	return TargetModelParameters

end

function DeepDoubleQLearningModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewDeepDoubleQLearningModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewDeepDoubleQLearningModel, DeepDoubleQLearningModel)
	
	NewDeepDoubleQLearningModel:setName("DeepDoubleQLearningV2")
	
	NewDeepDoubleQLearningModel.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate

	NewDeepDoubleQLearningModel.EligibilityTrace = parameterDictionary.EligibilityTrace

	NewDeepDoubleQLearningModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepDoubleQLearningModel.Model
		
		local discountFactor = NewDeepDoubleQLearningModel.discountFactor
		
		local EligibilityTrace = NewDeepDoubleQLearningModel.EligibilityTrace
		
		local PrimaryModelParameters = Model:getModelParameters(true)

		if (not PrimaryModelParameters) then 
			
			Model:generateLayers()
			
			PrimaryModelParameters = Model:getModelParameters(true)
			
		end

		local _, maxQValue = Model:predict(currentFeatureVector)

		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * maxQValue[1][1])

		local previousVector = Model:forwardPropagate(previousFeatureVector)
		
		local ClassesList = Model:getClassesList()

		local actionIndex = table.find(ClassesList, action)

		local lastValue = previousVector[1][actionIndex]

		local temporalDifferenceError = targetValue - lastValue
		
		local numberOfClasses = #ClassesList
		
		local outputDimensionSizeArray = {1, numberOfClasses}

		local temporalDifferenceErrorVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 0)

		temporalDifferenceErrorVector[1][actionIndex] = temporalDifferenceError
		
		if (EligibilityTrace) then

			EligibilityTrace:increment(1, actionIndex, discountFactor, outputDimensionSizeArray)

			temporalDifferenceErrorVector = EligibilityTrace:calculate(temporalDifferenceErrorVector)

		end
		
		local negatedTemporalDifferenceErrorVector = AqwamTensorLibrary:unaryMinus(temporalDifferenceErrorVector) -- The original non-deep Q-Learning version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.

		Model:forwardPropagate(previousFeatureVector, true)

		Model:update(negatedTemporalDifferenceErrorVector, true)

		local TargetModelParameters = Model:getModelParameters(true)

		TargetModelParameters = rateAverageModelParameters(NewDeepDoubleQLearningModel.averagingRate, TargetModelParameters, PrimaryModelParameters)

		Model:setModelParameters(TargetModelParameters, true)
		
		return temporalDifferenceErrorVector

	end)
	
	NewDeepDoubleQLearningModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewDeepDoubleQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewDeepDoubleQLearningModel:setResetFunction(function() 
		
		local EligibilityTrace = NewDeepDoubleQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)
	
	return NewDeepDoubleQLearningModel

end

return DeepDoubleQLearningModel]]></ProtectedString>
									<string name="ScriptGuid">{7DC11C16-DD29-4940-B3F1-80BD3FB04A7B}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepDoubleQLearningV2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5B01B2E953B9449EA13075F13155AEA8">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepDoubleQLearningModel = {}

DeepDoubleQLearningModel.__index = DeepDoubleQLearningModel

setmetatable(DeepDoubleQLearningModel, DeepReinforcementLearningBaseModel)

function DeepDoubleQLearningModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewDeepDoubleQLearningModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewDeepDoubleQLearningModel, DeepDoubleQLearningModel)
	
	NewDeepDoubleQLearningModel:setName("DeepDoubleQLearningV1")
	
	NewDeepDoubleQLearningModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewDeepDoubleQLearningModel.ModelParametersArray = parameterDictionary.ModelParametersArray or {}
	
	NewDeepDoubleQLearningModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepDoubleQLearningModel.Model
		
		local randomProbability = math.random()

		local updateSecondModel = (randomProbability >= 0.5)

		local selectedModelNumberForTargetVector = (updateSecondModel and 1) or 2

		local selectedModelNumberForUpdate = (updateSecondModel and 2) or 1

		local temporalDifferenceErrorVector, temporalDifferenceError = NewDeepDoubleQLearningModel:generateTemporalDifferenceErrorVector(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)
		
		local negatedTemporalDifferenceErrorVector = AqwamTensorLibrary:unaryMinus(temporalDifferenceErrorVector) -- The original non-deep Q-Learning version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.
		
		NewDeepDoubleQLearningModel:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		Model:forwardPropagate(previousFeatureVector, true)
		
		Model:update(negatedTemporalDifferenceErrorVector, true)

		NewDeepDoubleQLearningModel:saveModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		return temporalDifferenceError
		
	end)
	
	NewDeepDoubleQLearningModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewDeepDoubleQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)
	
	NewDeepDoubleQLearningModel:setResetFunction(function() 
		
		local EligibilityTrace = NewDeepDoubleQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewDeepDoubleQLearningModel

end

function DeepDoubleQLearningModel:saveModelParametersFromModelParametersArray(index)

	self.ModelParametersArray[index] = self.Model:getModelParameters()

end

function DeepDoubleQLearningModel:loadModelParametersFromModelParametersArray(index)

	local Model = self.Model

	local ModelParametersArray = self.ModelParametersArray

	if (not ModelParametersArray[index]) then

		Model:generateLayers()

		self:saveModelParametersFromModelParametersArray(index)

	end

	local CurrentModelParameters = ModelParametersArray[index]

	Model:setModelParameters(CurrentModelParameters, true)

end

function DeepDoubleQLearningModel:generateTemporalDifferenceErrorVector(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)
	
	local Model = self.Model
	
	local discountFactor = self.discountFactor
	
	local EligibilityTrace = self.EligibilityTrace
	
	self:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
	
	local previousVector = Model:forwardPropagate(previousFeatureVector)
	
	self:loadModelParametersFromModelParametersArray(selectedModelNumberForTargetVector)

	local _, maxQValue = Model:predict(currentFeatureVector)

	local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * maxQValue[1][1])
	
	local ClassesList = Model:getClassesList()
	
	local numberOfClasses = #ClassesList

	local actionIndex = table.find(ClassesList, action)
	
	local lastValue = previousVector[1][actionIndex]
	
	local temporalDifferenceError = targetValue - lastValue
	
	local outputDimensionSizeArray = {1, numberOfClasses}
		
	local temporalDifferenceErrorVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 0)

	temporalDifferenceErrorVector[1][actionIndex] = temporalDifferenceError
	
	if (EligibilityTrace) then

		EligibilityTrace:increment(1, actionIndex, discountFactor, outputDimensionSizeArray)
		
		temporalDifferenceErrorVector = EligibilityTrace:calculate(temporalDifferenceErrorVector)

	end
	
	return temporalDifferenceErrorVector, temporalDifferenceError
	
end

function DeepDoubleQLearningModel:setModelParameters1(ModelParameters1, doNotDeepCopy)
	
	if (doNotDeepCopy) then
		
		self.ModelParametersArray[1] = ModelParameters1
		
	else
		
		self.ModelParametersArray[1] = self:deepCopyTable(ModelParameters1)
		
	end

end

function DeepDoubleQLearningModel:setModelParameters2(ModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[2] = ModelParameters2

	else

		self.ModelParametersArray[2] = self:deepCopyTable(ModelParameters2)

	end

end

function DeepDoubleQLearningModel:getModelParameters1(doNotDeepCopy)
	
	if (doNotDeepCopy) then
		
		return self.ModelParametersArray[1]
		
	else
		
		return self:deepCopyTable(self.ModelParametersArray[1])
		
	end

end

function DeepDoubleQLearningModel:getModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[2]

	else

		return self:deepCopyTable(self.ModelParametersArray[2])

	end

end

return DeepDoubleQLearningModel]]></ProtectedString>
									<string name="ScriptGuid">{9E609806-0F8E-4A14-8DDE-6E02EFF06EA6}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepDoubleQLearningV1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE245CA88034B42768CC5DA0D99F8FC89">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local DeepReinforcementLearningBaseModel = require(script.Parent.DeepReinforcementLearningBaseModel)

DeepQLearningModel = {}

DeepQLearningModel.__index = DeepQLearningModel

setmetatable(DeepQLearningModel, DeepReinforcementLearningBaseModel)

function DeepQLearningModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewDeepQLearningModel = DeepReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewDeepQLearningModel, DeepQLearningModel)
	
	NewDeepQLearningModel:setName("DeepQLearning")
	
	NewDeepQLearningModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewDeepQLearningModel:setCategoricalUpdateFunction(function(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
		
		local Model = NewDeepQLearningModel.Model
		
		local discountFactor = NewDeepQLearningModel.discountFactor
		
		local EligibilityTrace = NewDeepQLearningModel.EligibilityTrace

		local _, maxQValue = Model:predict(currentFeatureVector)

		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * maxQValue[1][1])
		
		local ClassesList = Model:getClassesList()

		local numberOfClasses = #ClassesList

		local previousVector = Model:forwardPropagate(previousFeatureVector)

		local actionIndex = table.find(ClassesList, action)

		local lastValue = previousVector[1][actionIndex]

		local temporalDifferenceError = targetValue - lastValue
		
		local outputDimensionSizeArray = {1, numberOfClasses}

		local temporalDifferenceErrorVector = AqwamTensorLibrary:createTensor(outputDimensionSizeArray, 0)

		temporalDifferenceErrorVector[1][actionIndex] = temporalDifferenceError
		
		if (EligibilityTrace) then

			EligibilityTrace:increment(1, actionIndex, discountFactor, outputDimensionSizeArray)

			temporalDifferenceErrorVector = EligibilityTrace:calculate(temporalDifferenceErrorVector)

		end
		
		local negatedTemporalDifferenceErrorVector = AqwamTensorLibrary:unaryMinus(temporalDifferenceErrorVector) -- The original non-deep Q-Learning version performs gradient ascent. But the neural network performs gradient descent. So, we need to negate the error vector to make the neural network to perform gradient ascent.
		
		Model:forwardPropagate(previousFeatureVector, true)

		Model:update(negatedTemporalDifferenceErrorVector, true)
		
		return temporalDifferenceErrorVector

	end)
	
	NewDeepQLearningModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewDeepQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewDeepQLearningModel:setResetFunction(function()
		
		local EligibilityTrace = NewDeepQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewDeepQLearningModel

end

return DeepQLearningModel]]></ProtectedString>
									<string name="ScriptGuid">{A8C7E0C1-6EFD-488E-8DB3-F6C72E665F46}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepQLearning</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX759B07CF31434844AAAF3BCB4282A8A2">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

KNearestNeighboursClassifierModel = {}

KNearestNeighboursClassifierModel.__index = KNearestNeighboursClassifierModel

setmetatable(KNearestNeighboursClassifierModel, BaseModel)

local defaultKValue = 3

local defaultDistanceFunction = "Euclidean"

local defaultUseWeightedDistance = false

local defaultMaximumNumberOfData = math.huge

local function createDistanceMatrix(distanceFunction, featureMatrix, storedFeatureMatrix)

	local numberOfData = #featureMatrix

	local numberOfStoredData = #storedFeatureMatrix

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfStoredData}, 0)

	local calculateDistance = distanceFunctionDictionary[distanceFunction]

	for datasetIndex = 1, numberOfData, 1 do

		for storedDatasetIndex = 1, numberOfStoredData, 1 do

			distanceMatrix[datasetIndex][storedDatasetIndex] = calculateDistance({featureMatrix[datasetIndex]}, {storedFeatureMatrix[storedDatasetIndex]})

		end

	end

	return distanceMatrix

end

local function deepCopyTable(original, copies)

	copies = copies or {}

	local originalType = type(original)

	local copy

	if (originalType == 'table') then

		if copies[original] then

			copy = copies[original]

		else

			copy = {}

			copies[original] = copy

			for originalKey, originalValue in next, original, nil do

				copy[deepCopyTable(originalKey, copies)] = deepCopyTable(originalValue, copies)

			end

			setmetatable(copy, deepCopyTable(getmetatable(original), copies))

		end

	else -- number, string, boolean, etc

		copy = original

	end

	return copy

end

local function merge(distanceVector, labelVector, left, mid, right)

	local subArrayOne = mid - left + 1
	local subArrayTwo = right - mid

	local leftDistanceVector = {}
	local rightDistanceVector = {}

	local leftLabelVector = {}
	local rightLabelVector = {}

	for i = 1, subArrayOne do

		leftDistanceVector[i] = distanceVector[1][left + i - 1]
		leftLabelVector[i] = labelVector[left + i - 1][1]

	end

	for j = 1, subArrayTwo do

		rightDistanceVector[j] = distanceVector[1][mid + j]
		rightLabelVector[j] = labelVector[mid + j][1]

	end

	local indexOfSubArrayOne = 1
	local indexOfSubArrayTwo = 1
	local indexOfMergedArray = left

	while indexOfSubArrayOne <= subArrayOne and indexOfSubArrayTwo <= subArrayTwo do

		if leftDistanceVector[indexOfSubArrayOne] <= rightDistanceVector[indexOfSubArrayTwo] then

			distanceVector[1][indexOfMergedArray] = leftDistanceVector[indexOfSubArrayOne]
			labelVector[indexOfMergedArray][1] = leftLabelVector[indexOfSubArrayOne]
			indexOfSubArrayOne = indexOfSubArrayOne + 1

		else

			distanceVector[1][indexOfMergedArray] = rightDistanceVector[indexOfSubArrayTwo]
			labelVector[indexOfMergedArray][1] = rightLabelVector[indexOfSubArrayTwo]
			indexOfSubArrayTwo = indexOfSubArrayTwo + 1

		end

		indexOfMergedArray = indexOfMergedArray + 1

	end

	while (indexOfSubArrayOne <= subArrayOne) do

		distanceVector[1][indexOfMergedArray] = leftDistanceVector[indexOfSubArrayOne]
		labelVector[indexOfMergedArray][1] = leftLabelVector[indexOfSubArrayOne]
		indexOfSubArrayOne = indexOfSubArrayOne + 1
		indexOfMergedArray = indexOfMergedArray + 1

	end

	while (indexOfSubArrayTwo <= subArrayTwo) do

		distanceVector[1][indexOfMergedArray] = rightDistanceVector[indexOfSubArrayTwo]
		labelVector[indexOfMergedArray][1] = rightLabelVector[indexOfSubArrayTwo]
		indexOfSubArrayTwo = indexOfSubArrayTwo + 1
		indexOfMergedArray = indexOfMergedArray + 1

	end

end

local function mergeSort(distanceVector, labelVector, startingValue, endValue)

	if (startingValue >= endValue) then return end

	local mid = math.floor(startingValue + (endValue - startingValue) / 2)

	mergeSort(distanceVector, labelVector, startingValue, mid)
	mergeSort(distanceVector, labelVector, mid + 1, endValue)
	merge(distanceVector, labelVector, startingValue, mid, endValue)

end

local function getMajorityClass(sortedLabelVectorLowestToHighest, distanceVector, kValue, useWeightedDistance)

	local classWeights = {}

	local minimumNumberOfkValue = math.min(#sortedLabelVectorLowestToHighest, kValue)

	for k = 1, minimumNumberOfkValue, 1 do

		local label = sortedLabelVectorLowestToHighest[k][1]

		local distance = distanceVector[1][k]

		local weight

		if (useWeightedDistance) then

			weight = ((distance == 0) and math.huge) or (1 / distance)

		else

			weight = 1

		end

		classWeights[label] = (classWeights[label] or 0) + weight

	end

	local majorityClass, maxWeight = nil, -math.huge

	for label, weight in pairs(classWeights) do

		if weight > maxWeight then

			majorityClass = label

			maxWeight = weight

		end

	end

	return majorityClass

end

function KNearestNeighboursClassifierModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewKNearestNeighboursClassifierModel = BaseModel.new(parameterDictionary)

	setmetatable(NewKNearestNeighboursClassifierModel, KNearestNeighboursClassifierModel)
	
	NewKNearestNeighboursClassifierModel:setName("KNearestNeighboursClassifier")

	NewKNearestNeighboursClassifierModel.kValue = parameterDictionary.kValue or defaultKValue

	NewKNearestNeighboursClassifierModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction

	NewKNearestNeighboursClassifierModel.useWeightedDistance = NewKNearestNeighboursClassifierModel:getValueOrDefaultValue(parameterDictionary.useWeightedDistance, defaultUseWeightedDistance)
	
	NewKNearestNeighboursClassifierModel.maximumNumberOfData = parameterDictionary.maximumNumberOfData or defaultMaximumNumberOfData
	
	return NewKNearestNeighboursClassifierModel

end

function KNearestNeighboursClassifierModel:train(featureMatrix, labelVector)
	
	local numberOfData = #featureMatrix

	if (numberOfData ~= #labelVector) then error("The number of data in feature matrix and the label vector are not the same.") end
	
	local maximumNumberOfData = self.maximumNumberOfData

	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		local storedFeatureMatrix = ModelParameters[1]

		local storedLabelVector = ModelParameters[2]

		featureMatrix = AqwamTensorLibrary:concatenate(featureMatrix, storedFeatureMatrix, 1)

		labelVector = AqwamTensorLibrary:concatenate(labelVector, storedLabelVector, 1)
		
		numberOfData = #featureMatrix
		
		if (numberOfData > maximumNumberOfData) then
			
			local newFeatureMatrix = {}
			
			local newLabelVector = {}
			
			local dataShiftIndex = (numberOfData - maximumNumberOfData)
			
			for dataIndex = 1, maximumNumberOfData, 1 do
				
				newFeatureMatrix[dataIndex] = featureMatrix[dataIndex + dataShiftIndex]
				
				newLabelVector[dataIndex] = labelVector[dataIndex + dataShiftIndex]
				
			end
			
			featureMatrix = newFeatureMatrix
			
			labelVector = newLabelVector
			
			numberOfData = maximumNumberOfData
			
		end

	end

	if (numberOfData < self.kValue) and (self.isOutputPrinted) then warn("Number of data is less than the K value. Please add more data before doing any predictions.") end

	self.ModelParameters = {featureMatrix, labelVector}

end

function KNearestNeighboursClassifierModel:predict(featureMatrix, returnOriginalOutput)

	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then 

		local unknownValue = (returnOriginalOutput and math.huge) or nil

		return AqwamTensorLibrary:createTensor({#featureMatrix, 1}, unknownValue) 

	end

	local storedFeatureMatrix = ModelParameters[1]

	local storedLabelVector = ModelParameters[2]

	local kValue = self.kValue

	local distanceFunction = self.distanceFunction

	local useWeightedDistance = self.useWeightedDistance

	local distanceMatrix = createDistanceMatrix(distanceFunction, featureMatrix, storedFeatureMatrix)

	if (returnOriginalOutput) then return distanceMatrix end
	
	local numberOfOtherData = #storedFeatureMatrix

	local predictedLabelVector = {}
	
	for i, unwrappedDistanceVector in ipairs(distanceMatrix) do
		
		local sortedDistanceVector = {deepCopyTable(unwrappedDistanceVector)}

		local sortedLabelVectorLowestToHighest = deepCopyTable(storedLabelVector)

		mergeSort(sortedDistanceVector, sortedLabelVectorLowestToHighest, 1, numberOfOtherData)

		local majorityClass = getMajorityClass(sortedLabelVectorLowestToHighest, sortedDistanceVector, kValue, useWeightedDistance)

		predictedLabelVector[i] = {majorityClass}
		
	end

	return predictedLabelVector

end

return KNearestNeighboursClassifierModel]]></ProtectedString>
									<string name="ScriptGuid">{E209546B-B52F-4661-8A1F-46318FF477C1}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">KNearestNeighboursClassifier</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEE3B9A483A3B4855BAC8EE9A1E72BD96">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

KMeansModel = {}

KMeansModel.__index = KMeansModel

setmetatable(KMeansModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultNumberOfClusters = 1

local defaultDistanceFunction = "Euclidean"

local defaultMode = "Hybrid"

local defaultSetInitialCentroidsOnDataPoints = true

local defaultSetTheCentroidsDistanceFarthest = true

local defaultMaximumNumberOfDataPoints = nil

local function assignToCluster(distanceMatrix) -- Number of columns -> number of clusters
	
	local numberOfDistances = #distanceMatrix
	
	local clusterNumberVector = AqwamTensorLibrary:createTensor({numberOfDistances, 1})

	local clusterDistanceVector = AqwamTensorLibrary:createTensor({numberOfDistances, 1}) 

	for dataIndex, distanceVector in ipairs(distanceMatrix) do

		local closestClusterNumber

		local shortestDistance = math.huge

		for i, distance in ipairs(distanceVector) do

			if (distance < shortestDistance) then

				closestClusterNumber = i

				shortestDistance = distance

			end

		end

		clusterNumberVector[dataIndex][1] = closestClusterNumber

		clusterDistanceVector[dataIndex][1] = shortestDistance

	end

	return clusterNumberVector, clusterDistanceVector
	
end

local function createDistanceMatrix(distanceFunction, matrix1, matrix2)

	local numberOfData1 = #matrix1

	local numberOfData2 = #matrix2

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData1, numberOfData2})

	for matrix1Index = 1, numberOfData1, 1 do

		for matrix2Index = 1, numberOfData2, 1 do

			distanceMatrix[matrix1Index][matrix2Index] = distanceFunction({matrix1[matrix1Index]}, {matrix2[matrix2Index]})

		end

	end

	return distanceMatrix

end

local function chooseFarthestCentroidFromDatasetDistanceMatrix(distanceMatrix, blacklistedDataIndexArray)

	local dataIndex

	local maxDistance = -math.huge

	for row = 1, #distanceMatrix, 1 do

		if (not table.find(blacklistedDataIndexArray, row)) then

			local totalDistance = 0

			for column = 1, #distanceMatrix[1], 1 do totalDistance = totalDistance + distanceMatrix[row][column] end

			if (totalDistance > maxDistance) then

				maxDistance = totalDistance

				dataIndex = row

			end

		end

	end

	return dataIndex

end

local function chooseFarthestCentroids(featureMatrix, numberOfClusters, distanceFunction)
	
	local centroidMatrix = {}
	
	local dataIndexArray = {}
	
	local dataIndex
	
	local distanceMatrix = createDistanceMatrix(distanceFunction, featureMatrix, featureMatrix)
	
	repeat
		
		dataIndex = chooseFarthestCentroidFromDatasetDistanceMatrix(distanceMatrix, dataIndexArray)
		
		table.insert(dataIndexArray, dataIndex)
		
	until (#dataIndexArray == numberOfClusters)
	
	for row = 1, numberOfClusters, 1 do
		
		dataIndex = dataIndexArray[row]
		
		table.insert(centroidMatrix, featureMatrix[dataIndex])
		
	end
	
	return centroidMatrix
	
end

local function chooseRandomCentroids(featureMatrix, numberOfClusters)

	local modelParameters = {}

	local numberOfRows = #featureMatrix

	local randomRow

	local selectedRows = {}

	local hasANewRandomRowChosen

	for cluster = 1, numberOfClusters, 1 do

		repeat

			randomRow = Random.new():NextInteger(1, numberOfRows)

			hasANewRandomRowChosen = not (table.find(selectedRows, randomRow))

			if hasANewRandomRowChosen then

				table.insert(selectedRows, randomRow)
				
				modelParameters[cluster] = featureMatrix[randomRow]

			end

		until hasANewRandomRowChosen

	end

	return modelParameters

end

local function createClusterAssignmentArray(distanceMatrix)
	
	local numberOfClusters = #distanceMatrix[1]
	
	local clusterAssignmentArray = {}
	
	local dataPointClusterNumber
	
	local minimumDistance
	
	local index
	
	for dataIndex, unwrappedDistanceVector in ipairs(distanceMatrix) do
		
		minimumDistance = math.huge
		
		index = nil
		
		for clusterIndex, distance in ipairs(unwrappedDistanceVector) do
			
			if (distance < minimumDistance) then
				
				minimumDistance = distance
				
				index = clusterIndex
			end
			
		end
		
		clusterAssignmentArray[dataIndex] = index or math.random(1, numberOfClusters)
		
	end
	
	return clusterAssignmentArray
	
end

local function calculateCost(distanceMatrix, clusterAssignmentArray)
	
	local cost = 0
	
	local clusterIndex
	
	for dataIndex, unwrappedDistanceVector in ipairs(distanceMatrix) do
		
		clusterIndex = clusterAssignmentArray[dataIndex]
		
		cost = cost + unwrappedDistanceVector[clusterIndex]
		
	end
	
	cost = cost / #distanceMatrix
	
	return cost
	
end

local function calculateMean(featureMatrix, numberOfClusters, clusterAssignmentArray)
	
	local numberOfFeatures = #featureMatrix[1]
	
	local centroidMatrix = AqwamTensorLibrary:createTensor({numberOfClusters, numberOfFeatures}, 0)
	
	local clusterCountArray = table.create(numberOfClusters, 0)
	
	local clusterIndex
	
	local clusterCount
	
	for dataIndex, unwrappedFeatureVector in ipairs(featureMatrix) do
		
		clusterIndex = clusterAssignmentArray[dataIndex]
		
		centroidMatrix[clusterIndex] = AqwamTensorLibrary:add({centroidMatrix[clusterIndex]}, {unwrappedFeatureVector})[1]
		
		clusterCountArray[clusterIndex] = clusterCountArray[clusterIndex] + 1
		
	end
	
	for clusterIndex, unwrappedCentroidVector in ipairs(centroidMatrix) do
		
		clusterCount = clusterCountArray[clusterIndex]
		
		if (clusterCount ~= 0) then
			
			centroidMatrix[clusterIndex] = AqwamTensorLibrary:divide({unwrappedCentroidVector}, clusterCount)[1]
			
		end
		
	end
	
	return centroidMatrix
	
end

function KMeansModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations
	
	local NewKMeansModel = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewKMeansModel, KMeansModel)
	
	NewKMeansModel:setName("KMeans")

	NewKMeansModel.numberOfClusters = parameterDictionary.numberOfClusters or defaultNumberOfClusters
	
	NewKMeansModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction

	NewKMeansModel.mode = parameterDictionary.mode or defaultMode

	NewKMeansModel.setInitialCentroidsOnDataPoints =  NewKMeansModel:getValueOrDefaultValue(parameterDictionary.setInitialCentroidsOnDataPoints, defaultSetInitialCentroidsOnDataPoints)
	
	NewKMeansModel.setTheCentroidsDistanceFarthest = NewKMeansModel:getValueOrDefaultValue(parameterDictionary.setTheCentroidsDistanceFarthest, defaultSetTheCentroidsDistanceFarthest)
	
	NewKMeansModel.maximumNumberOfDataPoints = NewKMeansModel:getValueOrDefaultValue(parameterDictionary.maximumNumberOfDataPoints, defaultMaximumNumberOfDataPoints)
	
	return NewKMeansModel
	
end

function KMeansModel:initializeCentroids(featureMatrix, numberOfClusters, distanceFunction)
	
	local setInitialCentroidsOnDataPoints = self.setInitialCentroidsOnDataPoints
	
	local setTheCentroidsDistanceFarthest = self.setTheCentroidsDistanceFarthest
	
	if (setInitialCentroidsOnDataPoints) and (numberOfClusters == 1) then
		
		return AqwamTensorLibrary:mean(featureMatrix, 1)
	
	elseif (setInitialCentroidsOnDataPoints) and (setTheCentroidsDistanceFarthest) and (#featureMatrix >= numberOfClusters) then

		return chooseFarthestCentroids(featureMatrix, numberOfClusters, distanceFunction)

	elseif (setInitialCentroidsOnDataPoints) and (not setTheCentroidsDistanceFarthest) then

		return chooseRandomCentroids(featureMatrix, numberOfClusters)

	else

		return self:initializeMatrixBasedOnMode({numberOfClusters, #featureMatrix[1]})

	end
	
end

local function batchKMeans(featureMatrix, centroidMatrix, distanceMatrix)

	local clusterAssignmentArray = createClusterAssignmentArray(distanceMatrix) -- data x clusters
	
	centroidMatrix = calculateMean(featureMatrix, #centroidMatrix, clusterAssignmentArray)
	
	return centroidMatrix, clusterAssignmentArray
	
end

local function sequentialKMeans(featureMatrix, centroidMatrix, distanceMatrix, numberOfDataPointVector)
	
	local numberOfData = #featureMatrix
	
	local numberOfClusters = #centroidMatrix
	
	local clusterAssignmentArray = {}
	
	for dataIndex, unwrappedFeatureVector in ipairs(featureMatrix) do

		local featureVector = {unwrappedFeatureVector}

		local minimumDistance = math.huge

		local clusterIndexWithMinimumDistance

		for clusterIndex = 1, numberOfClusters, 1 do

			local distance = distanceMatrix[dataIndex][clusterIndex]

			if (distance < minimumDistance) then

				minimumDistance = distance

				clusterIndexWithMinimumDistance = clusterIndex

			end

		end

		local numberOfDataPoints = numberOfDataPointVector[clusterIndexWithMinimumDistance][1] + 1

		local centroidVector = {centroidMatrix[clusterIndexWithMinimumDistance]}

		local centroidChangeVectorPart1 = AqwamTensorLibrary:subtract(featureVector, centroidVector)

		local centroidChangeVector = AqwamTensorLibrary:multiply((1 / numberOfDataPoints), centroidChangeVectorPart1)

		local newCentroidVector = AqwamTensorLibrary:add(centroidVector, centroidChangeVector)

		numberOfDataPointVector[clusterIndexWithMinimumDistance][1] = numberOfDataPoints

		centroidMatrix[clusterIndexWithMinimumDistance] = newCentroidVector[1]
		
		clusterAssignmentArray[dataIndex] = clusterIndexWithMinimumDistance

	end
	
	return centroidMatrix, clusterAssignmentArray
	
end

local function createNumberOfDataPointVector(numberOfDataPointVector, clusterAssignmentArray, maximumNumberOfDataPoints)
	
	local numberOfDataPointArray = {}
	
	local newNumberOfDataPointVector = {}
	
	local totalNumberOfDataPoint

	for dataIndex, clusterAssignmentIndex in ipairs(clusterAssignmentArray) do

		numberOfDataPointArray[clusterAssignmentIndex] = (numberOfDataPointArray[clusterAssignmentIndex] or 0) + 1

	end
	
	for clusterIndex, numberOfDataPoint in ipairs(numberOfDataPointArray) do
		
		totalNumberOfDataPoint = numberOfDataPoint 
			
		if (numberOfDataPointVector) then totalNumberOfDataPoint = totalNumberOfDataPoint + numberOfDataPointVector[clusterIndex][1] end
		
		if (type(maximumNumberOfDataPoints) == "number") then
			
			if (totalNumberOfDataPoint > maximumNumberOfDataPoints) then totalNumberOfDataPoint = 1 end
			
		end
		
		newNumberOfDataPointVector[clusterIndex] = {totalNumberOfDataPoint}
		
	end
	
	return newNumberOfDataPointVector
	
end

local kMeansFunctionList = {
	
	["Batch"] = batchKMeans,
	
	["Sequential"] = sequentialKMeans,
	
}

function KMeansModel:train(featureMatrix)
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local numberOfClusters = self.numberOfClusters
	
	local distanceFunction = self.distanceFunction
	
	local mode = self.mode
	
	local maximumNumberOfDataPoints = self.maximumNumberOfDataPoints
	
	local ModelParameters = self.ModelParameters or {}

	local centroidMatrix = ModelParameters[1]

	local numberOfDataPointVector = ModelParameters[2]

	if (mode == "Hybrid") then -- This must be always above the centroid initialization check. Otherwise it will think this is second training round despite it being the first one!
		
		mode = (centroidMatrix and numberOfDataPointVector and "Sequential") or "Batch"		

	end
	
	local kMeansFunction = kMeansFunctionList[mode]

	if (not kMeansFunction) then error("Unknown mode.") end
	
	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]

	if (not distanceFunctionToApply) then error("Unknown distance function.") end
	
	if (mode == "Sequential") then
		
		numberOfDataPointVector = numberOfDataPointVector or AqwamTensorLibrary:createTensor({numberOfClusters, 1}, 0)
		
		maximumNumberOfIterations = 1 
		
	end
	
	if (centroidMatrix) then
		
		if (#featureMatrix[1] ~= #centroidMatrix[1]) then error("The number of features are not the same as the model parameters.") end
		
	else
		
		centroidMatrix = self:initializeCentroids(featureMatrix, numberOfClusters, distanceFunctionToApply)
		
	end

	local numberOfIterations = 0
	
	local costArray = {}
	
	local clusterAssignmentArray

	local distanceMatrix
	
	local cost
	
	local numberOfDataPointArray
	
	repeat
		
		numberOfIterations = numberOfIterations + 1
		
		self:iterationWait()
		
		distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, centroidMatrix)

		centroidMatrix, clusterAssignmentArray = kMeansFunction(featureMatrix, centroidMatrix, distanceMatrix, numberOfDataPointVector)
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return calculateCost(distanceMatrix, clusterAssignmentArray)

		end)
		
		if (cost) then

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end
		
	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	numberOfDataPointVector = createNumberOfDataPointVector(numberOfDataPointVector, clusterAssignmentArray, maximumNumberOfDataPoints)
	
	self.ModelParameters = {centroidMatrix, numberOfDataPointVector}
	
	return costArray
	
end

function KMeansModel:predict(featureMatrix, returnOriginalOutput)
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
	
	local ModelParameters = self.ModelParameters
	
	local centroidMatrix
	
	if (not ModelParameters) then
		
		local numberOfClusters = self.numberOfClusters

		centroidMatrix = self:initializeCentroids(featureMatrix, numberOfClusters, distanceFunctionToApply)
		
		local numberOfDataPointVector = AqwamTensorLibrary:createTensor({numberOfClusters, 1})
		
		self.ModelParameters = {centroidMatrix, numberOfDataPointVector}
		
	else
		
		centroidMatrix = ModelParameters[1]

	end
	
	local distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, centroidMatrix)
	
	if (returnOriginalOutput) then return distanceMatrix end

	local clusterNumberVector, clusterDistanceVector = assignToCluster(distanceMatrix)

	return clusterNumberVector, clusterDistanceVector
	
end

return KMeansModel]]></ProtectedString>
									<string name="ScriptGuid">{9351B950-2707-4686-B25F-61FD276EDA1F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">KMeans</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD6051E7776AC457FB28692DEC3531FDE">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

DeepReinforcementLearningActorCriticBaseModel = {}

DeepReinforcementLearningActorCriticBaseModel.__index = DeepReinforcementLearningActorCriticBaseModel

setmetatable(DeepReinforcementLearningActorCriticBaseModel, BaseInstance)

local defaultDiscountFactor = 0.95

function DeepReinforcementLearningActorCriticBaseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewDeepReinforcementLearningActorCriticBaseModel = {}
	
	setmetatable(NewDeepReinforcementLearningActorCriticBaseModel, DeepReinforcementLearningActorCriticBaseModel)
	
	NewDeepReinforcementLearningActorCriticBaseModel:setName("DeepReinforcementLearningActorCriticBaseModel")

	NewDeepReinforcementLearningActorCriticBaseModel:setClassName("DeepReinforcementLearningActorCriticModel")

	NewDeepReinforcementLearningActorCriticBaseModel.discountFactor = parameterDictionary.discountFactor or defaultDiscountFactor

	NewDeepReinforcementLearningActorCriticBaseModel.ActorModel = parameterDictionary.ActorModel
	
	NewDeepReinforcementLearningActorCriticBaseModel.CriticModel = parameterDictionary.CriticModel
	
	return NewDeepReinforcementLearningActorCriticBaseModel
	
end

function DeepReinforcementLearningActorCriticBaseModel:setDiscountFactor(discountFactor)

	self.discountFactor = discountFactor

end

function DeepReinforcementLearningActorCriticBaseModel:getDiscountFactor()

	return self.discountFactor

end

function DeepReinforcementLearningActorCriticBaseModel:setActorModel(ActorModel)
	
	self.ActorModel = ActorModel
	
end

function DeepReinforcementLearningActorCriticBaseModel:setCriticModel(CriticModel)

	self.CriticModel = CriticModel
	
end

function DeepReinforcementLearningActorCriticBaseModel:getActorModel()

	return self.ActorModel

end

function DeepReinforcementLearningActorCriticBaseModel:getCriticModel()

	return self.CriticModel

end

function DeepReinforcementLearningActorCriticBaseModel:setModelParametersArray(ModelParametersArray, doNotDeepCopy)

	self.ActorModel:setModelParameters(ModelParametersArray[1], doNotDeepCopy)
	
	self.CriticModel:setModelParameters(ModelParametersArray[2], doNotDeepCopy)

end

function DeepReinforcementLearningActorCriticBaseModel:getModelParametersArray(doNotDeepCopy)
	
	local ActorModelParameters = self.ActorModel:getModelParameters(doNotDeepCopy)
	
	local CriticModelParameters = self.CriticModel:getModelParameters(doNotDeepCopy)

	return {ActorModelParameters, CriticModelParameters}

end

function DeepReinforcementLearningActorCriticBaseModel:predict(featureVector, returnOriginalOutput)
	
	return self.ActorModel:predict(featureVector, returnOriginalOutput)
	
end

function DeepReinforcementLearningActorCriticBaseModel:getActionsList()

	return self.ActorModel:getClassesList()

end

function DeepReinforcementLearningActorCriticBaseModel:setCategoricalUpdateFunction(categoricalUpdateFunction)

	self.categoricalUpdateFunction = categoricalUpdateFunction

end

function DeepReinforcementLearningActorCriticBaseModel:setDiagonalGaussianUpdateFunction(diagonalGaussianUpdateFunction)

	self.diagonalGaussianUpdateFunction = diagonalGaussianUpdateFunction

end

function DeepReinforcementLearningActorCriticBaseModel:categoricalUpdate(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

	return self.categoricalUpdateFunction(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

end

function DeepReinforcementLearningActorCriticBaseModel:diagonalGaussianUpdate(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

	return self.diagonalGaussianUpdateFunction(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

end

function DeepReinforcementLearningActorCriticBaseModel:setEpisodeUpdateFunction(episodeUpdateFunction)

	self.episodeUpdateFunction = episodeUpdateFunction

end

function DeepReinforcementLearningActorCriticBaseModel:episodeUpdate(terminalStateValue)

	return self.episodeUpdateFunction(terminalStateValue)

end

function DeepReinforcementLearningActorCriticBaseModel:setResetFunction(resetFunction)

	self.resetFunction = resetFunction

end

function DeepReinforcementLearningActorCriticBaseModel:reset()

	return self.resetFunction() 

end

return DeepReinforcementLearningActorCriticBaseModel]]></ProtectedString>
									<string name="ScriptGuid">{6AFD43A5-002B-411A-910D-DAA0C7D1F6B8}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepReinforcementLearningActorCriticBaseModel</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6DC63740FD1040FA848409666B4B64BE">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

DeepReinforcementLearningBaseModel = {}

DeepReinforcementLearningBaseModel.__index = DeepReinforcementLearningBaseModel

setmetatable(DeepReinforcementLearningBaseModel, BaseInstance)

local defaultDiscountFactor = 0.95

function DeepReinforcementLearningBaseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewDeepReinforcementLearningBaseModel = {}
	
	setmetatable(NewDeepReinforcementLearningBaseModel, DeepReinforcementLearningBaseModel)
	
	NewDeepReinforcementLearningBaseModel:setName("DeepReinforcementLearningBaseModel")

	NewDeepReinforcementLearningBaseModel:setClassName("DeepReinforcementLearningModel")
	
	NewDeepReinforcementLearningBaseModel.discountFactor = parameterDictionary.discountFactor or defaultDiscountFactor
	
	NewDeepReinforcementLearningBaseModel.Model = parameterDictionary.Model
	
	return NewDeepReinforcementLearningBaseModel
	
end

function DeepReinforcementLearningBaseModel:setDiscountFactor(discountFactor)
	
	self.discountFactor = discountFactor
	
end

function DeepReinforcementLearningBaseModel:getDiscountFactor()
	
	return self.discountFactor
	
end

function DeepReinforcementLearningBaseModel:setModel(Model)
	
	self.Model = Model
	
end

function DeepReinforcementLearningBaseModel:getModel()

	return self.Model

end

function DeepReinforcementLearningBaseModel:setModelParameters(ModelParameters, doNotDeepCopy)

	self.Model:setModelParameters(ModelParameters, doNotDeepCopy)

end

function DeepReinforcementLearningBaseModel:getModelParameters(doNotDeepCopy)

	return self.Model:getModelParameters(doNotDeepCopy)

end

function DeepReinforcementLearningBaseModel:predict(featureVector, returnOriginalOutput)

	return self.Model:predict(featureVector, returnOriginalOutput)

end

function DeepReinforcementLearningBaseModel:getActionsList()
	
	return self.Model:getClassesList()
	
end

function DeepReinforcementLearningBaseModel:setCategoricalUpdateFunction(categoricalUpdateFunction)

	self.categoricalUpdateFunction = categoricalUpdateFunction

end

function DeepReinforcementLearningBaseModel:setDiagonalGaussianUpdateFunction(diagonalGaussianUpdateFunction)
	
	self.diagonalGaussianUpdateFunction = diagonalGaussianUpdateFunction
	
end

function DeepReinforcementLearningBaseModel:categoricalUpdate(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)
	
	return self.categoricalUpdateFunction(previousFeatureVector, action, rewardValue, currentFeatureVector, terminalStateValue)

end

function DeepReinforcementLearningBaseModel:diagonalGaussianUpdate(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

	return self.diagonalGaussianUpdateFunction(previousFeatureVector, actionMeanVector, actionStandardDeviationVector, actionNoiseVector, rewardValue, currentFeatureVector, terminalStateValue)

end

function DeepReinforcementLearningBaseModel:setEpisodeUpdateFunction(episodeUpdateFunction)

	self.episodeUpdateFunction = episodeUpdateFunction

end

function DeepReinforcementLearningBaseModel:episodeUpdate(terminalStateValue)

	return self.episodeUpdateFunction(terminalStateValue)

end

function DeepReinforcementLearningBaseModel:setResetFunction(resetFunction)

	self.resetFunction = resetFunction

end

function DeepReinforcementLearningBaseModel:reset()
	
	self.resetFunction() 

end

return DeepReinforcementLearningBaseModel]]></ProtectedString>
									<string name="ScriptGuid">{2237B5A4-0E82-458E-A515-3B2FDBC38763}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DeepReinforcementLearningBaseModel</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBF794E8B32C441F7907DFEEFD71C132F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

local AffinityPropagationModel = {}

AffinityPropagationModel.__index = AffinityPropagationModel

setmetatable(AffinityPropagationModel, IterativeMethodBaseModel)

local defaultMaxNumberOfIterations = 500

local defaultDamping = 0.5

local defaultDistanceFunction = "Euclidean"

local defaultPreferenceType = "Median"

local function createDistanceMatrix(distanceFunction, matrix1, matrix2)

	local numberOfData1 = #matrix1

	local numberOfData2 = #matrix2

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData1, numberOfData2})

	for i = 1, numberOfData1, 1 do

		for j = 1, numberOfData2, 1 do

			distanceMatrix[i][j] = distanceFunction({matrix1[i]}, {matrix2[j]})

		end

	end

	return distanceMatrix

end

local function getMedian(array)
	
	table.sort(array)
	
	local mid = math.floor(#array / 2)
	
	if ((#array % 2) == 0) then
		
		return ((array[mid] + array[mid + 1]) / 2)
		
	else
		
		return array[mid + 1]
		
	end
	
end

local function getAverage(array)
	
	local total = 0
	
	for _, value in ipairs(array) do
		
		total = total + value
		
	end
	
	return (total / #array)
	
end

local function setPreferencesToSimilarityMatrix(similarityMatrix, numberOfData, preferenceType, preferenceValueArray)
	
	local preferenceValue
	
	local triangularElementArray = {} -- Collect upper triangular non-diagonal elements

	for i = 1, numberOfData, 1 do
		
		for j = i + 1, numberOfData, 1 do
			
			table.insert(triangularElementArray, similarityMatrix[i][j])
			
		end
		
	end

	if (preferenceType == "Median") then
		
		preferenceValue = getMedian(triangularElementArray)
		
	elseif (preferenceType == "Average") then

		preferenceValue = getAverage(triangularElementArray)

	elseif (preferenceType == "Minimum") then

		preferenceValue = math.min(table.unpack(triangularElementArray))
		
	elseif (preferenceType == "Maximum") then

		preferenceValue = math.max(table.unpack(triangularElementArray))
		
	elseif (preferenceType == "Precomputed") then
		
		if (preferenceValueArray == nil) then error("No preference value array!") end
		
		if (#preferenceValueArray ~= numberOfData) then error("The length of the preference value array is not equal to number of data!") end
		
	else

		error("Invalid preference type!")

	end
	
	for i = 1, numberOfData do -- Fill diagonal with the computed preference value
		
		if (preferenceType == "Precomputed") then
			
			similarityMatrix[i][i] = preferenceValueArray[i]
			
		else
			
			similarityMatrix[i][i] = preferenceValue
			
		end
		
	end
	
	return similarityMatrix

end

local function calculateResponsibilityMatrix(responsibilityMatrix, availabilityMatrix, similarityMatrix)
	
	local numberOfData = #responsibilityMatrix

	for i = 1, numberOfData do

		for j = 1, numberOfData do

			local maxResponsibility = -math.huge

			for k = 1, numberOfData do

				if (k == j) then continue end

				maxResponsibility = math.max(maxResponsibility, similarityMatrix[i][k] + availabilityMatrix[k][j])

			end

			responsibilityMatrix[i][j] = similarityMatrix[i][j] - maxResponsibility

		end

	end
	
	return responsibilityMatrix

end

local function calculateAvailibilityMatrix(responsibilityMatrix, availibilityMatrix, damping)
	
	local updateFactor = 1 - damping
	
	local numberOfData = #responsibilityMatrix

	for i = 1, numberOfData, 1 do

		for j = 1, numberOfData, 1 do
			
			local availability
			
			local sumMaxAvailability = 0

			if (i ~= j) then
				
				for k = 1, numberOfData, 1 do

					if (k == i) and (k == j) then continue end

					local maxAvailability = math.max(0, responsibilityMatrix[k][j])
					
					sumMaxAvailability = sumMaxAvailability + maxAvailability

				end
				
				availability = (updateFactor * (responsibilityMatrix[j][j] + sumMaxAvailability)) + (damping * availibilityMatrix[i][j])
				
				availability = math.min(0, availability)
				
			else
				
				for k = 1, numberOfData, 1 do

					if (k == i) then continue end

					local maxAvailability = math.max(0, responsibilityMatrix[k][j])

					sumMaxAvailability = sumMaxAvailability + maxAvailability

				end
				
				availability = (updateFactor * sumMaxAvailability) + (damping * availibilityMatrix[i][j])

			end
			
			availibilityMatrix[i][j] = availability

		end

	end
	
	return availibilityMatrix

end

local function calculateCost(clusterNumberArray, responsibilityMatrix)

	local totalCost = 0

	for i = 1, #clusterNumberArray do

		totalCost += responsibilityMatrix[i][clusterNumberArray[i]]

	end

	return totalCost

end

local function assignClusters(responsibilityMatrix, availibilityMatrix)
	
	local calculatedValuesMatrix = AqwamTensorLibrary:add(responsibilityMatrix, availibilityMatrix)
	
	local clusterNumberArray = {}
	
	for i = 1, #calculatedValuesMatrix, 1 do
		
		local calculatedValuesVector = {calculatedValuesMatrix[i]}
		
		local clusterIndexArray = AqwamTensorLibrary:findMaximumValueDimensionIndexArray(calculatedValuesVector)

		if (clusterIndexArray == nil) then continue end

		local clusterNumber = clusterIndexArray[2]

		clusterNumberArray[i] = clusterNumber
		
	end

	return clusterNumberArray

end

function AffinityPropagationModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaxNumberOfIterations

	local NewAffinityPropagationModel = IterativeMethodBaseModel.new(parameterDictionary)

	setmetatable(NewAffinityPropagationModel, AffinityPropagationModel)
	
	NewAffinityPropagationModel:setName("AffinityPropagation")

	NewAffinityPropagationModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction
	
	NewAffinityPropagationModel.preferenceType = parameterDictionary.preferenceType or defaultPreferenceType

	NewAffinityPropagationModel.damping = parameterDictionary.damping or defaultDamping
	
	NewAffinityPropagationModel.preferenceValueArray = parameterDictionary.preferenceValueArray

	return NewAffinityPropagationModel

end

function AffinityPropagationModel:train(featureMatrix)
	
	local damping = self.damping
	
	local ModelParameters = self.ModelParameters or {}
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
	
	if (not distanceFunctionToApply) then error("Unknown distance function.") end
	
	local numberOfData = #featureMatrix
	
	local dimensionSizeArray = {numberOfData, numberOfData}
	
	local responsibilityMatrix = ModelParameters[3] or AqwamTensorLibrary:createTensor(dimensionSizeArray)

	local availabilityMatrix = ModelParameters[4] or AqwamTensorLibrary:createTensor(dimensionSizeArray)
	
	local distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, featureMatrix)

	local similarityMatrix = AqwamTensorLibrary:multiply(-1, distanceMatrix)

	local numberOfIterations = 0

	local costArray = {}

	local clusterNumberArray

	local cost

	similarityMatrix = setPreferencesToSimilarityMatrix(similarityMatrix, numberOfData, self.preferenceType, self.preferenceValueArray)

	repeat
		
		numberOfIterations = numberOfIterations + 1
		
		self:iterationWait()

		responsibilityMatrix = calculateResponsibilityMatrix(responsibilityMatrix, availabilityMatrix, similarityMatrix)

		availabilityMatrix = calculateAvailibilityMatrix(responsibilityMatrix, availabilityMatrix, damping)
		
		clusterNumberArray = assignClusters(responsibilityMatrix, availabilityMatrix)
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()
			
			return calculateCost(clusterNumberArray, responsibilityMatrix)
			
		end) 
		
		if (cost) then
			
			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)
			
		end
		
	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	self.ModelParameters = {featureMatrix, clusterNumberArray, responsibilityMatrix, availabilityMatrix}

	return costArray

end

function AffinityPropagationModel:predict(featureMatrix)
	
	local ModelParameters = self.ModelParameters
	
	local dimensionSizeArray = {#featureMatrix, 1}
	
	if (not ModelParameters) then
		
		local placeholderClusterVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, math.huge)
		
		local placeholderSimilarityVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, math.huge)
		
		return placeholderClusterVector, placeholderSimilarityVector
		
	end
	
	local storedFeatureMatrix, clusterNumberArray = table.unpack(ModelParameters)

	local maximumSimilarityVector = AqwamTensorLibrary:createTensor(dimensionSizeArray)
	
	local predictedClusterVector = AqwamTensorLibrary:createTensor(dimensionSizeArray)
	
	local storedFeatureMatrix, clusterNumberArray = table.unpack(ModelParameters)
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
	
	local distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, storedFeatureMatrix)
	
	local storedFeatureMatrixRowIndex
	
	local index
	
	for i, unwrappedDistanceVector in ipairs(distanceMatrix) do

		index = AqwamTensorLibrary:findMinimumValueDimensionIndexArray({unwrappedDistanceVector})

		if (index) then
			
			storedFeatureMatrixRowIndex = index[2]

			predictedClusterVector[i][1] = clusterNumberArray[storedFeatureMatrixRowIndex]

			maximumSimilarityVector[i][1] = unwrappedDistanceVector[storedFeatureMatrixRowIndex]
			
		end
		
	end
	
	return predictedClusterVector, maximumSimilarityVector

end

return AffinityPropagationModel]]></ProtectedString>
									<string name="ScriptGuid">{0F5E5FAC-ACB4-4D69-A65F-9D08570ADA79}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AffinityPropagation</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX136FED4D58D24AE8A60FEC6A8A3D7956">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local BaseModel = require(script.Parent.BaseModel)

IterativeBaseModel = {}

IterativeBaseModel.__index = IterativeBaseModel

setmetatable(IterativeBaseModel, BaseModel)

function IterativeBaseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewBaseModel = BaseModel.new(parameterDictionary)

	setmetatable(NewBaseModel, IterativeBaseModel)

	NewBaseModel:setName("IterativeBaseModel")

	NewBaseModel:setClassName("IterativeModel")
	
	NewBaseModel.maximumNumberOfIterations = NewBaseModel:getValueOrDefaultValue(parameterDictionary.maximumNumberOfIterations, 1) 
	
	NewBaseModel.numberOfIterationsPerCostCalculation = NewBaseModel:getValueOrDefaultValue(parameterDictionary.numberOfIterationsPerCostCalculation, 1) 

	NewBaseModel.maximumModelParametersInitializationValue = NewBaseModel:getValueOrDefaultValue(parameterDictionary.maximumModelParametersInitializationValue, nil)
	
	NewBaseModel.minimumModelParametersInitializationValue = NewBaseModel:getValueOrDefaultValue(parameterDictionary.minimumModelParametersInitializationValue, nil)
	
	NewBaseModel.iterationWaitDuration = NewBaseModel:getValueOrDefaultValue(parameterDictionary.iterationWaitDuration, nil)
	
	NewBaseModel.dataWaitDuration = NewBaseModel:getValueOrDefaultValue(parameterDictionary.dataWaitDuration, nil)
	
	NewBaseModel.sequenceWaitDuration = NewBaseModel:getValueOrDefaultValue(parameterDictionary.sequenceWaitDuration, nil)
	
	NewBaseModel.targetCostUpperBound = NewBaseModel:getValueOrDefaultValue(parameterDictionary.targetCostUpperBound, 0)
	
	NewBaseModel.targetCostLowerBound = NewBaseModel:getValueOrDefaultValue(parameterDictionary.targetCostLowerBound, 0)
	
	NewBaseModel.currentCostToCheckForConvergence = NewBaseModel:getValueOrDefaultValue(parameterDictionary.currentCostToCheckForConvergence, nil)
	
	NewBaseModel.currentNumberOfIterationsToCheckIfConverged = NewBaseModel:getValueOrDefaultValue(parameterDictionary.currentNumberOfIterationsToCheckIfConverged, 1)
	
	NewBaseModel.numberOfIterationsToCheckIfConverged = NewBaseModel:getValueOrDefaultValue(parameterDictionary.numberOfIterationsToCheckIfConverged, math.huge)

	return NewBaseModel
	
end

function IterativeBaseModel:setNumberOfIterationsToCheckIfConverged(numberOfIterations)
	
	self.numberOfIterationsToCheckIfConverged = numberOfIterations or self.numberOfIterationsToCheckIfConverged
	
end

function IterativeBaseModel:checkIfConverged(cost)
	
	if (not cost) then return false end
	
	if (not self.currentCostToCheckForConvergence) then
		
		self.currentCostToCheckForConvergence = cost
		
		return false
		
	end
	
	if (self.currentCostToCheckForConvergence ~= cost) then
		
		self.currentNumberOfIterationsToCheckIfConverged = 1
		
		self.currentCostToCheckForConvergence = cost

		return false
		
	end
	
	if (self.currentNumberOfIterationsToCheckIfConverged < self.numberOfIterationsToCheckIfConverged) then
		
		self.currentNumberOfIterationsToCheckIfConverged = self.currentNumberOfIterationsToCheckIfConverged + 1
		
		return false
		
	end
	
	self.currentNumberOfIterationsToCheckIfConverged = 1
	
	self.currentCostToCheckForConvergence = nil
	
	return true
	
end

function IterativeBaseModel:resetConvergenceCheck()
	
	self.currentNumberOfIterationsToCheckIfConverged = 1

	self.currentCostToCheckForConvergence = nil
	
end

function IterativeBaseModel:setTargetCost(upperBound, lowerBound)

	self.targetCostUpperBound = upperBound or self.targetCostUpperBound
	
	self.targetCostLowerBound = lowerBound or self.targetCostLowerBound

end

function IterativeBaseModel:checkIfTargetCostReached(cost)
	
	if (not cost) then return false end
	
	return (cost >= self.targetCostLowerBound) and (cost <= self.targetCostUpperBound)
	
end

function IterativeBaseModel:calculateCostWhenRequired(currentNumberOfIteration, costFunction)
	
	if ((currentNumberOfIteration % self.numberOfIterationsPerCostCalculation) == 0) then 
		
		return costFunction()
		
	else
		
		return nil
		
	end
	
end

function IterativeBaseModel:setNumberOfIterationsPerCostCalculation(numberOfIterationsPerCostCalculation)
	
	self.numberOfIterationsPerCostCalculation = self:getValueOrDefaultValue(numberOfIterationsPerCostCalculation, self.numberOfIterationsPerCostCalculation)
	
end

function IterativeBaseModel:setWaitDurations(iterationWaitDuration, dataWaitDuration, sequenceWaitDuration)
	
	self.iterationWaitDuration = iterationWaitDuration

	self.dataWaitDuration = dataWaitDuration

	self.sequenceWaitDuration = sequenceWaitDuration
	
end

function IterativeBaseModel:baseModelWait(waitDuration)
	
	if (type(waitDuration) == "nil") or (waitDuration == false) then return nil end
	
	if (type(waitDuration) == "number") then
		
		task.wait(waitDuration)
		
	else
		
		task.wait()
		
	end
	
end

function IterativeBaseModel:iterationWait()
	
	self:baseModelWait(self.iterationWaitDuration)
	
end

function IterativeBaseModel:dataWait()

	self:baseModelWait(self.dataWaitDuration)

end

function IterativeBaseModel:sequenceWait()

	self:baseModelWait(self.sequenceWaitDuration)

end

function IterativeBaseModel:printNumberOfIterationsAndCost(numberOfIterations, cost)
	
	if (not self.isOutputPrinted) then return end
	
	print("Iteration: " .. numberOfIterations .. "\t\tCost: " .. cost)
	
end

return IterativeBaseModel]]></ProtectedString>
									<string name="ScriptGuid">{AE08DD1B-D7A0-40B5-B31F-6E355BA97B91}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">IterativeMethodBaseModel</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXCCB6864CCF8348C1AC5D993375179364">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

DensityBasedSpatialClusteringOfApplicationsWithNoiseModel = {}

DensityBasedSpatialClusteringOfApplicationsWithNoiseModel.__index = DensityBasedSpatialClusteringOfApplicationsWithNoiseModel

setmetatable(DensityBasedSpatialClusteringOfApplicationsWithNoiseModel, IterativeMethodBaseModel)

local defaultMinimumNumberOfPoints = 2

local defaultDistanceFunction = "Manhattan"

local defaultEpsilon = 10

local function getNeighborArray(currentCorePointNumber, featureMatrix, epsilon, distanceFunction)
	
	local distance
	
	local neighborArray = {}
	
	for i = 1, #featureMatrix, 1 do
		
		if (i ~= currentCorePointNumber) then
			
			distance = distanceFunction({featureMatrix[currentCorePointNumber]}, {featureMatrix[i]})
			
			if (distance <= epsilon) then table.insert(neighborArray, i) end
			
		end
		
	end
	
	return neighborArray
	
end

local function mergeTables(table1, table2)
	
	for _, value in ipairs(table2) do table.insert(table1, value) end
	
	return table1
	
end

local function expandCluster(currentCorePointNumber, neighborArray, neighbouringCorePointNumber, clusterArrayArray, hasVisitedCorePointNumberArray, featureMatrix, epsilon, minimumNumberOfPoints, distanceFunction)
	
	clusterArrayArray[neighbouringCorePointNumber] = clusterArrayArray[neighbouringCorePointNumber] or {}
	
	clusterArrayArray[neighbouringCorePointNumber][#clusterArrayArray[neighbouringCorePointNumber] + 1] = currentCorePointNumber
	
	for _, neighbouringPointNumber in ipairs(neighborArray) do
		
		if (not hasVisitedCorePointNumberArray[neighbouringPointNumber]) then

			hasVisitedCorePointNumberArray[neighbouringPointNumber] = true

			local qNeighbors = getNeighborArray(neighbouringPointNumber, featureMatrix, epsilon, distanceFunction)

			if (#qNeighbors >= minimumNumberOfPoints) then

				neighborArray = mergeTables(neighborArray, qNeighbors)

			end

		end

		local isInCluster = false
		
		for _, clusterArray in ipairs(clusterArrayArray) do
			
			if (clusterArray[neighbouringPointNumber]) then

				isInCluster = true

				break

			end
			
		end

		if (not isInCluster) then

			clusterArrayArray[neighbouringCorePointNumber][#clusterArrayArray[neighbouringCorePointNumber] + 1] = neighbouringPointNumber

		end
		
	end
	
end

local function calculateCost(distanceFunction, featureMatrix, clusterArrayArray)
	
	local cost = 0
	
	for _, clusterArray in pairs(clusterArrayArray) do
		
		for i, cluster in ipairs(clusterArray) do
			
			for j = i + 1, #clusterArray, 1 do

				cost = cost + distanceFunction({featureMatrix[cluster]}, {featureMatrix[clusterArray[j]]})

			end
			
		end
		
	end
	
	return cost
	
end

function DensityBasedSpatialClusteringOfApplicationsWithNoiseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewDensityBasedSpatialClusteringOfApplicationsWithNoiseModel = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewDensityBasedSpatialClusteringOfApplicationsWithNoiseModel, DensityBasedSpatialClusteringOfApplicationsWithNoiseModel)
	
	NewDensityBasedSpatialClusteringOfApplicationsWithNoiseModel:setName("DensityBasedSpatialClusteringOfApplicationsWithNoise")
	
	NewDensityBasedSpatialClusteringOfApplicationsWithNoiseModel.minimumNumberOfPoints = parameterDictionary.minimumNumberOfPoints or defaultMinimumNumberOfPoints
	
	NewDensityBasedSpatialClusteringOfApplicationsWithNoiseModel.epsilon = parameterDictionary.epsilon or defaultEpsilon

	NewDensityBasedSpatialClusteringOfApplicationsWithNoiseModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction
	
	return NewDensityBasedSpatialClusteringOfApplicationsWithNoiseModel
	
end

function DensityBasedSpatialClusteringOfApplicationsWithNoiseModel:train(featureMatrix)
	
	if (self.ModelParameters) then

		local storedFeatureMatrix = self.ModelParameters[1]

		if (#storedFeatureMatrix[1] ~= #featureMatrix[1]) then error("The previous and current feature matrices do not have the same number of features.") end 

		featureMatrix = AqwamTensorLibrary:concatenate(featureMatrix, storedFeatureMatrix, 1)

	end
	
	local distanceFunction = self.distanceFunction
	
	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]
	
	if (not distanceFunctionToApply) then error("Unknown distance function.") end
	
	local minimumNumberOfPoints = self.minimumNumberOfPoints

	local epsilon = self.epsilon
	
	local costArray = {}

	local clusterArrayArray = {}

	local noiseCorePointNumberArray = {}

	local hasVisitedCorePointNumberArray = {}
	
	local cost
	
	local neighbouringCorePointNumber 
	
	local neighborArray
	
	for currentCorePointNumber, unwrappedFeatureVector in ipairs(featureMatrix) do
		
		self:iterationWait()

		if (not hasVisitedCorePointNumberArray[currentCorePointNumber]) then

			hasVisitedCorePointNumberArray[currentCorePointNumber] = true

			neighborArray = getNeighborArray(currentCorePointNumber, featureMatrix, epsilon, distanceFunctionToApply)

			if (#neighborArray < minimumNumberOfPoints) then

				table.insert(noiseCorePointNumberArray, currentCorePointNumber)

			else

				neighbouringCorePointNumber = #clusterArrayArray + 1

				expandCluster(currentCorePointNumber, neighborArray, neighbouringCorePointNumber, clusterArrayArray, hasVisitedCorePointNumberArray, featureMatrix, epsilon, minimumNumberOfPoints, distanceFunctionToApply)

			end

		end

		cost = self:calculateCostWhenRequired(currentCorePointNumber, function()

			return calculateCost(distanceFunctionToApply, featureMatrix, clusterArrayArray)

		end)

		if (cost) then

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(currentCorePointNumber, cost)

			if self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost) then break end

		end
		
	end
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	self.ModelParameters = {featureMatrix, clusterArrayArray}
	
	return costArray
	
end

function DensityBasedSpatialClusteringOfApplicationsWithNoiseModel:predict(featureMatrix)
	
	local numberOfData = #featureMatrix
	
	local dimensionSizeArray = {numberOfData, 1}
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then
		
		local placeholderClusterVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, nil)
		
		local placeholderDistanceVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, math.huge)
		
		return placeholderClusterVector, placeholderDistanceVector
		
	end
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
	
	local shortestDistanceVector = AqwamTensorLibrary:createTensor(dimensionSizeArray)

	local closestClusterVector = AqwamTensorLibrary:createTensor(dimensionSizeArray)
	
	local storedFeatureVector, clusterArrayArray = table.unpack(ModelParameters)
	
	local closestCluster
	
	local shortestDistance
	
	local featureVector
	
	for i, unwrappedFeatureVector in ipairs(featureMatrix) do
		
		closestCluster = nil

		shortestDistance = math.huge

		featureVector = {unwrappedFeatureVector}

		for clusterNumber, clusterArray in ipairs(clusterArrayArray) do

			local distance = 0
			
			for j, pointNumber in ipairs(clusterArray) do

				distance = distance + distanceFunctionToApply(featureVector, {storedFeatureVector[pointNumber]})
				
			end

			distance = distance / #clusterArray

			if (distance < shortestDistance) then

				closestCluster = clusterNumber

				shortestDistance = distance

			end

		end

		closestClusterVector[i][1] = closestCluster

		shortestDistanceVector[i][1] = shortestDistance
		
	end
	
	return closestClusterVector, shortestDistanceVector
	
end

return DensityBasedSpatialClusteringOfApplicationsWithNoiseModel]]></ProtectedString>
									<string name="ScriptGuid">{7C1B1926-64C8-4758-933B-DB121B052E0D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DensityBasedSpatialClusteringOfApplicationsWithNoise</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD1D9CC7958404E6580218BC76A6F2741">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

MeanShiftModel = {}

MeanShiftModel.__index = MeanShiftModel

setmetatable(MeanShiftModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultNumberOfClusters = 0

local defaultBandwidth = 10

local defaultMode = "Hybrid"

local defaultDistanceFunction = "Euclidean"

local defaultKernelFunction = "Gaussian"

local defaultLambda = 50

local kernelFunctionList = {

	["Gaussian"] = function(x, kernelParameters)
		
		local denominator = 2 * math.pow(kernelParameters.bandwidth, 2)
		
		local zValue = -(x / denominator)
		
		return math.exp(zValue)

	end,
	
	["Flat"] = function(x, kernelParameters)
		
		return ((x <= kernelParameters.lambda) and 1) or 0

	end

}

local function calculateDistance(distanceFunction, vector1, vector2)
	
	return distanceFunction(vector1, vector2) 
	
end

local function assignToCluster(distanceMatrix) -- Number of columns -> number of clusters
	
	local numberOfData = #distanceMatrix
	
	local clusterNumberVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 0)
	
	local clusterDistanceVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 0) 
	
	for dataIndex, distanceVector in ipairs(distanceMatrix) do
		
		local closestClusterNumber
		
		local shortestDistance = math.huge
		
		for i, distance in ipairs(distanceVector) do
			
			if (distance < shortestDistance) then
				
				closestClusterNumber = i
				
				shortestDistance = distance
				
			end
			
		end
		
		clusterNumberVector[dataIndex][1] = closestClusterNumber
		
		clusterDistanceVector[dataIndex][1] = shortestDistance
		
	end
	
	return clusterNumberVector, clusterDistanceVector
	
end

local function createDistanceMatrix(featureMatrix, modelParameters, distanceFunction)

	local numberOfData = #featureMatrix

	local numberOfClusters = #modelParameters

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfClusters}, 0)

	for datasetIndex = 1, #featureMatrix, 1 do

		for cluster = 1, #modelParameters, 1 do

			distanceMatrix[datasetIndex][cluster] = distanceFunction({featureMatrix[datasetIndex]}, {modelParameters[cluster]})

		end

	end

	return distanceMatrix

end

local function createClusterAssignmentMatrix(distanceMatrix) -- contains values of 0 and 1, where 0 is "does not belong to this cluster"

	local numberOfData = #distanceMatrix -- Number of rows

	local numberOfClusters = #distanceMatrix[1]

	local clusterAssignmentMatrix = AqwamTensorLibrary:createTensor({#distanceMatrix, #distanceMatrix[1]}, 0)

	local dataPointClusterNumber

	for dataIndex = 1, numberOfData, 1 do

		local distanceVector = {distanceMatrix[dataIndex]}

		local vectorIndexArray = AqwamTensorLibrary:findMinimumValueDimensionIndexArray(distanceVector)

		if (vectorIndexArray == nil) then continue end

		local clusterNumber = vectorIndexArray[2]

		clusterAssignmentMatrix[dataIndex][clusterNumber] = 1

	end

	return clusterAssignmentMatrix

end

local function calculateCost(distanceMatrix, clusterAssignmentMatrix)

	local costMatrix = AqwamTensorLibrary:multiply(distanceMatrix, clusterAssignmentMatrix)

	local cost = AqwamTensorLibrary:sum(costMatrix)

	return cost

end

local function findEqualRowIndex(matrix1, matrix2)
	
	local index
	
	for i = 1, #matrix1, 1 do
		
		local matrixInTable = {matrix1[i]}
		
		if AqwamTensorLibrary:areMatricesEqual(matrixInTable, matrix2) then
			
			index = i
			
			break
		
		end
		
	end
	
	return index
	
end

local function calculateMatrices(featureMatrix, centroidMatrix, clusterAssignmentMatrix, distanceMatrix, bandwidth, kernelFunction, kernelParameters, sumKernelMatrix, sumMultipliedKernelMatrix)
	
	for dataIndex, featureVector in ipairs(featureMatrix) do

		for clusterIndex, clusterVector in ipairs(centroidMatrix) do

			if (clusterAssignmentMatrix[dataIndex][clusterIndex] == 1) then

				local featureVector = {featureVector}

				local kernelInput = distanceMatrix[dataIndex][clusterIndex] / bandwidth

				local squaredKernelInput = math.pow(kernelInput, 2)

				local kernelVector = kernelFunction(squaredKernelInput, kernelParameters)

				local multipliedKernelVector = AqwamTensorLibrary:multiply(kernelVector, featureVector)

				local sumKernelVector = {sumKernelMatrix[clusterIndex]}

				local sumMultipliedKernelVector = {sumMultipliedKernelMatrix[clusterIndex]}

				sumKernelVector = AqwamTensorLibrary:add(sumKernelVector, kernelVector) 

				sumMultipliedKernelVector = AqwamTensorLibrary:add(sumMultipliedKernelVector, multipliedKernelVector)

				sumKernelMatrix[clusterIndex] = sumKernelVector[1]

				sumMultipliedKernelMatrix[clusterIndex] = sumMultipliedKernelVector[1]

			end

		end

	end
	
	local centroidMatrix = AqwamTensorLibrary:divide(sumMultipliedKernelMatrix, sumKernelMatrix)
	
	return centroidMatrix, sumKernelMatrix, sumMultipliedKernelMatrix
	
end

local function mergeCentroids(centroidMatrix, bandwidth, distanceFunction, sumKernelMatrix, sumMultipliedKernelMatrix)
	
	local distanceMatrix = createDistanceMatrix(centroidMatrix, centroidMatrix, distanceFunction)

	local centroidMergeArrayArray = {}
	
	local centroidMergeArray
	
	local needToBeMerged
	
	for primaryCentroidIndex, distanceVector in ipairs(distanceMatrix) do
		
		centroidMergeArray = {} 
		
		for secondaryCentroidIndex, distance in ipairs(distanceVector) do
			
			needToBeMerged = (primaryCentroidIndex ~= secondaryCentroidIndex) and (distance <= bandwidth)
			
			if (needToBeMerged) then table.insert(centroidMergeArray, secondaryCentroidIndex) end
			
		end
		
		centroidMergeArrayArray[primaryCentroidIndex] = centroidMergeArray
		
	end
	
	local mergedFlagArray = {}
	
	local newCentroidMatrix = {}
	
	local newSumKernelMatrix = {}
	
	local newSumMultipliedKernelMatrix = {}
	
	local numberOfFeatures = #centroidMatrix[1]

	for i, mergeArray in ipairs(centroidMergeArrayArray) do
		
		if (not mergedFlagArray[i]) then
			
			local combinedIndices = {i}
			
			for _, j in ipairs(mergeArray) do
				
				if (not mergedFlagArray[j]) then table.insert(combinedIndices, j) end
				
			end

			local newSumKernelVector = AqwamTensorLibrary:createTensor({1, numberOfFeatures}, 0)
			
			local newSumMultipliedKernelVector = AqwamTensorLibrary:createTensor({1, numberOfFeatures}, 0)

			for _, idx in ipairs(combinedIndices) do
				
				newSumKernelVector = AqwamTensorLibrary:add(newSumKernelVector, {sumKernelMatrix[idx]})
				
				newSumMultipliedKernelVector = AqwamTensorLibrary:add(newSumMultipliedKernelVector, {sumMultipliedKernelMatrix[idx]})
				
				mergedFlagArray[idx] = true
				
			end

			local newCentroidVector = AqwamTensorLibrary:divide(newSumMultipliedKernelVector, newSumKernelVector)
			
			table.insert(newCentroidMatrix, newCentroidVector[1])
			
			table.insert(newSumKernelMatrix, newSumKernelVector[1])
			
			table.insert(newSumMultipliedKernelMatrix, newSumMultipliedKernelVector[1])
			
		end
		
	end

	return newCentroidMatrix, newSumKernelMatrix, newSumMultipliedKernelMatrix
	
end

function MeanShiftModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations
	
	local NewMeanShiftModel = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewMeanShiftModel, MeanShiftModel)
	
	NewMeanShiftModel:setName("MeanShift")
	
	local bandwidth = parameterDictionary.bandwidth or defaultBandwidth
	
	local kernelParameters = {

		bandwidth = bandwidth,

		lambda = parameterDictionary.lambda or defaultLambda,

	}
	
	NewMeanShiftModel.numberOfClusters = parameterDictionary.numberOfClusters or defaultNumberOfClusters

	NewMeanShiftModel.bandwidth = bandwidth
	
	NewMeanShiftModel.mode = parameterDictionary.mode or defaultMode
	
	NewMeanShiftModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction
	
	NewMeanShiftModel.kernelFunction = parameterDictionary.kernelFunction or defaultKernelFunction
	
	NewMeanShiftModel.kernelParameters = kernelParameters
	
	return NewMeanShiftModel
	
end

function MeanShiftModel:train(featureMatrix)
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local numberOfClusters = self.numberOfClusters
	
	local bandwidth = self.bandwidth
	
	local mode = self.mode
	
	local distanceFunction = self.distanceFunction
	
	local kernelFunction = self.kernelFunction
	
	local kernelParameters = self.kernelParameters
	
	local ModelParameters = self.ModelParameters or {}
	
	local centroidMatrix = ModelParameters[1]
	
	local sumKernelMatrix = ModelParameters[2]
	
	local sumMultipliedKernelMatrix = ModelParameters[3]
	
	if (mode == "Hybrid") then

		mode = (centroidMatrix and sumKernelMatrix and sumMultipliedKernelMatrix and "Online") or "Offline"		

	end

	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]

	if (not distanceFunctionToApply) then error("Unknown distance function.") end
	
	local kernelFunctionToApply = kernelFunctionList[kernelFunction]
	
	if (not kernelFunctionToApply) then error("Unknown kernel function.") end
	
	local numberOfData = #featureMatrix

	local numberOfFeatures = #featureMatrix[1]
	
	local costArray = {}

	local numberOfIterations = 0
	
	local centroidDimensionSizeArray

	local distanceMatrix

	local clusterAssignmentMatrix 

	local cost
	
	if (mode == "Offline") then 

		centroidMatrix = nil
		
		sumKernelMatrix = nil
		
		sumMultipliedKernelMatrix = nil

	end
	
	-- The noise is added to the feature matrix is because we want to avoid the cost to be zero at the first iteration.

	centroidMatrix = centroidMatrix or AqwamTensorLibrary:add(featureMatrix, AqwamTensorLibrary:createRandomUniformTensor({numberOfData, numberOfFeatures}), -1e-16, 1e-16)
	
	centroidDimensionSizeArray = {#centroidMatrix, numberOfFeatures}

	sumKernelMatrix = sumKernelMatrix or AqwamTensorLibrary:createTensor(centroidDimensionSizeArray)

	sumMultipliedKernelMatrix = sumMultipliedKernelMatrix or AqwamTensorLibrary:createTensor(centroidDimensionSizeArray)

	repeat
		
		numberOfIterations = numberOfIterations + 1
		
		self:iterationWait()
		
		distanceMatrix = createDistanceMatrix(featureMatrix, centroidMatrix, distanceFunctionToApply)
		
		clusterAssignmentMatrix = createClusterAssignmentMatrix(distanceMatrix)
		
		centroidMatrix, sumKernelMatrix, sumMultipliedKernelMatrix = calculateMatrices(featureMatrix, centroidMatrix, clusterAssignmentMatrix, distanceMatrix, bandwidth, kernelFunctionToApply, kernelParameters, sumKernelMatrix, sumMultipliedKernelMatrix)
		
		centroidMatrix, sumKernelMatrix, sumMultipliedKernelMatrix = mergeCentroids(centroidMatrix, bandwidth, distanceFunctionToApply, sumKernelMatrix, sumMultipliedKernelMatrix)
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()
			
			return calculateCost(distanceMatrix, clusterAssignmentMatrix)
			
		end)
		
		if (cost) then
			
			table.insert(costArray, cost)
			
			self:printNumberOfIterationsAndCost(numberOfIterations, cost)
			
		end
		
	until (numberOfIterations == maximumNumberOfIterations) or (#centroidMatrix <= numberOfClusters) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	self.ModelParameters = {centroidMatrix, sumKernelMatrix, sumMultipliedKernelMatrix}
	
	return costArray
	
end

function MeanShiftModel:predict(featureMatrix, returnOriginalOutput)
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]

	local ModelParameters = self.ModelParameters

	local centroidMatrix

	if (not ModelParameters) then
		
		local numberOfClusters = self.numberOfClusters
		
		local numberOfFeatures = #featureMatrix[1]

		centroidMatrix = self:initializeCentroids(featureMatrix, numberOfClusters, distanceFunctionToApply)
		
		local dimensionSizeArray = {numberOfClusters, numberOfFeatures}

		local sumKernelMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray)
		
		local sumMultipliedKernelMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray)

		self.ModelParameters = {centroidMatrix, sumKernelMatrix, sumMultipliedKernelMatrix}
		
	else
		
		centroidMatrix = ModelParameters[1]

	end
	
	local distanceMatrix = createDistanceMatrix(featureMatrix, centroidMatrix, distanceFunctionToApply)
	
	if (returnOriginalOutput) then return distanceMatrix end

	local clusterNumberVector, clusterDistanceVector = assignToCluster(distanceMatrix)
	
	return clusterNumberVector, clusterDistanceVector
	
end

return MeanShiftModel]]></ProtectedString>
									<string name="ScriptGuid">{C09CCB1D-9CBA-4B72-83B2-5434D0E4316F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">MeanShift</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA19A14C28D814013B65BFA454E5BE113">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT WITHOUT PERMISSION!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

AgglomerativeHierarchicalModel = {}

AgglomerativeHierarchicalModel.__index = AgglomerativeHierarchicalModel

setmetatable(AgglomerativeHierarchicalModel, IterativeMethodBaseModel)

local defaultNumberOfCentroids = 1

local defaultDistanceFunction = "Euclidean"

local defaultLinkageFunction = "Minimum"

local defaultStopWhenModelParametersDoesNotChange = false

local function createCentroidDistanceMatrix(distanceFunction, centroidMatrix)

	local numberOfData = #centroidMatrix

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfData}, 0)

	for i = 1, numberOfData, 1 do

		for j = 1, numberOfData, 1 do

			if (i ~= j) then -- Necessary, because for some reason math.pow(0, 2) gives 1 instead of zero. So skip this step when same centroids.

				distanceMatrix[i][j] = distanceFunction({centroidMatrix[i]}, {centroidMatrix[j]})
				
			end

		end

	end

	return distanceMatrix

end

local function createNewMergedDistanceMatrix(centroidDistanceMatrix, centroidIndex1, centroidIndex2)

	local numberOfData = #centroidDistanceMatrix

	local newCentroidDistanceMatrix = {}

	for i = 1, numberOfData, 1 do

		if (i == centroidIndex1) or (i == centroidIndex2) then continue end

		local newCentroidDistanceVector = {}

		for j = 1, numberOfData, 1 do

			if (j == centroidIndex1) or (j == centroidIndex2) then continue end

			table.insert(newCentroidDistanceVector, centroidDistanceMatrix[i][j])

		end

		table.insert(newCentroidDistanceMatrix, newCentroidDistanceVector)

	end

	if (#newCentroidDistanceMatrix == 0) then return {{0}} end

	local newRow = {}

	for i = 1, #newCentroidDistanceMatrix[1], 1 do table.insert(newRow, 1, 0) end

	table.insert(newCentroidDistanceMatrix, 1, newRow)

	for i = 1, #newCentroidDistanceMatrix, 1 do table.insert(newCentroidDistanceMatrix[i], 1, 0) end

	return newCentroidDistanceMatrix

end

local function applyFunctionToFirstRowAndColumnOfDistanceMatrix(functionToApply, centroidDistanceMatrix, newCentroidDistanceMatrix, centroidIndex1, centroidIndex2)

	local newColumnIndex = 2

	local newRowIndex = 2

	local numberOfcentroids = #centroidDistanceMatrix

	for column = 1, numberOfcentroids, 1 do

		if (column ~= centroidIndex1) and (column ~= centroidIndex2) then
			
			local distance = functionToApply(centroidDistanceMatrix[centroidIndex1][column],  centroidDistanceMatrix[centroidIndex2][column])

			newCentroidDistanceMatrix[1][newColumnIndex] = distance

			newColumnIndex = newColumnIndex + 1
			
		end
		
	end

	for row = 1, numberOfcentroids, 1 do

		if (row ~= centroidIndex1) and (row ~= centroidIndex2) then
			
			local distance = functionToApply(centroidDistanceMatrix[row][centroidIndex1],  centroidDistanceMatrix[row][centroidIndex2])

			newCentroidDistanceMatrix[newRowIndex][1] = distance

			newRowIndex = newRowIndex + 1
			
		end

	end

	return newCentroidDistanceMatrix

end

-----------------------------------------------------------------------------------------------------------------------

local function minimumLinkage(centroids, centroidDistanceMatrix, centroidIndex1, centroidIndex2)

	local newCentroidDistanceMatrix = createNewMergedDistanceMatrix(centroidDistanceMatrix, centroidIndex1, centroidIndex2)

	newCentroidDistanceMatrix = applyFunctionToFirstRowAndColumnOfDistanceMatrix(math.min, centroidDistanceMatrix, newCentroidDistanceMatrix, centroidIndex1, centroidIndex2)

	return newCentroidDistanceMatrix

end

local function maximumLinkage(centroids, centroidDistanceMatrix, centroidIndex1, centroidIndex2)

	local newCentroidDistanceMatrix = createNewMergedDistanceMatrix(centroidDistanceMatrix, centroidIndex1, centroidIndex2)

	newCentroidDistanceMatrix = applyFunctionToFirstRowAndColumnOfDistanceMatrix(math.max, centroidDistanceMatrix, newCentroidDistanceMatrix, centroidIndex1, centroidIndex2)

	return newCentroidDistanceMatrix

end

local function groupAverageLinkage(centroids, centroidDistanceMatrix, centroidIndex1, centroidIndex2)

	local weightedGroupAverage = function (x, y) return (x + y) / 2 end

	local newCentroidDistanceMatrix = createNewMergedDistanceMatrix(centroidDistanceMatrix, centroidIndex1, centroidIndex2)

	newCentroidDistanceMatrix = applyFunctionToFirstRowAndColumnOfDistanceMatrix(weightedGroupAverage, centroidDistanceMatrix, newCentroidDistanceMatrix, centroidIndex1, centroidIndex2)

	return newCentroidDistanceMatrix

end

local function wardLinkage(centroids, centroidDistanceMatrix, centroidIndex1, centroidIndex2)

	local newCentroidDistanceMatrix = createCentroidDistanceMatrix(centroids, distanceFunctionDictionary["Euclidean"])

	for i = 2, #newCentroidDistanceMatrix,1 do

		newCentroidDistanceMatrix[1][i] = math.pow(newCentroidDistanceMatrix[1][i], 2)

		newCentroidDistanceMatrix[i][1] = math.pow(newCentroidDistanceMatrix[i][1], 2)

	end

	return newCentroidDistanceMatrix

end

-----------------------------------------------------------------------------------------------------------------------

local function findClosestCentroids(centroidDistanceMatrix)

	local distance

	local minimumCentroidDistance = math.huge

	local centroidIndex1 = nil

	local centroidIndex2 = nil

	for i = 1, #centroidDistanceMatrix, 1 do

		for j = 1, #centroidDistanceMatrix, 1 do

			distance = centroidDistanceMatrix[i][j]

			if (distance < minimumCentroidDistance) and (i~=j) then

				minimumCentroidDistance = distance

				centroidIndex1 = i

				centroidIndex2 = j

			end

		end

	end
	
	return centroidIndex1, centroidIndex2

end

local linkageFunctionList = {
	
	Minimum = minimumLinkage,
	
	Maximum = maximumLinkage,
	
	GroupAverage = groupAverageLinkage,
	
	Ward = wardLinkage,
	
}

local function mergeCentroids(centroids, centroidIndex1Combine, centroidIndex2ToCombine)

	local centroid1 = {centroids[centroidIndex1Combine]}

	local centroid2 = {centroids[centroidIndex2ToCombine]}

	local combinedCentroid = AqwamTensorLibrary:add(centroid1, centroid2)

	local centroidToBeAdded = AqwamTensorLibrary:divide(combinedCentroid, 2)
	
	local isIndex1SmallerThanIndex2 = (centroidIndex1Combine < centroidIndex2ToCombine)
	
	local firstCentroidIndexToBeRemoved = (isIndex1SmallerThanIndex2 and centroidIndex2ToCombine) or centroidIndex1Combine
	
	local secondCentroidIndexToBeRemoved = (isIndex1SmallerThanIndex2 and centroidIndex1Combine) or centroidIndex2ToCombine
	
	table.remove(centroids, firstCentroidIndexToBeRemoved)
	
	table.remove(centroids, secondCentroidIndexToBeRemoved)

	table.insert(centroids, centroidToBeAdded[1])

	return centroids

end

local function calculateCost(distanceFunction, featureMatrix, centroidMatrix)

	local cost = 0
	
	for _, unwrappedfeatureVector in ipairs(featureMatrix) do
		
		local featureVector = {unwrappedfeatureVector}

		local minimumDistance = math.huge
		
		for _, unwrappedCentroidVector in ipairs(centroidMatrix) do
			
			local centroidVector = {unwrappedCentroidVector}

			local distance = distanceFunction(featureVector, centroidVector)
			
			minimumDistance = math.min(minimumDistance, distance)
			
		end
		
		cost = cost + minimumDistance
		
	end

	return cost

end

local function createDistanceMatrix(distanceFunction, matrix1, matrix2)

	local numberOfData1 = #matrix1

	local numberOfData2 = #matrix2

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData1, numberOfData2})

	for matrix1Index = 1, numberOfData1, 1 do

		for matrix2Index = 1, numberOfData2, 1 do

			distanceMatrix[matrix1Index][matrix2Index] = distanceFunction({matrix1[matrix1Index]}, {matrix2[matrix2Index]})

		end

	end

	return distanceMatrix

end

local function assignToCluster(distanceMatrix) -- Number of columns -> number of clusters

	local numberOfDistances = #distanceMatrix

	local clusterNumberVector = AqwamTensorLibrary:createTensor({numberOfDistances, 1})

	local clusterDistanceVector = AqwamTensorLibrary:createTensor({numberOfDistances, 1}) 

	for dataIndex, distanceVector in ipairs(distanceMatrix) do

		local closestClusterNumber

		local shortestDistance = math.huge

		for i, distance in ipairs(distanceVector) do

			if (distance < shortestDistance) then

				closestClusterNumber = i

				shortestDistance = distance

			end

		end

		clusterNumberVector[dataIndex][1] = closestClusterNumber

		clusterDistanceVector[dataIndex][1] = shortestDistance

	end

	return clusterNumberVector, clusterDistanceVector

end

function AgglomerativeHierarchicalModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewAgglomerativeHierarchicalModel = IterativeMethodBaseModel.new(parameterDictionary)

	setmetatable(NewAgglomerativeHierarchicalModel, AgglomerativeHierarchicalModel)
	
	NewAgglomerativeHierarchicalModel:setName("AgglomerativeHierarchical")

	NewAgglomerativeHierarchicalModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction

	NewAgglomerativeHierarchicalModel.linkageFunction = parameterDictionary.linkageFunction or defaultLinkageFunction

	NewAgglomerativeHierarchicalModel.numberOfClusters = parameterDictionary.numberOfClusters or defaultNumberOfCentroids

	return NewAgglomerativeHierarchicalModel

end

function AgglomerativeHierarchicalModel:train(featureMatrix)
	
	local numberOfClusters = self.numberOfClusters

	local distanceFunction = self.distanceFunction

	local linkageFunction = self.linkageFunction
	
	local ModelParameters = self.ModelParameters
	
	local linkageFunctionToApply = linkageFunctionList[linkageFunction]
	
	if (not linkageFunctionToApply) then error("Unknown linkage function.") end
	
	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]
	
	if (not distanceFunctionToApply) then error("Unknown distance function.") end
	
	local centroidMatrix = AqwamTensorLibrary:copy(featureMatrix)
	
	local costArray = {}

	local numberOfIterations = 0

	local cost = 0

	local centroidDistanceMatrix

	local centroidIndex1

	local centroidIndex2
	
	local numberOfCentroids

	if (ModelParameters) then

		if (#centroidMatrix[1] ~= #ModelParameters[1]) then error("The number of features are not the same as the model parameters.") end

		centroidMatrix = AqwamTensorLibrary:concatenate(centroidMatrix, ModelParameters, 1)

	end

	centroidDistanceMatrix = createCentroidDistanceMatrix(distanceFunctionToApply, centroidMatrix)

	repeat
		
		numberOfIterations = numberOfIterations + 1

		self:iterationWait()
		
		centroidIndex1, centroidIndex2 = findClosestCentroids(centroidDistanceMatrix)

		centroidMatrix = mergeCentroids(centroidMatrix, centroidIndex1, centroidIndex2)

		centroidDistanceMatrix = linkageFunctionToApply(centroidMatrix, centroidDistanceMatrix, centroidIndex1, centroidIndex2)

		numberOfCentroids = #centroidMatrix
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()
			
			return calculateCost(distanceFunctionToApply, featureMatrix, centroidMatrix)
			
		end)
		
		if (cost) then
			
			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)
			
		end

	until (numberOfCentroids == numberOfClusters) or (numberOfCentroids == 1) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	self.ModelParameters = centroidMatrix

	return costArray

end

function AgglomerativeHierarchicalModel:predict(featureMatrix, returnOriginalOutput)
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then

		local numberOfData = #featureMatrix

		if (returnOriginalOutput) then AqwamTensorLibrary:createTensor({numberOfData, self.numberOfClusters}, math.huge) end

		local dimensionSizeArray = {numberOfData, 1}

		return AqwamTensorLibrary:createTensor(dimensionSizeArray, nil), AqwamTensorLibrary:createTensor(dimensionSizeArray, math.huge)

	end
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
	
	local distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, ModelParameters)

	if (returnOriginalOutput) then return distanceMatrix end

	local clusterNumberVector, clusterDistanceVector = assignToCluster(distanceMatrix)

	return clusterNumberVector, clusterDistanceVector

end

return AgglomerativeHierarchicalModel]]></ProtectedString>
									<string name="ScriptGuid">{EE9EB890-0DD2-4D68-AF79-7F6D5ACE03AE}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AgglomerativeHierarchical</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0F811525E57E4621AF25FB87AB9A017D">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

local ExpectationMaximizationModel = {}

ExpectationMaximizationModel.__index = ExpectationMaximizationModel

setmetatable(ExpectationMaximizationModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 10

local defaultNumberOfClusters = math.huge

local defaultMode = "Hybrid"

local defaultUseLogProbabilities = false

local defaultSetInitialCentroidsOnDataPoints = true

local defaultSetTheCentroidsDistanceFarthest = true

local defaultDistanceFunction = "Euclidean"

local defaultEpsilon = 1e-16

local function gaussian(featureVector, meanVector, varianceVector, epsilon)
	
	local exponentStep1 = AqwamTensorLibrary:subtract(featureVector, meanVector)

	local exponentStep2 = AqwamTensorLibrary:power(exponentStep1, 2)

	local exponentStep3 = AqwamTensorLibrary:divide(exponentStep2, varianceVector)

	local exponentStep4 = AqwamTensorLibrary:multiply(-0.5, exponentStep3)

	local exponentWithTerms = AqwamTensorLibrary:exponent(exponentStep4)
	
	local standardDeviationVector = AqwamTensorLibrary:power(varianceVector, 0.5)

	local divisorPart1 = AqwamTensorLibrary:multiply(standardDeviationVector, math.sqrt(2 * math.pi))
	
	local divisor = AqwamTensorLibrary:add(divisorPart1, epsilon)

	local gaussianDensity = AqwamTensorLibrary:divide(exponentWithTerms, divisor)
	
	return gaussianDensity

end

local function calculateGaussianMatrix(featureMatrix, meanMatrix, varianceMatrix, piMatrix, useLogProbabilities, epsilon)
	
	local numberOfClusters = #meanMatrix
	
	local initialValue = (useLogProbabilities and 0) or 1
	
	local probabilityMatrix = AqwamTensorLibrary:createTensor({#featureMatrix, numberOfClusters}, initialValue)
	
	local featureVector
	
	local weight
	
	local meanVector
	
	local varianceVector
	
	local probabilitiesVector
	
	for i, unwrappedFeatureVector in ipairs(featureMatrix) do
		
		featureVector = {unwrappedFeatureVector}

		for j = 1, numberOfClusters, 1 do

			weight = piMatrix[j][1]

			if (useLogProbabilities) then weight = math.log(weight + epsilon) end

			meanVector = {meanMatrix[j]}

			varianceVector = {varianceMatrix[j]}

			probabilitiesVector = gaussian(featureVector, meanVector, varianceVector, epsilon)

			for i, probability in ipairs(probabilitiesVector[1]) do

				if (useLogProbabilities) then

					weight = weight + math.log(probability + epsilon)

				else

					weight = weight * probability 

				end

			end

			probabilityMatrix[i][j] = weight

		end
		
	end
	
	return probabilityMatrix
	
end

local function expectationStep(featureMatrix, meanMatrix, varianceMatrix, piMatrix, useLogProbabilities, epsilon)
	
	local responsibilityMatrix = calculateGaussianMatrix(featureMatrix, meanMatrix, varianceMatrix, piMatrix, useLogProbabilities, epsilon) -- number of data x number of columns
	
	local responsibilitySumVector = AqwamTensorLibrary:sum(responsibilityMatrix, 1)
	
	local normalizedResponsibilityMatrix = AqwamTensorLibrary:divide(responsibilityMatrix, responsibilitySumVector)
	
	return normalizedResponsibilityMatrix
	
end

local function maximizationStep(featureMatrix, responsibilityMatrix, numberOfClusters, sumWeightMatrix, sumWeightXMatrix) -- data x features, data x clusters, clusters x 1, clusters x features

	local piMatrix = AqwamTensorLibrary:sum(responsibilityMatrix, 1)
	
	local piSum = AqwamTensorLibrary:sum(piMatrix)

	piMatrix = AqwamTensorLibrary:transpose(piMatrix)
	
	piMatrix = AqwamTensorLibrary:divide(piMatrix, piSum)

	local responsibilitiesMatrixTransposed = AqwamTensorLibrary:transpose(responsibilityMatrix) -- clusters x data
	
	local subSumWeightMatrix = AqwamTensorLibrary:sum(responsibilitiesMatrixTransposed, 2) -- clusters x 1
	
	local subSumWeightXMatrix = AqwamTensorLibrary:dotProduct(responsibilitiesMatrixTransposed, featureMatrix) -- clusters x features
	
	local newSumWeightMatrix = AqwamTensorLibrary:add(sumWeightMatrix, subSumWeightMatrix) -- clusters x 1

	local newSumWeightXMatrix = AqwamTensorLibrary:add(sumWeightXMatrix, subSumWeightXMatrix) -- clusters x features

	local meanMatrix = AqwamTensorLibrary:divide(newSumWeightXMatrix, newSumWeightMatrix) -- clusters x features

	local varianceMatrix = AqwamTensorLibrary:createTensor({numberOfClusters, #featureMatrix[1]}, 0)

	for i = 1, numberOfClusters, 1 do

		local meanVector = {meanMatrix[i]}

		local thisStandardDeviationMatrix = AqwamTensorLibrary:subtract(featureMatrix, meanVector)

		local thisVariationMatrix = AqwamTensorLibrary:power(thisStandardDeviationMatrix, 2)

		local thisSumVariationMatrix = AqwamTensorLibrary:sum(thisVariationMatrix, 1)

		varianceMatrix[i] = thisSumVariationMatrix[1]

	end

	varianceMatrix = AqwamTensorLibrary:divide(varianceMatrix, newSumWeightMatrix)

	return meanMatrix, varianceMatrix, piMatrix, subSumWeightMatrix, subSumWeightXMatrix

end

local function calculateCost(gaussianMatrix, epsilon)
	
	local clampedGaussianMatrix = AqwamTensorLibrary:applyFunction(math.max, gaussianMatrix, {{epsilon}})
	
	local logLikelihoodMatrix = AqwamTensorLibrary:applyFunction(math.log, clampedGaussianMatrix)

	local sumLogLikelihood = AqwamTensorLibrary:sum(logLikelihoodMatrix)
	
	return -sumLogLikelihood
	
end

local function chooseFarthestCentroidFromDatasetDistanceMatrix(distanceMatrix, blacklistedDataIndexArray)

	local dataIndex

	local maxDistance = -math.huge

	for row = 1, #distanceMatrix, 1 do

		if (not table.find(blacklistedDataIndexArray, row)) then
			
			local totalDistance = 0

			for column = 1, #distanceMatrix[1], 1 do totalDistance = totalDistance + distanceMatrix[row][column] end
			
			if (totalDistance > maxDistance) then
				
				maxDistance = totalDistance
				
				dataIndex = row
				
			end
			
		end

	end

	return dataIndex

end

local function createDistanceMatrix(matrix1, matrix2, distanceFunction)

	local numberOfData1 = #matrix1

	local numberOfData2 = #matrix2

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData1, numberOfData2})

	for matrix1Index = 1, numberOfData1, 1 do

		for matrix2Index = 1, numberOfData2, 1 do

			distanceMatrix[matrix1Index][matrix2Index] = distanceFunction({matrix1[matrix1Index]}, {matrix2[matrix2Index]})

		end

	end

	return distanceMatrix

end

local function chooseFarthestCentroids(featureMatrix, numberOfClusters, distanceFunction)

	local centroidMatrix = {}

	local dataIndexArray = {}

	local dataIndex

	local distanceMatrix = createDistanceMatrix(featureMatrix, featureMatrix, distanceFunction)

	repeat

		dataIndex = chooseFarthestCentroidFromDatasetDistanceMatrix(distanceMatrix, dataIndexArray)

		table.insert(dataIndexArray, dataIndex)

	until (#dataIndexArray == numberOfClusters)

	for row = 1, numberOfClusters, 1 do

		dataIndex = dataIndexArray[row]

		table.insert(centroidMatrix, featureMatrix[dataIndex])

	end

	return centroidMatrix

end

local function chooseRandomCentroids(featureMatrix, numberOfClusters)

	local modelParameters = {}

	local numberOfRows = #featureMatrix

	local randomRow

	local selectedRows = {}

	local hasANewRandomRowChosen

	for cluster = 1, numberOfClusters, 1 do

		repeat

			randomRow = Random.new():NextInteger(1, numberOfRows)

			hasANewRandomRowChosen = not (table.find(selectedRows, randomRow))

			if hasANewRandomRowChosen then

				table.insert(selectedRows, randomRow)
				modelParameters[cluster] = featureMatrix[randomRow]

			end

		until hasANewRandomRowChosen

	end

	return modelParameters

end

function ExpectationMaximizationModel:initializeCentroids(featureMatrix, numberOfClusters)
	
	local setInitialCentroidsOnDataPoints = self.setInitialCentroidsOnDataPoints
	
	local setTheCentroidsDistanceFarthest = self.setTheCentroidsDistanceFarthest
	
	if (setInitialCentroidsOnDataPoints) and (numberOfClusters == 1) then

		return AqwamTensorLibrary:mean(featureMatrix, 1)

	elseif (setInitialCentroidsOnDataPoints) and (setTheCentroidsDistanceFarthest) then
		
		local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
		
		if (not distanceFunctionToApply) then error("Unknown distance function.") end

		return chooseFarthestCentroids(featureMatrix, numberOfClusters, distanceFunctionToApply)

	elseif (setInitialCentroidsOnDataPoints) and (not setTheCentroidsDistanceFarthest) then

		return chooseRandomCentroids(featureMatrix, numberOfClusters)

	else

		return self:initializeMatrixBasedOnMode({numberOfClusters, #featureMatrix[1]})

	end

end

function ExpectationMaximizationModel:initializeMatrices(featureMatrix, numberOfClusters, numberOfFeatures)
	
	local centroidMatrixDimensionSizeArray = {numberOfClusters, numberOfFeatures}

	local meanMatrix = self:initializeCentroids(featureMatrix, numberOfClusters)

	local varianceMatrix = AqwamTensorLibrary:createRandomUniformTensor(centroidMatrixDimensionSizeArray, 0, 1)
	
	local piMatrix = AqwamTensorLibrary:createRandomUniformTensor({numberOfClusters, 1})

	local sumPi = AqwamTensorLibrary:sum(piMatrix)

	local sumWeightMatrix = AqwamTensorLibrary:createTensor(centroidMatrixDimensionSizeArray)

	local sumWeightXMatrix = AqwamTensorLibrary:createTensor(centroidMatrixDimensionSizeArray)
	
	piMatrix = AqwamTensorLibrary:divide(piMatrix, sumPi)
	
	return meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix
	
end

function ExpectationMaximizationModel:getBayesianInformationCriterion(featureMatrix, numberOfClusters, useLogProbabilities, epsilon)
	
	local numberOfData = #featureMatrix
	
	local numberOfFeatures = #featureMatrix[1]
	
	local meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix = self:initializeMatrices(featureMatrix, numberOfClusters, numberOfFeatures)
	
	local responsibilityMatrix = expectationStep(featureMatrix, meanMatrix, varianceMatrix, piMatrix, useLogProbabilities, epsilon)
	
	meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix = maximizationStep(featureMatrix, responsibilityMatrix, numberOfClusters, sumWeightMatrix, sumWeightXMatrix)
	
	local gaussianMatrix = calculateGaussianMatrix(featureMatrix, meanMatrix, varianceMatrix, piMatrix, useLogProbabilities, epsilon)
	
	local logLikelihood = AqwamTensorLibrary:logarithm(gaussianMatrix)
	
	if (useLogProbabilities) then
		
		logLikelihood = AqwamTensorLibrary:logarithm(gaussianMatrix)
		
	else
		
		logLikelihood = gaussianMatrix
		
	end

	local sumLogLikelihood = AqwamTensorLibrary:sum(logLikelihood)
	
	local k = (numberOfClusters - 1) + (numberOfClusters * numberOfFeatures * 2)
	
	local bayesianInformationCriterion = (k * math.log(numberOfData)) - (2 * sumLogLikelihood)
	
	return bayesianInformationCriterion, meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix
	
end

function ExpectationMaximizationModel:getBestMatrices(featureMatrix, useLogProbabilities, epsilon)
	
	local numberOfFeatures = #featureMatrix[1]
	
	local numberOfClusters = 1
	
	local bestBayesianInformationCriterion = math.huge
	
	local bestNumberOfClusters = numberOfClusters
	
	local bayesianInformationCriterion
	
	local meanMatrix
	
	local varianceMatrix
	
	local piMatrix
	
	local sumWeightMatrix
	
	local sumWeightXMatrix

	local bestMeanMatrix

	local bestVarianceMatrix
	
	local bestPiMatrix

	local bestSumWeightMatrix

	local bestSumWeightXMatrix

	while true do
		
		bayesianInformationCriterion, meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix = self:getBayesianInformationCriterion(featureMatrix, numberOfClusters, useLogProbabilities, epsilon)

		if (bayesianInformationCriterion < bestBayesianInformationCriterion) then
			
			bestBayesianInformationCriterion = bayesianInformationCriterion
			
			bestNumberOfClusters = numberOfClusters
			
			bestMeanMatrix = meanMatrix
			
			bestPiMatrix = piMatrix
			
			bestVarianceMatrix = varianceMatrix
			
			bestSumWeightMatrix = sumWeightMatrix
			
			bestSumWeightXMatrix = sumWeightXMatrix
			
		else
			
			break
			
		end

		numberOfClusters = numberOfClusters + 1
		
	end

	return bestMeanMatrix, bestVarianceMatrix, bestPiMatrix, bestSumWeightMatrix, bestSumWeightXMatrix
	
end

function ExpectationMaximizationModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewExpectationMaximizationModel = IterativeMethodBaseModel.new(parameterDictionary)

	setmetatable(NewExpectationMaximizationModel, ExpectationMaximizationModel)
	
	NewExpectationMaximizationModel:setName("ExpectationMaximization")
	
	NewExpectationMaximizationModel.numberOfClusters = parameterDictionary.numberOfClusters or defaultNumberOfClusters
	
	NewExpectationMaximizationModel.mode = parameterDictionary.mode or defaultMode
	
	NewExpectationMaximizationModel.useLogProbabilities = NewExpectationMaximizationModel:getValueOrDefaultValue(parameterDictionary.useLogProbabilities, defaultUseLogProbabilities)
	
	NewExpectationMaximizationModel.setInitialCentroidsOnDataPoints =  NewExpectationMaximizationModel:getValueOrDefaultValue(parameterDictionary.setInitialCentroidsOnDataPoints, defaultSetInitialCentroidsOnDataPoints)

	NewExpectationMaximizationModel.setTheCentroidsDistanceFarthest = NewExpectationMaximizationModel:getValueOrDefaultValue(parameterDictionary.setTheCentroidsDistanceFarthest, defaultSetTheCentroidsDistanceFarthest)
	
	NewExpectationMaximizationModel.distanceFunction = NewExpectationMaximizationModel:getValueOrDefaultValue(parameterDictionary.distanceFunction, defaultDistanceFunction)
	
	NewExpectationMaximizationModel.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	return NewExpectationMaximizationModel
end

function ExpectationMaximizationModel:train(featureMatrix)
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations

	local numberOfClusters = self.numberOfClusters
	
	local mode = self.mode
	
	local useLogProbabilities = false -- Do not bother doing this for training. It will result in the responsibilityMatrix to have nan and inf values.

	local epsilon = self.epsilon

	local ModelParameters = self.ModelParameters or {}
	
	local numberOfFeatures = #featureMatrix[1]

	local meanMatrix = ModelParameters[1]

	local varianceMatrix = ModelParameters[2]
	
	local piMatrix = ModelParameters[3]
	
	local sumWeightMatrix = ModelParameters[4]
	
	local sumWeightXMatrix = ModelParameters[5]
	
	if (mode == "Hybrid") then
		
		mode = (meanMatrix and varianceMatrix and piMatrix and sumWeightMatrix and sumWeightXMatrix and "Online") or "Offline"		
		
	end
	
	if (mode == "Offline") then
		
		meanMatrix = nil
		
		varianceMatrix = nil
		
		piMatrix = nil
		
		sumWeightMatrix = nil
		
		sumWeightXMatrix = nil
		
	end
	
	local logLikelihoodArray = {}
	
	local costArray = {}
	
	local numberOfIterations = 0
	
	local responsibilityMatrix
	
	local gaussianMatrix
	
	local cost
	
	local subSumWeightMatrix
	
	local subSumWeightXMatrix
	
	if (not meanMatrix) or (not varianceMatrix) or (not piMatrix) or (not sumWeightMatrix) or (not sumWeightXMatrix) then
		
		if (numberOfClusters == math.huge) then 
			
			meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix = self:getBestMatrices(featureMatrix, useLogProbabilities, epsilon)
			
		else
			
			meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix = self:initializeMatrices(featureMatrix, numberOfClusters, numberOfFeatures)
			
		end
		
	end
	
	numberOfClusters = #piMatrix -- This should be outside because nothing is replacing infinite number of clusters when it is given as a parameter after the first training.
	
	repeat
		
		numberOfIterations = numberOfIterations + 1
		
		self:iterationWait()

		responsibilityMatrix = expectationStep(featureMatrix, meanMatrix, varianceMatrix, piMatrix, useLogProbabilities, epsilon)

		meanMatrix, varianceMatrix, piMatrix, subSumWeightMatrix, subSumWeightXMatrix = maximizationStep(featureMatrix, responsibilityMatrix, numberOfClusters, sumWeightMatrix, sumWeightXMatrix)
		
		gaussianMatrix = calculateGaussianMatrix(featureMatrix, meanMatrix, varianceMatrix, piMatrix, useLogProbabilities, epsilon)
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()
			
			return calculateCost(gaussianMatrix, epsilon)
			
		end)
		
		if (cost) then
			
			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end

	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	-- Storing the final subSumWeightMatrix and subSumWeightXMatrix to "freeze" them for future model training.
	
	sumWeightMatrix = AqwamTensorLibrary:add(sumWeightMatrix, subSumWeightMatrix)
	
	sumWeightXMatrix = AqwamTensorLibrary:add(sumWeightXMatrix, subSumWeightXMatrix)
	
	-- We're just normalizing here to so that the sumWeightMatrix and sumWeightMatrix values doesn't go so big to the point of numerical overflow.
	
	local normalizationDenominator = AqwamTensorLibrary:sum(sumWeightMatrix)

	sumWeightMatrix = AqwamTensorLibrary:divide(sumWeightMatrix, normalizationDenominator)

	sumWeightXMatrix = AqwamTensorLibrary:divide(sumWeightXMatrix, normalizationDenominator)
	
	self.ModelParameters = {meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix}

	return costArray

end

function ExpectationMaximizationModel:predict(featureMatrix, returnOriginalOutput)
	
	local useLogProbabilities = self.useLogProbabilities
	
	local epsilon = self.epsilon
	
	local ModelParameters = self.ModelParameters
	
	local meanMatrix
	
	local varianceMatrix
	
	local piMatrix
	
	if (not ModelParameters) then

		local numberOfClusters = self.numberOfClusters
		
		local sumWeightMatrix

		local sumWeightXMatrix

		if (numberOfClusters == math.huge) then 

			meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix = self:getBestMatrices(featureMatrix, useLogProbabilities, epsilon)

		else

			meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix = self:initializeMatrices(featureMatrix, numberOfClusters, #featureMatrix[1])

		end

		self.ModelParameters = {meanMatrix, varianceMatrix, piMatrix, sumWeightMatrix, sumWeightXMatrix}
		
	else
		
		meanMatrix, varianceMatrix, piMatrix = table.unpack(ModelParameters)

	end
	
	local gaussianMatrix = calculateGaussianMatrix(featureMatrix, meanMatrix, varianceMatrix, piMatrix, useLogProbabilities, epsilon)
	
	if (returnOriginalOutput) then return gaussianMatrix end
	
	local initialValue = (useLogProbabilities and -math.huge) or 0
	
	local numberOfData = #featureMatrix
	
	local dimensionSizeArray = {numberOfData, 1}
	
	local selectedClustersVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, initialValue)

	local probabilityVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, initialValue)
	
	local selectedCluster
	
	local highestWeight
	
	for dataIndex, unwrappedGausssianVector in ipairs(gaussianMatrix) do
		
		selectedCluster = nil
		
		highestWeight = initialValue
		
		for clusterNumber, weight in ipairs(unwrappedGausssianVector) do
			
			if (weight > highestWeight) then
				
				selectedCluster = clusterNumber
				
				highestWeight = weight

			end
				
		end
		
		selectedClustersVector[dataIndex][1] = selectedCluster
		
		probabilityVector[dataIndex][1] = highestWeight
		
	end
	
	return selectedClustersVector, probabilityVector
	
end

return ExpectationMaximizationModel]]></ProtectedString>
									<string name="ScriptGuid">{28117056-18B3-46BF-8518-59E276CB5FDA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ExpectationMaximization</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1D9463A28724467485556A72DE813B95">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

local Cores = script.Parent.Parent.Cores

local distanceFunctionDictionary = require(Cores.DistanceFunctionDictionary)

local ZTableFunction = require(Cores.ZTableFunction)

LocalOutlierProbability = {}

LocalOutlierProbability.__index = LocalOutlierProbability

setmetatable(LocalOutlierProbability, BaseModel)

local defaultKValue = 3

local defaultDistanceFunction = "Euclidean"

local defaultLambda = 3

local defaultMaximumNumberOfData = math.huge

local function moreThanOrEqualToZeroClampFunction(value)
	
	-- Slightly modified from original max(0, erf(value)) due to numerical issues arising from floating-point round-off when calculating decimals.
	
	return math.clamp(value, 0, 1) 
	
end

local function createDistanceMatrix(distanceFunction, featureMatrix)

	local numberOfData = #featureMatrix

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfData}, 0)

	local calculateDistance = distanceFunctionDictionary[distanceFunction]

	for i, primaryUnwrappedFeatureVector in ipairs(featureMatrix) do

		for j, secondaryUnwrappedFeatureVector in ipairs(featureMatrix) do

			distanceMatrix[i][j] = calculateDistance({primaryUnwrappedFeatureVector}, {secondaryUnwrappedFeatureVector})

		end

	end

	return distanceMatrix

end

local function deepCopyTable(original, copies)

	copies = copies or {}

	local originalType = type(original)

	local copy

	if (originalType == 'table') then

		if copies[original] then

			copy = copies[original]

		else

			copy = {}

			copies[original] = copy

			for originalKey, originalValue in next, original, nil do

				copy[deepCopyTable(originalKey, copies)] = deepCopyTable(originalValue, copies)

			end

			setmetatable(copy, deepCopyTable(getmetatable(original), copies))

		end

	else -- number, string, boolean, etc

		copy = original

	end

	return copy

end

local function merge(unwrappedDistanceVector, left, mid, right)

	local subArrayOne = mid - left + 1
	local subArrayTwo = right - mid

	local unwrappedLeftDistanceVector = {}
	local unwrappedRightDistanceVector = {}

	for i = 1, subArrayOne do

		unwrappedLeftDistanceVector[i] = unwrappedDistanceVector[left + i - 1]

	end

	for j = 1, subArrayTwo do

		unwrappedRightDistanceVector[j] = unwrappedDistanceVector[mid + j]

	end

	local indexOfSubArrayOne = 1
	local indexOfSubArrayTwo = 1
	local indexOfMergedArray = left

	while indexOfSubArrayOne <= subArrayOne and indexOfSubArrayTwo <= subArrayTwo do

		if unwrappedLeftDistanceVector[indexOfSubArrayOne] <= unwrappedRightDistanceVector[indexOfSubArrayTwo] then

			unwrappedDistanceVector[indexOfMergedArray] = unwrappedLeftDistanceVector[indexOfSubArrayOne]
			indexOfSubArrayOne = indexOfSubArrayOne + 1

		else

			unwrappedDistanceVector[indexOfMergedArray] = unwrappedRightDistanceVector[indexOfSubArrayTwo]
			indexOfSubArrayTwo = indexOfSubArrayTwo + 1

		end

		indexOfMergedArray = indexOfMergedArray + 1

	end

	while (indexOfSubArrayOne <= subArrayOne) do

		unwrappedDistanceVector[indexOfMergedArray] = unwrappedLeftDistanceVector[indexOfSubArrayOne]
		indexOfSubArrayOne = indexOfSubArrayOne + 1
		indexOfMergedArray = indexOfMergedArray + 1

	end

	while (indexOfSubArrayTwo <= subArrayTwo) do

		unwrappedDistanceVector[indexOfMergedArray] = unwrappedRightDistanceVector[indexOfSubArrayTwo]
		indexOfSubArrayTwo = indexOfSubArrayTwo + 1
		indexOfMergedArray = indexOfMergedArray + 1

	end

end

local function mergeSort(distanceVector, startingValue, endValue)

	if (startingValue >= endValue) then return end

	local mid = math.floor(startingValue + (endValue - startingValue) / 2)

	mergeSort(distanceVector, startingValue, mid)
	mergeSort(distanceVector, mid + 1, endValue)
	merge(distanceVector, startingValue, mid, endValue)

end

function LocalOutlierProbability.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewLocalOutlierProbability = BaseModel.new(parameterDictionary)

	setmetatable(NewLocalOutlierProbability, LocalOutlierProbability)
	
	NewLocalOutlierProbability:setName("LocalOutlierProbability")

	NewLocalOutlierProbability.kValue = parameterDictionary.kValue or defaultKValue

	NewLocalOutlierProbability.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction
	
	NewLocalOutlierProbability.lamda = parameterDictionary.lamda or defaultLambda
	
	NewLocalOutlierProbability.maximumNumberOfData = parameterDictionary.maximumNumberOfData or defaultMaximumNumberOfData
	
	return NewLocalOutlierProbability

end

function LocalOutlierProbability:train(featureMatrix)

	local numberOfData = #featureMatrix

	local maximumNumberOfData = self.maximumNumberOfData

	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		local storedFeatureMatrix = ModelParameters[1]

		local storedLabelVector = ModelParameters[2]

		featureMatrix = AqwamTensorLibrary:concatenate(featureMatrix, storedFeatureMatrix, 1)

		numberOfData = #featureMatrix

		if (numberOfData > maximumNumberOfData) then

			local newFeatureMatrix = {}

			local newLabelVector = {}

			local dataShiftIndex = (numberOfData - maximumNumberOfData)

			for dataIndex = 1, maximumNumberOfData, 1 do

				newFeatureMatrix[dataIndex] = featureMatrix[dataIndex + dataShiftIndex]

			end

			featureMatrix = newFeatureMatrix

			numberOfData = maximumNumberOfData

		end

	end

	if (numberOfData <= self.kValue) and (self.isOutputPrinted) then warn("Number of data is less than or equal to the K value. Please add more data before doing any predictions.") end

	self.ModelParameters = featureMatrix

end

function LocalOutlierProbability:score()
	
	local featureMatrix = self.ModelParameters

	if (not featureMatrix) then return {{0}} end

	local kValue = self.kValue

	local distanceFunction = self.distanceFunction
	
	local lambda = self.lamda
	
	local numberOfData = #featureMatrix
	
	local numberOfDataMinusOne = numberOfData - 1
	
	local distanceMatrix = createDistanceMatrix(distanceFunction, featureMatrix)
	
	local nearestNeighbourIndexArrayArray = {}
	
	local numberOfNearestNeighboursVector = {}
	
	local sumDistanceVector = {}

	for i, unwrappedDistanceVector in ipairs(distanceMatrix) do

		local sortedUnwrappedDistanceVector = deepCopyTable(unwrappedDistanceVector)
		
		-- Ignores the distance to itself. It is removed before sorting to reduce computational resources.
		
		table.remove(sortedUnwrappedDistanceVector, i)

		mergeSort(sortedUnwrappedDistanceVector, 1, numberOfDataMinusOne)
		
		local kDistance = sortedUnwrappedDistanceVector[kValue]
		
		local nearestNeighbourIndexArray = {}
		
		local sumDistance = 0
		
		local numberOfNearestNeighbours = 0
		
		for j, distance in ipairs(unwrappedDistanceVector) do
			
			if (distance <= kDistance) then
				
				sumDistance = sumDistance + math.pow(distance, 2)
				
				table.insert(nearestNeighbourIndexArray, j) 
				
			end
			
		end
		
		sumDistanceVector[i] = {sumDistance}
		
		nearestNeighbourIndexArrayArray[i] = nearestNeighbourIndexArray
		
		numberOfNearestNeighboursVector[i] = {#nearestNeighbourIndexArray}

	end
	
	local standardDistanceVectorPart1 = AqwamTensorLibrary:divide(sumDistanceVector, numberOfNearestNeighboursVector)
	
	local standardDistanceVector = AqwamTensorLibrary:applyFunction(math.sqrt, standardDistanceVectorPart1)
	
	local probabilisticDistanceVector = AqwamTensorLibrary:multiply(lambda, standardDistanceVector)
	
	local probabilisticLocalOutlierProbabilityFactorVector = {}
	
	for i, nearestNeighboursIndexArray in ipairs(nearestNeighbourIndexArrayArray) do

		local meanProbabilityDistance = 0

		for _, nearestNeighbourIndex in ipairs(nearestNeighboursIndexArray) do

			meanProbabilityDistance = meanProbabilityDistance + probabilisticDistanceVector[nearestNeighbourIndex][1]

		end
		
		meanProbabilityDistance = meanProbabilityDistance / numberOfNearestNeighboursVector[i][1]
		
		local probabilisticLocalOutlierProbabilityFactor = (probabilisticDistanceVector[i][1] / meanProbabilityDistance) - 1
		
		probabilisticLocalOutlierProbabilityFactorVector[i] = {probabilisticLocalOutlierProbabilityFactor}

	end
	
	local nProbabilisticLocalOutlierProbabilityFactorVectorPart1 = AqwamTensorLibrary:power(probabilisticLocalOutlierProbabilityFactorVector, 2)
	
	local nProbabilisticLocalOutlierProbabilityFactorVectorPart2 = AqwamTensorLibrary:mean(nProbabilisticLocalOutlierProbabilityFactorVectorPart1)
	
	local nProbabilisticLocalOutlierProbabilityFactor = lambda * math.sqrt(nProbabilisticLocalOutlierProbabilityFactorVectorPart2)
	
	local gaussianErrorVectorPart2 = AqwamTensorLibrary:divide(probabilisticLocalOutlierProbabilityFactorVector, nProbabilisticLocalOutlierProbabilityFactor)
	
	local gaussianErrorVector = {}
	
	for i, unwrappedErrorVectorPart2 in ipairs(gaussianErrorVectorPart2) do
		
		gaussianErrorVector[i] = {ZTableFunction:calculateStandardNormalCumulativeDistributionValue(unwrappedErrorVectorPart2[1])}
		
	end
	
	local localOutlierProbabilityVector = AqwamTensorLibrary:applyFunction(moreThanOrEqualToZeroClampFunction, gaussianErrorVector)
	
	return localOutlierProbabilityVector

end

return LocalOutlierProbability]]></ProtectedString>
									<string name="ScriptGuid">{722B540A-E260-4E55-B8FD-B8A18DC4EBDB}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalOutlierProbability</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8E07100557CC43A7B2E94FC6E3DBD8AA">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

SupportVectorMachineModel = {}

SupportVectorMachineModel.__index = SupportVectorMachineModel

setmetatable(SupportVectorMachineModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultCvalue = 1

local defaultKernelFunction = "Linear"

local defaultGamma = 1

local defaultDegree = 3

local defaultSigma = 1

local defaultR = 0

local seperatorFunction = function (x) 

	return ((x > 0) and 1) or ((x < 0) and -1) or 0

end

local function createDistanceMatrix(distanceFunction, matrix1, matrix2)

	local numberOfData1 = #matrix1

	local numberOfData2 = #matrix2

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData1, numberOfData2})
	
	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]

	for i = 1, numberOfData1, 1 do

		for j = 1, numberOfData2, 1 do

			distanceMatrix[i][j] = distanceFunctionToApply({matrix1[i]}, {matrix2[j]})

		end

	end

	return distanceMatrix

end

local mappingList = {

	["Linear"] = function(featureMatrix)

		return featureMatrix

	end,

	["Polynomial"] = function(featureMatrix, kernelParameters)
		
		local degree = kernelParameters.degree
		
		local gamma = kernelParameters.gamma
		
		local r = kernelParameters.r
		
		local scaledFeatureMatrix = AqwamTensorLibrary:multiply(featureMatrix, gamma)
		
		local addedFeatureMatrix = AqwamTensorLibrary:add(scaledFeatureMatrix, r)

		return AqwamTensorLibrary:power(addedFeatureMatrix, degree)

	end,

	["RadialBasisFunction"] = function(featureMatrix, kernelParameters)
		
		local sigma = kernelParameters.sigma

		local squaredFeatureMatrix = AqwamTensorLibrary:power(featureMatrix, 2)

		local squaredSigmaVector = AqwamTensorLibrary:power(sigma, 2)

		local multipliedSquaredSigmaVector = AqwamTensorLibrary:multiply(-2, squaredSigmaVector)

		local zMatrix = AqwamTensorLibrary:divide(squaredFeatureMatrix, multipliedSquaredSigmaVector)

		return AqwamTensorLibrary:applyFunction(math.exp, zMatrix)

	end,
	
	["Sigmoid"] = function(featureMatrix, kernelParameters)

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r
		
		local kernelMappingMatrixPart1 = AqwamTensorLibrary:multiply(gamma, featureMatrix)

		local kernelMappingMatrixPart2 = AqwamTensorLibrary:add(kernelMappingMatrixPart1, r)

		local kernelMappingMatrix = AqwamTensorLibrary:applyFunction(math.tanh, kernelMappingMatrixPart2)
		
		return kernelMappingMatrix

	end,
	
	["Cosine"] = function(featureMatrix, kernelParameters)
		
		local zeroMatrix = AqwamTensorLibrary:createTensor({1, #featureMatrix[1]}, 0)

		local distanceMatrix = createDistanceMatrix("Euclidean", featureMatrix, zeroMatrix)

		local kernelMappingMatrix = AqwamTensorLibrary:divide(featureMatrix, distanceMatrix)

		return kernelMappingMatrix

	end,

}

local kernelFunctionList = {

	["Linear"] = function(featureMatrix)

		local kernelMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, AqwamTensorLibrary:transpose(featureMatrix))

		return kernelMatrix

	end,

	["Polynomial"] = function(featureMatrix, kernelParameters)

		local degree = kernelParameters.degree

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local dotProductedFeatureMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, AqwamTensorLibrary:transpose(featureMatrix))

		local scaledDotProductedFeatureMatrix = AqwamTensorLibrary:multiply(dotProductedFeatureMatrix, gamma)

		local addedFeatureMatrix = AqwamTensorLibrary:add(scaledDotProductedFeatureMatrix, r)

		local kernelMatrix = AqwamTensorLibrary:power(addedFeatureMatrix, degree)

		return kernelMatrix

	end,

	["RadialBasisFunction"] = function(featureMatrix, kernelParameters)

		local sigma = kernelParameters.sigma

		local distanceMatrix = createDistanceMatrix("Euclidean", featureMatrix, featureMatrix)

		local squaredDistanceMatrix = AqwamTensorLibrary:power(distanceMatrix, 2)

		local sigmaSquaredVector = AqwamTensorLibrary:power(sigma, 2)

		local multipliedSigmaSquaredVector = AqwamTensorLibrary:multiply(-2, sigmaSquaredVector)

		local zMatrix = AqwamTensorLibrary:divide(squaredDistanceMatrix, multipliedSigmaSquaredVector)

		local kernelMatrix = AqwamTensorLibrary:applyFunction(math.exp, zMatrix)

		return kernelMatrix

	end,

	["Sigmoid"] = function(featureMatrix, kernelParameters)

		local gamma = kernelParameters.gamma

		local r = kernelParameters.r

		local dotProductedFeatureMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, AqwamTensorLibrary:transpose(featureMatrix))

		local kernelMatrixPart1 = AqwamTensorLibrary:multiply(gamma, dotProductedFeatureMatrix)

		local kernelMatrixPart2 = AqwamTensorLibrary:add(kernelMatrixPart1, r)

		local kernelMatrix = AqwamTensorLibrary:applyFunction(math.tanh, kernelMatrixPart2)

		return kernelMatrix

	end,

	["Cosine"] = function(featureMatrix, kernelParameters)
		
		local zeroMatrix = AqwamTensorLibrary:createTensor({1, #featureMatrix[1]}, 0)

		local distanceMatrix = createDistanceMatrix("Euclidean", featureMatrix, zeroMatrix)

		local kernelMappingMatrix = AqwamTensorLibrary:divide(featureMatrix, distanceMatrix)
		
		local kernelMatrix = AqwamTensorLibrary:dotProduct(kernelMappingMatrix, AqwamTensorLibrary:transpose(kernelMappingMatrix))

		return kernelMatrix

	end,

}

local function calculateCost(modelParameters, individualKernelMatrix, kernelMatrix, labelVector, cValue)
	
	-- The dotProduct() only takes two arguments here to reduce computational time
	
	local predictedVector = AqwamTensorLibrary:dotProduct(individualKernelMatrix, modelParameters)
	
	local costVector = AqwamTensorLibrary:subtract(predictedVector, labelVector)
	
	costVector = AqwamTensorLibrary:multiply(-cValue, costVector)
	
	local transposedCostVector = AqwamTensorLibrary:transpose(costVector)
	
	local transposedLabelVector = AqwamTensorLibrary:transpose(labelVector)
	
	local costPart1 = AqwamTensorLibrary:dotProduct(transposedCostVector, kernelMatrix)
	
	costPart1 = AqwamTensorLibrary:dotProduct(costPart1, kernelMatrix)
	
	costPart1 = AqwamTensorLibrary:dotProduct(costPart1, costVector)[1][1]
	
	costPart1 = costPart1 / 2
	
	local costPart2 = AqwamTensorLibrary:dotProduct(transposedCostVector, kernelMatrix)
	
	costPart2 = AqwamTensorLibrary:dotProduct(costPart2, labelVector)[1][1]
	
	local costPart3 = AqwamTensorLibrary:dotProduct(transposedLabelVector, labelVector)[1][1]
	
	costPart3 = costPart3 / 2
	
	local costPart4 = AqwamTensorLibrary:dotProduct(transposedCostVector, kernelMatrix)
	
	costPart4 = AqwamTensorLibrary:dotProduct(costPart4, costVector)[1][1]
	
	costPart4 = costPart4 / (2 * cValue)
	
	local cost = costPart1 - costPart2 + costPart3 + costPart4
	
	return cost

end

local function calculateModelParameters(modelParameters, individualKernelMatrix, labelVector, cValue)

	local predictionVector = AqwamTensorLibrary:dotProduct(individualKernelMatrix, modelParameters) -- m x 1
	
	local errorVector = AqwamTensorLibrary:subtract(predictionVector, labelVector) -- m x 1
	
	local transposedIndividualKernelMatrix = AqwamTensorLibrary:transpose(individualKernelMatrix)
	
	local dotProductErrorVector = AqwamTensorLibrary:dotProduct(transposedIndividualKernelMatrix, errorVector) -- n x m, m x 1
	
	local NewModelParameters = AqwamTensorLibrary:multiply(-cValue, dotProductErrorVector)

	return NewModelParameters

end

function SupportVectorMachineModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewSupportVectorMachine = IterativeMethodBaseModel.new(parameterDictionary)

	setmetatable(NewSupportVectorMachine, SupportVectorMachineModel)
	
	NewSupportVectorMachine:setName("SupportVectorMachine")
	
	NewSupportVectorMachine.cValue = parameterDictionary.cValue or defaultCvalue

	NewSupportVectorMachine.kernelFunction = parameterDictionary.kernelFunction or defaultKernelFunction

	NewSupportVectorMachine.kernelParameters = {
		
		degree = parameterDictionary.degree or defaultDegree,
		
		gamma = parameterDictionary.gamma or defaultGamma,
		
		sigma = parameterDictionary.sigma or defaultSigma,
		
		r = parameterDictionary.r or defaultR
	
	}

	return NewSupportVectorMachine
end

function SupportVectorMachineModel:setCValue(cValue)

	self.cValue = cValue or self.cValue

end

function SupportVectorMachineModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector do not contain the same number of rows.") end
	
	local numberOfFeatures = #featureMatrix[1]
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (numberOfFeatures ~= #ModelParameters) then error("The number of features is not the same as the model parameters.") end

	else

		ModelParameters = self:initializeMatrixBasedOnMode({numberOfFeatures, 1})

	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations

	local kernelFunction = self.kernelFunction
	
	local kernelParameters = self.kernelParameters
	
	local cValue = self.cValue
	
	local mappedFeatureMatrix = mappingList[kernelFunction](featureMatrix, kernelParameters)
	
	local kernelMatrix = kernelFunctionList[kernelFunction](featureMatrix, kernelParameters)

	local numberOfIterations = 0
	
	local costArray = {}
	
	local cost
	
	repeat
		
		numberOfIterations = numberOfIterations + 1

		self:iterationWait()
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()
			
			return calculateCost(ModelParameters, mappedFeatureMatrix, kernelMatrix, labelVector, cValue)
			
		end)

		if (cost) then
			
			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)
			
		end

		ModelParameters = calculateModelParameters(ModelParameters, mappedFeatureMatrix, labelVector, cValue)

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	self.ModelParameters = ModelParameters

	return costArray

end

function SupportVectorMachineModel:predict(featureMatrix, returnOriginalOutput)
	
	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

		self.ModelParameters = ModelParameters

	end

	local mappedFeatureMatrix = mappingList[self.kernelFunction](featureMatrix, self.kernelParameters)

	local originalPredictedVector = AqwamTensorLibrary:dotProduct(mappedFeatureMatrix, ModelParameters)

	if (returnOriginalOutput) then return originalPredictedVector end

	local predictedVector = AqwamTensorLibrary:applyFunction(seperatorFunction, originalPredictedVector)

	return predictedVector

end

return SupportVectorMachineModel]]></ProtectedString>
									<string name="ScriptGuid">{7C15D0FD-44A1-4104-B0F4-527AED065443}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">SupportVectorMachine</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6D98BE46948C43E9962160AB5BF27B78">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

GradientMethodBaseModel = {}

GradientMethodBaseModel.__index = GradientMethodBaseModel

setmetatable(GradientMethodBaseModel, IterativeMethodBaseModel)

function GradientMethodBaseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewGradientMethodBaseModel = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewGradientMethodBaseModel, GradientMethodBaseModel)
	
	NewGradientMethodBaseModel:setName("GradientMethodBaseModel")

	NewGradientMethodBaseModel:setClassName("GradientMethodModel")
	
	NewGradientMethodBaseModel.autoResetOptimizers = NewGradientMethodBaseModel:getValueOrDefaultValue(parameterDictionary.autoResetOptimizers, true)
	
	NewGradientMethodBaseModel.areGradientsSaved = NewGradientMethodBaseModel:getValueOrDefaultValue(parameterDictionary.areGradientsSaved, false)
	
	NewGradientMethodBaseModel.Gradients = NewGradientMethodBaseModel:getValueOrDefaultValue(parameterDictionary.Gradients, nil)
	
	return NewGradientMethodBaseModel
	
end

function GradientMethodBaseModel:setAutoResetOptimizers(option)

	self.autoResetOptimizers = self:getValueOrDefaultValue(option, self.autoResetOptimizers)

end

function GradientMethodBaseModel:setAreGradientsSaved(option)
	
	self.areGradientsSaved = self:getValueOrDefaultValue(option, self.areGradientsSaved)
	
end

function GradientMethodBaseModel:getGradients(doNotDeepCopy)
	
	if (doNotDeepCopy) then

		return self.Gradients

	else

		return self:deepCopyTable(self.Gradients)

	end
	
end

function GradientMethodBaseModel:setGradients(Gradients, doNotDeepCopy)
	
	if (doNotDeepCopy) then

		self.Gradients = Gradients

	else

		self.Gradients = self:deepCopyTable(Gradients)

	end

end

function GradientMethodBaseModel:clearGradients()
	
	self.Gradients = nil
	
end

return GradientMethodBaseModel]]></ProtectedString>
									<string name="ScriptGuid">{245B168E-FEF2-48CA-8F3B-DE5FAB9DCEC1}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">GradientMethodBaseModel</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0C2660682B8846C0B4B96F65F54972C7">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseInstance = require(script.Parent.Parent.Cores.BaseInstance)

BaseModel = {}

BaseModel.__index = BaseModel

setmetatable(BaseModel, BaseInstance)

function BaseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewBaseModel = BaseInstance.new(parameterDictionary)

	setmetatable(NewBaseModel, BaseModel)

	NewBaseModel:setName("BaseModel")

	NewBaseModel:setClassName("Model")
	
	NewBaseModel.isOutputPrinted = NewBaseModel:getValueOrDefaultValue(parameterDictionary.isOutputPrinted, true)

	NewBaseModel.ModelParameters = NewBaseModel:getValueOrDefaultValue(parameterDictionary.ModelParameters, nil)
	
	NewBaseModel.modelParametersInitializationMode = NewBaseModel:getValueOrDefaultValue(parameterDictionary.modelParametersInitializationMode, "RandomUniformNegativeAndPositive") 

	NewBaseModel.maximumModelParametersInitializationValue = NewBaseModel:getValueOrDefaultValue(parameterDictionary.maximumModelParametersInitializationValue, nil)
	
	NewBaseModel.minimumModelParametersInitializationValue = NewBaseModel:getValueOrDefaultValue(parameterDictionary.minimumModelParametersInitializationValue, nil)

	return NewBaseModel
	
end

function BaseModel:getModelParameters(doNotDeepCopy)
	
	if (doNotDeepCopy) then
		
		return self.ModelParameters
		
	else
		
		return self:deepCopyTable(self.ModelParameters)
		
	end
	
end

function BaseModel:setModelParameters(ModelParameters, doNotDeepCopy)
	
	if (doNotDeepCopy) then
		
		self.ModelParameters = ModelParameters
		
	else
		
		self.ModelParameters = self:deepCopyTable(ModelParameters) 
		
	end
	
end

function BaseModel:clearModelParameters()
	
	self.ModelParameters = nil
	
end

function BaseModel:setPrintOutput(option) 
	
	self.isOutputPrinted = self:getValueOrDefaultValue(option, self.isOutputPrinted)
	
end

function BaseModel:setModelParametersInitializationMode(initializationMode, minimumModelParametersInitializationValue, maximumModelParametersInitializationValue)
	
	self.modelParametersInitializationMode = initializationMode
	
	self.minimumModelParametersInitializationValue = minimumModelParametersInitializationValue
	
	self.maximumModelParametersInitializationValue = maximumModelParametersInitializationValue
	
end

function BaseModel:initializeMatrixBasedOnMode(dimensionSizeArray, dimensionSizeToIgnoreArray) -- Some of the row/column might not be considered as an input variables/neurons. Hence, it should be ignored by subtracting from original rows and columns with the number of non-input variables/neurons.
	
	if (not dimensionSizeArray) then error("No dimension size array for weight initialization.") end
	
	dimensionSizeToIgnoreArray = dimensionSizeToIgnoreArray or {}

	local numberOfRowsToIgnore = dimensionSizeToIgnoreArray[1] or 0
	
	local numberOfColumnsToIgnore = dimensionSizeToIgnoreArray[2] or 0
	
	local adjustedNumberOfRows = dimensionSizeArray[1] - numberOfRowsToIgnore
	
	local adjustedNumberOfColumns = dimensionSizeArray[2] - numberOfColumnsToIgnore
	
	local numberOfDimensions = #dimensionSizeArray
	
	local initializationMode = self.modelParametersInitializationMode

	if (initializationMode == "Zero") then

		return AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)

	elseif (initializationMode == "RandomUniform") then

		return AqwamTensorLibrary:createRandomUniformTensor(dimensionSizeArray, self.minimumModelParametersInitializationValue, self.maximumModelParametersInitializationValue)

	elseif (initializationMode == "RandomNormal") then

		return AqwamTensorLibrary:createRandomNormalTensor(dimensionSizeArray, self.modelParametersMean, self.modelParametersStandardDeviation)

	elseif (initializationMode == "RandomUniformPositive") then

		return AqwamTensorLibrary:createRandomUniformTensor(dimensionSizeArray)

	elseif (initializationMode == "RandomUniformNegative") then

		local randomUniformTensor = AqwamTensorLibrary:createRandomUniformTensor(dimensionSizeArray)

		return AqwamTensorLibrary:multiply(randomUniformTensor, -1)

	elseif (initializationMode == "RandomUniformNegativeAndPositive") then

		local randomUniformTensor1 = AqwamTensorLibrary:createRandomUniformTensor(dimensionSizeArray)

		local randomUniformTensor2 = AqwamTensorLibrary:createRandomUniformTensor(dimensionSizeArray)

		return AqwamTensorLibrary:subtract(randomUniformTensor1, randomUniformTensor2)

	elseif (initializationMode == "HeNormal") then

		local variancePart1 = 2 / adjustedNumberOfRows

		local variancePart = math.sqrt(variancePart1)

		local randomNormalTensor = AqwamTensorLibrary:createRandomNormalTensor(dimensionSizeArray)

		return AqwamTensorLibrary:multiply(variancePart, randomNormalTensor)

	elseif (initializationMode == "HeUniform") then

		local variancePart1 = 6 / adjustedNumberOfRows

		local variancePart = math.sqrt(variancePart1)

		local randomUniformTensor = AqwamTensorLibrary:createRandomUniformTensor(dimensionSizeArray)

		return AqwamTensorLibrary:multiply(variancePart, randomUniformTensor) 

	elseif (initializationMode == "XavierNormal") then

		local variancePart1 = 2 / (adjustedNumberOfRows + adjustedNumberOfColumns)

		local variancePart = math.sqrt(variancePart1)

		local randomNormalTensor = AqwamTensorLibrary:createRandomNormalTensor(dimensionSizeArray)

		return AqwamTensorLibrary:multiply(variancePart, randomNormalTensor) 

	elseif (initializationMode == "XavierUniform") then

		local variancePart1 = 6 / (adjustedNumberOfRows + adjustedNumberOfColumns)

		local variancePart = math.sqrt(variancePart1)

		local randomUniformTensor = AqwamTensorLibrary:createRandomUniformTensor(dimensionSizeArray)

		return AqwamTensorLibrary:multiply(variancePart, randomUniformTensor)

	elseif (initializationMode == "LeCunNormal") then

		local variancePart1 = 1 / adjustedNumberOfRows

		local variancePart = math.sqrt(variancePart1)

		local randomNormalTensor = AqwamTensorLibrary:createRandomNormalTensor(dimensionSizeArray)

		return AqwamTensorLibrary:multiply(variancePart, randomNormalTensor) 

	elseif (initializationMode == "LeCunUniform") then

		local variancePart1 = 3 / adjustedNumberOfRows

		local variancePart = math.sqrt(variancePart1)

		local randomUniformTensor = AqwamTensorLibrary:createRandomUniformTensor(dimensionSizeArray)

		return AqwamTensorLibrary:multiply(variancePart, randomUniformTensor) 

	elseif (initializationMode == "None") then

		return nil

	else

		error("Invalid weight initialization mode.")

	end
	
end

return BaseModel]]></ProtectedString>
									<string name="ScriptGuid">{F9D3226A-D9AD-490C-9AC3-9AE50666EBAC}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BaseModel</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF0159DE1935D48E49AD4E470B065A9AC">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

NormalLinearRegressionModel = {}

NormalLinearRegressionModel.__index = NormalLinearRegressionModel

setmetatable(NormalLinearRegressionModel, BaseModel)

local defaultLambda = 0

function NormalLinearRegressionModel.new(parameterDictionary)

	local NewNormalLinearRegressionModel = BaseModel.new(parameterDictionary)

	setmetatable(NewNormalLinearRegressionModel, NormalLinearRegressionModel)

	NewNormalLinearRegressionModel:setName("NormalLinearRegression")

	NewNormalLinearRegressionModel.lambda = parameterDictionary.lambda or defaultLambda

	return NewNormalLinearRegressionModel

end

function NormalLinearRegressionModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end

	local lambda = self.lambda

	local transposedFeatureMatrix = AqwamTensorLibrary:transpose(featureMatrix)

	local dotProductFeatureMatrix = AqwamTensorLibrary:dotProduct(featureMatrix, transposedFeatureMatrix)

	if (lambda ~= 0) then

		local numberOfFeatures = #featureMatrix[1]

		local lambdaIdentityMatrix = AqwamTensorLibrary:createIdentityTensor({numberOfFeatures, numberOfFeatures})

		lambdaIdentityMatrix = AqwamTensorLibrary:multiply(lambdaIdentityMatrix, lambda)

		dotProductFeatureMatrix = AqwamTensorLibrary:add(dotProductFeatureMatrix, lambdaIdentityMatrix)

	end

	local inverseDotProduct = AqwamTensorLibrary:inverse(dotProductFeatureMatrix)

	if (not inverseDotProduct) then error("Could not find the model parameters.") end

	local dotProductFeatureMatrixAndLabelVector = AqwamTensorLibrary:dotProduct(transposedFeatureMatrix, labelVector)

	local ModelParameters = AqwamTensorLibrary:multiply(inverseDotProduct, dotProductFeatureMatrixAndLabelVector)

	self.ModelParameters = ModelParameters

end

function NormalLinearRegressionModel:predict(featureMatrix)

	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

		self.ModelParameters = ModelParameters

	end

	return AqwamTensorLibrary:dotProduct(featureMatrix, ModelParameters)

end

return NormalLinearRegressionModel]]></ProtectedString>
									<string name="ScriptGuid">{8FA18B70-22E2-4204-B2C6-B523D0252373}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">NormalLinearRegression</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX27D8FD3E27F648A488413E2E6ED4789B">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GradientMethodBaseModel = require(script.Parent.GradientMethodBaseModel)

LogisticRegressionModel = {}

LogisticRegressionModel.__index = LogisticRegressionModel

setmetatable(LogisticRegressionModel, GradientMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultLearningRate = 0.1

local defaultSigmoidFunction = "Sigmoid"

local sigmoidFunctionList = {

	["Sigmoid"] = function (z) return 1/(1 + math.exp(-1 * z)) end,

	["Tanh"] = function (z) return math.tanh(z) end,
	
	["HardSigmoid"] = function (z)

		local x = (z + 1) / 2

		if (x < 0) then return 0 elseif (x > 1) then return 1 else return x end

	end,
	
	["SoftSign"] = function (z) return z / (1 + math.abs(z)) end,
	
	["ArcTangent"] = function (z) return (2 / math.pi) * math.atan(z) end,

	["Swish"] = function (z) return z / (1 + math.exp(-z)) end,

	["BipolarSigmoid"] = function (z) return 2 / (1 + math.exp(-z)) - 1 end,

}

local derivativeLossFunctionList = {

	["Sigmoid"] = function (h, y) return (h - y) end,

	["Tanh"] = function (h, y) return (h - y) * (1 - math.pow(h, 2)) end,
	
	["HardSigmoid"] = function (h, y) return (h - y) * ((h <= 0 or h >= 1) and 0) or 0.5 end,

	["SoftSign"] = function (h, y) return (h - y) *  1 / ((1 + math.abs(h))^2) end,
	
	["ArcTangent"] = function (h, y) return (h - y) * (2 / math.pi) * (1 / (1 + h^2)) end,

	["Swish"] = function (h, y)
		
		local sigmoidValue = 1 / (1 + math.exp(-h))
		
		return (h - y) * sigmoidValue + h * sigmoidValue * (1 - sigmoidValue)
		
	end,

	["BipolarSigmoid"] = function (h, y) return (h - y) * 0.5 * (1 - h^2) end,

}

local lossFunctionList = {

	["Sigmoid"] = function (h, y) return -(y * math.log(h) + (1 - y) * math.log(1 - h)) end,

	["Tanh"] = function (h, y) return ((h - y)^2) / 2 end,
	
	["HardSigmoid"] = function (h, y) return -(y * math.log(h) + (1 - y) * math.log(1 - h)) end,

	["SoftSign"] = function (h, y) return ((h - y)^2) / 2 end,

	["ArcTangent"] = function (h, y) return ((h - y)^2) / 2 end,

	["Swish"] = function (h, y) return ((h - y)^2) / 2 end,

	["BipolarSigmoid"] = function (h, y) return ((h - y)^2) / 2 end,

}

local cutOffList = {
	
	["0.5"] = {"Sigmoid", "HardSigmoid", "Swish"}, -- 0.5 threshold for [0, 1] functions.

	["0"] = {"Tanh", "SoftSign", "ArcTangent", "BipolarSigmoid"}, -- 0 threshold for [-1, 1] functions.
	
}

local function getCutOffFunction(sigmoidFunction)
	
	for stringCutOffValue, sigmoidFunctionArray in pairs(cutOffList) do

		if (table.find(sigmoidFunctionArray, sigmoidFunction)) then

			local cutOffValue = tonumber(stringCutOffValue)

			local lowerValue = (cutOffValue == 0.5) and 0 or -1

			local cutOffFunction = function(x) 

				if (x > cutOffValue) then return 1 end

				if (x < cutOffValue) then return lowerValue end

				return cutOffValue

			end

			return cutOffFunction

		end

	end
	
	error("Unknown cut-off function.")
	
end

function LogisticRegressionModel:calculateCost(hypothesisVector, labelVector)

	local costVector = AqwamTensorLibrary:applyFunction(lossFunctionList[self.sigmoidFunction], hypothesisVector, labelVector)

	local totalCost = AqwamTensorLibrary:sum(costVector)
	
	local Regularizer = self.Regularizer

	if (Regularizer) then totalCost = totalCost + Regularizer:calculateCost(self.ModelParameters) end

	local averageCost = totalCost / #labelVector

	return averageCost

end

function LogisticRegressionModel:calculateHypothesisVector(featureMatrix, saveFeatureMatrix)

	local zVector = AqwamTensorLibrary:dotProduct(featureMatrix, self.ModelParameters)

	if (saveFeatureMatrix) then 

		self.featureMatrix = featureMatrix

	end

	local hypothesisVector = AqwamTensorLibrary:applyFunction(sigmoidFunctionList[self.sigmoidFunction], zVector)

	return hypothesisVector

end

function LogisticRegressionModel:calculateCostFunctionDerivativeMatrix(lossMatrix)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local featureMatrix = self.featureMatrix

	if (not featureMatrix) then error("Feature matrix not found.") end

	local costFunctionDerivativeMatrix = AqwamTensorLibrary:dotProduct(AqwamTensorLibrary:transpose(featureMatrix), lossMatrix)

	if (self.areGradientsSaved) then self.Gradients = costFunctionDerivativeMatrix end

	return costFunctionDerivativeMatrix

end

function LogisticRegressionModel:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (type(costFunctionDerivativeMatrix) == "number") then costFunctionDerivativeMatrix = {{costFunctionDerivativeMatrix}} end
	
	local ModelParameters = self.ModelParameters

	local Regularizer = self.Regularizer

	local Optimizer = self.Optimizer

	local learningRate = self.learningRate
	
	if (Regularizer) then

		local regularizationDerivatives = Regularizer:calculate(ModelParameters)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:add(costFunctionDerivativeMatrix, regularizationDerivatives)

	end

	costFunctionDerivativeMatrix = AqwamTensorLibrary:divide(costFunctionDerivativeMatrix, numberOfData)

	if (Optimizer) then

		costFunctionDerivativeMatrix = Optimizer:calculate(learningRate, costFunctionDerivativeMatrix, ModelParameters) 

	else

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrix)

	end

	self.ModelParameters = AqwamTensorLibrary:subtract(ModelParameters, costFunctionDerivativeMatrix)

end

function LogisticRegressionModel:update(lossMatrix, clearFeatureMatrix)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local numberOfData = #lossMatrix

	local costFunctionDerivativeMatrix = self:calculateCostFunctionDerivativeMatrix(lossMatrix)

	self:gradientDescent(costFunctionDerivativeMatrix, numberOfData)
	
	if (clearFeatureMatrix) then self.featureMatrix = nil end

end

function LogisticRegressionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewLogisticRegressionModel = GradientMethodBaseModel.new(parameterDictionary)

	setmetatable(NewLogisticRegressionModel, LogisticRegressionModel)
	
	NewLogisticRegressionModel:setName("LogisticRegression")

	NewLogisticRegressionModel.learningRate = parameterDictionary.learningRate or defaultLearningRate

	NewLogisticRegressionModel.sigmoidFunction = parameterDictionary.sigmoidFunction or defaultSigmoidFunction

	NewLogisticRegressionModel.Optimizer = parameterDictionary.Optimizer

	NewLogisticRegressionModel.Regularizer = parameterDictionary.Regularizer

	return NewLogisticRegressionModel

end

function LogisticRegressionModel:setOptimizer(Optimizer)

	self.Optimizer = Optimizer

end

function LogisticRegressionModel:setRegularizer(Regularizer)

	self.Regularizer = Regularizer

end

function LogisticRegressionModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (#featureMatrix[1] ~= #ModelParameters) then error("The number of features are not the same as the model parameters.") end

	else

		self.ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local derivativeLossFunctionToApply = derivativeLossFunctionList[self.sigmoidFunction] 
	
	local Optimizer = self.Optimizer
	
	local costArray = {}

	local numberOfIterations = 0
	
	local cost
	
	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		local hypothesisVector = self:calculateHypothesisVector(featureMatrix, true)

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return self:calculateCost(hypothesisVector, labelVector)

		end)

		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end

		local lossVector = AqwamTensorLibrary:applyFunction(derivativeLossFunctionToApply, hypothesisVector, labelVector)

		self:update(lossVector, true)

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then
		
		if (cost == math.huge) then warn("The model diverged.") end
		
		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end
		
	end

	if (Optimizer) and (self.autoResetOptimizers) then Optimizer:reset() end

	return costArray

end

function LogisticRegressionModel:predict(featureMatrix, returnOriginalOutput)

	if (not self.ModelParameters) then self.ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1}) end

	local outputVector = self:calculateHypothesisVector(featureMatrix, false)

	if (returnOriginalOutput) then return outputVector end
	
	local cutOffFunction = getCutOffFunction(self.sigmoidFunction)

	local predictedLabelVector = AqwamTensorLibrary:applyFunction(cutOffFunction, outputVector)

	return predictedLabelVector, outputVector

end

return LogisticRegressionModel]]></ProtectedString>
									<string name="ScriptGuid">{22ADE140-F44A-41D5-87BD-D6C032DB1017}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LogisticRegression</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA99F9E51415D42539C24F89621303D02">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GradientMethodBaseModel = require(script.Parent.GradientMethodBaseModel)

LinearRegressionModel = {}

LinearRegressionModel.__index = LinearRegressionModel

setmetatable(LinearRegressionModel, GradientMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultLearningRate = 0.3

local defaultCostFunction = "L2"

local lossFunctionList = {

	["L1"] = function (x1, x2)

		local part1 = AqwamTensorLibrary:subtract(x1, x2)

		return AqwamTensorLibrary:applyFunction(math.abs, part1) 

	end,

	["L2"] = function (x1, x2)

		local part1 = AqwamTensorLibrary:subtract(x1, x2)

		local part2 = AqwamTensorLibrary:power(part1, 2) 

		return AqwamTensorLibrary:divide(part2, 2)

	end,

}

function LinearRegressionModel:calculateCost(hypothesisVector, labelVector)

	if (type(hypothesisVector) == "number") then hypothesisVector = {{hypothesisVector}} end

	local costVector = lossFunctionList[self.costFunction](hypothesisVector, labelVector) 

	local totalCost = AqwamTensorLibrary:sum(costVector)
	
	local Regularizer = self.Regularizer

	if (Regularizer) then totalCost = totalCost + Regularizer:calculateCost(self.ModelParameters) end

	local averageCost = totalCost / #labelVector

	return averageCost

end

function LinearRegressionModel:calculateHypothesisVector(featureMatrix, saveFeatureMatrix)

	local hypothesisVector = AqwamTensorLibrary:dotProduct(featureMatrix, self.ModelParameters)

	if (saveFeatureMatrix) then self.featureMatrix = featureMatrix end

	return hypothesisVector

end

function LinearRegressionModel:calculateCostFunctionDerivativeMatrix(lossMatrix)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local featureMatrix = self.featureMatrix

	if (not featureMatrix) then error("Feature matrix not found.") end

	local costFunctionDerivativeMatrix = AqwamTensorLibrary:dotProduct(AqwamTensorLibrary:transpose(featureMatrix), lossMatrix)

	if (self.areGradientsSaved) then self.costFunctionDerivativeMatrix = costFunctionDerivativeMatrix end

	return costFunctionDerivativeMatrix

end

function LinearRegressionModel:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (type(costFunctionDerivativeMatrix) == "number") then costFunctionDerivativeMatrix = {{costFunctionDerivativeMatrix}} end
	
	local ModelParameters = self.ModelParameters
	
	local Regularizer = self.Regularizer
	
	local Optimizer = self.Optimizer
	
	local learningRate = self.learningRate

	if (Regularizer) then

		local regularizationDerivatives = Regularizer:calculate(ModelParameters)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:add(costFunctionDerivativeMatrix, regularizationDerivatives)

	end

	costFunctionDerivativeMatrix = AqwamTensorLibrary:divide(costFunctionDerivativeMatrix, numberOfData)

	if (Optimizer) then 

		costFunctionDerivativeMatrix = Optimizer:calculate(learningRate, costFunctionDerivativeMatrix, ModelParameters) 

	else

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrix)

	end

	self.ModelParameters = AqwamTensorLibrary:subtract(ModelParameters, costFunctionDerivativeMatrix)

end

function LinearRegressionModel:update(lossMatrix, clearAllMatrices)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local numberOfData = #lossMatrix

	local costFunctionDerivativeMatrix = self:calculateCostFunctionDerivativeMatrix(lossMatrix)

	self:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (clearAllMatrices) then 

		self.featureMatrix = nil 

		self.costFunctionDerivativeMatrix = nil

	end

end

function LinearRegressionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewLinearRegressionModel = GradientMethodBaseModel.new(parameterDictionary)

	setmetatable(NewLinearRegressionModel, LinearRegressionModel)
	
	NewLinearRegressionModel:setName("LinearRegression")

	NewLinearRegressionModel.learningRate = parameterDictionary.learningRate or defaultLearningRate

	NewLinearRegressionModel.costFunction = parameterDictionary.costFunction or defaultCostFunction

	NewLinearRegressionModel.Optimizer = parameterDictionary.Optimizer

	NewLinearRegressionModel.Regularizer = parameterDictionary.Regularizer

	return NewLinearRegressionModel

end

function LinearRegressionModel:setOptimizer(Optimizer)

	self.Optimizer = Optimizer

end

function LinearRegressionModel:setRegularizer(Regularizer)

	self.Regularizer = Regularizer

end

function LinearRegressionModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (#featureMatrix[1] ~= #ModelParameters) then error("The number of features are not the same as the model parameters.") end

	else

		self.ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations

	local Optimizer = self.Optimizer

	local costArray = {}

	local numberOfIterations = 0
	
	local cost

	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		local hypothesisVector = self:calculateHypothesisVector(featureMatrix, true)

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return self:calculateCost(hypothesisVector, labelVector)

		end)

		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end

		local lossVector = AqwamTensorLibrary:subtract(hypothesisVector, labelVector)

		self:update(lossVector, true)

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	if (Optimizer) and (self.autoResetOptimizers) then Optimizer:reset() end

	return costArray

end

function LinearRegressionModel:predict(featureMatrix)
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then
		
		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})
		
		self.ModelParameters = ModelParameters
		
	end

	local predictedVector = AqwamTensorLibrary:dotProduct(featureMatrix, ModelParameters)

	return predictedVector

end

return LinearRegressionModel]]></ProtectedString>
									<string name="ScriptGuid">{CD9CEB88-D5E2-48F4-BEDD-BFEBAAA0FFAB}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LinearRegression</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB63CF76E5C484C30BB16F0513B4CADAA">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

KMedoidsModel = {}

KMedoidsModel.__index = KMedoidsModel

setmetatable(KMedoidsModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = math.huge

local defaultNumberOfClusters = 1

local defaultDistanceFunction = "Manhattan"

local defaultSetTheCentroidsDistanceFarthest = true

local function checkIfTheDataPointClusterNumberBelongsToTheCluster(dataPointClusterNumber, cluster)
	
	if (dataPointClusterNumber == cluster) then
		
		return 1
		
	else
		
		return 0
		
	end
	
end

local function createDistanceMatrix(distanceFunction, featureMatrix, modelParameters)

	local numberOfData = #featureMatrix

	local numberOfClusters = #modelParameters

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfClusters})

	for datasetIndex = 1, #featureMatrix, 1 do

		for cluster = 1, #modelParameters, 1 do

			distanceMatrix[datasetIndex][cluster] = distanceFunction({featureMatrix[datasetIndex]}, {modelParameters[cluster]})

		end

	end

	return distanceMatrix

end

local function chooseFarthestCentroidFromDatasetDistanceMatrix(distanceMatrix, blacklistedDataIndexArray)

	local dataIndex

	local maxDistance = -math.huge

	for row = 1, #distanceMatrix, 1 do

		if (not table.find(blacklistedDataIndexArray, row)) then

			local totalDistance = 0

			for column = 1, #distanceMatrix[1], 1 do totalDistance = totalDistance + distanceMatrix[row][column] end

			if (totalDistance > maxDistance) then

				maxDistance = totalDistance

				dataIndex = row

			end

		end

	end

	return dataIndex

end

local function chooseFarthestCentroids(featureMatrix, numberOfClusters, distanceFunction)
	
	local modelParameters = {}
	
	local dataIndexArray = {}
	
	local dataIndex
	
	local distanceMatrix = createDistanceMatrix(distanceFunction, featureMatrix, featureMatrix)
	
	repeat
		
		dataIndex = chooseFarthestCentroidFromDatasetDistanceMatrix(distanceMatrix, dataIndexArray)
		
		table.insert(dataIndexArray, dataIndex)
		
	until (#dataIndexArray == numberOfClusters)
	
	for row = 1, numberOfClusters, 1 do
		
		dataIndex = dataIndexArray[row]
		
		table.insert(modelParameters, featureMatrix[dataIndex])
		
	end
	
	return modelParameters
	
end

local function chooseRandomCentroids(featureMatrix, numberOfClusters)

	local modelParameters = {}

	local numberOfRows = #featureMatrix

	local randomRow

	local selectedRows = {}

	local hasANewRandomRowChosen

	for cluster = 1, numberOfClusters, 1 do

		repeat

			randomRow = Random.new():NextInteger(1, numberOfRows)

			hasANewRandomRowChosen = not (table.find(selectedRows, randomRow))

			if hasANewRandomRowChosen then

				table.insert(selectedRows, randomRow)
				modelParameters[cluster] = featureMatrix[randomRow]

			end

		until hasANewRandomRowChosen

	end

	return modelParameters

end

local function createClusterAssignmentMatrix(distanceMatrix) -- contains values of 0 and 1, where 0 is "does not belong to this cluster"
	
	local numberOfData = #distanceMatrix -- Number of rows

	local numberOfClusters = #distanceMatrix[1]

	local clusterAssignmentMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfClusters})

	local dataPointClusterNumber

	for dataIndex = 1, numberOfData, 1 do

		local distanceVector = {distanceMatrix[dataIndex]}

		local vectorIndexArray = AqwamTensorLibrary:findMinimumValueDimensionIndexArray(distanceVector)

		if (vectorIndexArray == nil) then continue end

		local clusterNumber = vectorIndexArray[2]

		clusterAssignmentMatrix[dataIndex][clusterNumber] = 1

	end

	return clusterAssignmentMatrix
	
end

local function calculateCost(distanceMatrix)
	
	local clusterAssignmentMatrix = createClusterAssignmentMatrix(distanceMatrix)
	
	local costMatrix = AqwamTensorLibrary:multiply(distanceMatrix, clusterAssignmentMatrix)
	
	local cost = AqwamTensorLibrary:sum(costMatrix)
	
	return cost
	
end

local function initializeCentroids(featureMatrix, numberOfClusters, distanceFunction, setTheCentroidsDistanceFarthest)

	if (setTheCentroidsDistanceFarthest) and (#featureMatrix >= numberOfClusters) then

		return chooseFarthestCentroids(featureMatrix, numberOfClusters, distanceFunction)

	else

		return chooseRandomCentroids(featureMatrix, numberOfClusters)

	end

end


function KMedoidsModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations
	
	local NewKMedoidsModel = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewKMedoidsModel, KMedoidsModel)
	
	NewKMedoidsModel:setName("KMedoids")
	
	NewKMedoidsModel.numberOfClusters = parameterDictionary.numberOfClusters or defaultNumberOfClusters

	NewKMedoidsModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction

	NewKMedoidsModel.setTheCentroidsDistanceFarthest = NewKMedoidsModel:getValueOrDefaultValue(parameterDictionary.setTheCentroidsDistanceFarthest, defaultSetTheCentroidsDistanceFarthest)
	
	return NewKMedoidsModel
	
end

function KMedoidsModel:train(featureMatrix)
	
	local ModelParameters = self.ModelParameters
	
	local numberOfClusters = self.numberOfClusters
	
	local distanceFunction = self.distanceFunction
	
	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]

	if (not distanceFunctionToApply) then error("Unknown distance function.") end
	
	local medoidMatrix = ModelParameters
	
	if (medoidMatrix) then
		
		if (#featureMatrix[1] ~= #medoidMatrix[1]) then error("The number of features are not the same as the model parameters.") end
		
	else
		
		medoidMatrix = initializeCentroids(featureMatrix, numberOfClusters, distanceFunctionToApply, self.setTheCentroidsDistanceFarthest)
		
	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, medoidMatrix)
	
	local oldColumnDistanceArray = {}
	
	local costArray = {}

	local numberOfIterations = 0

	local previousCost = calculateCost(distanceMatrix)
	
	local currentCost
	
	local candidateMedoidVector
	
	repeat
		
		self:iterationWait()
		
		for candidateMedoidIndex, unwrappedCandidateMedoidVector in ipairs(featureMatrix) do
			
			self:dataWait()
			
			candidateMedoidVector = {unwrappedCandidateMedoidVector}
			
			for medoidIndex, unwrappedMedoidVector in ipairs(medoidMatrix) do

				medoidMatrix[medoidIndex] = unwrappedCandidateMedoidVector
				
				for dataIndex, unwrappedFeatureVector in ipairs(featureMatrix) do
					
					oldColumnDistanceArray[dataIndex] = distanceMatrix[dataIndex][medoidIndex]
					
					distanceMatrix[dataIndex][medoidIndex] = distanceFunctionToApply({unwrappedFeatureVector}, candidateMedoidVector)
					
				end

				currentCost = calculateCost(distanceMatrix)

				if (currentCost > previousCost) then
					
					for dataIndex, unwrappedFeatureVector in ipairs(featureMatrix) do 
						
						distanceMatrix[dataIndex][medoidIndex] = oldColumnDistanceArray[dataIndex]
						
					end

					medoidMatrix[medoidIndex] = unwrappedMedoidVector

					currentCost = previousCost
					
				else
					
					previousCost = currentCost

				end

				numberOfIterations = numberOfIterations + 1

				table.insert(costArray, currentCost)

				self:printNumberOfIterationsAndCost(numberOfIterations, currentCost)

				if (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(currentCost) or self:checkIfConverged(currentCost) then break end
				
			end

			if (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(currentCost) or self:checkIfConverged(currentCost) then break end
			
		end
		
	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(currentCost) or self:checkIfConverged(currentCost)
	
	if (self.isOutputPrinted) then

		if (currentCost == math.huge) then warn("The model diverged.") end

		if (currentCost ~= currentCost) then warn("The model produced nan (not a number) values.") end

	end
	
	self.ModelParameters = medoidMatrix
	
	return costArray
	
end

function KMedoidsModel:predict(featureMatrix, returnOriginalOutput)
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then

		local numberOfData = #featureMatrix

		if (returnOriginalOutput) then AqwamTensorLibrary:createTensor({numberOfData, self.numberOfClusters}, math.huge) end

		local dimensionSizeArray = {numberOfData, 1}

		return AqwamTensorLibrary:createTensor(dimensionSizeArray, nil), AqwamTensorLibrary:createTensor(dimensionSizeArray, math.huge)

	end
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
	
	local distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, ModelParameters)
	
	if (returnOriginalOutput) then return distanceMatrix end

	local numberOfData = #distanceMatrix

	local clusterNumberVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 0)

	local clusterDistanceVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 0) 

	for dataIndex, distanceVector in ipairs(distanceMatrix) do

		local closestClusterNumber

		local shortestDistance = math.huge

		for i, distance in ipairs(distanceVector) do

			if (distance < shortestDistance) then

				closestClusterNumber = i

				shortestDistance = distance

			end

		end

		clusterNumberVector[dataIndex][1] = closestClusterNumber

		clusterDistanceVector[dataIndex][1] = shortestDistance

	end

	return clusterNumberVector, clusterDistanceVector
	
end

return KMedoidsModel]]></ProtectedString>
									<string name="ScriptGuid">{C44B4AEF-E5A8-4638-BC09-517485141F47}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">KMedoids</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE8F78BBCCED4441389CBF458E5DC2B2C">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

OrderingPointsToIdentifyClusteringStructureModel = {}

OrderingPointsToIdentifyClusteringStructureModel.__index = OrderingPointsToIdentifyClusteringStructureModel

setmetatable(OrderingPointsToIdentifyClusteringStructureModel, IterativeMethodBaseModel)

local defaultMinimumNumberOfPoints = 2

local defaultDistanceFunction = "Manhattan"

local defaultEpsilon = 10

local function getNeighborArray(currentCorePointNumber, featureMatrix, epsilon, distanceFunction)
	
	local distance
	
	local neighborArray = {}
	
	for i = 1, #featureMatrix, 1 do
		
		if (i ~= currentCorePointNumber) then
			
			distance = distanceFunction({featureMatrix[currentCorePointNumber]}, {featureMatrix[i]})
			
			if (distance <= epsilon) then table.insert(neighborArray, i) end
			
		end
		
	end
	
	return neighborArray
	
end

local function calculateCoreDistance(pointNumber, featureMatrix, epsilon, minimumNumberOfPoints, distanceFunction)
	
	local distanceArray = {}
	
	local distance
	
	for i, unwrappedFeatureVector in ipairs(featureMatrix) do
		
		if (i ~= pointNumber) then

			distance = distanceFunction({featureMatrix[pointNumber]}, {unwrappedFeatureVector})

			table.insert(distanceArray, distance)

		end
		
	end
	
	if (#distanceArray < minimumNumberOfPoints) then return end
	
	table.sort(distanceArray)
	
	return distanceArray[minimumNumberOfPoints]
	
end

local function calculateReachabilityCost(reachabilityDistanceArray)
	
	local total = 0
	
	local count = 0

	for _, distance in pairs(reachabilityDistanceArray) do
		
		if (distance) and (distance ~= math.huge) then
			
			total = total + distance
			
			count = count + 1
			
		end
		
	end

	return ((count > 0) and (total / count)) or math.huge
end

local function insertSorted(seedPointArray, seedReachabilityDistanceArray, point, distance)
	
	local inserted = false
	
	for i, reachabilityDistance in ipairs(seedReachabilityDistanceArray) do
		
		if (distance < reachabilityDistance) then
			
			table.insert(seedReachabilityDistanceArray, i, distance)
			
			table.insert(seedPointArray, i, point)
			
			inserted = true
			
			break
			
		end
		
	end
	
	if (not inserted) then
		
		table.insert(seedReachabilityDistanceArray, distance)
		
		table.insert(seedPointArray, point)
		
	end
	
end

local function update(neighbourArray, pPointNumber, hasProcessedArray, reachabilityDistanceArray, seedPointArray, seedReachabilityDistanceArray, featureMatrix, epsilon, minimumNumberOfPoints, distanceFunction)
	
	local coreDistance = calculateCoreDistance(pPointNumber, featureMatrix, epsilon, minimumNumberOfPoints, distanceFunction)
	
	local reachabilityDistance
	
	local newReachabilityDistance
	
	local newReachabilityDistanceArrayIndex
	
	for _, oPointNumber in ipairs(neighbourArray) do
		
		if (not hasProcessedArray[oPointNumber]) then
			
			newReachabilityDistance = math.max(coreDistance, distanceFunction({featureMatrix[pPointNumber]}, {featureMatrix[oPointNumber]}))
			
			reachabilityDistance = reachabilityDistanceArray[oPointNumber]
			
			if (not reachabilityDistance) then
				
				reachabilityDistanceArray[oPointNumber] = newReachabilityDistance
				
				table.insert(seedPointArray, oPointNumber)
				
				table.insert(seedReachabilityDistanceArray, newReachabilityDistance)
				
			else
				
				if (newReachabilityDistance < reachabilityDistance) then
					
					reachabilityDistanceArray[oPointNumber] = newReachabilityDistance
					
					-- Moving up the new reachability distance inside the seedArray.
					
					insertSorted(seedPointArray, seedReachabilityDistanceArray, oPointNumber, newReachabilityDistance)
					
				end
				
			end
			
		end
		
	end
	
end

local function createClusterArrayArray(orderedPointArray, reachabilityDistanceArray, epsilonPrime)
	
	local clusterArrayArray = {}
	
	local clusterArray = {}
	
	local reachabilityDistance

	for i, pointIndex in ipairs(orderedPointArray) do
		
		reachabilityDistance = reachabilityDistanceArray[pointIndex] or math.huge

		if (reachabilityDistance <= epsilonPrime) then
			
			table.insert(clusterArray, pointIndex)
			
		else
			
			if (#clusterArray > 0) then
				
				table.insert(clusterArrayArray, clusterArray)
				
				clusterArray = {}
				
			end
			
		end
		
	end

	if (#clusterArray > 0) then
		
		table.insert(clusterArrayArray, clusterArray)
		
	end

	return clusterArrayArray
	
end

function OrderingPointsToIdentifyClusteringStructureModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewOrderingPointsToIdentifyClusteringStructureModel = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewOrderingPointsToIdentifyClusteringStructureModel, OrderingPointsToIdentifyClusteringStructureModel)
	
	NewOrderingPointsToIdentifyClusteringStructureModel:setName("OrderingPointsToIdentifyClusteringStructure")
	
	local epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	local epsilonPrime = (parameterDictionary.epsilonPrime) or (epsilon * 0.5)
	
	NewOrderingPointsToIdentifyClusteringStructureModel.minimumNumberOfPoints = parameterDictionary.minimumNumberOfPoints or defaultMinimumNumberOfPoints
	
	NewOrderingPointsToIdentifyClusteringStructureModel.epsilon = epsilon
	
	NewOrderingPointsToIdentifyClusteringStructureModel.epsilonPrime = epsilonPrime

	NewOrderingPointsToIdentifyClusteringStructureModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction
	
	return NewOrderingPointsToIdentifyClusteringStructureModel
	
end

function OrderingPointsToIdentifyClusteringStructureModel:train(featureMatrix)
	
	if (self.ModelParameters) then

		local storedFeatureMatrix = self.ModelParameters[1]

		if (#storedFeatureMatrix[1] ~= #featureMatrix[1]) then error("The previous and current feature matrices do not have the same number of features.") end 

		featureMatrix = AqwamTensorLibrary:concatenate(featureMatrix, storedFeatureMatrix, 1)

	end
	
	local distanceFunction = self.distanceFunction
	
	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]
	
	if (not distanceFunctionToApply) then error("Unknown distance function.") end
	
	local minimumNumberOfPoints = self.minimumNumberOfPoints

	local epsilon = self.epsilon
	
	local epsilonPrime = self.epsilonPrime
	
	local costArray = {}
	
	local reachabilityDistanceArray = {}
	
	local hasProcessedArray = {}
	
	local orderedPointArray = {}
	
	local neighbourArray
	
	local coreDistance
	
	local seedPointArray
	
	local seedReachabilityDistanceArray
	
	local neighbourComplementArray
	
	local cost
	
	for pPointNumber, unwrappedFeatureVector in ipairs(featureMatrix) do
		
		self:iterationWait()

		if (not hasProcessedArray[pPointNumber]) then
			
			neighbourArray = getNeighborArray(pPointNumber, featureMatrix, epsilon, distanceFunctionToApply)

			hasProcessedArray[pPointNumber] = true
			
			table.insert(orderedPointArray, pPointNumber)
			
			if (not reachabilityDistanceArray[pPointNumber]) then
				
				reachabilityDistanceArray[pPointNumber] = math.huge
				
			end
			
			coreDistance = calculateCoreDistance(pPointNumber, featureMatrix, epsilon, minimumNumberOfPoints, distanceFunctionToApply)

			if (coreDistance) then
				
				seedPointArray = {}
				
				seedReachabilityDistanceArray = {}
				
				update(neighbourArray, pPointNumber, hasProcessedArray, reachabilityDistanceArray, seedPointArray, seedReachabilityDistanceArray, featureMatrix, epsilon, minimumNumberOfPoints, distanceFunctionToApply)
				
				for _, qPointNumber in ipairs(seedPointArray) do
					
					neighbourComplementArray = getNeighborArray(qPointNumber, featureMatrix, epsilon, distanceFunctionToApply)
					
					hasProcessedArray[qPointNumber] = true
					
					table.insert(orderedPointArray, qPointNumber)
					
					coreDistance = calculateCoreDistance(qPointNumber, featureMatrix, epsilon, minimumNumberOfPoints, distanceFunctionToApply)
					
					if (coreDistance) then
						
						update(neighbourComplementArray, qPointNumber, hasProcessedArray, reachabilityDistanceArray, seedPointArray, seedReachabilityDistanceArray, featureMatrix, epsilon, minimumNumberOfPoints, distanceFunctionToApply)
						
					end
					
				end
				
			end

		end

		cost = self:calculateCostWhenRequired(pPointNumber, function()

			return calculateReachabilityCost(reachabilityDistanceArray)

		end)

		if (cost) then

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(pPointNumber, cost)

			if self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost) then break end

		end
		
	end
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	local clusterArrayArray = createClusterArrayArray(orderedPointArray, reachabilityDistanceArray, epsilonPrime)
	
	self.ModelParameters = {featureMatrix, orderedPointArray, reachabilityDistanceArray, clusterArrayArray}
	
	return costArray
	
end

function OrderingPointsToIdentifyClusteringStructureModel:predict(featureMatrix)
	
	local numberOfData = #featureMatrix
	
	local dimensionSizeArray = {numberOfData, 1}
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then
		
		local placeholderClusterVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, nil)
		
		local placeholderDistanceVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, math.huge)
		
		return placeholderClusterVector, placeholderDistanceVector
		
	end
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
	
	local shortestDistanceVector = AqwamTensorLibrary:createTensor(dimensionSizeArray)

	local closestClusterVector = AqwamTensorLibrary:createTensor(dimensionSizeArray)
	
	local storedFeatureVector, _, _, clusterArrayArray = table.unpack(ModelParameters)
	
	local closestCluster
	
	local shortestDistance
	
	local featureVector
	
	for i, unwrappedFeatureVector in ipairs(featureMatrix) do
		
		closestCluster = nil

		shortestDistance = math.huge

		featureVector = {unwrappedFeatureVector}

		for clusterNumber, clusterArray in ipairs(clusterArrayArray) do

			local distance = 0
			
			for j, pointNumber in ipairs(clusterArray) do

				distance = distance + distanceFunctionToApply(featureVector, {storedFeatureVector[pointNumber]})
				
			end

			distance = distance / #clusterArray

			if (distance < shortestDistance) then

				closestCluster = clusterNumber

				shortestDistance = distance

			end

		end

		closestClusterVector[i][1] = closestCluster

		shortestDistanceVector[i][1] = shortestDistance
		
	end
	
	return closestClusterVector, shortestDistanceVector
	
end

return OrderingPointsToIdentifyClusteringStructureModel]]></ProtectedString>
									<string name="ScriptGuid">{BA0B38FC-3382-4359-A443-44E0079CF0FC}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">OrderingPointsToIdentifyClusteringStructure</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2C09B11B228E427E8689B21446FE345F">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

FuzzyCMeansModel = {}

FuzzyCMeansModel.__index = FuzzyCMeansModel

setmetatable(FuzzyCMeansModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultNumberOfClusters = 1

local defaultFuzziness = 2

local defaultDistanceFunction = "Euclidean"

local defaultMode = "Hybrid"

local defaultSetInitialCentroidsOnDataPoints = true

local defaultSetTheCentroidsDistanceFarthest = true

local defaultEpsilon = 1e-16

local function assignToCluster(distanceMatrix) -- Number of columns -> number of clusters
	
	local numberOfDistances = #distanceMatrix
	
	local clusterNumberVector = AqwamTensorLibrary:createTensor({numberOfDistances, 1})

	local clusterDistanceVector = AqwamTensorLibrary:createTensor({numberOfDistances, 1}) 

	for dataIndex, distanceVector in ipairs(distanceMatrix) do

		local closestClusterNumber

		local shortestDistance = math.huge

		for i, distance in ipairs(distanceVector) do

			if (distance < shortestDistance) then

				closestClusterNumber = i

				shortestDistance = distance

			end

		end

		clusterNumberVector[dataIndex][1] = closestClusterNumber

		clusterDistanceVector[dataIndex][1] = shortestDistance

	end

	return clusterNumberVector, clusterDistanceVector
	
end

local function createDistanceMatrix(distanceFunction, matrix1, matrix2)

	local numberOfData1 = #matrix1

	local numberOfData2 = #matrix2

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData1, numberOfData2})

	for matrix1Index = 1, numberOfData1, 1 do

		for matrix2Index = 1, numberOfData2, 1 do

			distanceMatrix[matrix1Index][matrix2Index] = distanceFunction({matrix1[matrix1Index]}, {matrix2[matrix2Index]})

		end

	end

	return distanceMatrix

end

local function chooseFarthestCentroidFromDatasetDistanceMatrix(distanceMatrix, blacklistedDataIndexArray)

	local dataIndex

	local maxDistance = -math.huge

	for row = 1, #distanceMatrix, 1 do

		if (not table.find(blacklistedDataIndexArray, row)) then

			local totalDistance = 0

			for column = 1, #distanceMatrix[1], 1 do totalDistance = totalDistance + distanceMatrix[row][column] end

			if (totalDistance > maxDistance) then

				maxDistance = totalDistance

				dataIndex = row

			end

		end

	end

	return dataIndex

end

local function chooseFarthestCentroids(featureMatrix, numberOfClusters, distanceFunction)
	
	local centroidMatrix = {}
	
	local dataIndexArray = {}
	
	local dataIndex
	
	local distanceMatrix = createDistanceMatrix(distanceFunction, featureMatrix, featureMatrix)
	
	repeat
		
		dataIndex = chooseFarthestCentroidFromDatasetDistanceMatrix(distanceMatrix, dataIndexArray)
		
		table.insert(dataIndexArray, dataIndex)
		
	until (#dataIndexArray == numberOfClusters)
	
	for row = 1, numberOfClusters, 1 do
		
		dataIndex = dataIndexArray[row]
		
		table.insert(centroidMatrix, featureMatrix[dataIndex])
		
	end
	
	return centroidMatrix
	
end

local function chooseRandomCentroids(featureMatrix, numberOfClusters)

	local modelParameters = {}

	local numberOfRows = #featureMatrix

	local randomRow

	local selectedRows = {}

	local hasANewRandomRowChosen

	for cluster = 1, numberOfClusters, 1 do

		repeat

			randomRow = Random.new():NextInteger(1, numberOfRows)

			hasANewRandomRowChosen = not (table.find(selectedRows, randomRow))

			if hasANewRandomRowChosen then

				table.insert(selectedRows, randomRow)
				modelParameters[cluster] = featureMatrix[randomRow]

			end

		until hasANewRandomRowChosen

	end

	return modelParameters

end

local function calculateCost(distanceMatrix, clusterMembershipMatrix)
	
	local costMatrix = AqwamTensorLibrary:multiply(distanceMatrix, clusterMembershipMatrix)
	
	local cost = AqwamTensorLibrary:sum(costMatrix)
	
	return cost
	
end

function FuzzyCMeansModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations
	
	local NewFuzzyCMeansModel = IterativeMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewFuzzyCMeansModel, FuzzyCMeansModel)
	
	NewFuzzyCMeansModel:setName("FuzzyCMeans")

	NewFuzzyCMeansModel.numberOfClusters = parameterDictionary.numberOfClusters or defaultNumberOfClusters
	
	NewFuzzyCMeansModel.fuzziness = NewFuzzyCMeansModel:getValueOrDefaultValue(parameterDictionary.fuzziness, defaultFuzziness)
	
	NewFuzzyCMeansModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction

	NewFuzzyCMeansModel.mode = parameterDictionary.mode or defaultMode

	NewFuzzyCMeansModel.setInitialCentroidsOnDataPoints =  NewFuzzyCMeansModel:getValueOrDefaultValue(parameterDictionary.setInitialCentroidsOnDataPoints, defaultSetInitialCentroidsOnDataPoints)
	
	NewFuzzyCMeansModel.setTheCentroidsDistanceFarthest = NewFuzzyCMeansModel:getValueOrDefaultValue(parameterDictionary.setTheCentroidsDistanceFarthest, defaultSetTheCentroidsDistanceFarthest)
	
	NewFuzzyCMeansModel.epsilon = NewFuzzyCMeansModel:getValueOrDefaultValue(parameterDictionary.epsilon, defaultEpsilon)
	
	return NewFuzzyCMeansModel
	
end

function FuzzyCMeansModel:initializeCentroids(featureMatrix, numberOfClusters, distanceFunction)
	
	local setInitialCentroidsOnDataPoints = self.setInitialCentroidsOnDataPoints
	
	local setTheCentroidsDistanceFarthest = self.setTheCentroidsDistanceFarthest
	
	if (setInitialCentroidsOnDataPoints) and (numberOfClusters == 1) then
		
		return AqwamTensorLibrary:mean(featureMatrix, 1)
	
	elseif (setInitialCentroidsOnDataPoints) and (setTheCentroidsDistanceFarthest) and (#featureMatrix >= numberOfClusters) then

		return chooseFarthestCentroids(featureMatrix, numberOfClusters, distanceFunction)

	elseif (setInitialCentroidsOnDataPoints) and (not setTheCentroidsDistanceFarthest) then

		return chooseRandomCentroids(featureMatrix, numberOfClusters)

	else

		return self:initializeMatrixBasedOnMode({numberOfClusters, #featureMatrix[1]})

	end
	
end

local function calculateMembershipMatrix(distanceMatrix, fuzziness, epsilon)
	
	local numberOfData = #distanceMatrix
	
	local numberOfClusters = #distanceMatrix[1]
	
	local membershipMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfClusters}, 0)
	
	local ratioPowerConstant = 2 / (fuzziness - 1)
	
	for dataIndex, unwrappedDistanceVector in ipairs(distanceMatrix) do
		
		for i = 1, numberOfClusters do

			local denominator = 0
			
			local distanceI = unwrappedDistanceVector[i]

			for j = 1, numberOfClusters do
				
				local distanceJ = unwrappedDistanceVector[j]
				
				if (distanceJ ~= 0) then
					
					local ratio = distanceI / distanceJ
					
					denominator = denominator + (ratio ^ ratioPowerConstant)
					
				end

			end

			membershipMatrix[dataIndex][i] = 1 / (denominator + epsilon)

		end
		
	end

	return membershipMatrix
end

local function calculateMean(featureMatrix, centroidMatrix, clusterMembershipMatrix, fuzziness, epsilon)

	local numberOfData = #featureMatrix

	local numberOfCentroids = #centroidMatrix

	local numberOfFeatures = #centroidMatrix[1]

	local sumOfAssignedCentroidVector = AqwamTensorLibrary:sum(clusterMembershipMatrix, 1) -- since row is the number of data in clusterAssignmentMatrix, then we vertical sum it

	local newCentroidMatrix = AqwamTensorLibrary:createTensor({numberOfCentroids, numberOfFeatures})

	for cluster = 1, numberOfCentroids, 1 do

		local numeratorVector = AqwamTensorLibrary:createTensor({1, numberOfFeatures}, 0)

		local denominator = 0

		for dataIndex, unwrappedDataVector in ipairs(featureMatrix) do

			local membershipValue = clusterMembershipMatrix[dataIndex][cluster]^fuzziness

			local multipliedMembershipValue = AqwamTensorLibrary:multiply({unwrappedDataVector}, membershipValue)

			numeratorVector = AqwamTensorLibrary:add(numeratorVector, multipliedMembershipValue)

			denominator = denominator + membershipValue

		end

		local newCentroidVector = AqwamTensorLibrary:divide(numeratorVector, (denominator + epsilon))

		newCentroidMatrix[cluster] = newCentroidVector[1]

	end

	return newCentroidMatrix

end

local function calculateMatrices(featureMatrix, centroidMatrix, distanceMatrix, fuzziness, epsilon)

	local clusterMembershipMatrix = calculateMembershipMatrix(distanceMatrix, fuzziness, epsilon)
	
	centroidMatrix = calculateMean(featureMatrix, centroidMatrix, clusterMembershipMatrix, fuzziness, epsilon)
	
	return centroidMatrix, clusterMembershipMatrix
	
end

function FuzzyCMeansModel:train(featureMatrix)
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local numberOfClusters = self.numberOfClusters
	
	local fuzziness = self.fuzziness
	
	local distanceFunction = self.distanceFunction
	
	local mode = self.mode
	
	local epsilon = self.epsilon
	
	local centroidMatrix = self.ModelParameters

	if (mode == "Hybrid") then -- This must be always above the centroid initialization check. Otherwise it will think this is second training round despite it being the first one!
		
		mode = (centroidMatrix and "Online") or "Offline"

	end
	
	local distanceFunctionToApply = distanceFunctionDictionary[distanceFunction]

	if (not distanceFunctionToApply) then error("Unknown distance function.") end
	
	if (mode == "Offline") then centroidMatrix = nil end
	
	if (centroidMatrix) then
		
		if (#featureMatrix[1] ~= #centroidMatrix[1]) then error("The number of features are not the same as the model parameters.") end
		
	else
		
		centroidMatrix = self:initializeCentroids(featureMatrix, numberOfClusters, distanceFunctionToApply)
		
	end

	local numberOfIterations = 0
	
	local costArray = {}
	
	local clusterMembershipMatrix

	local distanceMatrix
	
	local cost
	
	repeat
		
		numberOfIterations = numberOfIterations + 1
		
		self:iterationWait()
		
		distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, centroidMatrix)

		centroidMatrix, clusterMembershipMatrix = calculateMatrices(featureMatrix, centroidMatrix, distanceMatrix, fuzziness, epsilon)
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return calculateCost(distanceMatrix, clusterMembershipMatrix)

		end)
		
		if (cost) then

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end
		
	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	self.ModelParameters = centroidMatrix
	
	return costArray
	
end

function FuzzyCMeansModel:predict(featureMatrix, returnMode)
	
	local distanceFunctionToApply = distanceFunctionDictionary[self.distanceFunction]
	
	local centroidMatrix = self.ModelParameters
	
	if (not centroidMatrix) then

		centroidMatrix = self:initializeCentroids(featureMatrix, self.numberOfClusters, distanceFunctionToApply)

		self.ModelParameters = centroidMatrix

	end
	
	local distanceMatrix = createDistanceMatrix(distanceFunctionToApply, featureMatrix, centroidMatrix)
	
	local returnType = type(returnMode)

	local isNotNil = (returnType ~= "nil")
	
	if (isNotNil) then
		
		local isBoolean = (returnType == "boolean")
		
		if (returnMode == "Distance") or (isBoolean and returnMode) then
			
			return distanceMatrix
		
		elseif (returnMode == "Membership") then
			
			return calculateMembershipMatrix(distanceMatrix, self.fuzziness, self.epsilon)
			
		else
			
			error("Unknown return mode value.")
			
		end
		
	end
	
	local clusterNumberVector, clusterDistanceVector = assignToCluster(distanceMatrix)

	return clusterNumberVector, clusterDistanceVector
	
end

return FuzzyCMeansModel]]></ProtectedString>
									<string name="ScriptGuid">{C01C70E9-3515-47EA-BC1B-9A78D106A8AD}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">FuzzyCMeans</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX990D72E1C5CE4B758BCFFA43F7E610A1">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Regression, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GradientMethodBaseModel = require(script.Parent.GradientMethodBaseModel)

SupportVectorRegressionGradientVariantModel = {}

SupportVectorRegressionGradientVariantModel.__index = SupportVectorRegressionGradientVariantModel

setmetatable(SupportVectorRegressionGradientVariantModel, GradientMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultLearningRate = 0.3

local defaultCValue = 1

local defaultEpsilon = 1

function SupportVectorRegressionGradientVariantModel:calculateCost(hypothesisVector, labelVector)

	if (type(hypothesisVector) == "number") then hypothesisVector = {{hypothesisVector}} end
	
	local epsilon = self.epsilon
	
	local errorVector = AqwamTensorLibrary:subtract(hypothesisVector, labelVector)
	
	local positiveSlackVariableVector = AqwamTensorLibrary:applyFunction(function(errorValue) return math.max(0, errorValue - epsilon) end, errorVector)

	local negativeSlackVariableVector = AqwamTensorLibrary:applyFunction(function(errorValue) return math.max(0, -errorValue - epsilon) end, errorVector)

	local slackVariableVector = AqwamTensorLibrary:add(positiveSlackVariableVector, negativeSlackVariableVector)

	local totalCost = AqwamTensorLibrary:sum(slackVariableVector)
	
	local Regularizer = self.Regularizer

	if (Regularizer) then totalCost = totalCost + Regularizer:calculateCost(self.ModelParameters) end

	local averageCost = (self.cValue * totalCost) / #labelVector

	return averageCost

end

function SupportVectorRegressionGradientVariantModel:calculateHypothesisVector(featureMatrix, saveFeatureMatrix)

	local hypothesisVector = AqwamTensorLibrary:dotProduct(featureMatrix, self.ModelParameters)

	if (saveFeatureMatrix) then self.featureMatrix = featureMatrix end

	return hypothesisVector

end

function SupportVectorRegressionGradientVariantModel:calculateCostFunctionDerivativeMatrix(lossMatrix)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local featureMatrix = self.featureMatrix

	if (not featureMatrix) then error("Feature matrix not found.") end

	local costFunctionDerivativeMatrix = AqwamTensorLibrary:dotProduct(AqwamTensorLibrary:transpose(featureMatrix), lossMatrix)

	if (self.areGradientsSaved) then self.costFunctionDerivativeMatrix = costFunctionDerivativeMatrix end

	return costFunctionDerivativeMatrix

end

function SupportVectorRegressionGradientVariantModel:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (type(costFunctionDerivativeMatrix) == "number") then costFunctionDerivativeMatrix = {{costFunctionDerivativeMatrix}} end
	
	local ModelParameters = self.ModelParameters
	
	local Regularizer = self.Regularizer
	
	local Optimizer = self.Optimizer
	
	local learningRate = self.learningRate

	if (Regularizer) then

		local regularizationDerivatives = Regularizer:calculate(ModelParameters)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:add(costFunctionDerivativeMatrix, regularizationDerivatives)

	end

	costFunctionDerivativeMatrix = AqwamTensorLibrary:divide(costFunctionDerivativeMatrix, numberOfData)

	if (Optimizer) then 

		costFunctionDerivativeMatrix = Optimizer:calculate(learningRate, costFunctionDerivativeMatrix, ModelParameters) 

	else

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrix)

	end

	self.ModelParameters = AqwamTensorLibrary:subtract(ModelParameters, costFunctionDerivativeMatrix)

end

function SupportVectorRegressionGradientVariantModel:update(lossMatrix, clearAllMatrices)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local numberOfData = #lossMatrix

	local costFunctionDerivativeMatrix = self:calculateCostFunctionDerivativeMatrix(lossMatrix)

	self:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (clearAllMatrices) then 

		self.featureMatrix = nil 

		self.costFunctionDerivativeMatrix = nil

	end

end

function SupportVectorRegressionGradientVariantModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewSupportVectorRegressionGradientVariantModel = GradientMethodBaseModel.new(parameterDictionary)

	setmetatable(NewSupportVectorRegressionGradientVariantModel, SupportVectorRegressionGradientVariantModel)
	
	NewSupportVectorRegressionGradientVariantModel:setName("SupportVectorRegressionGradientVariant")

	NewSupportVectorRegressionGradientVariantModel.learningRate = parameterDictionary.learningRate or defaultLearningRate
	
	NewSupportVectorRegressionGradientVariantModel.cValue = parameterDictionary.cValue or defaultCValue
	
	NewSupportVectorRegressionGradientVariantModel.epsilon = parameterDictionary.epsilon or defaultEpsilon

	NewSupportVectorRegressionGradientVariantModel.Optimizer = parameterDictionary.Optimizer

	NewSupportVectorRegressionGradientVariantModel.Regularizer = parameterDictionary.Regularizer

	return NewSupportVectorRegressionGradientVariantModel

end

function SupportVectorRegressionGradientVariantModel:setOptimizer(Optimizer)

	self.Optimizer = Optimizer

end

function SupportVectorRegressionGradientVariantModel:setRegularizer(Regularizer)

	self.Regularizer = Regularizer

end

function SupportVectorRegressionGradientVariantModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (#featureMatrix[1] ~= #ModelParameters) then error("The number of features are not the same as the model parameters.") end

	else

		self.ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local cValue = self.cValue
	
	local epsilon = self.epsilon

	local Optimizer = self.Optimizer
	
	local functionToApply = function(errorValue) return ((errorValue > epsilon) and (errorValue - epsilon)) or ((errorValue < -epsilon) and (errorValue + epsilon)) or 0 end

	local costArray = {}

	local numberOfIterations = 0
	
	local cost

	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		local hypothesisVector = self:calculateHypothesisVector(featureMatrix, true)

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return self:calculateCost(hypothesisVector, labelVector)

		end)

		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end
		
		local errorVector = AqwamTensorLibrary:subtract(hypothesisVector, labelVector)

		local lossVector = AqwamTensorLibrary:applyFunction(functionToApply, errorVector)
		
		lossVector = AqwamTensorLibrary:multiply(cValue, lossVector)

		self:update(lossVector, true)

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	if (Optimizer) and (self.autoResetOptimizers) then Optimizer:reset() end

	return costArray

end

function SupportVectorRegressionGradientVariantModel:predict(featureMatrix)
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then
		
		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})
		
		self.ModelParameters = ModelParameters
		
	end

	local predictedVector = AqwamTensorLibrary:dotProduct(featureMatrix, ModelParameters)

	return predictedVector

end

return SupportVectorRegressionGradientVariantModel]]></ProtectedString>
									<string name="ScriptGuid">{CD58C2F0-1275-4423-92D1-33463DFCA404}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">SupportVectorRegressionGradientVariant</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX82A2AED8DA1F4FBF99DE02AB6F50E346">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

PassiveAggressiveClassifierModel = {}

PassiveAggressiveClassifierModel.__index = PassiveAggressiveClassifierModel

setmetatable(PassiveAggressiveClassifierModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultVariant = "0"

local defaultCValue = 1

local cutOffFunction = function (x) 

	return ((x > 0) and 1) or ((x < 0) and -1) or 0

end

local tauFunctionList = {

	["0"] = function(lossValue, dotProductFeatureVectorValue, cValue)

		return (lossValue / dotProductFeatureVectorValue)

	end,

	["1"] = function(lossValue, dotProductFeatureVectorValue, cValue)

		return math.min(cValue, (lossValue / dotProductFeatureVectorValue))

	end,

	["2"] = function(lossValue, dotProductFeatureVectorValue, cValue)

		local denominatorValuePart1 = 1 / (2 * cValue)

		return (lossValue / (dotProductFeatureVectorValue + denominatorValuePart1))

	end,

}

function PassiveAggressiveClassifierModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewPassiveAggressiveClassifierModel = IterativeMethodBaseModel.new(parameterDictionary)

	setmetatable(NewPassiveAggressiveClassifierModel, PassiveAggressiveClassifierModel)
	
	NewPassiveAggressiveClassifierModel:setName("PassiveAggressiveClassifier")
	
	NewPassiveAggressiveClassifierModel.variant = parameterDictionary.variant or defaultVariant

	NewPassiveAggressiveClassifierModel.cValue = parameterDictionary.cValue or defaultCValue

	return NewPassiveAggressiveClassifierModel

end

function PassiveAggressiveClassifierModel:train(featureMatrix, labelVector)
	
	local numberOfData = #featureMatrix
	
	if (numberOfData ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (#featureMatrix[1] ~= #ModelParameters) then error("The number of features are not the same as the model parameters.") end

	else

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

	end
	
	local tauFunction = tauFunctionList[self.variant]
	
	if (not tauFunction) then error("Unknown variant.") end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local cValue = self.cValue
	
	local costArray = {}
	
	local numberOfIterations = 0
	
	local totalLoss
	
	local featureVector
	
	local labelValue
	
	local predictedLabelValue
	
	local lossValue
	
	local transposedFeatureVector
	
	local dotProductFeatureVectorValue
	
	local tau
	
	local weightChangeVector
	
	local cost
	
	repeat
		
		numberOfIterations = numberOfIterations + 1
		
		self:iterationWait()
		
		totalLoss = 0
		
		for dataIndex, unwrappedFeatureVector in ipairs(featureMatrix) do

			featureVector = {unwrappedFeatureVector}

			labelValue = labelVector[dataIndex][1]

			predictedLabelValue = AqwamTensorLibrary:dotProduct(featureVector, ModelParameters)[1][1]

			transposedFeatureVector = AqwamTensorLibrary:transpose(featureVector)

			dotProductFeatureVectorValue = AqwamTensorLibrary:dotProduct(featureVector, transposedFeatureVector)[1][1]

			lossValue = math.max(0, 1 - (labelValue * predictedLabelValue))

			tau = tauFunction(lossValue, dotProductFeatureVectorValue, cValue)

			weightChangeVector = AqwamTensorLibrary:multiply((tau * labelValue), transposedFeatureVector)

			ModelParameters = AqwamTensorLibrary:add(ModelParameters, weightChangeVector)

			totalLoss = totalLoss + lossValue

		end
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return (totalLoss / numberOfData)

		end)
		
		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end
		
	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end
	
	self.ModelParameters = ModelParameters
	
	return costArray

end

function PassiveAggressiveClassifierModel:predict(featureMatrix, returnOriginalOutput)
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

		self.ModelParameters = ModelParameters

	end
	
	local outputVector = AqwamTensorLibrary:dotProduct(featureMatrix, ModelParameters)

	if (returnOriginalOutput) then return outputVector end

	local predictedLabelVector = AqwamTensorLibrary:applyFunction(cutOffFunction, outputVector)

	return predictedLabelVector, outputVector

end

return PassiveAggressiveClassifierModel]]></ProtectedString>
									<string name="ScriptGuid">{84F0B874-4BD7-4B27-8B30-6B329B9ED27E}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">PassiveAggressiveClassifier</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX94D6AB4A1CE94750A70B2BC50FDADF10">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

PassiveAggressiveRegressorModel = {}

PassiveAggressiveRegressorModel.__index = PassiveAggressiveRegressorModel

setmetatable(PassiveAggressiveRegressorModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultVariant = "0"

local defaultEpsilon = 0

local defaultCValue = 1

local tauFunctionList = {

	["0"] = function(lossValue, dotProductFeatureVectorValue, cValue)

		return (lossValue / dotProductFeatureVectorValue)

	end,

	["1"] = function(lossValue, dotProductFeatureVectorValue, cValue)

		return math.min(cValue, (lossValue / dotProductFeatureVectorValue))

	end,

	["2"] = function(lossValue, dotProductFeatureVectorValue, cValue)

		local denominatorValuePart1 = 1 / (2 * cValue)

		return (lossValue / (dotProductFeatureVectorValue + denominatorValuePart1))

	end,

}

function PassiveAggressiveRegressorModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewPassiveAggressiveRegressorModel = IterativeMethodBaseModel.new(parameterDictionary)

	setmetatable(NewPassiveAggressiveRegressorModel, PassiveAggressiveRegressorModel)

	NewPassiveAggressiveRegressorModel:setName("PassiveAggressiveRegressor")

	NewPassiveAggressiveRegressorModel.variant = parameterDictionary.variant or defaultVariant
	
	NewPassiveAggressiveRegressorModel.epsilon = parameterDictionary.epsilon or defaultEpsilon

	NewPassiveAggressiveRegressorModel.cValue = parameterDictionary.cValue or defaultCValue

	return NewPassiveAggressiveRegressorModel

end

function PassiveAggressiveRegressorModel:train(featureMatrix, labelVector)
	
	local numberOfData = #featureMatrix

	if (numberOfData ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (#featureMatrix[1] ~= #ModelParameters) then error("The number of features are not the same as the model parameters.") end

	else

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

	end

	local tauFunction = tauFunctionList[self.variant]

	if (not tauFunction) then error("Unknown variant.") end

	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local epsilon = self.epsilon

	local cValue = self.cValue

	local costArray = {}
	
	local numberOfIterations = 0

	local totalLoss

	local featureVector

	local labelValue

	local predictedLabelValue

	local lossValue

	local transposedFeatureVector

	local dotProductFeatureVectorValue
	
	local differenceValue

	local tau

	local weightChangeVector

	local cost
	
	repeat
		
		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		totalLoss = 0
		
		for dataIndex, unwrappedFeatureVector in ipairs(featureMatrix) do

			featureVector = {unwrappedFeatureVector}

			labelValue = labelVector[dataIndex][1]

			predictedLabelValue = AqwamTensorLibrary:dotProduct(featureVector, ModelParameters)[1][1]

			transposedFeatureVector = AqwamTensorLibrary:transpose(featureVector)

			dotProductFeatureVectorValue = AqwamTensorLibrary:dotProduct(featureVector, transposedFeatureVector)[1][1]

			differenceValue = labelValue - predictedLabelValue

			lossValue = math.max(0, (math.abs(differenceValue) - epsilon))

			tau = tauFunction(lossValue, dotProductFeatureVectorValue, cValue)

			weightChangeVector = AqwamTensorLibrary:multiply((tau * math.sign(differenceValue)), transposedFeatureVector)

			ModelParameters = AqwamTensorLibrary:add(ModelParameters, weightChangeVector)

			totalLoss = totalLoss + lossValue

		end
		
		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return (totalLoss / numberOfData)

		end)
		
		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end
		
	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	self.ModelParameters = ModelParameters

	return costArray

end

function PassiveAggressiveRegressorModel:predict(featureMatrix)

	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

		self.ModelParameters = ModelParameters

	end

	local outputVector = AqwamTensorLibrary:dotProduct(featureMatrix, ModelParameters)

	if (type(outputVector) ~= "table") then outputVector = {{outputVector}} end

	return outputVector

end

return PassiveAggressiveRegressorModel]]></ProtectedString>
									<string name="ScriptGuid">{7FA9CE50-0A1E-4706-889D-BE97C4B37D0B}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">PassiveAggressiveRegressor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX426CADEA19004BA0A1F25D0C420A247E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local IterativeMethodBaseModel = require(script.Parent.IterativeMethodBaseModel)

OneClassPassiveAggressiveClassifierModel = {}

OneClassPassiveAggressiveClassifierModel.__index = OneClassPassiveAggressiveClassifierModel

setmetatable(OneClassPassiveAggressiveClassifierModel, IterativeMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultVariant = "0"

local defaultEpsilon = 0

local defaultCValue = 1

local cutOffFunction = function (x) 

	return ((x > 0) and 1) or ((x < 0) and -1) or 0

end

local tauFunctionList = {

	["0"] = function(lossValue, dotProductFeatureVectorValue, cValue)

		return (lossValue / dotProductFeatureVectorValue)

	end,

	["1"] = function(lossValue, dotProductFeatureVectorValue, cValue)

		return math.min(cValue, (lossValue / dotProductFeatureVectorValue))

	end,

	["2"] = function(lossValue, dotProductFeatureVectorValue, cValue)

		local denominatorValuePart1 = 1 / (2 * cValue)

		return (lossValue / (dotProductFeatureVectorValue + denominatorValuePart1))

	end,

}

function OneClassPassiveAggressiveClassifierModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewOneClassPassiveAggressiveClassifierModel = IterativeMethodBaseModel.new(parameterDictionary)

	setmetatable(NewOneClassPassiveAggressiveClassifierModel, OneClassPassiveAggressiveClassifierModel)

	NewOneClassPassiveAggressiveClassifierModel:setName("OneClassPassiveAggressiveClassifier")

	NewOneClassPassiveAggressiveClassifierModel.variant = parameterDictionary.variant or defaultVariant
	
	NewOneClassPassiveAggressiveClassifierModel.epsilon = parameterDictionary.epsilon or defaultEpsilon

	NewOneClassPassiveAggressiveClassifierModel.cValue = parameterDictionary.cValue or defaultCValue

	return NewOneClassPassiveAggressiveClassifierModel

end

function OneClassPassiveAggressiveClassifierModel:train(featureMatrix, labelVector)
	
	local numberOfData = #featureMatrix
	
	if (labelVector) then
		
		if (numberOfData ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
		
	else
		
		labelVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 1)
		
	end
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (#featureMatrix[1] ~= #ModelParameters) then error("The number of features are not the same as the model parameters.") end

	else

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

	end

	local tauFunction = tauFunctionList[self.variant]

	if (not tauFunction) then error("Unknown variant.") end

	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local epsilon = self.epsilon

	local cValue = self.cValue

	local costArray = {}
	
	local numberOfIterations = 0

	local totalLoss

	local featureVector

	local labelValue

	local predictedLabelValue

	local lossValue

	local transposedFeatureVector

	local dotProductFeatureVectorValue
	
	local labelValueSubtractedByWeightVector
	
	local transposedLabelValueSubtractedByWeightVector
	
	local dotProductLabelValueSubtractedByWeightVector
	
	local differenceValue

	local tau
	
	local weightChangeVectorPart1

	local weightChangeVector

	local cost
	
	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		totalLoss = 0
		
		for dataIndex, unwrappedFeatureVector in ipairs(featureMatrix) do
			
			featureVector = {unwrappedFeatureVector}

			labelValue = labelVector[dataIndex][1]

			predictedLabelValue = AqwamTensorLibrary:dotProduct(featureVector, ModelParameters)[1][1]

			transposedFeatureVector = AqwamTensorLibrary:transpose(featureVector)

			dotProductFeatureVectorValue = AqwamTensorLibrary:dotProduct(featureVector, transposedFeatureVector)[1][1]

			labelValueSubtractedByWeightVector = AqwamTensorLibrary:subtract(labelValue, ModelParameters)

			transposedLabelValueSubtractedByWeightVector = AqwamTensorLibrary:transpose(labelValueSubtractedByWeightVector)

			dotProductLabelValueSubtractedByWeightVector = AqwamTensorLibrary:dotProduct(transposedLabelValueSubtractedByWeightVector, labelValueSubtractedByWeightVector)

			differenceValue = labelValue - predictedLabelValue

			lossValue = math.max(0, (math.abs(differenceValue) - epsilon))

			tau = tauFunction(lossValue, dotProductFeatureVectorValue, cValue)

			weightChangeVectorPart1 = AqwamTensorLibrary:divide(labelValueSubtractedByWeightVector, dotProductLabelValueSubtractedByWeightVector)

			weightChangeVector = AqwamTensorLibrary:multiply(tau, weightChangeVectorPart1)

			ModelParameters = AqwamTensorLibrary:add(ModelParameters, weightChangeVector)

			totalLoss = totalLoss + lossValue
			
		end

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return (totalLoss / numberOfData)

		end)

		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end
		
	until (numberOfIterations >= maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	self.ModelParameters = ModelParameters

	return costArray

end

function OneClassPassiveAggressiveClassifierModel:predict(featureMatrix, returnOriginalOutput)

	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then

		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], 1})

		self.ModelParameters = ModelParameters

	end

	local outputVector = AqwamTensorLibrary:dotProduct(featureMatrix, ModelParameters)
	
	if (returnOriginalOutput) then return outputVector end

	local predictedLabelVector = AqwamTensorLibrary:applyFunction(cutOffFunction, outputVector)

	return predictedLabelVector, outputVector

end

return OneClassPassiveAggressiveClassifierModel]]></ProtectedString>
									<string name="ScriptGuid">{7F54B6B1-584F-4E6E-9763-AA3003B78514}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">OneClassPassiveAggressiveClassifier</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX531E0FCFCE644ABDB728FAB7CCE624D6">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularDoubleQLearningModel = {}

TabularDoubleQLearningModel.__index = TabularDoubleQLearningModel

setmetatable(TabularDoubleQLearningModel, TabularReinforcementLearningBaseModel)

local defaultAveragingRate = 0.01

function TabularDoubleQLearningModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularDoubleQLearningModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularDoubleQLearningModel, TabularDoubleQLearningModel)
	
	NewTabularDoubleQLearningModel:setName("TabularDoubleQLearningV2")
	
	NewTabularDoubleQLearningModel.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate
	
	NewTabularDoubleQLearningModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewTabularDoubleQLearningModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local averagingRate = NewTabularDoubleQLearningModel.averagingRate
		
		local learningRate = NewTabularDoubleQLearningModel.learningRate
		
		local discountFactor = NewTabularDoubleQLearningModel.discountFactor
		
		local EligibilityTrace = NewTabularDoubleQLearningModel.EligibilityTrace
		
		local Optimizer = NewTabularDoubleQLearningModel.Optimizer

		local ModelParameters = NewTabularDoubleQLearningModel.ModelParameters
		
		local StatesList = NewTabularDoubleQLearningModel:getStatesList()

		local ActionsList = NewTabularDoubleQLearningModel:getActionsList()
		
		local averagingRateComplement = 1 - averagingRate

		local _, maxQValue = NewTabularDoubleQLearningModel:predict({{currentStateValue}})

		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * maxQValue[1][1])
		
		local stateIndex = table.find(StatesList, previousStateValue)

		local actionIndex = table.find(ActionsList, action)

		local lastValue = ModelParameters[stateIndex][actionIndex]

		local temporalDifferenceError = targetValue - lastValue
		
		if (EligibilityTrace) then
			
			local numberOfStates = #StatesList

			local numberOfActions = #ActionsList
			
			local dimensionSizeArray = {numberOfStates, numberOfActions}
			
			local temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)
			
			temporalDifferenceErrorMatrix[stateIndex][actionIndex] = temporalDifferenceError

			EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray)

			temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix)
			
			temporalDifferenceError = temporalDifferenceErrorMatrix[stateIndex][actionIndex]

		end
		
		local gradientValue = temporalDifferenceError

		if (Optimizer) then

			gradientValue = Optimizer:calculate(learningRate, {{gradientValue}})

			gradientValue = gradientValue[1][1]

		else

			gradientValue = learningRate * gradientValue

		end
		
		local weightValue = ModelParameters[stateIndex][actionIndex]
		
		local newWeightValue = weightValue + gradientValue
		
		ModelParameters[stateIndex][actionIndex] = (averagingRate * weightValue) + (averagingRateComplement * newWeightValue)
		
		return temporalDifferenceError

	end)
	
	NewTabularDoubleQLearningModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewTabularDoubleQLearningModel.EligibilityTrace
		
		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularDoubleQLearningModel:setResetFunction(function()
		
		local EligibilityTrace = NewTabularDoubleQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularDoubleQLearningModel

end

return TabularDoubleQLearningModel]]></ProtectedString>
									<string name="ScriptGuid">{BDA76BE2-707E-470B-B821-F90B580BF382}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularDoubleQLearningV2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6BFF04EBE8FA48AE96C58C3DB787EEE2">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularDoubleStateActionRewardStateActionModel = {}

TabularDoubleStateActionRewardStateActionModel.__index = TabularDoubleStateActionRewardStateActionModel

setmetatable(TabularDoubleStateActionRewardStateActionModel, TabularReinforcementLearningBaseModel)

local defaultAveragingRate = 0.01

function TabularDoubleStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularDoubleStateActionRewardStateActionModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularDoubleStateActionRewardStateActionModel, TabularDoubleStateActionRewardStateActionModel)
	
	NewTabularDoubleStateActionRewardStateActionModel:setName("TabularDoubleStateActionRewardStateActionV2")
	
	NewTabularDoubleStateActionRewardStateActionModel.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate
	
	NewTabularDoubleStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewTabularDoubleStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local averagingRate = NewTabularDoubleStateActionRewardStateActionModel.averagingRate
		
		local learningRate = NewTabularDoubleStateActionRewardStateActionModel.learningRate
		
		local discountFactor = NewTabularDoubleStateActionRewardStateActionModel.discountFactor
		
		local EligibilityTrace = NewTabularDoubleStateActionRewardStateActionModel.EligibilityTrace
		
		local Optimizer = NewTabularDoubleStateActionRewardStateActionModel.Optimizer
		
		local ModelParameters = NewTabularDoubleStateActionRewardStateActionModel.ModelParameters
		
		local StatesList = NewTabularDoubleStateActionRewardStateActionModel:getStatesList()
		
		local previousQVector = NewTabularDoubleStateActionRewardStateActionModel:predict({{previousStateValue}}, true)

		local currentQVector = NewTabularDoubleStateActionRewardStateActionModel:predict({{currentStateValue}}, true)

		local discountedQVector = AqwamTensorLibrary:multiply(discountFactor, currentQVector, (1 - terminalStateValue))

		local targetVector = AqwamTensorLibrary:add(rewardValue, discountedQVector)
		
		local stateIndex = table.find(StatesList, previousStateValue)

		local temporalDifferenceErrorVector = AqwamTensorLibrary:subtract(targetVector, previousQVector)
		
		local averagingRateComplement = 1 - averagingRate
		
		if (EligibilityTrace) then
			
			local ActionsList = NewTabularDoubleStateActionRewardStateActionModel:getActionsList()

			local numberOfStates = #StatesList
			
			local numberOfActions = #ActionsList
			
			local actionIndex = table.find(ActionsList, action)

			local dimensionSizeArray = {numberOfStates, numberOfActions}

			local temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)

			temporalDifferenceErrorMatrix[stateIndex] = temporalDifferenceErrorVector[1]

			EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray)

			temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix)

			temporalDifferenceErrorVector = {temporalDifferenceErrorMatrix[stateIndex]}

		end
		
		local gradientTensor = temporalDifferenceErrorVector
		
		if (Optimizer) then
			
			gradientTensor = Optimizer:calculate(learningRate, gradientTensor)
			
		else
			
			gradientTensor = AqwamTensorLibrary:multiply(learningRate, gradientTensor)
			
		end
		
		local weightVector = {ModelParameters[stateIndex]}
		
		local targetVector = AqwamTensorLibrary:add(weightVector, gradientTensor)
		
		local multipliedPrimaryVector = AqwamTensorLibrary:multiply(averagingRate, weightVector)
		
		local multipliedTargetVector = AqwamTensorLibrary:multiply(averagingRateComplement, targetVector)
		
		ModelParameters[stateIndex] = AqwamTensorLibrary:add(multipliedPrimaryVector, multipliedTargetVector)[1]
		
		return temporalDifferenceErrorVector

	end)
	
	NewTabularDoubleStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewTabularDoubleStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularDoubleStateActionRewardStateActionModel:setResetFunction(function()
		
		local EligibilityTrace = NewTabularDoubleStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularDoubleStateActionRewardStateActionModel

end

return TabularDoubleStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{1909B143-B92D-4D30-A3FE-2C69ACBAD260}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularDoubleStateActionRewardStateActionV2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9AF3FC2D58184491A2383FD51E688BFE">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularDoubleExpectedStateActionRewardStateActionModel = {}

TabularDoubleExpectedStateActionRewardStateActionModel.__index = TabularDoubleExpectedStateActionRewardStateActionModel

setmetatable(TabularDoubleExpectedStateActionRewardStateActionModel, TabularReinforcementLearningBaseModel)

local defaultAveragingRate = 0.01

local defaultEpsilon = 0.5

function TabularDoubleExpectedStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularDoubleExpectedStateActionRewardStateActionModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)

	setmetatable(NewTabularDoubleExpectedStateActionRewardStateActionModel, TabularDoubleExpectedStateActionRewardStateActionModel)
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel:setName("TabularDoubleExpectedStateActionRewardStateActionV2")
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel.averagingRate = parameterDictionary.averagingRate or defaultAveragingRate
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace

	NewTabularDoubleExpectedStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local averagingRate = NewTabularDoubleExpectedStateActionRewardStateActionModel.averagingRate
		
		local learningRate = NewTabularDoubleExpectedStateActionRewardStateActionModel.learningRate
		
		local discountFactor = NewTabularDoubleExpectedStateActionRewardStateActionModel.discountFactor
		
		local epsilon = NewTabularDoubleExpectedStateActionRewardStateActionModel.epsilon
		
		local EligibilityTrace = NewTabularDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace
		
		local Optimizer = NewTabularDoubleExpectedStateActionRewardStateActionModel.Optimizer
		
		local ModelParameters = NewTabularDoubleExpectedStateActionRewardStateActionModel.ModelParameters
		
		local StatesList = NewTabularDoubleExpectedStateActionRewardStateActionModel:getStatesList()

		local ActionsList = NewTabularDoubleExpectedStateActionRewardStateActionModel:getActionsList()
		
		local averagingRateComplement = 1 - averagingRate
		
		local numberOfActions = #ActionsList

		local expectedQValue = 0

		local numberOfGreedyActions = 0

		local actionIndex = table.find(ActionsList, action)
		
		local previousVector = NewTabularDoubleExpectedStateActionRewardStateActionModel:predict({{previousStateValue}}, true)
		
		local targetVector = NewTabularDoubleExpectedStateActionRewardStateActionModel:predict({{currentStateValue}}, true)
		
		local maxQValue = AqwamTensorLibrary:findMaximumValue(targetVector)
		
		local stateIndex = table.find(StatesList, previousStateValue)
		
		local actionIndex = table.find(ActionsList, action)

		local unwrappedTargetVector = targetVector[1]

		for i = 1, numberOfActions, 1 do

			if (unwrappedTargetVector[i] == maxQValue) then

				numberOfGreedyActions = numberOfGreedyActions + 1

			end

		end

		local nonGreedyActionProbability = epsilon / numberOfActions

		local greedyActionProbability = ((1 - epsilon) / numberOfGreedyActions) + nonGreedyActionProbability

		for _, qValue in ipairs(unwrappedTargetVector) do

			if (qValue == maxQValue) then

				expectedQValue = expectedQValue + (qValue * greedyActionProbability)

			else

				expectedQValue = expectedQValue + (qValue * nonGreedyActionProbability)

			end

		end
		
		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * expectedQValue)

		local lastValue = previousVector[1][actionIndex]

		local temporalDifferenceError = targetValue - lastValue
		
		if (EligibilityTrace) then
			
			local numberOfStates = #StatesList
			
			local dimensionSizeArray = {numberOfStates, numberOfActions}

			local temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)

			temporalDifferenceErrorMatrix[stateIndex][actionIndex] = temporalDifferenceError

			EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray)

			temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix)

			temporalDifferenceError = temporalDifferenceErrorMatrix[stateIndex][actionIndex]

		end
		
		local gradientValue = temporalDifferenceError

		if (Optimizer) then

			gradientValue = Optimizer:calculate(learningRate, {{gradientValue}})

			gradientValue = gradientValue[1][1]

		else

			gradientValue = learningRate * gradientValue

		end

		local weightValue = ModelParameters[stateIndex][actionIndex]

		local newWeightValue = weightValue + gradientValue

		ModelParameters[stateIndex][actionIndex] = (averagingRate * weightValue) + (averagingRateComplement * newWeightValue)
		
		return temporalDifferenceError

	end)
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue) 
		
		local EligibilityTrace = NewTabularDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularDoubleExpectedStateActionRewardStateActionModel:setResetFunction(function() 
		
		local EligibilityTrace = NewTabularDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularDoubleExpectedStateActionRewardStateActionModel

end

return TabularDoubleExpectedStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{6F696EAE-76D8-41CF-A43F-93782FFB44DF}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularDoubleExpectedStateActionRewardStateActionV2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1E908F8F9B724FDFBC4CEC80CBD21E61">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularDoubleQLearningModel = {}

TabularDoubleQLearningModel.__index = TabularDoubleQLearningModel

setmetatable(TabularDoubleQLearningModel, TabularReinforcementLearningBaseModel)

function TabularDoubleQLearningModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularDoubleQLearningModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularDoubleQLearningModel, TabularDoubleQLearningModel)
	
	NewTabularDoubleQLearningModel:setName("TabularDoubleQLearningV1")
	
	NewTabularDoubleQLearningModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewTabularDoubleQLearningModel.ModelParametersArray = parameterDictionary.ModelParametersArray or {}
	
	NewTabularDoubleQLearningModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local learningRate = NewTabularDoubleQLearningModel.learningRate
		
		local Optimizer = NewTabularDoubleQLearningModel.Optimizer
		
		local randomProbability = math.random()

		local updateSecondModel = (randomProbability >= 0.5)

		local selectedModelNumberForTargetVector = (updateSecondModel and 1) or 2

		local selectedModelNumberForUpdate = (updateSecondModel and 2) or 1

		local temporalDifferenceError, stateIndex, actionIndex = NewTabularDoubleQLearningModel:generateTemporalDifferenceError(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)
		
		NewTabularDoubleQLearningModel:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		local ModelParameters = NewTabularDoubleQLearningModel.ModelParameters
		
		local gradientValue = temporalDifferenceError

		if (Optimizer) then

			gradientValue = Optimizer:calculate(learningRate, {{gradientValue}})

			gradientValue = gradientValue[1][1]

		else

			gradientValue = learningRate * gradientValue

		end
		
		ModelParameters[stateIndex][actionIndex] = ModelParameters[stateIndex][actionIndex] + gradientValue
		
		NewTabularDoubleQLearningModel:saveModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		return temporalDifferenceError

	end)
	
	NewTabularDoubleQLearningModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewTabularDoubleQLearningModel.EligibilityTrace
		
		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularDoubleQLearningModel:setResetFunction(function()
		
		local EligibilityTrace = NewTabularDoubleQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularDoubleQLearningModel

end

function TabularDoubleQLearningModel:saveModelParametersFromModelParametersArray(index)

	self.ModelParametersArray[index] = self:getModelParameters()

end

function TabularDoubleQLearningModel:loadModelParametersFromModelParametersArray(index)

	local ModelParametersArray = self.ModelParametersArray

	if (not ModelParametersArray[index]) then

		self:saveModelParametersFromModelParametersArray(index)

	end

	local CurrentModelParameters = ModelParametersArray[index]

	self:setModelParameters(CurrentModelParameters, true)

end

function TabularDoubleQLearningModel:generateTemporalDifferenceError(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)

	local discountFactor = self.discountFactor

	local EligibilityTrace = self.EligibilityTrace
	
	local StatesList = self:getStatesList()

	local ActionsList = self:getActionsList()

	self:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
	
	local previousVector = self:predict({{previousStateValue}}, true)

	self:loadModelParametersFromModelParametersArray(selectedModelNumberForTargetVector)
	
	local _, maxQValue = self:predict({{currentStateValue}})
	
	local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * maxQValue[1][1])

	local stateIndex = table.find(StatesList, previousStateValue)

	local actionIndex = table.find(ActionsList, action)

	local lastValue = previousVector[1][actionIndex]

	local temporalDifferenceError = targetValue - lastValue

	if (EligibilityTrace) then

		local numberOfStates = #StatesList

		local numberOfActions = #ActionsList

		local dimensionSizeArray = {numberOfStates, numberOfActions}

		local temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)

		temporalDifferenceErrorMatrix[stateIndex][actionIndex] = temporalDifferenceError

		EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray)

		temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix)

		temporalDifferenceError = temporalDifferenceErrorMatrix[stateIndex][actionIndex]

	end

	return temporalDifferenceError, stateIndex, actionIndex

end

function TabularDoubleQLearningModel:setModelParameters1(ModelParameters1, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[1] = ModelParameters1

	else

		self.ModelParametersArray[1] = self:deepCopyTable(ModelParameters1)

	end

end

function TabularDoubleQLearningModel:setModelParameters2(ModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[2] = ModelParameters2

	else

		self.ModelParametersArray[2] = self:deepCopyTable(ModelParameters2)

	end

end

function TabularDoubleQLearningModel:getModelParameters1(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[1]

	else

		return self:deepCopyTable(self.ModelParametersArray[1])

	end

end

function TabularDoubleQLearningModel:getModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[2]

	else

		return self:deepCopyTable(self.ModelParametersArray[2])

	end

end

return TabularDoubleQLearningModel]]></ProtectedString>
									<string name="ScriptGuid">{A2A9256C-18CE-4223-986D-F91C9CB5E8F3}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularDoubleQLearningV1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX840969DCF61545928669B460176E3835">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularClippedDoubleQLearningModel = {}

TabularClippedDoubleQLearningModel.__index = TabularClippedDoubleQLearningModel

setmetatable(TabularClippedDoubleQLearningModel, TabularReinforcementLearningBaseModel)

function TabularClippedDoubleQLearningModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularClippedDoubleQLearningModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularClippedDoubleQLearningModel, TabularClippedDoubleQLearningModel)
	
	NewTabularClippedDoubleQLearningModel:setName("TabularClippedDoubleQLearning")
	
	NewTabularClippedDoubleQLearningModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewTabularClippedDoubleQLearningModel.ModelParametersArray = parameterDictionary.ModelParametersArray or {}
	
	NewTabularClippedDoubleQLearningModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local learningRate = NewTabularClippedDoubleQLearningModel.learningRate

		local discountFactor = NewTabularClippedDoubleQLearningModel.discountFactor

		local EligibilityTrace = NewTabularClippedDoubleQLearningModel.EligibilityTrace
		
		local Optimizer = NewTabularClippedDoubleQLearningModel.Optimizer

		local ModelParametersArray = NewTabularClippedDoubleQLearningModel.ModelParametersArray
		
		local StatesList = NewTabularClippedDoubleQLearningModel:getStatesList()
		
		local ActionsList = NewTabularClippedDoubleQLearningModel:getActionsList()
		
		local previousStateValueVector = {{previousStateValue}}

		local maxQValueArray = {}

		for i = 1, 2, 1 do

			NewTabularClippedDoubleQLearningModel:setModelParameters(ModelParametersArray[i], true)

			local _, maxQValue = NewTabularClippedDoubleQLearningModel:predict(previousStateValueVector)

			table.insert(maxQValueArray, maxQValue[1][1])

			ModelParametersArray[i] = NewTabularClippedDoubleQLearningModel:getModelParameters(true)

		end

		local maxQValue = math.min(table.unpack(maxQValueArray))

		local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * maxQValue)
		
		local stateIndex = table.find(StatesList, previousStateValue)

		local actionIndex = table.find(ActionsList, action)

		local temporalDifferenceErrorArray = {}
		
		local temporalDifferenceErrorMatrix

		if (EligibilityTrace) then 
			
			local numberOfStates = #StatesList

			local numberOfActions = #ActionsList
			
			local dimensionSizeArray = {numberOfStates, numberOfActions}
			
			temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)
			
			EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray) 
			
		end

		for i = 1, 2, 1 do

			NewTabularClippedDoubleQLearningModel:setModelParameters(ModelParametersArray[i], true)

			local previousVector = NewTabularClippedDoubleQLearningModel:predict(previousStateValueVector, true)

			local lastValue = previousVector[1][actionIndex]

			local temporalDifferenceError = targetValue - lastValue

			if (EligibilityTrace) then 
				
				temporalDifferenceErrorMatrix[stateIndex][actionIndex] = temporalDifferenceError
				
				temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix) 
				
				temporalDifferenceError = temporalDifferenceErrorMatrix[stateIndex][actionIndex]
				
			end
			
			local gradientValue = temporalDifferenceError
			
			if (Optimizer) then
				
				gradientValue = Optimizer:calculate(learningRate, {{gradientValue}})
				
				gradientValue = gradientValue[1][1]
				
			else
				
				gradientValue = learningRate * gradientValue
				
			end
			
			local ModelParameters = NewTabularClippedDoubleQLearningModel:getModelParameters(true)

			ModelParameters[stateIndex][actionIndex] = ModelParameters[stateIndex][actionIndex] + gradientValue
			
			temporalDifferenceErrorArray[i] = temporalDifferenceError

		end
		
		local temporalDifferenceErrorVector = {temporalDifferenceErrorArray}

		return temporalDifferenceErrorVector

	end)
	
	NewTabularClippedDoubleQLearningModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewTabularClippedDoubleQLearningModel.EligibilityTrace
		
		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularClippedDoubleQLearningModel:setResetFunction(function()
		
		local EligibilityTrace = NewTabularClippedDoubleQLearningModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularClippedDoubleQLearningModel

end

function TabularClippedDoubleQLearningModel:setModelParameters1(ModelParameters1, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[1] = ModelParameters1

	else

		self.ModelParametersArray[1] = self:deepCopyTable(ModelParameters1)

	end

end

function TabularClippedDoubleQLearningModel:setModelParameters2(ModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[2] = ModelParameters2

	else

		self.ModelParametersArray[2] = self:deepCopyTable(ModelParameters2)

	end

end

function TabularClippedDoubleQLearningModel:getModelParameters1(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[1]

	else

		return self:deepCopyTable(self.ModelParametersArray[1])

	end

end

function TabularClippedDoubleQLearningModel:getModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[2]

	else

		return self:deepCopyTable(self.ModelParametersArray[2])

	end

end

return TabularClippedDoubleQLearningModel]]></ProtectedString>
									<string name="ScriptGuid">{B4AD8BA4-4A76-40A2-B8C1-E61C6E30B10C}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularClippedDoubleQLearning</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX97569264666646A69FFD0673A438A858">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularDoubleStateActionRewardStateActionModel = {}

TabularDoubleStateActionRewardStateActionModel.__index = TabularDoubleStateActionRewardStateActionModel

setmetatable(TabularDoubleStateActionRewardStateActionModel, TabularReinforcementLearningBaseModel)

function TabularDoubleStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularDoubleStateActionRewardStateActionModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularDoubleStateActionRewardStateActionModel, TabularDoubleStateActionRewardStateActionModel)
	
	NewTabularDoubleStateActionRewardStateActionModel:setName("TabularDoubleStateActionRewardStateActionV1")
	
	NewTabularDoubleStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewTabularDoubleStateActionRewardStateActionModel.ModelParametersArray = parameterDictionary.ModelParametersArray or {}
	
	NewTabularDoubleStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local learningRate = NewTabularDoubleStateActionRewardStateActionModel.learningRate
		
		local Optimizer = NewTabularDoubleStateActionRewardStateActionModel.Optimizer
		
		local randomProbability = math.random()

		local updateSecondModel = (randomProbability >= 0.5)

		local selectedModelNumberForTargetVector = (updateSecondModel and 1) or 2

		local selectedModelNumberForUpdate = (updateSecondModel and 2) or 1

		local temporalDifferenceErrorVector, stateIndex = NewTabularDoubleStateActionRewardStateActionModel:generateTemporalDifferenceError(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)
		
		NewTabularDoubleStateActionRewardStateActionModel:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		local ModelParameters = NewTabularDoubleStateActionRewardStateActionModel.ModelParameters

		if (Optimizer) then

			temporalDifferenceErrorVector = Optimizer:calculate(learningRate, temporalDifferenceErrorVector)

		else
			
			temporalDifferenceErrorVector = AqwamTensorLibrary:multiply(learningRate, temporalDifferenceErrorVector)

		end
		
		ModelParameters[stateIndex] = AqwamTensorLibrary:add({ModelParameters[stateIndex]}, temporalDifferenceErrorVector)[1]
		
		NewTabularDoubleStateActionRewardStateActionModel:saveModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		return temporalDifferenceErrorVector

	end)
	
	NewTabularDoubleStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewTabularDoubleStateActionRewardStateActionModel.EligibilityTrace
		
		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularDoubleStateActionRewardStateActionModel:setResetFunction(function()
		
		local EligibilityTrace = NewTabularDoubleStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularDoubleStateActionRewardStateActionModel

end

function TabularDoubleStateActionRewardStateActionModel:saveModelParametersFromModelParametersArray(index)

	self.ModelParametersArray[index] = self:getModelParameters()

end

function TabularDoubleStateActionRewardStateActionModel:loadModelParametersFromModelParametersArray(index)

	local ModelParametersArray = self.ModelParametersArray

	if (not ModelParametersArray[index]) then

		self:saveModelParametersFromModelParametersArray(index)

	end

	local CurrentModelParameters = ModelParametersArray[index]

	self:setModelParameters(CurrentModelParameters, true)

end

function TabularDoubleStateActionRewardStateActionModel:generateTemporalDifferenceError(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)

	local discountFactor = self.discountFactor

	local EligibilityTrace = self.EligibilityTrace
	
	local StatesList = self:getStatesList()

	local ActionsList = self:getActionsList()

	self:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
	
	local previousQVector = self:predict({{previousStateValue}}, true)

	self:loadModelParametersFromModelParametersArray(selectedModelNumberForTargetVector)
	
	local currentQVector = self:predict({{currentStateValue}}, true)

	local discountedQVector = AqwamTensorLibrary:multiply(discountFactor, currentQVector, (1 - terminalStateValue))

	local targetVector = AqwamTensorLibrary:add(rewardValue, discountedQVector)

	local temporalDifferenceErrorVector = AqwamTensorLibrary:subtract(targetVector, previousQVector)
	
	local stateIndex = table.find(StatesList, previousStateValue)

	if (EligibilityTrace) then

		local numberOfStates = #StatesList

		local numberOfActions = #ActionsList

		local dimensionSizeArray = {numberOfStates, numberOfActions}
		
		local actionIndex = table.find(ActionsList, action)

		local temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)

		temporalDifferenceErrorMatrix[stateIndex] = temporalDifferenceErrorVector[1]

		EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray)

		temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix)

		temporalDifferenceErrorVector = {temporalDifferenceErrorMatrix[stateIndex]}

	end

	return temporalDifferenceErrorVector, stateIndex

end

function TabularDoubleStateActionRewardStateActionModel:setModelParameters1(ModelParameters1, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[1] = ModelParameters1

	else

		self.ModelParametersArray[1] = self:deepCopyTable(ModelParameters1)

	end

end

function TabularDoubleStateActionRewardStateActionModel:setModelParameters2(ModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[2] = ModelParameters2

	else

		self.ModelParametersArray[2] = self:deepCopyTable(ModelParameters2)

	end

end

function TabularDoubleStateActionRewardStateActionModel:getModelParameters1(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[1]

	else

		return self:deepCopyTable(self.ModelParametersArray[1])

	end

end

function TabularDoubleStateActionRewardStateActionModel:getModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[2]

	else

		return self:deepCopyTable(self.ModelParametersArray[2])

	end

end

return TabularDoubleStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{811878BC-B752-4C2F-B361-5A530F6DE20D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularDoubleStateActionRewardStateActionV1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC5EC56E62F4D45C68151B1D6FF676A4E">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local TabularReinforcementLearningBaseModel = require(script.Parent.TabularReinforcementLearningBaseModel)

TabularDoubleExpectedStateActionRewardStateActionModel = {}

TabularDoubleExpectedStateActionRewardStateActionModel.__index = TabularDoubleExpectedStateActionRewardStateActionModel

setmetatable(TabularDoubleExpectedStateActionRewardStateActionModel, TabularReinforcementLearningBaseModel)

local defaultEpsilon = 0.5

function TabularDoubleExpectedStateActionRewardStateActionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewTabularDoubleExpectedStateActionRewardStateActionModel = TabularReinforcementLearningBaseModel.new(parameterDictionary)
	
	setmetatable(NewTabularDoubleExpectedStateActionRewardStateActionModel, TabularDoubleExpectedStateActionRewardStateActionModel)
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel:setName("TabularDoubleExpectedStateActionRewardStateActionV1")
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel.epsilon = parameterDictionary.epsilon or defaultEpsilon
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace = parameterDictionary.EligibilityTrace
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel.ModelParametersArray = parameterDictionary.ModelParametersArray or {}
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel:setCategoricalUpdateFunction(function(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue)
		
		local learningRate = NewTabularDoubleExpectedStateActionRewardStateActionModel.learningRate
		
		local Optimizer = NewTabularDoubleExpectedStateActionRewardStateActionModel.Optimizer
		
		local randomProbability = math.random()

		local updateSecondModel = (randomProbability >= 0.5)

		local selectedModelNumberForTargetVector = (updateSecondModel and 1) or 2

		local selectedModelNumberForUpdate = (updateSecondModel and 2) or 1

		local temporalDifferenceError, stateIndex, actionIndex = NewTabularDoubleExpectedStateActionRewardStateActionModel:generateTemporalDifferenceError(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)
		
		NewTabularDoubleExpectedStateActionRewardStateActionModel:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		local ModelParameters = NewTabularDoubleExpectedStateActionRewardStateActionModel.ModelParameters

		local gradientValue = temporalDifferenceError

		if (Optimizer) then

			gradientValue = Optimizer:calculate(learningRate, {{gradientValue}})

			gradientValue = gradientValue[1][1]

		else

			gradientValue = learningRate * gradientValue

		end

		ModelParameters[stateIndex][actionIndex] = ModelParameters[stateIndex][actionIndex] + gradientValue
		
		NewTabularDoubleExpectedStateActionRewardStateActionModel:saveModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
		
		return temporalDifferenceError

	end)
	
	NewTabularDoubleExpectedStateActionRewardStateActionModel:setEpisodeUpdateFunction(function(terminalStateValue)
		
		local EligibilityTrace = NewTabularDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace
		
		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	NewTabularDoubleExpectedStateActionRewardStateActionModel:setResetFunction(function()
		
		local EligibilityTrace = NewTabularDoubleExpectedStateActionRewardStateActionModel.EligibilityTrace

		if (EligibilityTrace) then EligibilityTrace:reset() end
		
	end)

	return NewTabularDoubleExpectedStateActionRewardStateActionModel

end

function TabularDoubleExpectedStateActionRewardStateActionModel:saveModelParametersFromModelParametersArray(index)

	self.ModelParametersArray[index] = self:getModelParameters()

end

function TabularDoubleExpectedStateActionRewardStateActionModel:loadModelParametersFromModelParametersArray(index)

	local ModelParametersArray = self.ModelParametersArray

	if (not ModelParametersArray[index]) then

		self:saveModelParametersFromModelParametersArray(index)

	end

	local CurrentModelParameters = ModelParametersArray[index]

	self:setModelParameters(CurrentModelParameters, true)

end

function TabularDoubleExpectedStateActionRewardStateActionModel:generateTemporalDifferenceError(previousStateValue, action, rewardValue, currentStateValue, terminalStateValue, selectedModelNumberForTargetVector, selectedModelNumberForUpdate)

	local discountFactor = self.discountFactor
	
	local epsilon = self.epsilon

	local EligibilityTrace = self.EligibilityTrace
	
	local StatesList = self:getStatesList()

	local ActionsList = self:getActionsList()

	self:loadModelParametersFromModelParametersArray(selectedModelNumberForUpdate)
	
	local previousVector = self:predict({{previousStateValue}}, true)

	self:loadModelParametersFromModelParametersArray(selectedModelNumberForTargetVector)
	
	local targetVector = self:predict({{currentStateValue}}, true)

	local numberOfActions = #ActionsList

	local expectedQValue = 0

	local numberOfGreedyActions = 0

	local actionIndex = table.find(ActionsList, action)

	local maxQValue = AqwamTensorLibrary:findMaximumValue(targetVector)

	local stateIndex = table.find(StatesList, previousStateValue)

	local actionIndex = table.find(ActionsList, action)

	local unwrappedTargetVector = targetVector[1]

	for i = 1, numberOfActions, 1 do

		if (unwrappedTargetVector[i] == maxQValue) then

			numberOfGreedyActions = numberOfGreedyActions + 1

		end

	end

	local nonGreedyActionProbability = epsilon / numberOfActions

	local greedyActionProbability = ((1 - epsilon) / numberOfGreedyActions) + nonGreedyActionProbability

	for _, qValue in ipairs(unwrappedTargetVector) do

		if (qValue == maxQValue) then

			expectedQValue = expectedQValue + (qValue * greedyActionProbability)

		else

			expectedQValue = expectedQValue + (qValue * nonGreedyActionProbability)

		end

	end

	local targetValue = rewardValue + (discountFactor * (1 - terminalStateValue) * expectedQValue)

	local lastValue = previousVector[1][actionIndex]

	local temporalDifferenceError = targetValue - lastValue

	if (EligibilityTrace) then

		local numberOfStates = #StatesList

		local dimensionSizeArray = {numberOfStates, numberOfActions}

		local temporalDifferenceErrorMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, 0)

		temporalDifferenceErrorMatrix[stateIndex][actionIndex] = temporalDifferenceError

		EligibilityTrace:increment(stateIndex, actionIndex, discountFactor, dimensionSizeArray)

		temporalDifferenceErrorMatrix = EligibilityTrace:calculate(temporalDifferenceErrorMatrix)

		temporalDifferenceError = temporalDifferenceErrorMatrix[stateIndex][actionIndex]

	end

	return temporalDifferenceError, stateIndex, actionIndex

end

function TabularDoubleExpectedStateActionRewardStateActionModel:setModelParameters1(ModelParameters1, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[1] = ModelParameters1

	else

		self.ModelParametersArray[1] = self:deepCopyTable(ModelParameters1)

	end

end

function TabularDoubleExpectedStateActionRewardStateActionModel:setModelParameters2(ModelParameters2, doNotDeepCopy)

	if (doNotDeepCopy) then

		self.ModelParametersArray[2] = ModelParameters2

	else

		self.ModelParametersArray[2] = self:deepCopyTable(ModelParameters2)

	end

end

function TabularDoubleExpectedStateActionRewardStateActionModel:getModelParameters1(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[1]

	else

		return self:deepCopyTable(self.ModelParametersArray[1])

	end

end

function TabularDoubleExpectedStateActionRewardStateActionModel:getModelParameters2(doNotDeepCopy)

	if (doNotDeepCopy) then

		return self.ModelParametersArray[2]

	else

		return self:deepCopyTable(self.ModelParametersArray[2])

	end

end

return TabularDoubleExpectedStateActionRewardStateActionModel]]></ProtectedString>
									<string name="ScriptGuid">{E37E0843-4DDD-4F56-AC93-AB404AA3143A}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">TabularDoubleExpectedStateActionRewardStateActionV1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBDB0BE9FD6EC48B5A79013430C106AB7">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

BayesianLinearRegressionModel = {}

BayesianLinearRegressionModel.__index = BayesianLinearRegressionModel

setmetatable(BayesianLinearRegressionModel, BaseModel)

local defaultPriorPrecision = 1.0 -- alpha

local defaultLikelihoodPrecision = 1.0 -- beta

local defaultUseLogProbabilities = false

local function calculateGaussianProbability(useLogProbabilities, thresholdVector, meanVector, standardDeviationVector)

	local gaussianProbability = (useLogProbabilities and 0) or 1

	local exponentStep1Vector = AqwamTensorLibrary:subtract(thresholdVector, meanVector)

	local exponentStep2Vector = AqwamTensorLibrary:power(exponentStep1Vector, 2)

	local exponentPart3Vector = AqwamTensorLibrary:power(standardDeviationVector, 2)

	local exponentStep4Vector = AqwamTensorLibrary:divide(exponentStep2Vector, exponentPart3Vector)

	local exponentStep5Vector = AqwamTensorLibrary:multiply(-0.5, exponentStep4Vector)

	local exponentWithTermsVector = AqwamTensorLibrary:applyFunction(math.exp, exponentStep5Vector)

	local divisorVector = AqwamTensorLibrary:multiply(standardDeviationVector, math.sqrt(2 * math.pi))

	local gaussianProbabilityVector = AqwamTensorLibrary:divide(exponentWithTermsVector, divisorVector)

	if (useLogProbabilities) then gaussianProbabilityVector = AqwamTensorLibrary:applyFunction(math.log, gaussianProbabilityVector) end

	return gaussianProbabilityVector

end

function BayesianLinearRegressionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewBayesianLinearRegressionModelModel = BaseModel.new(parameterDictionary)

	setmetatable(NewBayesianLinearRegressionModelModel, BayesianLinearRegressionModel)

	NewBayesianLinearRegressionModelModel:setName("BayesianLinearRegression")

	NewBayesianLinearRegressionModelModel.priorPrecision = parameterDictionary.priorPrecision or defaultPriorPrecision

	NewBayesianLinearRegressionModelModel.likelihoodPrecision = parameterDictionary.likelihoodPrecision or defaultLikelihoodPrecision
	
	NewBayesianLinearRegressionModelModel.useLogProbabilities = NewBayesianLinearRegressionModelModel:getValueOrDefaultValue(parameterDictionary.useLogProbabilities, defaultUseLogProbabilities)

	return NewBayesianLinearRegressionModelModel
	
end

function BayesianLinearRegressionModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end

	local priorPrecision = self.priorPrecision

	local likelihoodPrecision = self.likelihoodPrecision

	local numberOfFeatures = #featureMatrix[1]

	local transposedFeatureMatrix = AqwamTensorLibrary:transpose(featureMatrix)

	local dotProductFeatureMatrix = AqwamTensorLibrary:dotProduct(transposedFeatureMatrix, featureMatrix)

	local priorPrecisionIdentityMatrix = AqwamTensorLibrary:createIdentityTensor({numberOfFeatures, numberOfFeatures})

	priorPrecisionIdentityMatrix = AqwamTensorLibrary:multiply(priorPrecisionIdentityMatrix, priorPrecision)

	local scaledDotProductFeatureMatrix = AqwamTensorLibrary:multiply(dotProductFeatureMatrix, likelihoodPrecision)

	local inverseSNMatrix = AqwamTensorLibrary:add(priorPrecisionIdentityMatrix, scaledDotProductFeatureMatrix)

	local posteriorCovarianceMatrix = AqwamTensorLibrary:inverse(inverseSNMatrix)

	if (not posteriorCovarianceMatrix) then error("Could not invert matrix for posterior.") end

	local dotProductFeatureMatrixLabelVector = AqwamTensorLibrary:dotProduct(transposedFeatureMatrix, labelVector)

	local posteriorMeanVectorPart1 = AqwamTensorLibrary:dotProduct(posteriorCovarianceMatrix, dotProductFeatureMatrixLabelVector)

	local posteriorMeanVector = AqwamTensorLibrary:multiply(posteriorMeanVectorPart1, likelihoodPrecision)

	self.ModelParameters = {posteriorMeanVector, posteriorCovarianceMatrix}

end

function BayesianLinearRegressionModel:predict(featureMatrix, thresholdMatrix)
	
	if (thresholdMatrix) then
		
		if (#featureMatrix ~= #thresholdMatrix) then error("The feature matrix and the threshold matrix does not contain the same number of rows.") end
		
	end

	local ModelParameters = self.ModelParameters
	
	local posteriorMeanVector
	
	local posteriorCovarianceMatrix

	if (not ModelParameters) then
		
		local dimensionSizeArray = {#featureMatrix[1], 1}

		posteriorMeanVector = self:initializeMatrixBasedOnMode(dimensionSizeArray)
		
		posteriorCovarianceMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, math.huge)

		self.ModelParameters = {posteriorMeanVector, posteriorCovarianceMatrix}
		
	else
		
		posteriorMeanVector = ModelParameters[1]

		posteriorCovarianceMatrix = ModelParameters[2]

	end
	
	local predictedMeanVector = AqwamTensorLibrary:dotProduct(featureMatrix, posteriorMeanVector)

	if (not thresholdMatrix) then return predictedMeanVector end
	
	local likelihoodPrecision = self.likelihoodPrecision
	
	local inverseLikelihoodPrecision = 1 / likelihoodPrecision
	
	local transposedFeatureMatrix = AqwamTensorLibrary:transpose(featureMatrix)
	
	local predictedVarianceVectorPart1 = AqwamTensorLibrary:dotProduct(featureMatrix, posteriorCovarianceMatrix)
	
	local predictedVarianceVectorPart2 = AqwamTensorLibrary:dotProduct(predictedVarianceVectorPart1, transposedFeatureMatrix)
	
	local predictedVarianceVector = {}
	
	for i, predictedVarianceTable in ipairs(predictedVarianceVectorPart2) do
		
		predictedVarianceVector[i] = {predictedVarianceTable[i] + inverseLikelihoodPrecision}
		
	end
	
	local predictedStandardDeviationVector = AqwamTensorLibrary:applyFunction(math.sqrt, predictedVarianceVector)
	
	local probabilityMatrix = calculateGaussianProbability(self.useLogProbabilities, thresholdMatrix, predictedMeanVector, predictedStandardDeviationVector)

	return predictedMeanVector, probabilityMatrix 
	
end

return BayesianLinearRegressionModel]]></ProtectedString>
									<string name="ScriptGuid">{0E478711-DDFA-4A44-9DB6-1FBF62031030}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BayesianLinearRegression</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8497D306844C46E89298B042482FC1BB">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

local zTableFunction = require(script.Parent.Parent.Cores.ZTableFunction)

BayesianQuantileLinearRegressionModel = {}

BayesianQuantileLinearRegressionModel.__index = BayesianQuantileLinearRegressionModel

setmetatable(BayesianQuantileLinearRegressionModel, BaseModel)

local defaultPriorPrecision = 1.0 -- alpha

local defaultLikelihoodPrecision = 1.0 -- beta

function BayesianQuantileLinearRegressionModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewBayesianQuantileLinearRegressionModel = BaseModel.new(parameterDictionary)

	setmetatable(NewBayesianQuantileLinearRegressionModel, BayesianQuantileLinearRegressionModel)

	NewBayesianQuantileLinearRegressionModel:setName("BayesianQuantileLinearRegression")

	NewBayesianQuantileLinearRegressionModel.priorPrecision = parameterDictionary.priorPrecision or defaultPriorPrecision

	NewBayesianQuantileLinearRegressionModel.likelihoodPrecision = parameterDictionary.likelihoodPrecision or defaultLikelihoodPrecision

	return NewBayesianQuantileLinearRegressionModel

end

function BayesianQuantileLinearRegressionModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end

	local priorPrecision = self.priorPrecision

	local likelihoodPrecision = self.likelihoodPrecision

	local numberOfFeatures = #featureMatrix[1]

	local transposedFeatureMatrix = AqwamTensorLibrary:transpose(featureMatrix)

	local dotProductFeatureMatrix = AqwamTensorLibrary:dotProduct(transposedFeatureMatrix, featureMatrix)

	local priorPrecisionIdentityMatrix = AqwamTensorLibrary:createIdentityTensor({numberOfFeatures, numberOfFeatures})

	priorPrecisionIdentityMatrix = AqwamTensorLibrary:multiply(priorPrecisionIdentityMatrix, priorPrecision)

	local scaledDotProductFeatureMatrix = AqwamTensorLibrary:multiply(dotProductFeatureMatrix, likelihoodPrecision)

	local inverseSNMatrix = AqwamTensorLibrary:add(priorPrecisionIdentityMatrix, scaledDotProductFeatureMatrix)

	local posteriorCovarianceMatrix = AqwamTensorLibrary:inverse(inverseSNMatrix)

	if (not posteriorCovarianceMatrix) then error("Could not invert matrix for posterior.") end

	local dotProductFeatureMatrixLabelVector = AqwamTensorLibrary:dotProduct(transposedFeatureMatrix, labelVector)

	local posteriorMeanVectorPart1 = AqwamTensorLibrary:dotProduct(posteriorCovarianceMatrix, dotProductFeatureMatrixLabelVector)

	local posteriorMeanVector = AqwamTensorLibrary:multiply(posteriorMeanVectorPart1, likelihoodPrecision)

	self.ModelParameters = {posteriorMeanVector, posteriorCovarianceMatrix}

end

function BayesianQuantileLinearRegressionModel:predict(featureMatrix, quantileMatrix)

	local numberOfData = #featureMatrix

	if (quantileMatrix) then

		if (numberOfData ~= #quantileMatrix) then error("The feature matrix and the quantile matrix does not contain the same number of rows.") end

	end

	local ModelParameters = self.ModelParameters

	local posteriorMeanVector

	local posteriorCovarianceMatrix

	if (not ModelParameters) then

		local dimensionSizeArray = {#featureMatrix[1], 1}

		posteriorMeanVector = self:initializeMatrixBasedOnMode(dimensionSizeArray)

		posteriorCovarianceMatrix = AqwamTensorLibrary:createTensor(dimensionSizeArray, math.huge)

		self.ModelParameters = {posteriorMeanVector, posteriorCovarianceMatrix}

	else

		posteriorMeanVector = ModelParameters[1]

		posteriorCovarianceMatrix = ModelParameters[2]

	end

	local predictedMeanVector = AqwamTensorLibrary:dotProduct(featureMatrix, posteriorMeanVector)

	if (not quantileMatrix) then return predictedMeanVector end

	local likelihoodPrecision = self.likelihoodPrecision

	local inverseLikelihoodPrecision = 1 / likelihoodPrecision

	local transposedFeatureMatrix = AqwamTensorLibrary:transpose(featureMatrix)

	local predictedVarianceVectorPart1 = AqwamTensorLibrary:dotProduct(featureMatrix, posteriorCovarianceMatrix)

	local predictedVarianceVectorPart2 = AqwamTensorLibrary:dotProduct(predictedVarianceVectorPart1, transposedFeatureMatrix)

	local predictedVarianceVector = {}

	for i, predictedVarianceTable in ipairs(predictedVarianceVectorPart2) do

		predictedVarianceVector[i] = {predictedVarianceTable[i] + inverseLikelihoodPrecision}

	end

	local predictedStandardDeviationVector = AqwamTensorLibrary:applyFunction(math.sqrt, predictedVarianceVector)

	local numberOfQuantiles = #quantileMatrix[1]

	local predictedQuantileMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfQuantiles}, 0)
	
	local unwrappedPredictedQuantileVector
	
	local predictedMeanValue
	
	local predictedStandardDeviationValue

	local zValue

	for i, unwrappedQuantileVector in ipairs(quantileMatrix) do
		
		unwrappedPredictedQuantileVector = predictedQuantileMatrix[i]
		
		predictedMeanValue = predictedMeanVector[i][1]
		
		predictedStandardDeviationValue = predictedStandardDeviationVector[i][1]
		
		for j, quantileValue in ipairs(unwrappedQuantileVector) do
			
			zValue = zTableFunction:calculateStandardNormalInverseCumulativeDistributionValue(quantileValue)
			
			unwrappedPredictedQuantileVector[j] = predictedMeanValue + (zValue * predictedStandardDeviationValue)
			
		end
		
		predictedQuantileMatrix[i] = unwrappedPredictedQuantileVector

	end

	return predictedMeanVector, predictedQuantileMatrix 

end

return BayesianQuantileLinearRegressionModel]]></ProtectedString>
									<string name="ScriptGuid">{62589394-91F4-4F62-B8B6-924E7311FDFA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BayesianQuantileLinearRegression</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1B519BDA3FD845B2A2229DF3572197C3">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GradientMethodBaseModel = require(script.Parent.GradientMethodBaseModel)

QuantileLinearRegressionModel = {}

QuantileLinearRegressionModel.__index = QuantileLinearRegressionModel

setmetatable(QuantileLinearRegressionModel, GradientMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultLearningRate = 0.3

local function quantileLoss(hypothesisValue, labelValue, tau)
	
	local differenceValue = hypothesisValue - labelValue
	
	local multiplierValue = ((differenceValue < 0) and (tau - 1)) or tau
	
	local quantileLossValue = differenceValue * multiplierValue

	return quantileLossValue
	
end

function QuantileLinearRegressionModel:calculateCost(hypothesisVector, labelVector)

	if (type(hypothesisVector) == "number") then hypothesisVector = {{hypothesisVector}} end

	local costVector = AqwamTensorLibrary:applyFunction(quantileLoss, hypothesisVector, labelVector, {self.quantilesList}) 

	local totalCost = AqwamTensorLibrary:sum(costVector)
	
	local Regularizer = self.Regularizer

	if (Regularizer) then totalCost = totalCost + Regularizer:calculateCost(self.ModelParameters) end

	local averageCost = totalCost / #labelVector

	return averageCost

end

function QuantileLinearRegressionModel:calculateHypothesisVector(featureMatrix, saveFeatureMatrix)

	local hypothesisVector = AqwamTensorLibrary:dotProduct(featureMatrix, self.ModelParameters)

	if (saveFeatureMatrix) then self.featureMatrix = featureMatrix end

	return hypothesisVector

end

function QuantileLinearRegressionModel:calculateCostFunctionDerivativeMatrix(lossMatrix)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local featureMatrix = self.featureMatrix

	if (not featureMatrix) then error("Feature matrix not found.") end
	
	local gradientWeightMatrix = AqwamTensorLibrary:applyFunction(function(lossValue, tau) return (lossValue < 0) and (tau - 1) or tau end, lossMatrix, {self.quantilesList})

	local costFunctionDerivativeMatrix = AqwamTensorLibrary:dotProduct(AqwamTensorLibrary:transpose(featureMatrix), gradientWeightMatrix)

	if (self.areGradientsSaved) then self.costFunctionDerivativeMatrix = costFunctionDerivativeMatrix end

	return costFunctionDerivativeMatrix

end

function QuantileLinearRegressionModel:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (type(costFunctionDerivativeMatrix) == "number") then costFunctionDerivativeMatrix = {{costFunctionDerivativeMatrix}} end
	
	local ModelParameters = self.ModelParameters
	
	local Regularizer = self.Regularizer
	
	local Optimizer = self.Optimizer
	
	local learningRate = self.learningRate

	if (Regularizer) then

		local regularizationDerivatives = Regularizer:calculate(ModelParameters)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:add(costFunctionDerivativeMatrix, regularizationDerivatives)

	end

	costFunctionDerivativeMatrix = AqwamTensorLibrary:divide(costFunctionDerivativeMatrix, numberOfData)

	if (Optimizer) then 

		costFunctionDerivativeMatrix = Optimizer:calculate(learningRate, costFunctionDerivativeMatrix, ModelParameters) 

	else

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrix)

	end

	self.ModelParameters = AqwamTensorLibrary:subtract(ModelParameters, costFunctionDerivativeMatrix)

end

function QuantileLinearRegressionModel:update(lossMatrix, clearAllMatrices)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local numberOfData = #lossMatrix

	local costFunctionDerivativeMatrix = self:calculateCostFunctionDerivativeMatrix(lossMatrix)

	self:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (clearAllMatrices) then 
		
		self.featureMatrix = nil 
		
		self.costFunctionDerivativeMatrix = nil
		
	end

end

function QuantileLinearRegressionModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewQuantileLinearRegressionModel = GradientMethodBaseModel.new(parameterDictionary)

	setmetatable(NewQuantileLinearRegressionModel, QuantileLinearRegressionModel)
	
	NewQuantileLinearRegressionModel:setName("QuantileLinearRegression")
	
	local quantilesList = parameterDictionary.quantilesList or {}
	
	if (#quantilesList == 0) then quantilesList[1] = 0.5 end

	NewQuantileLinearRegressionModel.learningRate = parameterDictionary.learningRate or defaultLearningRate

	NewQuantileLinearRegressionModel.quantilesList = quantilesList

	NewQuantileLinearRegressionModel.Optimizer = parameterDictionary.Optimizer

	NewQuantileLinearRegressionModel.Regularizer = parameterDictionary.Regularizer

	return NewQuantileLinearRegressionModel

end

function QuantileLinearRegressionModel:setOptimizer(Optimizer)

	self.Optimizer = Optimizer

end

function QuantileLinearRegressionModel:setRegularizer(Regularizer)

	self.Regularizer = Regularizer

end

function QuantileLinearRegressionModel:train(featureMatrix, labelVector)

	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	local ModelParameters = self.ModelParameters

	if (ModelParameters) then

		if (#featureMatrix[1] ~= #ModelParameters) then error("The number of features are not the same as the model parameters.") end

	else

		self.ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], #self.quantilesList})

	end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations

	local Optimizer = self.Optimizer

	local costArray = {}

	local numberOfIterations = 0
	
	local cost

	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		local hypothesisVector = self:calculateHypothesisVector(featureMatrix, true)

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return self:calculateCost(hypothesisVector, labelVector)

		end)

		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end

		local lossVector = AqwamTensorLibrary:subtract(hypothesisVector, labelVector)

		self:update(lossVector, true)

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	if (Optimizer) and (self.autoResetOptimizers) then Optimizer:reset() end

	return costArray

end

function QuantileLinearRegressionModel:predict(featureMatrix)
	
	local ModelParameters = self.ModelParameters
	
	if (not ModelParameters) then
		
		ModelParameters = self:initializeMatrixBasedOnMode({#featureMatrix[1], #self.quantilesList})
		
		self.ModelParameters = ModelParameters
		
	end

	local predictedVector = AqwamTensorLibrary:dotProduct(featureMatrix, ModelParameters)

	return predictedVector

end

return QuantileLinearRegressionModel]]></ProtectedString>
									<string name="ScriptGuid">{3B36E0DF-8DBD-4E85-A326-99584F570F25}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">QuantileLinearRegression</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE6C05FA092A14DF09A35AFE02A8C451A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GradientMethodBaseModel = require(script.Parent.GradientMethodBaseModel)

MarkovModel = {}

MarkovModel.__index = MarkovModel

setmetatable(MarkovModel, GradientMethodBaseModel)

local defaultLearningRate = 0.1

local defaultStateSelectionFunction = "Maximum"

local defaultTemperature = 1

local RandomObject = Random.new()

local function selectIndexWithHighestValue(valueVector)

	local selectedIndex = 1

	local highestValue = -math.huge

	for index, value in ipairs(valueVector[1]) do

		if (value > highestValue) then

			highestValue = value

			selectedIndex = index

		end

	end

	return selectedIndex

end

local function calculateStableProbability(valueVector, temperature)

	local maximumValue = AqwamTensorLibrary:findMaximumValue(valueVector)

	local zValueVector = AqwamTensorLibrary:subtract(valueVector, maximumValue)

	local temperatureZValueVector = AqwamTensorLibrary:divide(zValueVector, temperature)

	local exponentVector = AqwamTensorLibrary:exponent(temperatureZValueVector)

	local sumExponentValue = AqwamTensorLibrary:sum(exponentVector)

	local probabilityVector = AqwamTensorLibrary:divide(exponentVector, sumExponentValue)

	return probabilityVector

end

local function calculateProbability(valueVector, temperature)

	local temperatureZValueVector = AqwamTensorLibrary:divide(valueVector, temperature)

	local exponentVector = AqwamTensorLibrary:exponent(temperatureZValueVector)

	local sumExponentValue = AqwamTensorLibrary:sum(exponentVector)

	local probabilityVector = AqwamTensorLibrary:divide(exponentVector, sumExponentValue)

	return probabilityVector

end

local function sample(probabilityVector)

	local unwrappedProbabilityVector = probabilityVector[1]

	local totalProbability = 0

	for _, probability in ipairs(unwrappedProbabilityVector) do

		totalProbability = totalProbability + probability

	end

	local randomProbability = math.random() * totalProbability

	local cumulativeProbability = 0

	for index, probability in ipairs(unwrappedProbabilityVector) do

		cumulativeProbability = cumulativeProbability + probability

		if (cumulativeProbability >= randomProbability) then return index end

	end

	return #unwrappedProbabilityVector

end

local stateSelectionFunctionList = {
	
	["Maximum"] = selectIndexWithHighestValue,
	
	["StableSoftmaxSampling"] = function(stateVector, temperature)
		
		local stableActionProbabilityVector = calculateStableProbability(stateVector, temperature)

		return sample(stableActionProbabilityVector)
		
	end,
	
	["StableBoltzmannSampling"] = function(stateVector, temperature)

		local stableActionProbabilityVector = calculateStableProbability(stateVector, temperature)

		return sample(stableActionProbabilityVector)

	end,
	
	["SoftmaxSampling"] = function(stateVector, temperature)

		local stableActionProbabilityVector = calculateProbability(stateVector, temperature)

		return sample(stableActionProbabilityVector)

	end,
	
	["BoltzmannSampling"] = function(stateVector, temperature)

		local stableActionProbabilityVector = calculateProbability(stateVector, temperature)

		return sample(stableActionProbabilityVector)

	end,
	
}

function MarkovModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewMarkovModel = GradientMethodBaseModel.new(parameterDictionary)
	
	setmetatable(NewMarkovModel, MarkovModel)
	
	NewMarkovModel:setName("Markov")

	NewMarkovModel:setClassName("Markov")
	
	local isHidden = parameterDictionary.isHidden
	
	local StatesList = parameterDictionary.StatesList or {}
	
	local ObservationsList = parameterDictionary.ObservationsList or {}
	
	if (type(isHidden) ~= "boolean") then isHidden = (#ObservationsList > 0) and (ObservationsList ~= StatesList) end
	
	NewMarkovModel.learningRate = parameterDictionary.learningRate or defaultLearningRate
	
	NewMarkovModel.isHidden = isHidden
	
	NewMarkovModel.StatesList = StatesList
	
	NewMarkovModel.ObservationsList = ObservationsList
	
	NewMarkovModel.stateSelectionFunction = parameterDictionary.stateSelectionFunction or defaultStateSelectionFunction
	
	NewMarkovModel.temperature = parameterDictionary.temperature or defaultTemperature
	
	NewMarkovModel.TransitionProbabilityOptimizer = parameterDictionary.TransitionProbabilityOptimizer
	
	NewMarkovModel.EmissionProbabilityOptimizer = parameterDictionary.EmissionProbabilityOptimizer
	
	NewMarkovModel.ModelParameters = parameterDictionary.ModelParameters
	
	return NewMarkovModel
	
end

function MarkovModel:setLearningRate(learningRate)

	self.learningRate = learningRate

end

function MarkovModel:getLearningRate()

	return self.learningRate

end

function MarkovModel:train(previousStateVector, currentStateVector, currentObservationStateVector)
	
	local numberOfData = #previousStateVector
	
	if (numberOfData ~= #currentStateVector) then error("The number of data in the previous state vector is not equal to the number of data in the current state vector.") end
	
	if (currentObservationStateVector) then
		
		if (numberOfData ~= #currentObservationStateVector) then error("The number of data in the previous state vector is not equal to the number of data in the current observation state vector.") end
		
	end
	
	local learningRate = self.learningRate
	
	local isHidden = self.isHidden
	
	local StatesList = self.StatesList
	
	local ObservationsList = self.ObservationsList
	
	local TransitionProbabilityOptimizer = self.TransitionProbabilityOptimizer
	
	local EmissionProbabilityOptimizer = self.EmissionProbabilityOptimizer
	
	local ModelParameters = self.ModelParameters or {}
	
	local numberOfStates = #StatesList
	
	local numberOfObservations = #ObservationsList
	
	local transitionProbabilityMatrix = ModelParameters[1] or AqwamTensorLibrary:createTensor({numberOfStates, numberOfStates})
	
	local emissionProbabilityMatrix
	
	if (isHidden) then
		
		emissionProbabilityMatrix = ModelParameters[2] or AqwamTensorLibrary:createTensor({numberOfStates, numberOfObservations})
		
	end
	
	local previousState
	
	local currentState
	
	local currentObservationState
	
	local previousStateIndex
	
	local currentStateIndex
	
	local observationStateIndex
	
	local unwrappedPreviousStateTransitionProbabilityVector
	
	local targetTransitionProbabilityValue
	
	local transitionProbabilityChangeValue
	
	local transitionProbabilityChangeVector
	
	local newTransitionProbabilityVector
	
	local sumNewTransitionProbability
	
	local unwrappedCurrentStateEmissionProbabilityVector
	
	local targetStateEmissionProbabilityValue
	
	local stateEmissionProbabilityChangeVector
	
	local newStateEmissionProbabilityVector
	
	local sumNewStateEmissionProbability
	
	for i, unwrappedPreviousStateVector in ipairs(previousStateVector) do
		
		previousState = unwrappedPreviousStateVector[1]
		
		currentState = currentStateVector[i][1]
		
		previousStateIndex = table.find(StatesList, previousState)
		
		currentStateIndex = table.find(StatesList, currentState)

		if (previousStateIndex) and (currentStateIndex) then
			
			unwrappedPreviousStateTransitionProbabilityVector = transitionProbabilityMatrix[previousStateIndex]
			
			transitionProbabilityChangeVector = {}
			
			for j, previousStateTransitionProbabilityValue in ipairs(unwrappedPreviousStateTransitionProbabilityVector) do
				
				targetTransitionProbabilityValue = ((j == currentStateIndex) and 1) or 0
				
				transitionProbabilityChangeVector[j] = targetTransitionProbabilityValue - previousStateTransitionProbabilityValue
				
			end
			
			transitionProbabilityChangeVector = {transitionProbabilityChangeVector}
			
			if (TransitionProbabilityOptimizer) then

				transitionProbabilityChangeVector = TransitionProbabilityOptimizer:calculate(learningRate, transitionProbabilityChangeVector)

			else

				transitionProbabilityChangeVector = AqwamTensorLibrary:multiply(learningRate, transitionProbabilityChangeVector)

			end
			
			newTransitionProbabilityVector = AqwamTensorLibrary:add({unwrappedPreviousStateTransitionProbabilityVector}, transitionProbabilityChangeVector)
			
			sumNewTransitionProbability = AqwamTensorLibrary:sum(newTransitionProbabilityVector)
			
			if (sumNewTransitionProbability ~= 0) then
				
				newTransitionProbabilityVector = AqwamTensorLibrary:divide(newTransitionProbabilityVector, sumNewTransitionProbability)

				transitionProbabilityMatrix[previousStateIndex] = newTransitionProbabilityVector[1]
				
			end
			
		end
		
		if (isHidden) then
			
			currentObservationState = currentObservationStateVector[i][1]

			if (currentObservationState) then

				observationStateIndex = table.find(ObservationsList, currentObservationState)

				if (currentStateIndex) and (observationStateIndex) then

					unwrappedCurrentStateEmissionProbabilityVector = emissionProbabilityMatrix[currentStateIndex]
					
					stateEmissionProbabilityChangeVector = {}

					for j, currentStateEmissionProbabilityValue in ipairs(unwrappedCurrentStateEmissionProbabilityVector) do

						targetStateEmissionProbabilityValue = ((j == observationStateIndex) and 1) or 0
						
						stateEmissionProbabilityChangeVector[j] = targetStateEmissionProbabilityValue - currentStateEmissionProbabilityValue

					end
					
					stateEmissionProbabilityChangeVector = {stateEmissionProbabilityChangeVector}
					
					if (EmissionProbabilityOptimizer) then

						stateEmissionProbabilityChangeVector = EmissionProbabilityOptimizer:calculate(learningRate, stateEmissionProbabilityChangeVector)

					else

						stateEmissionProbabilityChangeVector = AqwamTensorLibrary:multiply(learningRate, stateEmissionProbabilityChangeVector)

					end
					
					newStateEmissionProbabilityVector = AqwamTensorLibrary:add({unwrappedCurrentStateEmissionProbabilityVector}, stateEmissionProbabilityChangeVector)
					
					sumNewStateEmissionProbability = AqwamTensorLibrary:sum(newStateEmissionProbabilityVector)
					
					if (sumNewStateEmissionProbability ~= 0) then
						
						newStateEmissionProbabilityVector = AqwamTensorLibrary:divide(newStateEmissionProbabilityVector, sumNewStateEmissionProbability)

						emissionProbabilityMatrix[currentStateIndex] = newStateEmissionProbabilityVector[1]
						
					end
					
				end
			end
			
		end
		
	end
	
	self.ModelParameters = {transitionProbabilityMatrix, emissionProbabilityMatrix}
	
	if (self.autoResetOptimizers) then
		
		if (TransitionProbabilityOptimizer) then TransitionProbabilityOptimizer:reset() end
		
		if (EmissionProbabilityOptimizer) then EmissionProbabilityOptimizer:reset() end
		
	end
	
end

function MarkovModel:predict(stateVector, returnOriginalOutput)
	
	local isHidden = self.isHidden
	
	local StatesList = self.StatesList
	
	local ObservationsList = self.ObservationsList
	
	local ModelParameters = self.ModelParameters
	
	local numberOfStates = #StatesList

	local numberOfObservations = #ObservationsList
	
	local transitionProbabilityMatrix

	local emissionProbabilityMatrix
	
	if (not ModelParameters) then
		
		transitionProbabilityMatrix = AqwamTensorLibrary:createTensor({numberOfStates, numberOfStates})
		
		if (isHidden) then
			
			emissionProbabilityMatrix = AqwamTensorLibrary:createTensor({numberOfStates, numberOfObservations})
			
		end
		
		self.ModelParameters = {transitionProbabilityMatrix, emissionProbabilityMatrix}
		
	else
		
		transitionProbabilityMatrix = ModelParameters[1]
		
		emissionProbabilityMatrix = ModelParameters[2]
		
	end
	
	local resultTensor = {}
	
	local selectedMatrix = (isHidden and emissionProbabilityMatrix) or transitionProbabilityMatrix
	
	for i, unwrappedStateVector in ipairs(stateVector) do
		
		local state = unwrappedStateVector[1]
		
		local stateIndex = table.find(StatesList, state)
		
		if (not stateIndex) then error("State \"" .. state ..  "\" does not exist in the states list.") end
		
		resultTensor[i] = selectedMatrix[stateIndex]
		
	end
	
	if (returnOriginalOutput) then return resultTensor end
	
	local stateSelectionFunction = self.stateSelectionFunction
	
	local stateSelectionFunctionToApply = stateSelectionFunctionList[stateSelectionFunction]
	
	if (not stateSelectionFunctionToApply) then error("Invalid state selection function.") end
	
	local temperature = self.temperature
	
	local stateVector = {}
	
	local valueVector = {}
	
	local SelectedList = (isHidden and ObservationsList) or StatesList
	
	for i, unwrappedResultVector in ipairs(resultTensor) do
		
		local stateIndex = stateSelectionFunctionToApply({unwrappedResultVector}, temperature)
		
		local value = unwrappedResultVector[stateIndex]
		
		local state = SelectedList[stateIndex] 
		
		if (not state) then error("Output state for index " .. stateIndex .. " does not exist in the list.") end
		
		stateVector[i] = {state}
		
		valueVector[i] = {value}
		
	end

	return stateVector, valueVector

end

function MarkovModel:setStatesList(StatesList)
	
	self.StatesList = StatesList
	
end

function MarkovModel:getStatesList()
	
	return self.StatesList
	
end

function MarkovModel:setObservationsList(ObservationsList)
	
	self.ObservationsList = ObservationsList
	
end

function MarkovModel:getObservationsList()
	
	return self.ObservationsList
	
end

return MarkovModel]]></ProtectedString>
									<string name="ScriptGuid">{C27624DA-D151-4B06-BE7D-E0C7C620792B}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Markov</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX03763DD3F30A4CC49F28532141195CA6">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

DynamicBayesianNetworkModel = {}

DynamicBayesianNetworkModel.__index = DynamicBayesianNetworkModel

setmetatable(DynamicBayesianNetworkModel, BaseModel)

local defaultMode = "Hybrid"

local defaultIsHidden = false

local defaultLossFunction = "L2"

function DynamicBayesianNetworkModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewDynamicBayesianNetworkModel = BaseModel.new(parameterDictionary)

	setmetatable(NewDynamicBayesianNetworkModel, DynamicBayesianNetworkModel)

	NewDynamicBayesianNetworkModel:setName("DynamicBayesianNetwork")

	NewDynamicBayesianNetworkModel.mode = parameterDictionary.mode or defaultMode
	
	NewDynamicBayesianNetworkModel.isHidden = NewDynamicBayesianNetworkModel:getValueOrDefaultValue(parameterDictionary.isHidden, defaultIsHidden)
	
	NewDynamicBayesianNetworkModel.lossFunction = parameterDictionary.lossFunction or defaultLossFunction

	NewDynamicBayesianNetworkModel.TransitionProbabilityOptimizer = parameterDictionary.TransitionProbabilityOptimizer

	NewDynamicBayesianNetworkModel.EmissionProbabilityOptimizer = parameterDictionary.EmissionProbabilityOptimizer

	NewDynamicBayesianNetworkModel.ModelParameters = parameterDictionary.ModelParameters

	return NewDynamicBayesianNetworkModel

end

-- State matrix are basically (row) one hot encoding in which the state values are active.

function DynamicBayesianNetworkModel:train(previousStateMatrix, currentStateMatrix, currentObservationStateMatrix)
	
	local numberOfData = #previousStateMatrix
	
	if (numberOfData ~= #currentStateMatrix) then error("The number of data in the previous state vector is not equal to the number of data in the current state vector.") end

	if (currentObservationStateMatrix) then

		if (numberOfData ~= #currentObservationStateMatrix) then error("The number of data in the previous state vector is not equal to the number of data in the current observation state vector.") end

	end
	
	local mode = self.mode

	local isHidden = self.isHidden
	
	local lossFunction = self.lossFunction

	local ModelParameters = self.ModelParameters or {}

	local transitionCountMatrix = ModelParameters[3]

	local emissionCountMatrix = ModelParameters[4]
	
	local numberOfPreviousStateColumns = #previousStateMatrix[1]

	local numberOfCurrentStateColumns = #currentStateMatrix[1]
	
	local numberOfCurrentObservationStateColumns
	
	local numberOfStates

	local numberOfObservations
	
	if (currentObservationStateMatrix) then numberOfCurrentObservationStateColumns = #currentObservationStateMatrix[1] end

	if (mode == "Hybrid") then
		
		local hasTransition = transitionCountMatrix
		
		local hasEmission = (isHidden and emissionCountMatrix) or (not isHidden)

		mode = (hasTransition and hasEmission and "Online") or "Offline"		

	end
	
	if (mode == "Offline") then
		
		numberOfStates = numberOfPreviousStateColumns

		transitionCountMatrix = AqwamTensorLibrary:createTensor({numberOfStates, numberOfStates})
		
		if (isHidden) then 
			
			numberOfObservations = numberOfCurrentObservationStateColumns
			
			emissionCountMatrix = AqwamTensorLibrary:createTensor({numberOfStates, numberOfObservations}) 
			
		end
		
	else
		
		numberOfStates = #transitionCountMatrix
		
		if (isHidden) then numberOfObservations = #emissionCountMatrix[1] end
		
	end
	
	if (numberOfPreviousStateColumns ~= numberOfStates) then error("The number of previous state columns is not equal to the number of states.") end

	if (numberOfCurrentStateColumns ~= numberOfStates) then error("The number of current state columns is not equal to the number of states.") end
	
	if (isHidden) then

		if (numberOfCurrentObservationStateColumns ~= numberOfObservations) then error("The number of current observation state columns is not equal to the number of observations.") end

	end
	
	local unwrappedCurrentStateVector
	
	local unwrappedCurrentObservationStateVector
	
	local unwrappedTransitionCountVector
	
	local unwrappedEmissionCountVector
	
	for dataIndex, unwrappedPreviousStateVector in ipairs(previousStateMatrix) do
		
		unwrappedCurrentStateVector = currentStateMatrix[dataIndex]
		
		for previousStateIndex, previousStateValue in ipairs(unwrappedPreviousStateVector) do
			
			unwrappedTransitionCountVector = transitionCountMatrix[previousStateIndex]
			
			for currentStateIndex, currentStateValue in ipairs(unwrappedCurrentStateVector) do

				unwrappedTransitionCountVector[currentStateIndex] = unwrappedTransitionCountVector[currentStateIndex] + (previousStateValue * currentStateValue)
				
				if (isHidden) then

					unwrappedCurrentObservationStateVector = currentObservationStateMatrix[dataIndex]

					unwrappedEmissionCountVector = emissionCountMatrix[currentStateIndex]

					for currentObservationStateIndex, currentObservationStateValue in ipairs(unwrappedCurrentObservationStateVector) do

						unwrappedEmissionCountVector[currentObservationStateIndex] = unwrappedEmissionCountVector[currentObservationStateIndex] + (currentStateValue * currentObservationStateValue)

					end

				end
				
			end
			
		end
		
	end
	
	local sumTransitionCountVector = AqwamTensorLibrary:sum(transitionCountMatrix, 1)
	
	local transitionProbabilityMatrix = AqwamTensorLibrary:divide(transitionCountMatrix, sumTransitionCountVector)
	
	local emissionProbabilityMatrix 
	
	if (isHidden) then
		
		local sumEmissionCountVector = AqwamTensorLibrary:sum(emissionCountMatrix, 1)

		emissionProbabilityMatrix = AqwamTensorLibrary:divide(emissionCountMatrix, sumEmissionCountVector)
		
	end
	
	-- stateMatrix -> numberOfData x numberOfStates
	
	-- transitionProbabilityMatrix -> numberOfStateProbabilities x numberOfStates
	
	-- emissionProbabilityMatrix -> numberOfObservationProbabilities x numberOfStates

	self.ModelParameters = {transitionProbabilityMatrix, emissionProbabilityMatrix, transitionCountMatrix, emissionCountMatrix}
	
	local targetStateMatrix = (isHidden and currentObservationStateMatrix) or currentStateMatrix
	
	local matrixToDotProduct = (isHidden and emissionProbabilityMatrix) or transitionProbabilityMatrix
	
	local predictedCurrentStateMatrix = AqwamTensorLibrary:dotProduct(previousStateMatrix, matrixToDotProduct)
	
	local lossMatrix = AqwamTensorLibrary:subtract(targetStateMatrix, predictedCurrentStateMatrix)

	if (lossFunction == "L1") then

		lossMatrix = AqwamTensorLibrary:applyFunction(math.abs, lossMatrix)

	elseif (lossFunction == "L2") then

		lossMatrix = AqwamTensorLibrary:power(lossMatrix, 2)

	else

		error("Invalid loss function.")

	end

	local cost = AqwamTensorLibrary:sum(lossMatrix)

	cost = cost / numberOfData

	return {cost}
	
end

function DynamicBayesianNetworkModel:predict(stateMatrix)

	local isHidden = self.isHidden

	local ModelParameters = self.ModelParameters
	
	local numberOfStates

	local numberOfObservations
	
	local transitionProbabilityMatrix

	local emissionProbabilityMatrix

	if (not ModelParameters) then
		
		local transitionCountMatrix
		
		local emissionCountMatrix
		
		numberOfStates = #stateMatrix[1]

		local transitionMatrixDimensionSizeArray = {numberOfStates, numberOfStates}

		transitionProbabilityMatrix = AqwamTensorLibrary:createTensor(transitionMatrixDimensionSizeArray)
		
		transitionCountMatrix = AqwamTensorLibrary:createTensor(transitionMatrixDimensionSizeArray)

		if (isHidden) then
			
			numberOfObservations = numberOfStates
			
			local emissionMatrixDimensionSizeArray = {numberOfStates, numberOfObservations}

			emissionProbabilityMatrix = AqwamTensorLibrary:createTensor(emissionMatrixDimensionSizeArray)
			
			emissionCountMatrix = AqwamTensorLibrary:createTensor(emissionMatrixDimensionSizeArray)

		end

		self.ModelParameters = {transitionProbabilityMatrix, emissionProbabilityMatrix, transitionCountMatrix, emissionCountMatrix}

	else

		transitionProbabilityMatrix = ModelParameters[1]
		
		numberOfStates = #transitionProbabilityMatrix
		
		if (isHidden) then
			
			emissionProbabilityMatrix = ModelParameters[2]

			numberOfObservations = #emissionProbabilityMatrix[1]
			
		end

	end

	local selectedMatrix = (isHidden and emissionProbabilityMatrix) or transitionProbabilityMatrix
	
	local resultTensor = AqwamTensorLibrary:dotProduct(stateMatrix, selectedMatrix)
	
	return resultTensor

end

return DynamicBayesianNetworkModel]]></ProtectedString>
									<string name="ScriptGuid">{E4D7208C-95FB-4C79-9692-5B8445C47EE1}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DynamicBayesianNetwork</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7EEC2036B74D4C9A93B0259313BB2540">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GradientMethodBaseModel = require(script.Parent.GradientMethodBaseModel)

ConditionalRandomFieldModel = {}

ConditionalRandomFieldModel.__index = ConditionalRandomFieldModel

setmetatable(ConditionalRandomFieldModel, GradientMethodBaseModel)

local defaultMaximumNumberOfIterations = 500

local defaultLearningRate = 0.1

local defaultAddBias = true

local defaultAddStabilization = true

function ConditionalRandomFieldModel:calculateCost(predictedCurrentStateMatrix, currentStateMatrix)
	
	local logPredictedCurrentStateMatrix = AqwamTensorLibrary:applyFunction(math.log, predictedCurrentStateMatrix)
	
	local costMatrix = AqwamTensorLibrary:multiply(currentStateMatrix, logPredictedCurrentStateMatrix)
	
	local totalCost = -AqwamTensorLibrary:sum(costMatrix)
	
	local Regularizer = self.Regularizer

	if (Regularizer) then totalCost = totalCost + Regularizer:calculateCost(self.ModelParameters) end

	local averageCost = totalCost / #currentStateMatrix

	return averageCost

end

function ConditionalRandomFieldModel:calculateNextStateMatrix(stateMatrix, saveStateMatrix)

	local zMatrix = AqwamTensorLibrary:dotProduct(stateMatrix, self.ModelParameters)
	
	if (self.addStabilization) then

		local maximumZVector = AqwamTensorLibrary:findMaximumValue(zMatrix, 2)

		zMatrix = AqwamTensorLibrary:subtract(zMatrix, maximumZVector)

	end
	
	local exponentMatrix = AqwamTensorLibrary:applyFunction(math.exp, zMatrix)
	
	local sumExponentVector = AqwamTensorLibrary:sum(exponentMatrix, 2)
	
	local nextStateMatrix = AqwamTensorLibrary:divide(exponentMatrix, sumExponentVector)

	if (saveStateMatrix) then 

		self.stateMatrix = stateMatrix

	end

	return nextStateMatrix

end

function ConditionalRandomFieldModel:calculateCostFunctionDerivativeMatrix(lossMatrix)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local stateMatrix = self.stateMatrix

	if (not stateMatrix) then error("State matrix not found.") end

	local costFunctionDerivativeMatrix = AqwamTensorLibrary:dotProduct(AqwamTensorLibrary:transpose(stateMatrix), lossMatrix)

	if (self.areGradientsSaved) then self.Gradients = costFunctionDerivativeMatrix end

	return costFunctionDerivativeMatrix

end

function ConditionalRandomFieldModel:gradientDescent(costFunctionDerivativeMatrix, numberOfData)

	if (type(costFunctionDerivativeMatrix) == "number") then costFunctionDerivativeMatrix = {{costFunctionDerivativeMatrix}} end
	
	local ModelParameters = self.ModelParameters

	local Regularizer = self.Regularizer

	local Optimizer = self.Optimizer

	local learningRate = self.learningRate
	
	if (Regularizer) then

		local regularizationDerivatives = Regularizer:calculate(ModelParameters)

		costFunctionDerivativeMatrix = AqwamTensorLibrary:add(costFunctionDerivativeMatrix, regularizationDerivatives)

	end

	costFunctionDerivativeMatrix = AqwamTensorLibrary:divide(costFunctionDerivativeMatrix, numberOfData)

	if (Optimizer) then

		costFunctionDerivativeMatrix = Optimizer:calculate(learningRate, costFunctionDerivativeMatrix, ModelParameters) 

	else

		costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrix)

	end

	self.ModelParameters = AqwamTensorLibrary:subtract(ModelParameters, costFunctionDerivativeMatrix)

end

function ConditionalRandomFieldModel:update(lossMatrix, clearFeatureMatrix)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local numberOfData = #lossMatrix

	local costFunctionDerivativeMatrix = self:calculateCostFunctionDerivativeMatrix(lossMatrix)

	self:gradientDescent(costFunctionDerivativeMatrix, numberOfData)
	
	if (clearFeatureMatrix) then self.featureMatrix = nil end

end

function ConditionalRandomFieldModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewConditionalRandomFieldModel = GradientMethodBaseModel.new(parameterDictionary)

	setmetatable(NewConditionalRandomFieldModel, ConditionalRandomFieldModel)
	
	NewConditionalRandomFieldModel:setName("ConditionalRandomField")

	NewConditionalRandomFieldModel.learningRate = parameterDictionary.learningRate or defaultLearningRate
	
	NewConditionalRandomFieldModel.addBias = NewConditionalRandomFieldModel:getValueOrDefaultValue(parameterDictionary.addBias, defaultAddBias)
	
	NewConditionalRandomFieldModel.addStabilization = NewConditionalRandomFieldModel:getValueOrDefaultValue(parameterDictionary.addStabilization, defaultAddStabilization)

	NewConditionalRandomFieldModel.Optimizer = parameterDictionary.Optimizer

	NewConditionalRandomFieldModel.Regularizer = parameterDictionary.Regularizer

	return NewConditionalRandomFieldModel

end

function ConditionalRandomFieldModel:setOptimizer(Optimizer)

	self.Optimizer = Optimizer

end

function ConditionalRandomFieldModel:setRegularizer(Regularizer)

	self.Regularizer = Regularizer

end

function ConditionalRandomFieldModel:train(previousStateMatrix, currentStateMatrix)
	
	local numberOfData = #previousStateMatrix

	if (numberOfData ~= #currentStateMatrix) then error("The number of data in the previous state vector is not equal to the number of data in the current state vector.") end
	
	local addBias = self.addBias
	
	local hasBiasValue = (addBias and 1) or 0
	
	local ModelParameters = self.ModelParameters

	local numberOfPreviousStateColumns = #previousStateMatrix[1]

	local numberOfCurrentStateColumns = #currentStateMatrix[1]

	local numberOfStates

	if (not ModelParameters) then

		numberOfStates = numberOfCurrentStateColumns

		self.ModelParameters = self:initializeMatrixBasedOnMode({numberOfStates + hasBiasValue, numberOfStates})
		
	else
		
		numberOfStates = #ModelParameters

	end

	if (numberOfPreviousStateColumns ~= numberOfStates) then
		
		if (addBias) and ((numberOfPreviousStateColumns - numberOfStates) == 1) then
			
			error("The number of previous state columns is not equal to the number of states and bias.") 
			
		else
			
			error("The number of previous state columns is not equal to the number of states.") 
			
		end
		
	end

	if (numberOfCurrentStateColumns ~= numberOfStates) then error("The number of current state columns is not equal to the number of states.") end
	
	local maximumNumberOfIterations = self.maximumNumberOfIterations
	
	local Optimizer = self.Optimizer
	
	local costArray = {}

	local numberOfIterations = 0
	
	local cost
	
	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		local predictedCurrentStateMatrix = self:calculateNextStateMatrix(previousStateMatrix, true)

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return self:calculateCost(predictedCurrentStateMatrix, currentStateMatrix)

		end)

		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end

		local lossVector = AqwamTensorLibrary:subtract(predictedCurrentStateMatrix, currentStateMatrix)

		self:update(lossVector, true)

	until (numberOfIterations == maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)
	
	if (self.isOutputPrinted) then
		
		if (cost == math.huge) then warn("The model diverged.") end
		
		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end
		
	end

	if (Optimizer) and (self.autoResetOptimizers) then Optimizer:reset() end

	return costArray

end

function ConditionalRandomFieldModel:predict(stateMatrix)
	
	if (not self.ModelParameters) then 
		
		local numberOfStates = #stateMatrix[1]
		
		local hasBiasValue = (self.addBias and 1) or 0
		
		self.ModelParameters = self:initializeMatrixBasedOnMode({numberOfStates + hasBiasValue, numberOfStates}) 
		
	end

	local nextStateMatrix = self:calculateNextStateMatrix(stateMatrix, false)

	return nextStateMatrix

end

return ConditionalRandomFieldModel]]></ProtectedString>
									<string name="ScriptGuid">{7287C2B3-A550-46F8-AAB4-F84778D7F590}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ConditionalRandomField</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX229700A510B140A58FC8D17BB514B1C4">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

KalmanFilterModel = {}

KalmanFilterModel.__index = KalmanFilterModel

setmetatable(KalmanFilterModel, BaseModel)

local defaultNoiseValue = 1 -- Do not use very small value for this. It will cause the Mahalanobis distance to have very large values.

local defaultLossFunction = "L2"

local defaultUseJosephForm = true

function KalmanFilterModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewKalmanFilterModel = BaseModel.new(parameterDictionary)

	setmetatable(NewKalmanFilterModel, KalmanFilterModel)

	NewKalmanFilterModel:setName("KalmanFilter")
	
	NewKalmanFilterModel.stateTransitionModelMatrix = parameterDictionary.stateTransitionModelMatrix
	
	NewKalmanFilterModel.observationModelMatrix = parameterDictionary.observationModelMatrix
	
	NewKalmanFilterModel.processNoiseCovarianceMatrix = parameterDictionary.processNoiseCovarianceMatrix
	
	NewKalmanFilterModel.observationNoiseCovarianceMatrix = parameterDictionary.observationNoiseCovarianceMatrix
	
	NewKalmanFilterModel.controlInputMatrix = parameterDictionary.controlInputMatrix
	
	NewKalmanFilterModel.controlVector = parameterDictionary.controlVector
	
	NewKalmanFilterModel.noiseValue = parameterDictionary.noiseValue or defaultNoiseValue
	
	NewKalmanFilterModel.lossFunction = parameterDictionary.lossFunction or defaultLossFunction
	
	NewKalmanFilterModel.useJosephForm = NewKalmanFilterModel:getValueOrDefaultValue(parameterDictionary.useJosephForm, defaultUseJosephForm)

	return NewKalmanFilterModel
	
end

function KalmanFilterModel:train(previousStateMatrix, currentStateMatrix)

	local numberOfData = #previousStateMatrix

	if (numberOfData ~= #currentStateMatrix) then error("The number of data in the previous state vector is not equal to the number of data in the current state vector.") end
	
	local numberOfStates = #previousStateMatrix[1]

	if (numberOfStates ~= #currentStateMatrix[1]) then error("The number of current state columns is not equal to the number of states.") end
	
	local numberOfStatesDimensionSizeArray = {numberOfStates, numberOfStates}
	
	local stateTransitionModelMatrix = self.stateTransitionModelMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray)

	local observationModelMatrix = self.observationModelMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray)
	
	local controlInputMatrix = self.controlInputMatrix

	local controlVector = self.controlVector -- 1 x states
	
	local noiseValue = self.noiseValue
	
	local lossFunction = self.lossFunction
	
	local useJosephForm = self.useJosephForm

	--local observationNoiseMatrix = AqwamTensorLibrary:createRandomNormalTensor(dimensionSizeArray)

	--local processNoiseMatrix = AqwamTensorLibrary:createRandomNormalTensor(dimensionSizeArray)

	local ModelParameters = self.ModelParameters or {}
	
	local priorStateMatrix = ModelParameters[1]
	
	local priorCovarianceMatrix = ModelParameters[2]
	
	local observationNoiseCovarianceMatrix = self.observationNoiseCovarianceMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)

	local processNoiseCovarianceMatrix = self.processNoiseCovarianceMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)
	
	previousStateMatrix = AqwamTensorLibrary:transpose(previousStateMatrix) -- data x states -> states x data
	
	currentStateMatrix = AqwamTensorLibrary:transpose(currentStateMatrix) -- data x states -> states x data
	
	if (not priorStateMatrix) then
		
		local priorStateMatrixPart1 = AqwamTensorLibrary:dotProduct(stateTransitionModelMatrix, previousStateMatrix)
		
		local priorStateMatrixPart2

		if (controlInputMatrix) then

			priorStateMatrixPart2 = AqwamTensorLibrary:dotProduct(controlInputMatrix, controlVector)

		elseif (controlVector) then

			priorStateMatrixPart2 = controlVector

		end
		
		if (priorStateMatrixPart2) then
			
			priorStateMatrix = AqwamTensorLibrary:add(priorStateMatrixPart1, priorStateMatrixPart2)
			
		else
			
			priorStateMatrix = priorStateMatrixPart1
			
		end
		
	end
	
	local transposedStateTransitionModelMatrix = AqwamTensorLibrary:transpose(stateTransitionModelMatrix)
	
	if (not priorCovarianceMatrix) then
		
		local priorCovarianceMatrixPart1 = AqwamTensorLibrary:dotProduct(stateTransitionModelMatrix, stateTransitionModelMatrix, transposedStateTransitionModelMatrix) -- n x n, n x n
		
		priorCovarianceMatrix = AqwamTensorLibrary:add(priorCovarianceMatrixPart1, processNoiseCovarianceMatrix)
		
	end

	local priorCovarianceMatrixPart1 = AqwamTensorLibrary:dotProduct(stateTransitionModelMatrix, priorCovarianceMatrix, transposedStateTransitionModelMatrix) -- n x n, -- n x n

	priorCovarianceMatrix = AqwamTensorLibrary:add(priorCovarianceMatrixPart1, processNoiseCovarianceMatrix)
	
	local transposedObservationModelMatrix = AqwamTensorLibrary:transpose(observationModelMatrix)
	
	local observationMatrix = currentStateMatrix
	
	local innovationMatrixPart1 = AqwamTensorLibrary:dotProduct(observationModelMatrix, priorStateMatrix)
	
	local innovationMatrix = AqwamTensorLibrary:subtract(observationMatrix, innovationMatrixPart1)
	
	local transposedObservationModelMatrix = AqwamTensorLibrary:transpose(observationModelMatrix)
	
	local innovationCovarianceMatrixPart1 = AqwamTensorLibrary:dotProduct(observationModelMatrix, priorCovarianceMatrix, transposedObservationModelMatrix)
	
	local innovationCovarianceMatrix = AqwamTensorLibrary:add(innovationCovarianceMatrixPart1, observationNoiseCovarianceMatrix)
	
	local inverseInnovationCovarianceMatrix = AqwamTensorLibrary:inverse(innovationCovarianceMatrix)
	
	if (not inverseInnovationCovarianceMatrix) then error("Could not find the inverse of innovation covariance matrix.") end
	
	local optimalKalmanGainMatrix = AqwamTensorLibrary:dotProduct(priorCovarianceMatrix, transposedObservationModelMatrix, inverseInnovationCovarianceMatrix)
	
	local posteriorStateMatrixPart1 = AqwamTensorLibrary:dotProduct(optimalKalmanGainMatrix, innovationMatrix)
	
	local posteriorStateMatrix = AqwamTensorLibrary:add(priorStateMatrix, posteriorStateMatrixPart1)
	
	local identityMatrix = AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray)

	local KHMatrix = AqwamTensorLibrary:dotProduct(optimalKalmanGainMatrix, observationModelMatrix)

	local identityMinusKHMatrix = AqwamTensorLibrary:subtract(identityMatrix, KHMatrix)
	
	local posteriorCovarianceMatrix = AqwamTensorLibrary:dotProduct(identityMinusKHMatrix, priorCovarianceMatrix)
	
	if (useJosephForm) then
		
		local transposedIdentityMinusKHMatrix = AqwamTensorLibrary:transpose(identityMinusKHMatrix)

		local josephFormMatrixPart1 = AqwamTensorLibrary:dotProduct(posteriorCovarianceMatrix, transposedIdentityMinusKHMatrix)

		local transposedKalmanGainMatrix = AqwamTensorLibrary:transpose(optimalKalmanGainMatrix)

		local josephFormMatrixPart2 = AqwamTensorLibrary:dotProduct(optimalKalmanGainMatrix, observationNoiseCovarianceMatrix, transposedKalmanGainMatrix)

		posteriorCovarianceMatrix = AqwamTensorLibrary:add(josephFormMatrixPart1, josephFormMatrixPart2)
		
	end

	--[[
	
	local residualMatrixPart1 = AqwamTensorLibrary:dotProduct(observationModelMatrix, observationMatrix)
	
	local residualMatrix = AqwamTensorLibrary:subtract(observationMatrix, residualMatrixPart1)
	
	-- Need to double check this part for calculating covariance matrices.
	
	local transposedResidualMatrix = AqwamTensorLibrary:transpose(residualMatrix)
	
	local dotProductResidualMatrix = AqwamTensorLibrary:dotProduct(transposedResidualMatrix, residualMatrix)
	
	local processNoiseCovarianceMatrixPart1 = AqwamTensorLibrary:dotProduct(stateTransitionModelMatrix, priorCovarianceMatrix, transposedStateTransitionModelMatrix)
	
	processNoiseCovarianceMatrix = AqwamTensorLibrary:subtract(posteriorCovarianceMatrix, processNoiseCovarianceMatrixPart1)
	
	--]]
	
	local meanCorrectionMatrix = AqwamTensorLibrary:mean(posteriorStateMatrixPart1, 2)
	
	self.ModelParameters = {posteriorStateMatrix, posteriorCovarianceMatrix, meanCorrectionMatrix}
	
	-- Returning this as a cost like other models.

	local lossMatrix = innovationMatrix
	
	if (lossFunction == "L1") then
		
		lossMatrix = AqwamTensorLibrary:applyFunction(math.abs, lossMatrix)
		
	elseif (lossFunction == "L2") then
		
		lossMatrix = AqwamTensorLibrary:power(lossMatrix, 2)
		
	elseif (lossFunction  == "Mahalanobis") then
		
		local transposedInnovationMatrix = AqwamTensorLibrary:transpose(innovationMatrix)
		
		lossMatrix = AqwamTensorLibrary:dotProduct(transposedInnovationMatrix, inverseInnovationCovarianceMatrix, innovationMatrix)
		
	else
		
		error("Invalid loss function.")
		
	end
	
	local cost = AqwamTensorLibrary:sum(lossMatrix)
	
	cost = cost / numberOfData

	return {cost}

end

function KalmanFilterModel:predict(stateMatrix)
	
	local controlInputMatrix = self.controlInputMatrix

	local controlVector = self.controlVector -- 1 x states
	
	local ModelParameters = self.ModelParameters or {}

	local meanCorrectionMatrix = ModelParameters[3]
	
	--local processNoiseMatrix = self.processNoiseMatrix
	
	stateMatrix = AqwamTensorLibrary:transpose(stateMatrix)

	local nextStateMatrixPart1 = AqwamTensorLibrary:add(stateMatrix, meanCorrectionMatrix)

	local nextStateMatrixPart2
	
	local nextStateMatrix

	if (controlInputMatrix) then

		nextStateMatrixPart2 = AqwamTensorLibrary:dotProduct(controlInputMatrix, controlVector)

	elseif (controlVector) then

		nextStateMatrixPart2 = controlVector

	end

	if (nextStateMatrixPart2) then

		nextStateMatrix = AqwamTensorLibrary:add(nextStateMatrixPart1, nextStateMatrixPart2)

	else

		nextStateMatrix = nextStateMatrixPart1

	end
	
	nextStateMatrix = AqwamTensorLibrary:transpose(nextStateMatrix)
	
	return nextStateMatrix
	
end

return KalmanFilterModel]]></ProtectedString>
									<string name="ScriptGuid">{220A849D-4D2A-487C-80CA-521D5D171DC8}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">KalmanFilter</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC2FD1DD329514CA497AF17B2731C1531">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

ExtendedKalmanFilterModel = {}

ExtendedKalmanFilterModel.__index = ExtendedKalmanFilterModel

setmetatable(ExtendedKalmanFilterModel, BaseModel)

local defaultNoiseValue = 1 -- Do not use very small value for this. It will cause the Mahalanobis distance to have very large values.

local defaultLossFunction = "L2"

local defaultUseJosephForm = true

local function defaultStateFunction(previousStateMatrix, controlVector) -- states x data, 1 x states
	
	if (not controlVector) then return previousStateMatrix end
	
	return AqwamTensorLibrary:add(previousStateMatrix, controlVector)
	
end

local function defaultObservationStateFunction(stateMatrix) -- states x data

	return stateMatrix

end

local function defaultStateTransitionJacobianFunction(stateMatrix, controlVector) -- states x data, 1 x states
	
	local numberOfStates = #stateMatrix
	
	return AqwamTensorLibrary:createIdentityTensor({numberOfStates, numberOfStates})
	
end

local function defaultObservationJacobianFunction(stateMatrix) -- states x data
	
	return AqwamTensorLibrary:createIdentityTensor({#stateMatrix, #stateMatrix})
	
end

function ExtendedKalmanFilterModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}

	local NewExtendedKalmanFilterModel = BaseModel.new(parameterDictionary)

	setmetatable(NewExtendedKalmanFilterModel, ExtendedKalmanFilterModel)

	NewExtendedKalmanFilterModel:setName("ExtendedKalmanFilter")
	
	NewExtendedKalmanFilterModel.stateTransitionModelMatrix = parameterDictionary.stateTransitionModelMatrix
	
	NewExtendedKalmanFilterModel.observationNoiseCovarianceMatrix = parameterDictionary.observationNoiseCovarianceMatrix
	
	NewExtendedKalmanFilterModel.processNoiseCovarianceMatrix = parameterDictionary.processNoiseCovarianceMatrix
	
	NewExtendedKalmanFilterModel.controlVector = parameterDictionary.controlVector
	
	NewExtendedKalmanFilterModel.noiseValue = parameterDictionary.noiseValue or defaultNoiseValue
	
	NewExtendedKalmanFilterModel.stateFunction = parameterDictionary.stateFunction or defaultStateFunction
	
	NewExtendedKalmanFilterModel.observationStateFunction = parameterDictionary.observationStateFunction or defaultObservationStateFunction
	
	NewExtendedKalmanFilterModel.stateTransitionJacobianFunction = parameterDictionary.stateTransitionJacobianFunction or defaultStateTransitionJacobianFunction
	
	NewExtendedKalmanFilterModel.observationJacobianFunction = parameterDictionary.observationJacobianFunction or defaultObservationJacobianFunction
	
	NewExtendedKalmanFilterModel.lossFunction = parameterDictionary.lossFunction or defaultLossFunction
	
	NewExtendedKalmanFilterModel.useJosephForm = NewExtendedKalmanFilterModel:getValueOrDefaultValue(parameterDictionary.useJosephForm, defaultUseJosephForm)
	
	return NewExtendedKalmanFilterModel
	
end

function ExtendedKalmanFilterModel:train(previousStateMatrix, currentStateMatrix)

	local numberOfData = #previousStateMatrix

	if (numberOfData ~= #currentStateMatrix) then error("The number of data in the previous state vector is not equal to the number of data in the current state vector.") end
	
	local numberOfStates = #previousStateMatrix[1]

	if (numberOfStates ~= #currentStateMatrix[1]) then error("The number of states in the previous state vector is not equal to the number of states in the current state vector.") end
	
	local numberOfStatesDimensionSizeArray = {numberOfStates, numberOfStates}
	
	previousStateMatrix = AqwamTensorLibrary:transpose(previousStateMatrix)
	
	currentStateMatrix = AqwamTensorLibrary:transpose(currentStateMatrix)

	local controlVector = self.controlVector
	
	local noiseValue = self.noiseValue
	
	local lossFunction = self.lossFunction
	
	local useJosephForm = self.useJosephForm
	
	local ModelParameters = self.ModelParameters or {}
	
	local priorStateMatrix = ModelParameters[1] or previousStateMatrix

	local priorCovarianceMatrix = ModelParameters[2] or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray)
	
	local observationNoiseCovarianceMatrix = self.observationNoiseCovarianceMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)

	local processNoiseCovarianceMatrix = self.processNoiseCovarianceMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)

	local predictedStateMatrix = self.stateFunction(priorStateMatrix, controlVector)
	
	local stateTransitionJacobianMatrix = self.stateTransitionJacobianFunction(priorStateMatrix, controlVector)

	local transposedStateTransitionJacobianMatrix = AqwamTensorLibrary:transpose(stateTransitionJacobianMatrix)

	local predictedCovarianceMatrixPart1 = AqwamTensorLibrary:dotProduct(stateTransitionJacobianMatrix, priorCovarianceMatrix, transposedStateTransitionJacobianMatrix)

	local predictedCovarianceMatrix = AqwamTensorLibrary:add(predictedCovarianceMatrixPart1, processNoiseCovarianceMatrix)

	local observationMatrix = self.observationStateFunction(predictedStateMatrix)
	
	local observationJacobianMatrix = self.observationJacobianFunction(predictedStateMatrix)
	
	local transposedObservationJacobianMatrix = AqwamTensorLibrary:transpose(observationJacobianMatrix)

	local innovationMatrix = AqwamTensorLibrary:subtract(currentStateMatrix, observationMatrix)

	local innovationCovarianceMatrixPart1 = AqwamTensorLibrary:dotProduct(observationJacobianMatrix, predictedCovarianceMatrix, transposedObservationJacobianMatrix)

	local innovationCovarianceMatrix = AqwamTensorLibrary:add(innovationCovarianceMatrixPart1, observationNoiseCovarianceMatrix)

	local inverseInnovationCovarianceMatrix = AqwamTensorLibrary:inverse(innovationCovarianceMatrix)

	local kalmanGainMatrix = AqwamTensorLibrary:dotProduct(predictedCovarianceMatrix, transposedObservationJacobianMatrix, inverseInnovationCovarianceMatrix)

	local posteriorStateMatrixPart1 = AqwamTensorLibrary:dotProduct(kalmanGainMatrix, innovationMatrix)
	
	local posteriorStateMatrix = AqwamTensorLibrary:add(predictedStateMatrix, posteriorStateMatrixPart1)

	local identityMatrix = AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray)
	
	local KHMatrix = AqwamTensorLibrary:dotProduct(kalmanGainMatrix, observationJacobianMatrix)
	
	local identityMinusKHMatrix = AqwamTensorLibrary:subtract(identityMatrix, KHMatrix)
	
	local posteriorCovarianceMatrix = AqwamTensorLibrary:dotProduct(identityMinusKHMatrix, priorCovarianceMatrix)

	if (useJosephForm) then

		local transposedIdentityMinusKHMatrix = AqwamTensorLibrary:transpose(identityMinusKHMatrix)

		local josephFormMatrixPart1 = AqwamTensorLibrary:dotProduct(posteriorCovarianceMatrix, transposedIdentityMinusKHMatrix)

		local transposedKalmanGainMatrix = AqwamTensorLibrary:transpose(kalmanGainMatrix)

		local josephFormMatrixPart2 = AqwamTensorLibrary:dotProduct(kalmanGainMatrix, observationNoiseCovarianceMatrix, transposedKalmanGainMatrix)

		posteriorCovarianceMatrix = AqwamTensorLibrary:add(josephFormMatrixPart1, josephFormMatrixPart2)

	end
	
	local meanCorrectionMatrix = AqwamTensorLibrary:mean(posteriorStateMatrixPart1, 2)

	self.ModelParameters = {posteriorStateMatrix, posteriorCovarianceMatrix, meanCorrectionMatrix}
	
	-- Returning this as a cost like other models.
	
	local lossMatrix = innovationMatrix
	
	if (lossFunction == "L1") then
		
		lossMatrix = AqwamTensorLibrary:applyFunction(math.abs, lossMatrix)
		
	elseif (lossFunction == "L2") then
		
		lossMatrix = AqwamTensorLibrary:power(lossMatrix, 2)
		
	elseif (lossFunction  == "Mahalanobis") then
		
		local transposedInnovationMatrix = AqwamTensorLibrary:transpose(innovationMatrix)
		
		lossMatrix = AqwamTensorLibrary:dotProduct(transposedInnovationMatrix, inverseInnovationCovarianceMatrix, innovationMatrix)
		
	else
		
		error("Invalid loss function.")
		
	end
	
	local cost = AqwamTensorLibrary:sum(lossMatrix)
	
	cost = cost / numberOfData
	
	return {cost}

end

function ExtendedKalmanFilterModel:predict(stateMatrix)
	
	local ModelParameters = self.ModelParameters or {}
	
	local meanCorrectionMatrix = ModelParameters[3]
	
	stateMatrix = AqwamTensorLibrary:transpose(stateMatrix)
	
	local nextStateMatrix = self.stateFunction(stateMatrix, self.controlVector)
	
	if (meanCorrectionMatrix) then nextStateMatrix = AqwamTensorLibrary:add(nextStateMatrix, meanCorrectionMatrix) end
	
	nextStateMatrix = AqwamTensorLibrary:transpose(nextStateMatrix)
	
	return nextStateMatrix
	
end

return ExtendedKalmanFilterModel]]></ProtectedString>
									<string name="ScriptGuid">{2DA5DACB-E392-4843-83DB-12B773D90A11}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ExtendedKalmanFilter</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX73D1077E2433419D8025C2F0F83A0484">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

UnscentedKalmanFilterModel = {}

UnscentedKalmanFilterModel.__index = UnscentedKalmanFilterModel

setmetatable(UnscentedKalmanFilterModel, BaseModel)

local defaultAlpha = 1e-3

local defaultBeta = 2

local defaultKappa = 0

local defaultNoiseValue = 1 -- Do not use very small value for this. It will cause the Mahalanobis distance to have very large values.

local defaultLossFunction = "L2"

local function defaultStateTransitionFunction(stateMatrix, deltaTime)
	
	return stateMatrix
	
end

local function defaultObservationFunction(stateMatrix)

	return stateMatrix
	
end

function UnscentedKalmanFilterModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewUKFModel = BaseModel.new(parameterDictionary)
	
	setmetatable(NewUKFModel, UnscentedKalmanFilterModel)
	
	NewUKFModel:setName("UnscentedKalmanFilter")
	
	NewUKFModel.alpha = parameterDictionary.alpha or defaultAlpha
	
	NewUKFModel.beta = parameterDictionary.beta or defaultBeta
	
	NewUKFModel.kappa = parameterDictionary.kappa or defaultKappa

	NewUKFModel.noiseValue = parameterDictionary.noiseValue or defaultNoiseValue
	
	NewUKFModel.lossFunction = parameterDictionary.lossFunction or defaultLossFunction

	NewUKFModel.stateTransitionFunction = parameterDictionary.stateTransitionFunction or defaultStateTransitionFunction
	
	NewUKFModel.observationFunction = parameterDictionary.observationFunction or defaultObservationFunction

	NewUKFModel.processNoiseCovarianceMatrix = parameterDictionary.processNoiseCovarianceMatrix
	
	NewUKFModel.observationNoiseCovarianceMatrix = parameterDictionary.observationNoiseCovarianceMatrix

	return NewUKFModel
end

local function generateSigmaPoints(meanStateMatrix, covarianceMatrix, alpha, kappa)

	local numberOfStates = #meanStateMatrix
	
	local lambdaValue = math.pow(alpha, 2) * (numberOfStates + kappa) - numberOfStates

	local scaledCovarianceMatrix = AqwamTensorLibrary:multiply(covarianceMatrix, (numberOfStates + lambdaValue))

	local squareRootCovarianceMatrix = AqwamTensorLibrary:applyFunction(math.sqrt, scaledCovarianceMatrix)

	local sigmaPointMatrixArray = {}
	
	table.insert(sigmaPointMatrixArray, meanStateMatrix)
	
	local columnVector 
	
	local sigmaPlus
	
	local sigmaMinus

	for i = 1, numberOfStates, 1 do

		columnVector = AqwamTensorLibrary:extract(squareRootCovarianceMatrix, {1, i}, {numberOfStates, i})

		sigmaPlus = AqwamTensorLibrary:add(meanStateMatrix, columnVector)
		
		sigmaMinus = AqwamTensorLibrary:subtract(meanStateMatrix, columnVector)

		table.insert(sigmaPointMatrixArray, sigmaPlus)
		
		table.insert(sigmaPointMatrixArray, sigmaMinus)
		
	end

	return sigmaPointMatrixArray, lambdaValue
	
end

local function calculateWeightedMeanMatrix(matrixArray, weightArray)
	
	local numberOfMatrices = #matrixArray
	
	local weightedMeanMatrix = AqwamTensorLibrary:multiply(matrixArray[1], weightArray[1])
	
	local meanMatrix

	for i = 2, numberOfMatrices do
		
		meanMatrix = AqwamTensorLibrary:multiply(matrixArray[i], weightArray[i])
		
		weightedMeanMatrix = AqwamTensorLibrary:add(weightedMeanMatrix, meanMatrix)
		
	end

	return weightedMeanMatrix
	
end

local function calculateWeightedCovariance(matrixArray, weightArray, meanMatrix)
	
	local weightedCovarianceMatrix
	
	local covarianceMatrixPart1
	
	local transposedCovarianceMatrixPart1
	
	local covarianceMatrixPart2
	
	local covarianceMatrix
	
	for i, matrix in ipairs(matrixArray) do
		
		covarianceMatrixPart1 = AqwamTensorLibrary:subtract(matrix, meanMatrix)
		
		transposedCovarianceMatrixPart1 = AqwamTensorLibrary:transpose(covarianceMatrixPart1)
		
		covarianceMatrixPart2 = AqwamTensorLibrary:dotProduct(covarianceMatrixPart1, transposedCovarianceMatrixPart1)
		
		covarianceMatrix = AqwamTensorLibrary:multiply(weightArray[i], covarianceMatrixPart2)
		
		if (i == 1) then
			
			weightedCovarianceMatrix = covarianceMatrix
			
		else
			
			weightedCovarianceMatrix = AqwamTensorLibrary:add(weightedCovarianceMatrix, covarianceMatrix)
			
		end
		
	end

	return weightedCovarianceMatrix
	
end

local function calculateCrossVariance(stateSigmaMatrixArray, meanStateMatrix, observationSigmaArray, meanObsMatrix, weightArray)
	
	local numberOfSigmaPoints = #stateSigmaMatrixArray

	local crossCovarianceMatrix

	local stateDeviationMatrix

	local observationDeviationMatrix

	local transposedObservationDeviationMatrix

	local weightedCrossMatrixPart1 

	local weightedCrossMatrix

	for i = 1, numberOfSigmaPoints do

		stateDeviationMatrix = AqwamTensorLibrary:subtract(stateSigmaMatrixArray[i], meanStateMatrix)

		observationDeviationMatrix = AqwamTensorLibrary:subtract(observationSigmaArray[i], meanObsMatrix)

		transposedObservationDeviationMatrix = AqwamTensorLibrary:transpose(observationDeviationMatrix)

		weightedCrossMatrixPart1 = AqwamTensorLibrary:dotProduct(stateDeviationMatrix, transposedObservationDeviationMatrix)

		weightedCrossMatrix = AqwamTensorLibrary:multiply(weightArray[i], weightedCrossMatrixPart1)

		if (i == 1) then

			crossCovarianceMatrix = weightedCrossMatrix

		else

			crossCovarianceMatrix = AqwamTensorLibrary:add(crossCovarianceMatrix, weightedCrossMatrix)

		end

	end

	return crossCovarianceMatrix
	
end

function UnscentedKalmanFilterModel:train(previousStateMatrix, currentStateMatrix)
	
	local numberOfData = #previousStateMatrix

	if (numberOfData ~= #currentStateMatrix) then error("The number of data in the previous state vector is not equal to the number of data in the current state vector.") end

	local numberOfStates = #previousStateMatrix[1]

	if (numberOfStates ~= #currentStateMatrix[1]) then error("The number of states in the previous state vector is not equal to the number of states in the current state vector.") end

	local numberOfStatesDimensionSizeArray = {numberOfStates, numberOfStates}
	
	previousStateMatrix = AqwamTensorLibrary:transpose(previousStateMatrix)

	currentStateMatrix = AqwamTensorLibrary:transpose(currentStateMatrix)
	
	local alpha = self.alpha

	local beta = self.beta

	local kappa = self.kappa

	local noiseValue = self.noiseValue

	local lossFunction = self.lossFunction
	
	local stateTransitionFunction = self.stateTransitionFunction
	
	local observationFunction = self.observationFunction
	
	local processNoiseCovarianceMatrix = self.processNoiseCovarianceMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)
	
	local observationNoiseCovarianceMatrix = self.observationNoiseCovarianceMatrix or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)

	local ModelParameters = self.ModelParameters or {}
	
	local priorMeanStateMatrix = ModelParameters[1] or previousStateMatrix
	
	local priorCovarianceMatrix = ModelParameters[2] or AqwamTensorLibrary:createIdentityTensor(numberOfStatesDimensionSizeArray, noiseValue)

	local sigmaPointMatrixArray, lambdaValue = generateSigmaPoints(priorMeanStateMatrix, priorCovarianceMatrix, alpha, kappa)
	
	local numberOfSigmaPoints = #sigmaPointMatrixArray

	local weightMeanArray = {}
	
	local weightCovarianceArray = {}

	weightMeanArray[1] = lambdaValue / (numberOfStates + lambdaValue)
	
	weightCovarianceArray[1] = weightMeanArray[1] + (1 - alpha^2 + beta)

	for i = 2, numberOfSigmaPoints, 1 do
		
		weightMeanArray[i] = 1 / (2 * (numberOfStates + lambdaValue))
		
		weightCovarianceArray[i] = weightMeanArray[i]
		
	end

	local predictedSigmaPointMatrixArray = {}
	
	for i, sigmaPointMatrix in ipairs(sigmaPointMatrixArray) do
		
		predictedSigmaPointMatrixArray[i] = stateTransitionFunction(sigmaPointMatrix)
		
	end

	local predictedMeanStateMatrix = calculateWeightedMeanMatrix(predictedSigmaPointMatrixArray, weightMeanArray)
	
	local predictedCovarianceMatrix = calculateWeightedCovariance(predictedSigmaPointMatrixArray, weightCovarianceArray, predictedMeanStateMatrix)
	
	predictedCovarianceMatrix = AqwamTensorLibrary:add(predictedCovarianceMatrix, processNoiseCovarianceMatrix)

	local predictedObservationSigmaPointsArray = {}
	
	for i, predictedSigmaPointMatrix in ipairs(predictedSigmaPointMatrixArray) do
		
		predictedObservationSigmaPointsArray[i] = observationFunction(predictedSigmaPointMatrix)
		
	end

	local predictedMeanObservationMatrix = calculateWeightedMeanMatrix(predictedObservationSigmaPointsArray, weightMeanArray)
	
	local innovationCovarianceMatrix = calculateWeightedCovariance(predictedObservationSigmaPointsArray, weightCovarianceArray, predictedMeanObservationMatrix)
	
	innovationCovarianceMatrix = AqwamTensorLibrary:add(innovationCovarianceMatrix, observationNoiseCovarianceMatrix)

	local crossCovarianceMatrix = calculateCrossVariance(predictedSigmaPointMatrixArray, predictedMeanStateMatrix, predictedObservationSigmaPointsArray, predictedMeanObservationMatrix, weightCovarianceArray)

	local inverseInnovationCovarianceMatrix = AqwamTensorLibrary:inverse(innovationCovarianceMatrix)
	
	local kalmanGainMatrix = AqwamTensorLibrary:dotProduct(crossCovarianceMatrix, inverseInnovationCovarianceMatrix)

	local innovationMatrix = AqwamTensorLibrary:subtract(currentStateMatrix, predictedMeanObservationMatrix)
	
	local posteriorStateMatrixPart1 = AqwamTensorLibrary:dotProduct(kalmanGainMatrix, innovationMatrix)
	
	local posteriorMeanStateMatrix = AqwamTensorLibrary:add(posteriorStateMatrixPart1, predictedMeanStateMatrix)
	
	local transposedKalmanGainMatrix = AqwamTensorLibrary:transpose(kalmanGainMatrix)
	
	local posteriorCovarianceMatrixPart1 = AqwamTensorLibrary:dotProduct(kalmanGainMatrix, inverseInnovationCovarianceMatrix, transposedKalmanGainMatrix)

	local posteriorCovarianceMatrix = AqwamTensorLibrary:subtract(priorCovarianceMatrix, posteriorCovarianceMatrixPart1)
	
	local meanCorrectionMatrix = AqwamTensorLibrary:mean(posteriorStateMatrixPart1, 2)

	self.ModelParameters = {posteriorMeanStateMatrix, posteriorCovarianceMatrix, meanCorrectionMatrix}

	-- Returning this as a cost like other models.
	
	local lossMatrix = innovationMatrix

	if (lossFunction == "L1") then

		lossMatrix = AqwamTensorLibrary:applyFunction(math.abs, lossMatrix)

	elseif (lossFunction == "L2") then

		lossMatrix = AqwamTensorLibrary:power(lossMatrix, 2)

	elseif (lossFunction  == "Mahalanobis") then

		local transposedInnovationMatrix = AqwamTensorLibrary:transpose(innovationMatrix)

		lossMatrix = AqwamTensorLibrary:dotProduct(transposedInnovationMatrix, inverseInnovationCovarianceMatrix, innovationMatrix)

	else

		error("Invalid loss function.")

	end

	local cost = AqwamTensorLibrary:sum(lossMatrix)

	cost = cost / numberOfData

	return {cost}
	
end

function UnscentedKalmanFilterModel:predict(stateMatrix)
	
	local ModelParameters = self.ModelParameters or {}

	local meanCorrectionMatrix = ModelParameters[3]

	stateMatrix = AqwamTensorLibrary:transpose(stateMatrix)

	local nextStateMatrix = self.stateTransitionFunction(stateMatrix)

	if (meanCorrectionMatrix) then nextStateMatrix = AqwamTensorLibrary:add(nextStateMatrix, meanCorrectionMatrix) end

	nextStateMatrix = AqwamTensorLibrary:transpose(nextStateMatrix)

	return nextStateMatrix
	
end

return UnscentedKalmanFilterModel]]></ProtectedString>
									<string name="ScriptGuid">{A479976A-BED5-4D67-AB8D-3BABEFC83CA0}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UnscentedKalmanFilter</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1E5ABE4DDA2546338F18F38FF3E87402">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local NaiveBayesBaseModel = require(script.Parent.NaiveBayesBaseModel)

BernoulliNaiveBayesModel = {}

BernoulliNaiveBayesModel.__index = BernoulliNaiveBayesModel

setmetatable(BernoulliNaiveBayesModel, NaiveBayesBaseModel)

local defaultMode = "Hybrid"

local function calculateBernoulliProbability(useLogProbabilities, featureVector, featureProbabilityVector)

	local bernoulliProbability = (useLogProbabilities and 0) or 1

	local functionToApply = function(featureValue, featureProbabilityValue) return (featureProbabilityValue * math.pow((1 - featureProbabilityValue), (1 - featureValue))) end

	local bernoulliProbabilityVector = AqwamTensorLibrary:applyFunction(functionToApply, featureVector, featureProbabilityVector)
	
	if (useLogProbabilities) then

		bernoulliProbabilityVector = AqwamTensorLibrary:applyFunction(math.log, bernoulliProbabilityVector)

	end

	for column = 1, #bernoulliProbabilityVector[1], 1 do

		if (useLogProbabilities) then

			bernoulliProbability = bernoulliProbability + bernoulliProbabilityVector[1][column]

		else

			bernoulliProbability = bernoulliProbability * bernoulliProbabilityVector[1][column]

		end

	end

	return bernoulliProbability

end

local function calculatePosteriorProbability(useLogProbabilities, featureVector, featureProbabilityVector, priorProbabilityValue)

	local posteriorProbability

	local likelihoodProbability = calculateBernoulliProbability(useLogProbabilities, featureVector, featureProbabilityVector)

	if (useLogProbabilities) then

		posteriorProbability = likelihoodProbability + priorProbabilityValue

	else

		posteriorProbability = likelihoodProbability * priorProbabilityValue

	end

	return posteriorProbability

end

function BernoulliNaiveBayesModel:calculateCost(featureMatrix, labelMatrix)
	
	local useLogProbabilities = self.useLogProbabilities

	local ClassesList = self.ClassesList

	local ModelParameters = self.ModelParameters
	
	local featureProbabilityMatrix = ModelParameters[1]

	local priorProbabilityVector = ModelParameters[2]

	local posteriorProbabilityVector = {}

	local numberOfData = #featureMatrix

	local numberOfClasses = #ClassesList

	local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfClasses}, 0)

	local featureVector

	local featureProbabilityVector

	local priorProbabilityValue

	for data, unwrappedFeatureVector in ipairs(featureMatrix) do

		featureVector = {unwrappedFeatureVector}

		for class = 1, numberOfClasses, 1 do

			featureProbabilityVector = {featureProbabilityMatrix[class]}

			priorProbabilityValue = priorProbabilityVector[class][1]

			posteriorProbabilityMatrix[data][class] = calculatePosteriorProbability(useLogProbabilities, featureVector, featureProbabilityVector, priorProbabilityValue)

		end

	end

	if (useLogProbabilities) then

		posteriorProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, posteriorProbabilityMatrix)

	end

	local cost = self:categoricalCrossEntropy(labelMatrix, posteriorProbabilityMatrix)

	return cost

end

local function calculateMatrices(extractedFeatureMatrixTable, numberOfData, featureProbabilityMatrix, priorProbabilityVector, numberOfDataPointVector)
	
	local sumMatrix = AqwamTensorLibrary:multiply(featureProbabilityMatrix, numberOfDataPointVector)

	local newTotalNumberOfDataPoint = numberOfData + AqwamTensorLibrary:sum(numberOfDataPointVector)

	local newFeatureProbabilityMatrix = {}

	local newNumberOfDataPointVector = {}
	
	local numberOfOldSubData

	local numberOfSubData
	
	local subSumVector
	
	local sumVector

	local featureProbabilityVector

	for classIndex, extractedFeatureMatrix in ipairs(extractedFeatureMatrixTable) do
		
		numberOfOldSubData = numberOfDataPointVector[classIndex][1]
		
		if (type(extractedFeatureMatrix) == "table") then
			
			numberOfSubData = (#extractedFeatureMatrix + numberOfOldSubData)
			
			subSumVector = AqwamTensorLibrary:sum(extractedFeatureMatrix, 1)

			sumVector = {sumMatrix[classIndex]}

			sumVector = AqwamTensorLibrary:add(sumVector, subSumVector)

			featureProbabilityVector = AqwamTensorLibrary:divide(sumVector, numberOfSubData)
			
			newFeatureProbabilityMatrix[classIndex] = featureProbabilityVector[1]
			
		else
			
			numberOfSubData = numberOfOldSubData
			
			newFeatureProbabilityMatrix[classIndex] = featureProbabilityMatrix[classIndex]
			
		end
		
		newNumberOfDataPointVector[classIndex] = {numberOfSubData}

	end
	
	local newPriorProbabilityVector = AqwamTensorLibrary:divide(newNumberOfDataPointVector, newTotalNumberOfDataPoint)

	return newFeatureProbabilityMatrix, newPriorProbabilityVector, newNumberOfDataPointVector

end

function BernoulliNaiveBayesModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewBernoulliNaiveBayesModel = NaiveBayesBaseModel.new(parameterDictionary)

	setmetatable(NewBernoulliNaiveBayesModel, BernoulliNaiveBayesModel)
	
	NewBernoulliNaiveBayesModel:setName("BernoulliNaiveBayes")
	
	NewBernoulliNaiveBayesModel.mode = parameterDictionary.mode or defaultMode
	
	NewBernoulliNaiveBayesModel:setTrainFunction(function(featureMatrix, labelVector)
		
		local mode = NewBernoulliNaiveBayesModel.mode

		local useLogProbabilities = NewBernoulliNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewBernoulliNaiveBayesModel.ModelParameters or {}

		local featureProbabilityMatrix = ModelParameters[1]

		local priorProbabilityVector = ModelParameters[2]

		local numberOfDataPointVector = ModelParameters[3]

		if (mode == "Hybrid") then

			mode = (featureProbabilityMatrix and priorProbabilityVector and numberOfDataPointVector and "Online") or "Offline"		

		end

		if (mode == "Offline") then

			featureProbabilityMatrix = nil
			
			priorProbabilityVector = nil
			
			numberOfDataPointVector = nil

		end
		
		local numberOfData = #featureMatrix

		local numberOfFeatures = #featureMatrix[1]
		
		local numberOfClasses = #NewBernoulliNaiveBayesModel.ClassesList

		local zeroValue = (useLogProbabilities and -math.huge) or 0

		local oneValue = (useLogProbabilities and 0) or 1

		local classVectorDimensionSizeArray = {numberOfClasses, 1}
		
		local logisticMatrix = NewBernoulliNaiveBayesModel:convertLabelVectorToLogisticMatrix(labelVector)

		local extractedFeatureMatrixTable = NewBernoulliNaiveBayesModel:separateFeatureMatrixByClass(featureMatrix, logisticMatrix)

		featureProbabilityMatrix = featureProbabilityMatrix or AqwamTensorLibrary:createTensor({numberOfClasses, numberOfFeatures}, zeroValue)

		priorProbabilityVector = priorProbabilityVector or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, oneValue)

		numberOfDataPointVector = numberOfDataPointVector or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, 0)
		
		if (useLogProbabilities) then

			if (featureProbabilityMatrix) then featureProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, featureProbabilityMatrix) end

			if (priorProbabilityVector) then priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.exp, priorProbabilityVector) end

		end
		
		featureProbabilityMatrix, priorProbabilityVector, numberOfDataPointVector = calculateMatrices(extractedFeatureMatrixTable, numberOfData, featureProbabilityMatrix, priorProbabilityVector, numberOfDataPointVector)
		
		if (useLogProbabilities) then

			featureProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.log, featureProbabilityMatrix)

			priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.log, priorProbabilityVector)

		end
		
		numberOfDataPointVector = NewBernoulliNaiveBayesModel:resetNumberOfDataPointsOnReachingLimit(numberOfDataPointVector)

		NewBernoulliNaiveBayesModel.ModelParameters = {featureProbabilityMatrix, priorProbabilityVector, numberOfDataPointVector}

		local cost = NewBernoulliNaiveBayesModel:calculateCost(featureMatrix, logisticMatrix)

		return {cost}
		
	end)
	
	NewBernoulliNaiveBayesModel:setPredictFunction(function(featureMatrix, returnOriginalOutput)

		local ClassesList = NewBernoulliNaiveBayesModel.ClassesList

		local useLogProbabilities = NewBernoulliNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewBernoulliNaiveBayesModel.ModelParameters

		local numberOfClasses = #ClassesList

		local numberOfData = #featureMatrix

		local posteriorProbabilityMatrixDimensionSizeArray = {numberOfData, numberOfClasses}

		local initialValue = (useLogProbabilities and -math.huge) or 0

		if (not ModelParameters) then

			if (returnOriginalOutput) then return AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, initialValue) end

			local dimensionSizeArray = {numberOfData, 1}

			local placeHolderLabelVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, nil)

			local placeHolderLabelProbabilityVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, initialValue)

			return placeHolderLabelVector, placeHolderLabelProbabilityVector

		end
		
		local featureProbabilityMatrix = ModelParameters[1]
		
		local priorProbabilityVector = ModelParameters[2]

		local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, initialValue)

		for classIndex, classValue in ipairs(ClassesList) do

			local featureProbabilityVector = {featureProbabilityMatrix[classIndex]}

			local priorProbabilityValue = priorProbabilityVector[classIndex][1]

			for i = 1, numberOfData, 1 do

				local featureVector = {featureMatrix[i]}

				posteriorProbabilityMatrix[i][classIndex] = calculatePosteriorProbability(useLogProbabilities, featureVector, featureProbabilityVector, priorProbabilityValue)

			end

		end

		if (returnOriginalOutput) then return posteriorProbabilityMatrix end

		return NewBernoulliNaiveBayesModel:getLabelFromOutputMatrix(posteriorProbabilityMatrix)
		
	end)
	
	NewBernoulliNaiveBayesModel:setGenerateFunction(function(labelVector, noiseMatrix)
		
		local numberOfData = #labelVector

		if (noiseMatrix) then

			if (numberOfData ~= #noiseMatrix) then error("The label vector and the noise matrix does not contain the same number of rows.") end

		end

		local ClassesList = NewBernoulliNaiveBayesModel.ClassesList

		local useLogProbabilities = NewBernoulliNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewBernoulliNaiveBayesModel.ModelParameters
		
		local featureProbabilityMatrix = ModelParameters[1]
		
		local numberOfFeatures = #featureProbabilityMatrix[1]
		
		local selectedFeatureProbabiltyMatrix = {}
		
		if (useLogProbabilities) then

			featureProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, featureProbabilityMatrix)

		end
		
		for data, unwrappedLabelVector in ipairs(labelVector) do

			local label = unwrappedLabelVector[1]

			local classIndex = table.find(ClassesList, label)

			if (classIndex) then
				
				selectedFeatureProbabiltyMatrix[data] = featureProbabilityMatrix[classIndex]
				
			else
				
				selectedFeatureProbabiltyMatrix[data] = table.create(numberOfFeatures, 0)

			end

		end
		
		noiseMatrix = noiseMatrix or AqwamTensorLibrary:createRandomUniformTensor({numberOfData, numberOfFeatures})
		
		local binaryProbabilityFunction = function(noiseProbability, featureProbability) return ((noiseProbability < featureProbability) and 1) or 0 end
		
		local generatedFeatureMatrix = AqwamTensorLibrary:applyFunction(binaryProbabilityFunction, noiseMatrix, selectedFeatureProbabiltyMatrix)

		return generatedFeatureMatrix

	end)

	return NewBernoulliNaiveBayesModel

end

return BernoulliNaiveBayesModel]]></ProtectedString>
									<string name="ScriptGuid">{B2348B28-3282-463B-8122-1FF7E6E23190}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BernoulliNaiveBayes</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8EDAF598961F43FF8D121030770F2CBF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local NaiveBayesBaseModel = require(script.Parent.NaiveBayesBaseModel)

CategoricalNaiveBayesModel = {}

CategoricalNaiveBayesModel.__index = CategoricalNaiveBayesModel

setmetatable(CategoricalNaiveBayesModel, NaiveBayesBaseModel)

local defaultMode = "Hybrid"

local function applyFunctionToDictionaryArrayArray(functionToApply, dictionaryArrayArray)
	
	local newDictionaryArrayArray = {}
	
	for classIndex, featureDictionaryArray in ipairs(dictionaryArrayArray) do
		
		local newFeatureDictionaryArray = {}
		
		for featureIndex, featureDictionary in ipairs(featureDictionaryArray) do
			
			local newFeatureDictionary = {}
			
			for key, value in pairs(featureDictionary) do
				
				newFeatureDictionary[key] = functionToApply(value)
				
			end
			
			newFeatureDictionaryArray[featureIndex] = newFeatureDictionary
			
		end
		
		newDictionaryArrayArray[classIndex] = newFeatureDictionaryArray
		
	end
	
	return newDictionaryArrayArray
end

local function calculateCategoricalProbability(useLogProbabilities, featureTable, featureProbabilityDictionaryArray)
	
	local probabilityInitialization = (useLogProbabilities and 0) or 1
	
	local categoricalProbability = probabilityInitialization
	
	for f, value in ipairs(featureTable) do
		
		local featureProbability = featureProbabilityDictionaryArray[f][value] or probabilityInitialization
		
		if (useLogProbabilities) then

			categoricalProbability = categoricalProbability + math.log(featureProbability)

		else

			categoricalProbability = categoricalProbability * featureProbability

		end
		
	end
	
	return categoricalProbability
	
end

local function calculatePosteriorProbability(useLogProbabilities, featureTable, featureProbabilityDictionaryArray, priorProbabilityValue)

	local posteriorProbability

	local likelihoodProbability = calculateCategoricalProbability(useLogProbabilities, featureTable, featureProbabilityDictionaryArray)

	if (useLogProbabilities) then

		posteriorProbability = likelihoodProbability + priorProbabilityValue

	else

		posteriorProbability = likelihoodProbability * priorProbabilityValue

	end

	return posteriorProbability

end

function CategoricalNaiveBayesModel:calculateCost(featureMatrix, labelMatrix)

	local useLogProbabilities = self.useLogProbabilities

	local ClassesList = self.ClassesList

	local ModelParameters = self.ModelParameters

	local featureProbabilityDictionaryArrayArray = ModelParameters[1]

	local priorProbabilityVector = ModelParameters[2]

	local numberOfData = #featureMatrix

	local numberOfClasses = #ClassesList

	local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfClasses}, 0)

	local featureProbabilityDictionaryArray

	local priorProbabilityValue

	local posteriorProbabilityValue

	local classIndex

	local label
	
	for data, featureTable in ipairs(featureMatrix) do

		for class = 1, numberOfClasses, 1 do

			featureProbabilityDictionaryArray = featureProbabilityDictionaryArrayArray[class]

			priorProbabilityValue = priorProbabilityVector[class][1]

			posteriorProbabilityMatrix[data][class] = calculatePosteriorProbability(useLogProbabilities, featureTable, featureProbabilityDictionaryArray, priorProbabilityValue)

		end

	end

	if (useLogProbabilities) then

		posteriorProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, posteriorProbabilityMatrix)

	end

	local cost = self:categoricalCrossEntropy(labelMatrix, posteriorProbabilityMatrix)

	return cost

end

local function calculateMatrices(extractedFeatureMatrixTable, numberOfData, numberOfFeatures, featureProbabilityDictionaryArrayArray, priorProbabilityVector, numberOfDataPointVector)
	
	local newTotalNumberOfDataPoint = numberOfData + AqwamTensorLibrary:sum(numberOfDataPointVector)
	
	local newFeatureProbabilityDictionaryArrayArray = {}

	local newNumberOfDataPointVector = {}
	
	local featureProbabilityDictionaryArray
	
	local numberOfOldSubData

	local numberOfSubData
	
	local newFeatureDictionaryArray
	
	local newFeatureDictionary

	for classIndex, extractedFeatureMatrix in ipairs(extractedFeatureMatrixTable) do
		
		numberOfOldSubData = numberOfDataPointVector[classIndex][1]
		
		featureProbabilityDictionaryArray = featureProbabilityDictionaryArrayArray[classIndex]

		newFeatureDictionaryArray = {}

		if (type(extractedFeatureMatrix) == "table") then

			numberOfSubData = (#extractedFeatureMatrix + numberOfOldSubData)
			
			for featureColumn, featureProbabilityDictionary in ipairs(featureProbabilityDictionaryArray) do

				newFeatureDictionary = {}

				for featureKey, featureProbability in pairs(featureProbabilityDictionary) do newFeatureDictionary[featureKey] = featureProbability * numberOfOldSubData end

				newFeatureDictionaryArray[featureColumn] = newFeatureDictionary

			end

			for _, unwrappedFeatureVector in ipairs(extractedFeatureMatrix) do

				for featureIndex, featureValue in ipairs(unwrappedFeatureVector) do

					newFeatureDictionary = newFeatureDictionaryArray[featureIndex] or {}

					newFeatureDictionary[featureValue] = (newFeatureDictionary[featureValue] or 0) + 1
					
					newFeatureDictionaryArray[featureIndex] = newFeatureDictionary
					
				end

			end
			
			local newFeatureProbabilityDictionaryArray = {}

			for featureColumn, newFeatureDictionary in ipairs(newFeatureDictionaryArray) do

				local newFeatureProbabilityDictionary = {} 

				for featureKey, featureValue in pairs(newFeatureDictionary) do

					newFeatureProbabilityDictionary[featureKey] = featureValue / numberOfSubData

				end

				newFeatureProbabilityDictionaryArray[featureColumn] = newFeatureProbabilityDictionary

			end
			
			newFeatureProbabilityDictionaryArrayArray[classIndex] = newFeatureProbabilityDictionaryArray

		else

			numberOfSubData = numberOfOldSubData
			
			newFeatureProbabilityDictionaryArrayArray[classIndex] = featureProbabilityDictionaryArray

		end

		newNumberOfDataPointVector[classIndex] = {numberOfSubData}

	end
	
	local newPriorProbabilityVector = AqwamTensorLibrary:divide(newNumberOfDataPointVector, newTotalNumberOfDataPoint)

	return newFeatureProbabilityDictionaryArrayArray, newPriorProbabilityVector, newNumberOfDataPointVector

end

function CategoricalNaiveBayesModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewCategoricalNaiveBayesModel = NaiveBayesBaseModel.new(parameterDictionary)

	setmetatable(NewCategoricalNaiveBayesModel, CategoricalNaiveBayesModel)

	NewCategoricalNaiveBayesModel:setName("CategoricalNaiveBayes")

	NewCategoricalNaiveBayesModel.mode = parameterDictionary.mode or defaultMode

	NewCategoricalNaiveBayesModel:setTrainFunction(function(featureMatrix, labelVector)

		local mode = NewCategoricalNaiveBayesModel.mode

		local useLogProbabilities = NewCategoricalNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewCategoricalNaiveBayesModel.ModelParameters or {}

		local featureProbabilityDictionaryArrayArray = ModelParameters[1]

		local priorProbabilityVector = ModelParameters[2]

		local numberOfDataPointVector = ModelParameters[3]

		if (mode == "Hybrid") then

			mode = (featureProbabilityDictionaryArrayArray and priorProbabilityVector and numberOfDataPointVector and "Online") or "Offline"		

		end

		if (mode == "Offline") then
			
			featureProbabilityDictionaryArrayArray = nil

			priorProbabilityVector = nil
			
			numberOfDataPointVector = nil

		end
		
		local numberOfData = #featureMatrix

		local numberOfFeatures = #featureMatrix[1]
		
		local numberOfClasses = #NewCategoricalNaiveBayesModel.ClassesList

		local oneValue = (useLogProbabilities and 0) or 1
		
		local logisticMatrix = NewCategoricalNaiveBayesModel:convertLabelVectorToLogisticMatrix(labelVector)

		local extractedFeatureMatrixTable = NewCategoricalNaiveBayesModel:separateFeatureMatrixByClass(featureMatrix, logisticMatrix)
		
		if (not featureProbabilityDictionaryArrayArray) then

			featureProbabilityDictionaryArrayArray = {}

			for class = 1, numberOfClasses, 1 do

				local featureDictionaryArray = {}

				for feature = 1, numberOfFeatures, 1 do

					featureDictionaryArray[numberOfFeatures] = {}

				end

				featureProbabilityDictionaryArrayArray[class] = featureDictionaryArray

			end

		end

		priorProbabilityVector = priorProbabilityVector or AqwamTensorLibrary:createTensor({numberOfClasses, 1}, oneValue)

		numberOfDataPointVector = numberOfDataPointVector or AqwamTensorLibrary:createTensor({numberOfClasses, 1}, 0)

		if (useLogProbabilities) then

			if (featureProbabilityDictionaryArrayArray) then featureProbabilityDictionaryArrayArray = applyFunctionToDictionaryArrayArray(math.exp, featureProbabilityDictionaryArrayArray) end

			if (priorProbabilityVector) then priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.exp, priorProbabilityVector) end

		end

		featureProbabilityDictionaryArrayArray, priorProbabilityVector, numberOfDataPointVector = calculateMatrices(extractedFeatureMatrixTable, numberOfData, numberOfFeatures, featureProbabilityDictionaryArrayArray, priorProbabilityVector, numberOfDataPointVector)

		if (useLogProbabilities) then

			featureProbabilityDictionaryArrayArray = applyFunctionToDictionaryArrayArray(math.log, featureProbabilityDictionaryArrayArray)

			priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.log, priorProbabilityVector)

		end
		
		numberOfDataPointVector = NewCategoricalNaiveBayesModel:resetNumberOfDataPointsOnReachingLimit(numberOfDataPointVector)

		NewCategoricalNaiveBayesModel.ModelParameters = {featureProbabilityDictionaryArrayArray, priorProbabilityVector, numberOfDataPointVector}

		local cost = NewCategoricalNaiveBayesModel:calculateCost(featureMatrix, logisticMatrix)

		return {cost}

	end)

	NewCategoricalNaiveBayesModel:setPredictFunction(function(featureMatrix, returnOriginalOutput)

		local ClassesList = NewCategoricalNaiveBayesModel.ClassesList

		local useLogProbabilities = NewCategoricalNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewCategoricalNaiveBayesModel.ModelParameters

		local numberOfClasses = #ClassesList

		local numberOfData = #featureMatrix

		local posteriorProbabilityMatrixDimensionSizeArray = {numberOfData, numberOfClasses}

		local initialValue = (useLogProbabilities and -math.huge) or 0

		if (not ModelParameters) then

			if (returnOriginalOutput) then return AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, initialValue) end

			local dimensionSizeArray = {numberOfData, 1}

			local placeHolderLabelVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, nil)

			local placeHolderLabelProbabilityVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, initialValue)

			return placeHolderLabelVector, placeHolderLabelProbabilityVector

		end

		local featureProbabilityDictionaryArrayArray = ModelParameters[1]

		local priorProbabilityVector = ModelParameters[2]

		local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, 0)
		
		local featureProbabilityDictionaryArray
		
		local priorProbabilityValue

		for data, featureTable in ipairs(featureMatrix) do

			for class = 1, numberOfClasses, 1 do

				featureProbabilityDictionaryArray = featureProbabilityDictionaryArrayArray[class]

				priorProbabilityValue = priorProbabilityVector[class][1]

				posteriorProbabilityMatrix[data][class] = calculatePosteriorProbability(useLogProbabilities, featureTable, featureProbabilityDictionaryArray, priorProbabilityValue)

			end

		end

		if (returnOriginalOutput) then return posteriorProbabilityMatrix end

		return NewCategoricalNaiveBayesModel:getLabelFromOutputMatrix(posteriorProbabilityMatrix)

	end)

	NewCategoricalNaiveBayesModel:setGenerateFunction(function(labelVector, noiseMatrix)

		local numberOfData = #labelVector
		
		if (noiseMatrix) then

			if (numberOfData ~= #noiseMatrix) then error("The label vector and the noise matrix does not contain the same number of rows.") end

		end

		local ClassesList = NewCategoricalNaiveBayesModel.ClassesList

		local useLogProbabilities = NewCategoricalNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewCategoricalNaiveBayesModel.ModelParameters

		local featureProbabilityDictionaryArrayArray = ModelParameters[1]

		local numberOfFeatures = #featureProbabilityDictionaryArrayArray[1]

		local generatedFeatureMatrix = {}
		
		noiseMatrix = noiseMatrix or AqwamTensorLibrary:createRandomUniformTensor({numberOfData, numberOfFeatures})

		if (useLogProbabilities) then

			featureProbabilityDictionaryArrayArray = applyFunctionToDictionaryArrayArray(math.exp, featureProbabilityDictionaryArrayArray)

		end

		for data, unwrappedLabelVector in ipairs(labelVector) do

			local label = unwrappedLabelVector[1]
			
			local classIndex = table.find(ClassesList, label)
			
			local generatedFeatureVector

			if (classIndex) then
				
				local featureProbabilityDictionaryArray = featureProbabilityDictionaryArrayArray[classIndex]

				generatedFeatureVector = {}

				for featureIndex, featureProbabilityDictionary in ipairs(featureProbabilityDictionaryArray) do

					-- Sample from categorical distribution.
					
					local randomProbability = noiseMatrix[data][featureIndex]
					
					local cumulativeProbability = 0
					
					local chosenValue

					for value, featureProbability in pairs(featureProbabilityDictionary) do
						
						cumulativeProbability = cumulativeProbability + featureProbability
						
						if (randomProbability <= cumulativeProbability) then
							
							chosenValue = value
							
							break
							
						end
						
					end
					
					generatedFeatureVector[featureIndex] = chosenValue
					
				end
				
			else
				
				generatedFeatureVector = table.create(numberOfFeatures, 0)
				
			end
			
			generatedFeatureMatrix[data] = generatedFeatureVector

		end

		return generatedFeatureMatrix

	end)

	return NewCategoricalNaiveBayesModel

end

return CategoricalNaiveBayesModel]]></ProtectedString>
									<string name="ScriptGuid">{F295D4BE-99DD-4F54-A0B8-8A2EB68B96A3}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">CategoricalNaiveBayes</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD34D94BEBB3B4CD586F544712DBED7E8">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local NaiveBayesBaseModel = require(script.Parent.NaiveBayesBaseModel)

ComplementNaiveBayesModel = {}

ComplementNaiveBayesModel.__index = ComplementNaiveBayesModel

setmetatable(ComplementNaiveBayesModel, NaiveBayesBaseModel)

local defaultMode = "Hybrid"

local function sampleMultinomial(probabilityArray, totalCount)

	local numberOfProbabilities = #probabilityArray

	local remainingCount = totalCount

	local featureArray = {}

	for i, p in ipairs(probabilityArray) do

		local count = math.floor(p * totalCount + 0.5)

		featureArray[i] = count

		remainingCount = remainingCount - count

	end

	while (remainingCount > 0) do

		local idx = math.random(1, numberOfProbabilities)

		featureArray[idx] = featureArray[idx] + 1

		remainingCount = remainingCount - 1

	end

	return featureArray
end

local function calculateComplementProbability(useLogProbabilities, featureVector, complementFeatureProbabilityVector)

	local complementProbability = (useLogProbabilities and 0) or 1

	local functionToApply = function(featureValue, complementFeatureProbabilityValue) return math.pow(complementFeatureProbabilityValue, featureValue) end

	local complementProbabilityVector = AqwamTensorLibrary:applyFunction(functionToApply, featureVector, complementFeatureProbabilityVector)
	
	if (useLogProbabilities) then
		
		complementProbabilityVector = AqwamTensorLibrary:applyFunction(math.log, complementProbabilityVector)
		
	end

	for column = 1, #complementProbabilityVector[1], 1 do

		if (useLogProbabilities) then

			complementProbability = complementProbability + complementProbabilityVector[1][column]

		else

			complementProbability = complementProbability * complementProbabilityVector[1][column]

		end

	end

	return complementProbability

end

local function calculatePosteriorProbability(useLogProbabilities, featureVector, complementFeatureProbabilityVector, priorProbabilityValue)

	local posteriorProbability

	local likelihoodProbability = calculateComplementProbability(useLogProbabilities, featureVector, complementFeatureProbabilityVector)

	if (useLogProbabilities) then

		posteriorProbability = likelihoodProbability + priorProbabilityValue

	else

		posteriorProbability = likelihoodProbability * priorProbabilityValue

	end

	return posteriorProbability

end

function ComplementNaiveBayesModel:calculateCost(featureMatrix, logisticMatrix)
	
	local useLogProbabilities = self.useLogProbabilities

	local ClassesList = self.ClassesList
	
	local ModelParameters = self.ModelParameters

	local complementFeatureProbabilityMatrix = ModelParameters[1]

	local priorProbabilityVector = ModelParameters[2]
	
	local numberOfData = #featureMatrix
	
	local numberOfClasses = #ClassesList

	local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfClasses}, 0)
	
	local featureVector

	local complementFeatureProbabilityVector

	local priorProbabilityValue

	for data, unwrappedFeatureVector in ipairs(featureMatrix) do

		featureVector = {unwrappedFeatureVector}
		
		for class = 1, numberOfClasses, 1 do
			
			complementFeatureProbabilityVector = {complementFeatureProbabilityMatrix[class]}

			priorProbabilityValue = priorProbabilityVector[class][1]
			
			posteriorProbabilityMatrix[data][class] = calculatePosteriorProbability(useLogProbabilities, featureVector, complementFeatureProbabilityVector, priorProbabilityValue)
			
		end

	end
	
	if (useLogProbabilities) then

		posteriorProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, posteriorProbabilityMatrix)
		
	end

	local cost = self:categoricalCrossEntropy(logisticMatrix, posteriorProbabilityMatrix)

	return cost

end

local function calculateMatrices(extractedFeatureMatrixTable, numberOfData, complementFeatureProbabilityMatrix, priorProbabilityVector, numberOfFeatureCountVector, numberOfDataPointVector)
	
	local newTotalNumberOfDataPoint = numberOfData + AqwamTensorLibrary:sum(numberOfDataPointVector)
	
	local newComplementFeatureProbabilityMatrix = {}
	
	local newNumberOfFeatureCountVector = {}
	
	local newNumberOfDataPointVector = {}
	
	local numberOfOldFeatureCount
	
	local numberOfFeatureCount
	
	local numberOfOldSubData

	local numberOfSubData
	
	local complementFeatureProbabilityVector
	
	local totalSumExtractedComplementFeatureVector
	
	local numberOfComplementSubData
	
	local sumExtractedComplementFeatureVector
	
	local newComplementFeatureProbabilityVector
	
	for classIndex, extractedFeatureMatrix in ipairs(extractedFeatureMatrixTable) do

		numberOfOldSubData = numberOfDataPointVector[classIndex][1]
		
		if (type(extractedFeatureMatrix) == "table") then
			
			numberOfSubData = (#extractedFeatureMatrix + numberOfOldSubData)

			numberOfOldFeatureCount = numberOfFeatureCountVector[classIndex][1]

			complementFeatureProbabilityVector = {complementFeatureProbabilityMatrix[classIndex]}

			totalSumExtractedComplementFeatureVector = AqwamTensorLibrary:multiply(complementFeatureProbabilityVector, numberOfOldFeatureCount)

			for complementClassIndex, extractedComplementFeatureMatrix in ipairs(extractedFeatureMatrixTable) do

				if (complementClassIndex ~= classIndex) then

					numberOfComplementSubData = #extractedComplementFeatureMatrix

					sumExtractedComplementFeatureVector = AqwamTensorLibrary:sum(extractedComplementFeatureMatrix, 1)

					totalSumExtractedComplementFeatureVector = AqwamTensorLibrary:add(totalSumExtractedComplementFeatureVector, sumExtractedComplementFeatureVector)

				end

			end

			numberOfFeatureCount = AqwamTensorLibrary:sum(totalSumExtractedComplementFeatureVector)

			newComplementFeatureProbabilityVector = AqwamTensorLibrary:divide(totalSumExtractedComplementFeatureVector, numberOfFeatureCount)

			newComplementFeatureProbabilityMatrix[classIndex] = newComplementFeatureProbabilityVector[1]
			
			newNumberOfFeatureCountVector[classIndex] = {numberOfFeatureCount}
			
		else
			
			numberOfSubData = numberOfOldSubData
			
			newComplementFeatureProbabilityMatrix[classIndex] = complementFeatureProbabilityMatrix[classIndex]
			
			newNumberOfFeatureCountVector[classIndex] = {numberOfOldFeatureCount}
			
		end

		newNumberOfDataPointVector[classIndex] = {numberOfSubData}

	end
	
	local newPriorProbabilityVector = AqwamTensorLibrary:divide(newNumberOfDataPointVector, newTotalNumberOfDataPoint)
	
	return newComplementFeatureProbabilityMatrix, newPriorProbabilityVector, newNumberOfFeatureCountVector, newNumberOfDataPointVector
	
end

function ComplementNaiveBayesModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewComplementNaiveBayesModel = NaiveBayesBaseModel.new(parameterDictionary)

	setmetatable(NewComplementNaiveBayesModel, ComplementNaiveBayesModel)
	
	NewComplementNaiveBayesModel:setName("ComplementNaiveBayes")
	
	NewComplementNaiveBayesModel.mode = parameterDictionary.mode or defaultMode
	
	NewComplementNaiveBayesModel:setTrainFunction(function(featureMatrix, labelVector)
		
		local mode = NewComplementNaiveBayesModel.mode
		
		local useLogProbabilities = NewComplementNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewComplementNaiveBayesModel.ModelParameters or {}

		local complementFeatureProbabilityMatrix = ModelParameters[1]

		local priorProbabilityVector = ModelParameters[2]
		
		local numberOfFeatureCountVector = ModelParameters[3]

		local numberOfDataPointVector = ModelParameters[4]

		if (mode == "Hybrid") then

			mode = (complementFeatureProbabilityMatrix and priorProbabilityVector and numberOfFeatureCountVector and numberOfDataPointVector and "Online") or "Offline"		

		end
		
		if (mode == "Offline") then

			complementFeatureProbabilityMatrix = nil
			
			priorProbabilityVector = nil
			
			numberOfFeatureCountVector = nil
			
			numberOfDataPointVector = nil

		end
		
		local numberOfData = #featureMatrix

		local numberOfFeatures = #featureMatrix[1]
		
		local numberOfClasses = #NewComplementNaiveBayesModel.ClassesList

		local zeroValue = (useLogProbabilities and -math.huge) or 0

		local oneValue = (useLogProbabilities and 0) or 1
		
		local classVectorDimensionSizeArray = {numberOfClasses, 1}
		
		local logisticMatrix = NewComplementNaiveBayesModel:convertLabelVectorToLogisticMatrix(labelVector)

		local extractedFeatureMatrixTable = NewComplementNaiveBayesModel:separateFeatureMatrixByClass(featureMatrix, logisticMatrix)

		complementFeatureProbabilityMatrix = complementFeatureProbabilityMatrix or AqwamTensorLibrary:createTensor({numberOfClasses, numberOfFeatures}, zeroValue)

		priorProbabilityVector = priorProbabilityVector or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, oneValue)
		
		numberOfFeatureCountVector = numberOfFeatureCountVector or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, 0)

		numberOfDataPointVector = numberOfDataPointVector or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, 0)
		
		if (useLogProbabilities) then

			if (complementFeatureProbabilityMatrix) then complementFeatureProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, complementFeatureProbabilityMatrix) end

			if (priorProbabilityVector) then priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.exp, priorProbabilityVector) end

		end
		
		complementFeatureProbabilityMatrix, priorProbabilityVector, numberOfFeatureCountVector, numberOfDataPointVector = calculateMatrices(extractedFeatureMatrixTable, numberOfData, complementFeatureProbabilityMatrix, priorProbabilityVector, numberOfFeatureCountVector, numberOfDataPointVector)
		
		if (useLogProbabilities) then

			complementFeatureProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.log, complementFeatureProbabilityMatrix)

			priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.log, priorProbabilityVector)

		end
		
		numberOfDataPointVector = NewComplementNaiveBayesModel:resetNumberOfDataPointsOnReachingLimit(numberOfDataPointVector)

		NewComplementNaiveBayesModel.ModelParameters = {complementFeatureProbabilityMatrix, priorProbabilityVector, numberOfFeatureCountVector, numberOfDataPointVector}

		local cost = NewComplementNaiveBayesModel:calculateCost(featureMatrix, logisticMatrix)

		return {cost}
		
	end)
	
	NewComplementNaiveBayesModel:setPredictFunction(function(featureMatrix, returnOriginalOutput)

		local ClassesList = NewComplementNaiveBayesModel.ClassesList

		local useLogProbabilities = NewComplementNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewComplementNaiveBayesModel.ModelParameters

		local numberOfClasses = #ClassesList

		local numberOfData = #featureMatrix

		local posteriorProbabilityMatrixDimensionSizeArray = {numberOfData, numberOfClasses}

		local initialValue = (useLogProbabilities and -math.huge) or 0

		if (not ModelParameters) then

			if (returnOriginalOutput) then return AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, initialValue) end

			local dimensionSizeArray = {numberOfData, 1}

			local placeHolderLabelVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, nil)

			local placeHolderLabelProbabilityVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, initialValue)

			return placeHolderLabelVector, placeHolderLabelProbabilityVector

		end
		
		local complementFeatureProbabilityMatrix = ModelParameters[1]
		
		local priorProbabilityVector = ModelParameters[2]

		local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, initialValue)
		
		local complementFeatureProbabilityVector
		
		local priorProbabilityValue 
		
		local featureVector

		for classIndex, classValue in ipairs(ClassesList) do

			local complementFeatureProbabilityVector = {complementFeatureProbabilityMatrix[classIndex]}

			local priorProbabilityValue = priorProbabilityVector[classIndex][1]

			for i = 1, numberOfData, 1 do

				featureVector = {featureMatrix[i]}

				posteriorProbabilityMatrix[i][classIndex] = calculatePosteriorProbability(useLogProbabilities, featureVector, complementFeatureProbabilityVector, priorProbabilityValue)

			end

		end

		if (returnOriginalOutput) then return posteriorProbabilityMatrix end

		return NewComplementNaiveBayesModel:getLabelFromOutputMatrix(posteriorProbabilityMatrix)
		
	end)
	
	NewComplementNaiveBayesModel:setGenerateFunction(function(labelVector, totalCountVector)
		
		local numberOfData = #labelVector
		
		if (totalCountVector) then

			if (numberOfData ~= #totalCountVector) then error("The label vector and the total count does not contain the same number of rows.") end

		end
		
		local ClassesList = NewComplementNaiveBayesModel.ClassesList
		
		local useLogProbabilities = NewComplementNaiveBayesModel.useLogProbabilities
		
		local ModelParameters = NewComplementNaiveBayesModel.ModelParameters
		
		local complementFeatureProbabilityMatrix = ModelParameters[1]
		
		local numberOfFeatures = #complementFeatureProbabilityMatrix[1]
		
		local generatedFeatureMatrix = {}
		
		if (useLogProbabilities) then
			
			complementFeatureProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, complementFeatureProbabilityMatrix)
			
		end
		
		totalCountVector = totalCountVector or AqwamTensorLibrary:createTensor({numberOfData, 1}, 1)
		
		local featureProbabilityMatrix = AqwamTensorLibrary:subtract(1, complementFeatureProbabilityMatrix)
		
		for data, unwrappedLabelVector in ipairs(labelVector) do

			local label = unwrappedLabelVector[1]

			local classIndex = table.find(ClassesList, label)

			if (classIndex) then

				local featureProbabilityArray = featureProbabilityMatrix[classIndex]

				local totalCount = totalCountVector[data][1]

				generatedFeatureMatrix[data] = sampleMultinomial(featureProbabilityArray, totalCount)

			else

				generatedFeatureMatrix[data] = table.create(numberOfFeatures, 0)

			end

		end

		return generatedFeatureMatrix
		
	end)

	return NewComplementNaiveBayesModel

end

return ComplementNaiveBayesModel]]></ProtectedString>
									<string name="ScriptGuid">{95903D5F-3E47-4149-A911-FFDE724CE2D3}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ComplementNaiveBayes</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3CCD0A47A29246228E0255FAAF7B1096">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local NaiveBayesBaseModel = require(script.Parent.NaiveBayesBaseModel)

MultinomialNaiveBayesModel = {}

MultinomialNaiveBayesModel.__index = MultinomialNaiveBayesModel

setmetatable(MultinomialNaiveBayesModel, NaiveBayesBaseModel)

local defaultMode = "Hybrid"

local function factorial(n)
	
	local value = 1
	
	for i = 2, n, 1 do
		
		value = value * i
		
	end
	
	return value
	
end

local function logFactorial(n)
	
	local value = 0

	for i = 2, n, 1 do

		value = value + math.log(i)

	end
	
	return value
	
end

local function sampleMultinomial(probabilityArray, totalCount)
	
	local numberOfProbabilities = #probabilityArray
	
	local remainingCount = totalCount
	
	local featureArray = {}
	
	for i, p in ipairs(probabilityArray) do
		
		local count = math.floor(p * totalCount + 0.5)
		
		featureArray[i] = count
		
		remainingCount = remainingCount - count
		
	end

	while (remainingCount > 0) do
		
		local idx = math.random(1, numberOfProbabilities)
		
		featureArray[idx] = featureArray[idx] + 1
		
		remainingCount = remainingCount - 1
		
	end
	
	return featureArray
end

local function calculateMultinomialProbability(useLogProbabilities, featureVector, featureProbabilityVector)

	local multinomialProbabilityPart1 = (useLogProbabilities and 0) or 1
	
	if (useLogProbabilities) then
		
		featureProbabilityVector = AqwamTensorLibrary:applyFunction(math.log, featureProbabilityVector)
		
	end

	for column = 1, #featureProbabilityVector[1], 1 do
		
		if (useLogProbabilities) then
			
			multinomialProbabilityPart1 = multinomialProbabilityPart1 + featureVector[1][column] * featureProbabilityVector[1][column]
			
		else
			
			multinomialProbabilityPart1 = multinomialProbabilityPart1 * (featureProbabilityVector[1][column] ^ featureVector[1][column])
			
		end
		
	end
	
	local totalFeatureCount = AqwamTensorLibrary:sum(featureVector)
	
	local logFactorialSumFeatureCount = logFactorial(totalFeatureCount)
	
	local logFactorialFeatureVector = AqwamTensorLibrary:applyFunction(logFactorial, featureVector)
	
	local sumLogFactorialFeatureValue = 0
	
	for column = 1, #logFactorialFeatureVector[1], 1 do
		
		sumLogFactorialFeatureValue = sumLogFactorialFeatureValue + logFactorialFeatureVector[1][column]
		
	end
	
	local multinomialProbabilityPart2
	
	if (useLogProbabilities) then
		
		multinomialProbabilityPart2 = logFactorialSumFeatureCount - sumLogFactorialFeatureValue
		
	else
		
		multinomialProbabilityPart2 = math.exp(logFactorialSumFeatureCount - sumLogFactorialFeatureValue)
		
	end
	
	local multinomialProbability = multinomialProbabilityPart1 * multinomialProbabilityPart2

	return multinomialProbability

end

local function calculatePosteriorProbability(useLogProbabilities, featureVector, featureProbabilityVector, featureProbabilityValue)

	local posteriorProbability

	local likelihoodProbability = calculateMultinomialProbability(useLogProbabilities, featureVector, featureProbabilityVector)

	if (useLogProbabilities) then

		posteriorProbability = likelihoodProbability + featureProbabilityValue

	else

		posteriorProbability = likelihoodProbability * featureProbabilityValue

	end

	return posteriorProbability

end

function MultinomialNaiveBayesModel:calculateCost(featureMatrix, labelMatrix)
	
	local useLogProbabilities = self.useLogProbabilities

	local ClassesList = self.ClassesList

	local ModelParameters = self.ModelParameters
	
	local featureProbabilityMatrix = ModelParameters[1]

	local priorProbabilityVector = ModelParameters[2]

	local numberOfData = #featureMatrix

	local numberOfClasses = #ClassesList

	local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfClasses}, 0)

	local featureVector

	local featureProbabilityVector

	local priorProbabilityValue

	for data, unwrappedFeatureVector in ipairs(featureMatrix) do

		featureVector = {unwrappedFeatureVector}

		for class = 1, numberOfClasses, 1 do

			featureProbabilityVector = {featureProbabilityMatrix[class]}

			priorProbabilityValue = priorProbabilityVector[class][1]

			posteriorProbabilityMatrix[data][class] = calculatePosteriorProbability(useLogProbabilities, featureVector, featureProbabilityVector, priorProbabilityValue)

		end

	end

	if (useLogProbabilities) then

		posteriorProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, posteriorProbabilityMatrix)

	end

	local cost = self:categoricalCrossEntropy(labelMatrix, posteriorProbabilityMatrix)

	return cost

end

local function calculateMatrices(extractedFeatureMatrixTable, numberOfData, featureProbabilityMatrix, priorProbabilityVector, featureCountMatrix, numberOfDataPointVector)
	
	local newFeatureProbabilityMatrix = {}
	
	local newFeatureCountMatrix = {}
	
	local newNumberOfDataPointVector = {}
	
	local featureCountVector
	
	local oldFeatureCountVector
	
	local totalFeatureCountVector
	
	local sumFeatureCount
	
	local numberOfOldSubData
	
	local numberOfSubData
	
	local newTotalNumberOfDataPoint = numberOfData + AqwamTensorLibrary:sum(numberOfDataPointVector)
	
	for classIndex, extractedFeatureMatrix in ipairs(extractedFeatureMatrixTable) do
		
		numberOfOldSubData = numberOfDataPointVector[classIndex][1]
		
		if (type(extractedFeatureMatrix) == "table") then
			
			numberOfSubData = (#extractedFeatureMatrix + numberOfOldSubData)
			
			featureCountVector = AqwamTensorLibrary:sum(extractedFeatureMatrix, 1)

			oldFeatureCountVector = {featureCountMatrix[classIndex]}

			totalFeatureCountVector = AqwamTensorLibrary:add(oldFeatureCountVector, featureCountVector)

			sumFeatureCount = AqwamTensorLibrary:sum(totalFeatureCountVector)

			newFeatureProbabilityMatrix[classIndex] = AqwamTensorLibrary:divide(totalFeatureCountVector, sumFeatureCount)[1]

			newFeatureCountMatrix[classIndex] = totalFeatureCountVector[1]
			
		else
			
			numberOfSubData = numberOfOldSubData
			
			newFeatureProbabilityMatrix[classIndex] = featureProbabilityMatrix[classIndex]
			
		end

		newNumberOfDataPointVector[classIndex] = {numberOfSubData}
		
	end
	
	local newPriorProbabilityVector = AqwamTensorLibrary:divide(newNumberOfDataPointVector, newTotalNumberOfDataPoint)
	
	return newFeatureProbabilityMatrix, newPriorProbabilityVector, newFeatureCountMatrix, newNumberOfDataPointVector
	
end

function MultinomialNaiveBayesModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewMultinomialNaiveBayesModel = NaiveBayesBaseModel.new(parameterDictionary)

	setmetatable(NewMultinomialNaiveBayesModel, MultinomialNaiveBayesModel)
	
	NewMultinomialNaiveBayesModel:setName("MultinomialNaiveBayes")
	
	NewMultinomialNaiveBayesModel.mode = parameterDictionary.mode or defaultMode
	
	NewMultinomialNaiveBayesModel:setTrainFunction(function(featureMatrix, labelVector)
		
		local mode = NewMultinomialNaiveBayesModel.mode
		
		local useLogProbabilities = NewMultinomialNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewMultinomialNaiveBayesModel.ModelParameters or {}

		local featureProbabilityMatrix = ModelParameters[1]

		local priorProbabilityVector = ModelParameters[2]
		
		local featureCountMatrix = ModelParameters[3]
		
		local numberOfDataPointVector = ModelParameters[4]

		if (mode == "Hybrid") then

			mode = (featureProbabilityMatrix and priorProbabilityVector and featureCountMatrix and numberOfDataPointVector and "Online") or "Offline"		

		end

		if (mode == "Offline") then

			featureProbabilityMatrix = nil
			
			priorProbabilityVector = nil
			
			featureCountMatrix = nil
			
			numberOfDataPointVector = nil

		end
		
		local numberOfData = #featureMatrix

		local numberOfFeatures = #featureMatrix[1]
		
		local numberOfClasses = #NewMultinomialNaiveBayesModel.ClassesList

		local zeroValue = (useLogProbabilities and -math.huge) or 0

		local oneValue = (useLogProbabilities and 0) or 1
		
		local classVectorDimensionSizeArray = {numberOfClasses, 1}
		
		local logisticMatrix = NewMultinomialNaiveBayesModel:convertLabelVectorToLogisticMatrix(labelVector)

		local extractedFeatureMatrixTable = NewMultinomialNaiveBayesModel:separateFeatureMatrixByClass(featureMatrix, logisticMatrix)

		featureProbabilityMatrix = featureProbabilityMatrix or AqwamTensorLibrary:createTensor({numberOfClasses, numberOfFeatures}, zeroValue)

		priorProbabilityVector = priorProbabilityVector or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, oneValue)
		
		featureCountMatrix = featureCountMatrix or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, oneValue)

		numberOfDataPointVector = numberOfDataPointVector or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, 0)
		
		if (useLogProbabilities) then

			if (featureProbabilityMatrix) then featureProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, featureProbabilityMatrix) end

			if (priorProbabilityVector) then priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.exp, priorProbabilityVector) end

		end
		
		featureProbabilityMatrix, priorProbabilityVector, featureCountMatrix, numberOfDataPointVector = calculateMatrices(extractedFeatureMatrixTable, numberOfData, featureProbabilityMatrix, priorProbabilityVector, featureCountMatrix, numberOfDataPointVector)
		
		if (useLogProbabilities) then

			featureProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.log, featureProbabilityMatrix)

			priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.log, priorProbabilityVector)

		end
		
		numberOfDataPointVector = NewMultinomialNaiveBayesModel:resetNumberOfDataPointsOnReachingLimit(numberOfDataPointVector)

		NewMultinomialNaiveBayesModel.ModelParameters = {featureProbabilityMatrix, priorProbabilityVector, featureCountMatrix, numberOfDataPointVector}

		local cost = NewMultinomialNaiveBayesModel:calculateCost(featureMatrix, logisticMatrix)

		return {cost}
		
	end)
	
	NewMultinomialNaiveBayesModel:setPredictFunction(function(featureMatrix, returnOriginalOutput)

		local ClassesList = NewMultinomialNaiveBayesModel.ClassesList

		local useLogProbabilities = NewMultinomialNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewMultinomialNaiveBayesModel.ModelParameters

		local numberOfClasses = #ClassesList

		local numberOfData = #featureMatrix

		local posteriorProbabilityMatrixDimensionSizeArray = {numberOfData, numberOfClasses}

		local initialValue = (useLogProbabilities and -math.huge) or 0

		if (not ModelParameters) then

			if (returnOriginalOutput) then return AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, initialValue) end

			local dimensionSizeArray = {numberOfData, 1}

			local placeHolderLabelVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, nil)

			local placeHolderLabelProbabilityVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, initialValue)

			return placeHolderLabelVector, placeHolderLabelProbabilityVector

		end
		
		local featureProbabilityMatrix = ModelParameters[1]
		
		local priorProbabilityMatrix = ModelParameters[2]

		local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, initialValue)
		
		local featureProbabilityVector
		
		local priorProbabilityValue
		
		local featureVector

		for classIndex, classValue in ipairs(ClassesList) do

			featureProbabilityVector = {featureProbabilityMatrix[classIndex]}

			priorProbabilityValue = priorProbabilityMatrix[classIndex][1]

			for i = 1, numberOfData, 1 do

				featureVector = {featureMatrix[i]}

				posteriorProbabilityMatrix[i][classIndex] = calculatePosteriorProbability(useLogProbabilities, featureVector, featureProbabilityVector, priorProbabilityValue)

			end

		end

		if (returnOriginalOutput) then return posteriorProbabilityMatrix end

		return NewMultinomialNaiveBayesModel:getLabelFromOutputMatrix(posteriorProbabilityMatrix)
		
	end)
	
	NewMultinomialNaiveBayesModel:setGenerateFunction(function(labelVector, totalCountVector)
		
		local numberOfData = #labelVector
		
		if (totalCountVector) then

			if (numberOfData ~= #totalCountVector) then error("The label vector and the total count vector does not contain the same number of rows.") end

		end

		local ClassesList = NewMultinomialNaiveBayesModel.ClassesList
		
		local useLogProbabilities = NewMultinomialNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewMultinomialNaiveBayesModel.ModelParameters
		
		local featureProbabilityMatrix = ModelParameters[1]
		
		local numberOfFeatures = #featureProbabilityMatrix[1]
		
		local generatedFeatureMatrix = {}
		
		if (useLogProbabilities) then

			featureProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, featureProbabilityMatrix)

		end
		
		totalCountVector = totalCountVector or AqwamTensorLibrary:createTensor({numberOfData, 1}, 1)

		for data, unwrappedLabelVector in ipairs(labelVector) do
			
			local label = unwrappedLabelVector[1]
			
			local classIndex = table.find(ClassesList, label)
			
			if (classIndex) then
				
				local featureProbabilityArray = featureProbabilityMatrix[classIndex]
				
				local totalCount = totalCountVector[data][1]
				
				generatedFeatureMatrix[data] = sampleMultinomial(featureProbabilityArray, totalCount)
				
			else
				
				generatedFeatureMatrix[data] = table.create(numberOfFeatures, 0)
				
			end
			
		end

		return generatedFeatureMatrix

	end)

	return NewMultinomialNaiveBayesModel

end

return MultinomialNaiveBayesModel]]></ProtectedString>
									<string name="ScriptGuid">{E65DB84A-00D0-4B75-845B-F43EF95114E4}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">MultinomialNaiveBayes</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8E0CDE68CEAF478F866F91B168313F07">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

NaiveBayesBaseModel = {}

NaiveBayesBaseModel.__index = NaiveBayesBaseModel

setmetatable(NaiveBayesBaseModel, BaseModel)

local defaultUseLogProbabilities = false

local defaultMaximumNumberOfDataPoints = nil

local function areNumbersOnlyInList(list)

	for i, value in ipairs(list) do

		if (typeof(value) ~= "number") then return false end

	end

	return true

end

local function extractFeatureMatrixFromPosition(featureMatrix, positionList)

	local extractedFeatureMatrix = {}

	for i = 1, #featureMatrix, 1 do

		if table.find(positionList, i) then

			table.insert(extractedFeatureMatrix, featureMatrix[i])

		end	

	end

	return extractedFeatureMatrix

end

local function createClassesList(labelVector)

	local ClassesList = {}

	local value

	for i = 1, #labelVector, 1 do

		value = labelVector[i][1]

		if not table.find(ClassesList, value) then

			table.insert(ClassesList, value)

		end

	end

	return ClassesList

end

local function checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList)

	for i = 1, #labelVector, 1 do

		if (not table.find(ClassesList, labelVector[i][1])) then return true end

	end

	return false

end

function NaiveBayesBaseModel.new(parameterDictionary)
	
	parameterDictionary = parameterDictionary or {}
	
	local NewBaseModel = BaseModel.new(parameterDictionary)

	setmetatable(NewBaseModel, NaiveBayesBaseModel)

	NewBaseModel:setName("NaiveBayesBaseModel")

	NewBaseModel:setClassName("NaiveBayesModel")
	
	NewBaseModel.ClassesList = parameterDictionary.ClassesList or {}
	
	NewBaseModel.useLogProbabilities = BaseModel:getValueOrDefaultValue(parameterDictionary.useLogProbabilities, defaultUseLogProbabilities)
	
	NewBaseModel.maximumNumberOfDataPoints = BaseModel:getValueOrDefaultValue(parameterDictionary.maximumNumberOfDataPoints, defaultMaximumNumberOfDataPoints)

	return NewBaseModel
	
end

function NaiveBayesBaseModel:separateFeatureMatrixByClass(featureMatrix, labelMatrix)
	
	local ClassesList = self.ClassesList
	
	local extractedFeatureMatrixTable = {}
	
	for i = 1, #ClassesList, 1 do extractedFeatureMatrixTable[i] = {} end
	
	for i, labelTable in ipairs(labelMatrix) do
		
		for j, labelValue in ipairs(labelTable) do
			
			if (labelValue > 0) then table.insert(extractedFeatureMatrixTable[j], featureMatrix[i]) end
			
		end
		
	end

	return extractedFeatureMatrixTable

end

function NaiveBayesBaseModel:processLabelVector(labelVector)
	
	local ClassesList = self.ClassesList

	if (#ClassesList == 0) then

		ClassesList = createClassesList(labelVector)

		local areNumbersOnly = areNumbersOnlyInList(ClassesList)

		if (areNumbersOnly) then table.sort(ClassesList, function(a,b) return a < b end) end
		
		self.ClassesList = ClassesList

	else

		if checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList) then error("A value does not exist in the model\'s classes list is present in the label vector.") end

	end

end

function NaiveBayesBaseModel:convertLabelVectorToLogisticMatrix(labelVector)

	if (typeof(labelVector) == "number") then

		labelVector = {{labelVector}}

	end

	local incorrectLabelValue

	local numberOfData = #labelVector
	
	local ClassesList = self.ClassesList

	local logisticMatrix = AqwamTensorLibrary:createTensor({numberOfData, #ClassesList}, 0)

	local label

	local labelPosition

	for data = 1, numberOfData, 1 do

		label = labelVector[data][1]
		
		labelPosition = table.find(ClassesList, label)
		
		if (labelPosition) then
			
			logisticMatrix[data][labelPosition] = 1
			
		end

	end

	return logisticMatrix

end

function NaiveBayesBaseModel:getLabelFromOutputMatrix(outputMatrix)
	
	local ClassesList = self.ClassesList

	local numberOfData = #outputMatrix

	local predictedLabelVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 0)

	local highestProbabilityVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 0)

	local highestProbability

	local outputVector

	local classIndexArray

	local predictedLabel

	for i = 1, #outputMatrix, 1 do

		outputVector = {outputMatrix[i]}

		classIndexArray, highestProbability = AqwamTensorLibrary:findMaximumValueDimensionIndexArray(outputMatrix)

		if (classIndexArray) then
			
			predictedLabel = ClassesList[classIndexArray[2]]

			predictedLabelVector[i][1] = predictedLabel

			highestProbabilityVector[i][1] = highestProbability
			
		end

	end

	return predictedLabelVector, highestProbabilityVector

end

function NaiveBayesBaseModel:categoricalCrossEntropy(labelMatrix, generatedLabelMatrix)
	
	local functionToApply = function (labelValue, generatedLabelValue) return -(labelValue * math.log(generatedLabelValue)) end

	local categoricalCrossEntropyTensor = AqwamTensorLibrary:applyFunction(functionToApply, labelMatrix, generatedLabelMatrix)

	local sumCategoricalCrossEntropyValue = AqwamTensorLibrary:sum(categoricalCrossEntropyTensor)

	return sumCategoricalCrossEntropyValue
	
end

function NaiveBayesBaseModel:resetNumberOfDataPointsOnReachingLimit(numberOfDataPointVector)
	
	local maximumNumberOfDataPoints = self.maximumNumberOfDataPoints
	
	if (type(maximumNumberOfDataPoints) ~= "number") then return numberOfDataPointVector end
	
	local numberOfDataPoint
	
	for i, unwrappedNumberOfDataPointVector in ipairs(numberOfDataPointVector) do
		
		if (unwrappedNumberOfDataPointVector[1] > maximumNumberOfDataPoints) then
			
			unwrappedNumberOfDataPointVector[1] = 1
			
		end
		
	end
	
	return numberOfDataPointVector
	
end

function NaiveBayesBaseModel:train(featureMatrix, labelVector)
	
	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	self:processLabelVector(labelVector)
	
	return self.trainFunction(featureMatrix, labelVector)
	
end


function NaiveBayesBaseModel:setTrainFunction(trainFunction)
	
	self.trainFunction = trainFunction
	
end

function NaiveBayesBaseModel:predict(featureMatrix, returnOriginalOutput)

	return self.predictFunction(featureMatrix, returnOriginalOutput)

end

function NaiveBayesBaseModel:setPredictFunction(predictFunction)

	self.predictFunction = predictFunction

end

function NaiveBayesBaseModel:generate(labelVector, ...)
	
	return self.generateFunction(labelVector, ...)
	
end

function NaiveBayesBaseModel:setGenerateFunction(generateFunction)
	
	self.generateFunction = generateFunction
	
end

function NaiveBayesBaseModel:getClassesList()

	return self.ClassesList

end

function NaiveBayesBaseModel:setClassesList(ClassesList)

	self.ClassesList = ClassesList

end

return NaiveBayesBaseModel]]></ProtectedString>
									<string name="ScriptGuid">{ECEE188A-169A-4B74-BD94-D5A566565CB6}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">NaiveBayesBaseModel</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDC1394C9494F4E9EA0062D18558D8750">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local BaseModel = require(script.Parent.BaseModel)

local distanceFunctionDictionary = require(script.Parent.Parent.Cores.DistanceFunctionDictionary)

NearestCentroidModel = {}

NearestCentroidModel.__index = NearestCentroidModel

setmetatable(NearestCentroidModel, BaseModel)

local defaultDistanceFunction = "Euclidean"

local defaultMaximumNumberOfDataPoints = nil

local function createDistanceMatrix(distanceFunction, featureMatrix, centroidMatrix)

	local numberOfData = #featureMatrix

	local numberOfStoredData = #centroidMatrix

	local distanceMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfStoredData}, 0)

	local calculateDistance = distanceFunctionDictionary[distanceFunction]

	for datasetIndex = 1, numberOfData, 1 do

		for storedDatasetIndex = 1, numberOfStoredData, 1 do

			distanceMatrix[datasetIndex][storedDatasetIndex] = calculateDistance({featureMatrix[datasetIndex]}, {centroidMatrix[storedDatasetIndex]})

		end

	end

	return distanceMatrix

end

local function areNumbersOnlyInList(list)

	for i, value in ipairs(list) do

		if (typeof(value) ~= "number") then return false end

	end

	return true

end

local function extractFeatureMatrixFromPosition(featureMatrix, positionList)

	local extractedFeatureMatrix = {}

	for i = 1, #featureMatrix, 1 do

		if table.find(positionList, i) then

			table.insert(extractedFeatureMatrix, featureMatrix[i])

		end	

	end

	return extractedFeatureMatrix

end

local function createClassesList(labelVector)

	local ClassesList = {}

	local value

	for i = 1, #labelVector, 1 do

		value = labelVector[i][1]

		if not table.find(ClassesList, value) then

			table.insert(ClassesList, value)

		end

	end

	return ClassesList

end

local function checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList)

	for i = 1, #labelVector, 1 do

		if (not table.find(ClassesList, labelVector[i][1])) then return true end

	end

	return false

end

function NearestCentroidModel:processLabelVector(labelVector)

	local ClassesList = self.ClassesList

	if (#ClassesList == 0) then

		ClassesList = createClassesList(labelVector)

		local areNumbersOnly = areNumbersOnlyInList(ClassesList)

		if (areNumbersOnly) then table.sort(ClassesList, function(a,b) return a < b end) end

		self.ClassesList = ClassesList

	else

		if checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList) then error("A value does not exist in the model\'s classes list is present in the label vector.") end

	end

end

function NearestCentroidModel:convertLabelVectorToLogisticMatrix(labelVector)

	if (typeof(labelVector) == "number") then

		labelVector = {{labelVector}}

	end

	local incorrectLabelValue

	local numberOfData = #labelVector

	local ClassesList = self.ClassesList

	local logisticMatrix = AqwamTensorLibrary:createTensor({numberOfData, #ClassesList}, 0)

	local label

	local labelPosition

	for data = 1, numberOfData, 1 do

		label = labelVector[data][1]

		labelPosition = table.find(ClassesList, label)

		if (labelPosition) then

			logisticMatrix[data][labelPosition] = 1

		end

	end

	return logisticMatrix

end

function NearestCentroidModel:separateFeatureMatrixByClass(featureMatrix, labelMatrix)

	local ClassesList = self.ClassesList

	local extractedFeatureMatrixTable = {}

	for i = 1, #ClassesList, 1 do extractedFeatureMatrixTable[i] = {} end

	for i, labelTable in ipairs(labelMatrix) do

		for j, labelValue in ipairs(labelTable) do

			if (labelValue > 0) then table.insert(extractedFeatureMatrixTable[j], featureMatrix[i]) end

		end

	end

	return extractedFeatureMatrixTable

end

function NearestCentroidModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewNearestCentroidModel = BaseModel.new(parameterDictionary)

	setmetatable(NewNearestCentroidModel, NearestCentroidModel)
	
	NewNearestCentroidModel:setName("NearestCentroid")

	NewNearestCentroidModel.distanceFunction = parameterDictionary.distanceFunction or defaultDistanceFunction
	
	NewNearestCentroidModel.ClassesList = parameterDictionary.ClassesList or {}
	
	NewNearestCentroidModel.maximumNumberOfDataPoints = BaseModel:getValueOrDefaultValue(parameterDictionary.maximumNumberOfDataPoints, defaultMaximumNumberOfDataPoints)

	return NewNearestCentroidModel

end

function NearestCentroidModel:train(featureMatrix, labelVector)
	
	if (#featureMatrix ~= #labelVector) then error("The feature matrix and the label vector does not contain the same number of rows.") end
	
	local numberOfData = #featureMatrix

	if (numberOfData ~= #labelVector) then error("The number of data in feature matrix and the label vector are not the same.") end
	
	self:processLabelVector(labelVector)
	
	local labelMatrix
	
	if (#labelVector[1] == 1) then
		
		labelMatrix = self:convertLabelVectorToLogisticMatrix(labelVector)
		
	else
		
		labelMatrix = labelVector
		
	end

	local numberOfFeatures = #featureMatrix[1]
	
	local distanceFunction = self.distanceFunction
	
	local numberOfClasses = #self.ClassesList
	
	local maximumNumberOfDataPoints = self.maximumNumberOfDataPoints
	
	local ModelParameters = self.ModelParameters or {}
	
	local centroidMatrix = ModelParameters[1] or AqwamTensorLibrary:createTensor({numberOfClasses, numberOfFeatures}, 0)
	
	local numberOfDataPointVector = ModelParameters[2] or AqwamTensorLibrary:createTensor({numberOfClasses, 1}, 0)
	
	local sumMatrix = AqwamTensorLibrary:multiply(centroidMatrix, numberOfDataPointVector)
	
	local extractedFeatureMatrixTable = self:separateFeatureMatrixByClass(featureMatrix, labelMatrix)
	
	local numberOfDataPoints

	for clusterIndex, featureMatrix in ipairs(extractedFeatureMatrixTable) do
		
		if (featureMatrix) then
			
			local sumVector = {sumMatrix[clusterIndex]}

			local subSumVector = AqwamTensorLibrary:sum(featureMatrix, 1)

			sumVector = AqwamTensorLibrary:add(sumVector, subSumVector)

			sumMatrix[clusterIndex] = sumVector[1]
			
			numberOfDataPoints = numberOfDataPointVector[clusterIndex][1] + #featureMatrix
			
			if (type(maximumNumberOfDataPoints) == "number") then
				
				if (numberOfDataPoints > maximumNumberOfDataPoints) then numberOfDataPoints = 1 end
				
			end

			numberOfDataPointVector[clusterIndex][1] = numberOfDataPoints
			
		end
		
	end
	
	centroidMatrix = AqwamTensorLibrary:divide(sumMatrix, numberOfDataPointVector)
	
	local distanceMatrix = createDistanceMatrix(distanceFunction, featureMatrix, centroidMatrix)
	
	local costMatrix = AqwamTensorLibrary:multiply(distanceMatrix, labelMatrix)
	
	local cost = AqwamTensorLibrary:sum(costMatrix)
	
	cost = cost / numberOfData
	
	if (self.isOutputPrinted) then

		if (cost == math.huge) then warn("The model diverged.") end

		if (cost ~= cost) then warn("The model produced nan (not a number) values.") end

	end

	self.ModelParameters = {centroidMatrix, numberOfDataPointVector}
	
	return {cost}

end

function NearestCentroidModel:predict(featureMatrix, returnOriginalOutput)
	
	local ModelParameters = self.ModelParameters
	
	local ClassesList = self.ClassesList

	if (not ModelParameters) then
		
		local numberOfData = #featureMatrix
		
		local numberOfClasses = #ClassesList
		
		if (returnOriginalOutput) then return AqwamTensorLibrary:createTensor({numberOfData, numberOfClasses}, math.huge) end
		
		local dimensionSizeArray = {numberOfData, 1}
		
		local placeHolderLabelVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, nil)
		
		local placeHolderLabelDistanceVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, math.huge)
		
		return placeHolderLabelVector, placeHolderLabelDistanceVector
		
	end

	local centroidMatrix = ModelParameters[1]

	local distanceMatrix = createDistanceMatrix(self.distanceFunction, featureMatrix, centroidMatrix)

	if (returnOriginalOutput) then return distanceMatrix end

	local predictedLabelVector = {}
	
	local distanceVector = {}
	
	for dataIndex, unwrappedDistanceVector in ipairs(distanceMatrix) do
		
		local minimumDistance = math.huge

		local nearestClassIndex
		
		for classIndex, distance in ipairs(unwrappedDistanceVector) do
			
			if (distance < minimumDistance) then

				minimumDistance = distance

				nearestClassIndex = classIndex

			end			
			
		end
		
		predictedLabelVector[dataIndex] = {ClassesList[nearestClassIndex]}

		distanceVector[dataIndex] = {minimumDistance}
		
	end

	return predictedLabelVector, distanceVector

end

return NearestCentroidModel]]></ProtectedString>
									<string name="ScriptGuid">{D4D8061A-47C8-4658-8636-207D867B19FE}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">NearestCentroid</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0B634F903AD044A18476EF630FCF76B0">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local NaiveBayesBaseModel = require(script.Parent.NaiveBayesBaseModel)

GaussianNaiveBayesModel = {}

GaussianNaiveBayesModel.__index = GaussianNaiveBayesModel

setmetatable(GaussianNaiveBayesModel, NaiveBayesBaseModel)

local defaultMode = "Hybrid"

local function calculateGaussianProbability(useLogProbabilities, featureVector, meanVector, standardDeviationVector)

	local gaussianProbability = (useLogProbabilities and 0) or 1

	local exponentStep1Vector = AqwamTensorLibrary:subtract(featureVector, meanVector)

	local exponentStep2Vector = AqwamTensorLibrary:power(exponentStep1Vector, 2)

	local exponentPart3Vector = AqwamTensorLibrary:power(standardDeviationVector, 2)

	local exponentStep4Vector = AqwamTensorLibrary:divide(exponentStep2Vector, exponentPart3Vector)

	local exponentStep5Vector = AqwamTensorLibrary:multiply(-0.5, exponentStep4Vector)

	local exponentWithTermsVector = AqwamTensorLibrary:applyFunction(math.exp, exponentStep5Vector)

	local divisorVector = AqwamTensorLibrary:multiply(standardDeviationVector, math.sqrt(2 * math.pi))

	local gaussianProbabilityVector = AqwamTensorLibrary:divide(exponentWithTermsVector, divisorVector)

	for column = 1, #gaussianProbabilityVector[1], 1 do

		if (useLogProbabilities) then

			gaussianProbability = gaussianProbability + gaussianProbabilityVector[1][column]

		else

			gaussianProbability = gaussianProbability * gaussianProbabilityVector[1][column]

		end

	end

	return gaussianProbability

end

local function calculatePosteriorProbability(useLogProbabilities, featureVector, meanVector, standardDeviationVector, priorProbabilityValue)

	local posteriorProbability

	local likelihoodProbability = calculateGaussianProbability(useLogProbabilities, featureVector, meanVector, standardDeviationVector)

	if (useLogProbabilities) then

		posteriorProbability = likelihoodProbability + priorProbabilityValue

	else

		posteriorProbability = likelihoodProbability * priorProbabilityValue

	end

	return posteriorProbability

end

function GaussianNaiveBayesModel:calculateCost(featureMatrix, labelMatrix)

	local useLogProbabilities = self.useLogProbabilities
	
	local ClassesList = self.ClassesList
	
	local ModelParameters = self.ModelParameters
	
	local meanMatrix = ModelParameters[1]

	local standardDeviationMatrix = ModelParameters[2]

	local priorProbabilityVector = ModelParameters[3]

	local numberOfData = #featureMatrix

	local numberOfClasses = #ClassesList

	local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfClasses}, 0)

	local featureVector

	local meanVector

	local standardDeviationVector

	local priorProbabilityValue
	
	for data, unwrappedFeatureVector in ipairs(featureMatrix) do

		featureVector = {unwrappedFeatureVector}

		for class = 1, numberOfClasses, 1 do

			meanVector = {meanMatrix[class]}

			standardDeviationVector = {standardDeviationMatrix[class]}

			priorProbabilityValue = priorProbabilityVector[class][1]

			posteriorProbabilityMatrix[data][class] = calculatePosteriorProbability(useLogProbabilities, featureVector, meanVector, standardDeviationVector, priorProbabilityValue)

		end

	end
	
	if (useLogProbabilities) then

		posteriorProbabilityMatrix = AqwamTensorLibrary:applyFunction(math.exp, posteriorProbabilityMatrix)

	end

	local cost = self:categoricalCrossEntropy(labelMatrix, posteriorProbabilityMatrix)

	return cost

end

local function calculateMatrices(extractedFeatureMatrixTable, numberOfData, meanMatrix, standardDeviationMatrix, priorProbabilityVector, numberOfDataPointVector)
	
	local sumMatrix = AqwamTensorLibrary:multiply(meanMatrix, numberOfDataPointVector)

	local varianceMatrix = AqwamTensorLibrary:power(standardDeviationMatrix, 2)

	local multipliedVarianceMatrix = AqwamTensorLibrary:multiply(varianceMatrix, numberOfDataPointVector)

	local newTotalNumberOfDataPoint = numberOfData + AqwamTensorLibrary:sum(numberOfDataPointVector)

	local newMeanMatrix = {}

	local newStandardDeviationVector = {}

	local newNumberOfDataPointVector = {}
	
	local extractedFeatureMatrix
	
	local numberOfOldSubData
	
	local numberOfSubData
	
	local subSumVector
	
	local sumVector
	
	local oldMeanVector
	
	local newMeanVector
	
	local featureMatrixMinusMeanMatrix

	local featureMatrixMinusNewMeanMatrix

	local multipliedAdjustedFeatureMatrix

	local subMultipliedVarianceVector

	local multipliedVarianceVector

	local newVarianceVector
	
	local newStandardDeviationVector

	for classIndex, extractedFeatureMatrix in ipairs(extractedFeatureMatrixTable) do
		
		numberOfOldSubData = numberOfDataPointVector[classIndex][1]
		
		if (type(extractedFeatureMatrix) == "table") then
			
			numberOfSubData = (#extractedFeatureMatrix + numberOfOldSubData)

			subSumVector = AqwamTensorLibrary:sum(extractedFeatureMatrix, 1)

			sumVector = {sumMatrix[classIndex]}

			sumVector = AqwamTensorLibrary:add(sumVector, subSumVector)

			oldMeanVector = {meanMatrix[classIndex]}

			newMeanVector = AqwamTensorLibrary:divide(sumVector, numberOfSubData)

			-- Welford's algorithm for calculating new variance.

			featureMatrixMinusMeanMatrix = AqwamTensorLibrary:subtract(extractedFeatureMatrix, oldMeanVector)

			featureMatrixMinusNewMeanMatrix = AqwamTensorLibrary:subtract(extractedFeatureMatrix, newMeanVector)

			multipliedAdjustedFeatureMatrix = AqwamTensorLibrary:multiply(featureMatrixMinusMeanMatrix, featureMatrixMinusNewMeanMatrix)

			subMultipliedVarianceVector = AqwamTensorLibrary:sum(multipliedAdjustedFeatureMatrix, 1)

			multipliedVarianceVector = AqwamTensorLibrary:add({multipliedVarianceMatrix[classIndex]}, subMultipliedVarianceVector)

			newVarianceVector = AqwamTensorLibrary:divide(multipliedVarianceVector, numberOfSubData)

			-- End of Welford's algorithm.

			newStandardDeviationVector = AqwamTensorLibrary:power(newVarianceVector, 0.5)

			newMeanMatrix[classIndex] = newMeanVector[1]
			
			newStandardDeviationVector[classIndex] = newStandardDeviationVector[1]
			
		else
			
			numberOfSubData = numberOfOldSubData
			
			newMeanMatrix[classIndex] = meanMatrix[classIndex]

			newStandardDeviationVector[classIndex] = standardDeviationMatrix[classIndex]
			
		end
		
		newNumberOfDataPointVector[classIndex] = {numberOfSubData}
		
	end
	
	local newPriorProbabilityVector = AqwamTensorLibrary:divide(newNumberOfDataPointVector, newTotalNumberOfDataPoint)
	
	return newMeanMatrix, newStandardDeviationVector, newPriorProbabilityVector, newNumberOfDataPointVector
	
end

function GaussianNaiveBayesModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	local NewGaussianNaiveBayesModel = NaiveBayesBaseModel.new(parameterDictionary)

	setmetatable(NewGaussianNaiveBayesModel, GaussianNaiveBayesModel)
	
	NewGaussianNaiveBayesModel:setName("GaussianNaiveBayes")
	
	NewGaussianNaiveBayesModel.mode = parameterDictionary.mode or defaultMode
	
	NewGaussianNaiveBayesModel:setTrainFunction(function(featureMatrix, labelVector)
		
		local mode = NewGaussianNaiveBayesModel.mode
		
		local useLogProbabilities = NewGaussianNaiveBayesModel.useLogProbabilities
		
		local ModelParameters = NewGaussianNaiveBayesModel.ModelParameters or {}
		
		local meanMatrix = ModelParameters[1]
		
		local standardDeviationMatrix = ModelParameters[2]
		
		local priorProbabilityVector = ModelParameters[3]
		
		local numberOfDataPointVector = ModelParameters[4]

		if (mode == "Hybrid") then

			mode = (meanMatrix and standardDeviationMatrix and priorProbabilityVector and numberOfDataPointVector and "Online") or "Offline"		

		end
		
		if (mode == "Offline") then

			meanMatrix = nil
			
			standardDeviationMatrix = nil
			
			priorProbabilityVector = nil
			
			numberOfDataPointVector = nil

		end
		
		local numberOfData = #featureMatrix

		local numberOfFeatures = #featureMatrix[1]
		
		local numberOfClasses = #NewGaussianNaiveBayesModel.ClassesList

		local zeroValue = (useLogProbabilities and -math.huge) or 0

		local oneValue = (useLogProbabilities and 0) or 1
		
		local classMatrixDimensionSizeArray = {numberOfClasses, numberOfFeatures}
		
		local classVectorDimensionSizeArray = {numberOfClasses, 1}
		
		local logisticMatrix = NewGaussianNaiveBayesModel:convertLabelVectorToLogisticMatrix(labelVector)

		local extractedFeatureMatrixTable = NewGaussianNaiveBayesModel:separateFeatureMatrixByClass(featureMatrix, logisticMatrix)

		meanMatrix = meanMatrix or AqwamTensorLibrary:createTensor(classMatrixDimensionSizeArray, zeroValue)

		standardDeviationMatrix = standardDeviationMatrix or AqwamTensorLibrary:createTensor(classMatrixDimensionSizeArray, zeroValue)

		priorProbabilityVector = priorProbabilityVector or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, oneValue)

		numberOfDataPointVector = numberOfDataPointVector or AqwamTensorLibrary:createTensor(classVectorDimensionSizeArray, 0)
		
		if (useLogProbabilities) then
			
			if (meanMatrix) then meanMatrix = AqwamTensorLibrary:applyFunction(math.exp, meanMatrix) end
			
			if (standardDeviationMatrix) then standardDeviationMatrix = AqwamTensorLibrary:applyFunction(math.exp, standardDeviationMatrix) end
			
			if (priorProbabilityVector) then priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.exp, priorProbabilityVector) end
			
		end
		
		meanMatrix, standardDeviationMatrix, priorProbabilityVector, numberOfDataPointVector = calculateMatrices(extractedFeatureMatrixTable, numberOfData, meanMatrix, standardDeviationMatrix, priorProbabilityVector, numberOfDataPointVector)
		
		if (useLogProbabilities) then
			
			meanMatrix = AqwamTensorLibrary:applyFunction(math.log, meanMatrix)

			standardDeviationMatrix = AqwamTensorLibrary:applyFunction(math.log, standardDeviationMatrix)

			priorProbabilityVector = AqwamTensorLibrary:applyFunction(math.log, priorProbabilityVector)
			
		end
		
		numberOfDataPointVector = NewGaussianNaiveBayesModel:resetNumberOfDataPointsOnReachingLimit(numberOfDataPointVector)

		NewGaussianNaiveBayesModel.ModelParameters = {meanMatrix, standardDeviationMatrix, priorProbabilityVector, numberOfDataPointVector}

		local cost = NewGaussianNaiveBayesModel:calculateCost(featureMatrix, logisticMatrix)

		return {cost}
		
	end)
	
	NewGaussianNaiveBayesModel:setPredictFunction(function(featureMatrix, returnOriginalOutput)
		
		local ClassesList = NewGaussianNaiveBayesModel.ClassesList

		local useLogProbabilities = NewGaussianNaiveBayesModel.useLogProbabilities

		local ModelParameters = NewGaussianNaiveBayesModel.ModelParameters
		
		local numberOfClasses = #ClassesList
		
		local numberOfData = #featureMatrix
		
		local posteriorProbabilityMatrixDimensionSizeArray = {numberOfData, numberOfClasses}
		
		local initialValue = (useLogProbabilities and -math.huge) or 0
		
		if (not ModelParameters) then

			if (returnOriginalOutput) then return AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, initialValue) end

			local dimensionSizeArray = {numberOfData, 1}

			local placeHolderLabelVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, nil)

			local placeHolderLabelProbabilityVector = AqwamTensorLibrary:createTensor(dimensionSizeArray, initialValue)

			return placeHolderLabelVector, placeHolderLabelProbabilityVector

		end

		local meanMatrix = ModelParameters[1]

		local standardDeviationMatrix = ModelParameters[2]
		
		local priorProbabilityVector = ModelParameters[3]
		
		local posteriorProbabilityMatrix = AqwamTensorLibrary:createTensor(posteriorProbabilityMatrixDimensionSizeArray, initialValue)

		for classIndex, classValue in ipairs(ClassesList) do

			local meanVector = {meanMatrix[classIndex]}

			local standardDeviationVector = {standardDeviationMatrix[classIndex]}

			local priorProbabilityValue = priorProbabilityVector[classIndex][1]

			for i = 1, numberOfData, 1 do

				local featureVector = {featureMatrix[i]}

				posteriorProbabilityMatrix[i][classIndex] = calculatePosteriorProbability(useLogProbabilities, featureVector, meanVector, standardDeviationVector, priorProbabilityValue)

			end

		end

		if (returnOriginalOutput) then return posteriorProbabilityMatrix end

		return NewGaussianNaiveBayesModel:getLabelFromOutputMatrix(posteriorProbabilityMatrix)
		
	end)
	
	NewGaussianNaiveBayesModel:setGenerateFunction(function(labelVector, noiseMatrix)
		
		if (noiseMatrix) then

			if (#labelVector ~= #noiseMatrix) then error("The label vector and the noise matrix does not contain the same number of rows.") end

		end
		
		local ClassesList = NewGaussianNaiveBayesModel.ClassesList
		
		local useLogProbabilities = NewGaussianNaiveBayesModel.useLogProbabilities
		
		local ModelParameters = NewGaussianNaiveBayesModel.ModelParameters
		
		local meanMatrix = ModelParameters[1]
		
		local standardDeviationMatrix = ModelParameters[2]
		
		local selectedMeanMatrix = {}
		
		local selectedStandardDeviationMatrix = {}
		
		for data, unwrappedLabelVector in ipairs(labelVector) do
			
			local label = unwrappedLabelVector[1]
			
			local classIndex = table.find(ClassesList, label)
			
			if (classIndex) then
				
				selectedMeanMatrix[data] = meanMatrix[classIndex]
				
				selectedStandardDeviationMatrix[data] = standardDeviationMatrix[classIndex]
				
			end
			
		end
		
		if (useLogProbabilities) then

			selectedMeanMatrix = AqwamTensorLibrary:applyFunction(math.exp, selectedMeanMatrix)

			selectedStandardDeviationMatrix = AqwamTensorLibrary:applyFunction(math.exp, selectedStandardDeviationMatrix)

		end
		
		local dimensionSizeArray = AqwamTensorLibrary:getDimensionSizeArray(selectedMeanMatrix)
		
		noiseMatrix = noiseMatrix or AqwamTensorLibrary:createRandomNormalTensor(dimensionSizeArray)
		
		local generatedFeatureMatrixPart1 = AqwamTensorLibrary:multiply(selectedStandardDeviationMatrix, noiseMatrix)
		
		local generatedFeatureMatrix = AqwamTensorLibrary:add(selectedMeanMatrix, generatedFeatureMatrixPart1)
		
		return generatedFeatureMatrix
		
	end)

	return NewGaussianNaiveBayesModel

end

return GaussianNaiveBayesModel]]></ProtectedString>
									<string name="ScriptGuid">{3F3F8F9A-0923-4ECA-8231-43A6CB657DBA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">GaussianNaiveBayes</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD384B3271B264777B642CDE3A14A466A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[[

	--------------------------------------------------------------------

	Aqwam's Machine, Deep And Reinforcement Learning Library (DataPredict)

	Author: Aqwam Harish Aiman
	
	Email: aqwam.harish.aiman@gmail.com
	
	YouTube: https://www.youtube.com/channel/UCUrwoxv5dufEmbGsxyEUPZw
	
	LinkedIn: https://www.linkedin.com/in/aqwam-harish-aiman/
	
	--------------------------------------------------------------------
		
	By using this library, you agree to comply with our Terms and Conditions in the link below:
	
	https://github.com/AqwamCreates/DataPredict/blob/main/docs/TermsAndConditions.md
	
	--------------------------------------------------------------------
	
	DO NOT REMOVE THIS TEXT!
	
	--------------------------------------------------------------------

--]]

local AqwamTensorLibrary = require(script.Parent.Parent.AqwamTensorLibraryLinker.Value)

local GradientMethodBaseModel = require(script.Parent.GradientMethodBaseModel)

NeuralNetworkModel = {}

NeuralNetworkModel.__index = NeuralNetworkModel

setmetatable(NeuralNetworkModel, GradientMethodBaseModel)

local defaultCostFunction = "MeanSquaredError"

local defaultMaximumNumberOfIterations = 500

local defaultLearningRate = 0.1

local defaultActivationFunction = "LeakyReLU"

local defaultDropoutRate = 0

local layerPropertyValueTypeCheckingFunctionList = {

	["NumberOfNeurons"] = function(value)

		local valueType = type(value)

		if (valueType ~= "nil") and (valueType ~= "number") then error("Invalid input for number of neurons.") end 

	end,

	["HasBias"] = function(value)

		local valueType = type(value)

		if (valueType ~= "nil") and (valueType ~= "boolean") then error("Invalid input for has bias.") end 

	end,

	["ActivationFunction"] = function(value)

		local valueType = type(value)

		if (valueType ~= "nil") and (valueType ~= "string") then error("Invalid input for activation function.") end

	end,

	["LearningRate"] = function(value)

		local valueType = type(value)

		if (valueType ~= "nil") and (valueType ~= "number") then error("Invalid input for learning rate.") end

	end,

	["DropoutRate"] = function(value)

		local valueType = type(value)

		if (valueType ~= "nil") and (valueType ~= "number") then error("Invalid input for dropout rate.") end

	end,


}

local costFunctionList = {
	
	["MeanSquaredError"] = function(generatedLabelMatrix, labelMatrix)
		
		local functionToApply = function (generatedLabelValue, labelValue) return math.pow((generatedLabelValue - labelValue), 2) end

		local squaredErrorTensor = AqwamTensorLibrary:applyFunction(functionToApply, generatedLabelMatrix, labelMatrix)

		local sumSquaredErrorValue = AqwamTensorLibrary:sum(squaredErrorTensor)

		return sumSquaredErrorValue
		
	end,
	
	["MeanAbsoluteError"] = function(generatedLabelMatrix, labelMatrix)

		local functionToApply = function (generatedLabelValue, labelValue) return math.abs(generatedLabelValue - labelValue) end

		local absoluteErrorTensor = AqwamTensorLibrary:applyFunction(functionToApply, generatedLabelMatrix, labelMatrix)

		local sumAbsoluteErrorValue = AqwamTensorLibrary:sum(absoluteErrorTensor)

		return sumAbsoluteErrorValue

	end,
	
	["BinaryCrossEntropy"] = function(generatedLabelMatrix, labelMatrix)

		local functionToApply = function (generatedLabelValue, labelValue) return -(labelValue * math.log(generatedLabelValue) + (1 - labelValue) * math.log(1 - generatedLabelValue)) end

		local binaryCrossEntropyTensor = AqwamTensorLibrary:applyFunction(functionToApply, generatedLabelMatrix, labelMatrix)

		local sumBinaryCrossEntropyValue = AqwamTensorLibrary:sum(binaryCrossEntropyTensor)

		return sumBinaryCrossEntropyValue

	end,
	
	["CategoricalCrossEntropy"] = function(generatedLabelMatrix, labelMatrix)

		local functionToApply = function (generatedLabelValue, labelValue) return -(labelValue * math.log(generatedLabelValue)) end

		local categoricalCrossEntropyTensor = AqwamTensorLibrary:applyFunction(functionToApply, generatedLabelMatrix, labelMatrix)

		local sumCategoricalCrossEntropyValue = AqwamTensorLibrary:sum(categoricalCrossEntropyTensor)

		return sumCategoricalCrossEntropyValue

	end,
	
}

local elementWiseActivationFunctionList = {

	["Sigmoid"] = function(z) return 1/(1 + math.exp(-1 * z)) end,

	["Tanh"] = function (z) return math.tanh(z) end,

	["ReLU"] = function (z) return math.max(0, z) end,

	["LeakyReLU"] = function (z) return math.max((0.01 * z), z) end,

	["ELU"] = function (z) return if (z > 0) then z else (0.01 * (math.exp(z) - 1)) end,

	["Gaussian"] = function (z) return math.exp(-math.pow(z, 2)) end,

	["SiLU"] = function (z) return z / (1 + math.exp(-z)) end,

	["Mish"] = function (z) return z * math.tanh(math.log(1 + math.exp(z))) end,

	["BinaryStep"] = function (z) return ((z > 0) and 1) or 0 end

}

local activationFunctionList = {

	["Softmax"] = function (zMatrix)

		local exponentZMatrix = AqwamTensorLibrary:applyFunction(math.exp, zMatrix)

		local exponentZSumMatrix = AqwamTensorLibrary:sum(exponentZMatrix, 2)

		local aMatrix = AqwamTensorLibrary:divide(exponentZMatrix, exponentZSumMatrix)

		return aMatrix

	end,

	["StableSoftmax"] = function (zMatrix)

		local maximumZVector = AqwamTensorLibrary:findMaximumValue(zMatrix, 2)

		zMatrix = AqwamTensorLibrary:subtract(zMatrix, maximumZVector)

		local exponentZMatrix = AqwamTensorLibrary:applyFunction(math.exp, zMatrix)

		local exponentZSumMatrix = AqwamTensorLibrary:sum(exponentZMatrix, 2)

		local aMatrix = AqwamTensorLibrary:divide(exponentZMatrix, exponentZSumMatrix)

		return aMatrix

	end,

	["None"] = function (zMatrix) return zMatrix end,

}

local lossFunctionList = {
	
	["MeanSquaredError"] = function(generatedLabelMatrix, labelMatrix)

		local lossTensor = AqwamTensorLibrary:subtract(generatedLabelMatrix, labelMatrix)

		return AqwamTensorLibrary:multiply(2, lossTensor)

	end,

	["MeanAbsoluteError"] = function(generatedLabelMatrix, labelMatrix)

		return AqwamTensorLibrary:subtract(generatedLabelMatrix, labelMatrix)

	end,

	["BinaryCrossEntropy"] = function(generatedLabelMatrix, labelMatrix)

		local functionToApply = function (generatedLabelValue, labelValue) return ((generatedLabelValue - labelValue) / (generatedLabelValue * (1 - generatedLabelValue))) end

		return AqwamTensorLibrary:applyFunction(functionToApply, generatedLabelMatrix, labelMatrix)

	end,

	["CategoricalCrossEntropy"] = function(generatedLabelMatrix, labelMatrix)

		return AqwamTensorLibrary:subtract(generatedLabelMatrix, labelMatrix)

	end,
	
}

local elementWiseActivationFunctionDerivativeList = {

	["Sigmoid"] = function (a) return (a * (1 - a)) end,

	["Tanh"] = function (a) return (1 - math.pow(a, 2)) end,

	["ReLU"] = function (z) if (z > 0) then return 1 else return 0 end end,

	["LeakyReLU"] = function (z) if (z > 0) then return 1 else return 0.01 end end,

	["ELU"] = function (z) if (z > 0) then return 1 else return 0.01 * math.exp(z) end end,

	["Gaussian"] = function (z) return -2 * z * math.exp(-math.pow(z, 2)) end,

	["SiLU"] = function (z) return (1 + math.exp(-z) + (z * math.exp(-z))) / (1 + math.exp(-z))^2 end,

	["Mish"] = function (z) return math.exp(z) * (math.exp(3 * z) + 4 * math.exp(2 * z) + (6 + 4 * z) * math.exp(z) + 4 * (1 + z)) / math.pow((1 + math.pow((math.exp(z) + 1), 2)), 2) end

}

local activationFunctionDerivativeList = {

	["BinaryStep"] = function (aMatrix, zMatrix) return AqwamTensorLibrary:createTensor({#zMatrix, #zMatrix[1]}, 0) end,

	["Softmax"] = function (aMatrix, zMatrix)

		local derivativeMatrix = AqwamTensorLibrary:createTensor({#aMatrix, #aMatrix[1]}, 0)

		local unwrappedDerivativeVector

		local derivativeValue

		for i, unwrappedAVector in ipairs(aMatrix) do

			unwrappedDerivativeVector = derivativeMatrix[i]

			for j, a1Value in ipairs(unwrappedAVector) do

				for k, a2Value in ipairs(unwrappedAVector) do

					if (j == k) then

						derivativeValue = a1Value * (1 - a2Value)

					else

						derivativeValue = -a1Value * a2Value

					end

					unwrappedDerivativeVector[j] = unwrappedDerivativeVector[j] + derivativeValue

				end

			end

		end

		return derivativeMatrix

	end,

	["StableSoftmax"] = function (aMatrix, zMatrix)

		local derivativeMatrix = AqwamTensorLibrary:createTensor({#aMatrix, #aMatrix[1]}, 0)

		local unwrappedDerivativeVector

		local derivativeValue

		for i, unwrappedAVector in ipairs(aMatrix) do

			unwrappedDerivativeVector = derivativeMatrix[i]

			for j, a1Value in ipairs(unwrappedAVector) do

				for k, a2Value in ipairs(unwrappedAVector) do

					if (j == k) then

						derivativeValue = a1Value * (1 - a2Value)

					else

						derivativeValue = -a1Value * a2Value

					end

					unwrappedDerivativeVector[j] = unwrappedDerivativeVector[j] + derivativeValue

				end

			end

		end

		return derivativeMatrix

	end,

	["None"] = function (aMatrix, zMatrix) return AqwamTensorLibrary:createTensor({#zMatrix, #zMatrix[1]}, 1) end,

}

local cutOffListForScalarValues = {

	["Sigmoid"] = function (a) return (a >= 0.5) end,

	["Tanh"] = function (a) return (a >= 0) end,

	["ReLU"] = function (a) return (a >= 0) end,

	["LeakyReLU"] = function (a) return (a >= 0) end,

	["ELU"] = function (a) return (a >= 0) end,

	["Gaussian"] = function (a) return (a >= 0.5) end,

	["SiLU"] = function (a) return (a >= 0) end,

	["Mish"] = function (a) return (a >= 0) end,

	["BinaryStep"] = function (a) return (a > 0) end,

	["Softmax"] = function (a) return (a >= 0.5) end,

	["StableSoftmax"] = function (a) return (a >= 0.5) end,

	["None"] = function (a) return (a >= 0) end,

}

local function createClassesList(labelVector)

	local classesList = {}

	local value

	for i = 1, #labelVector, 1 do

		value = labelVector[i][1]

		if not table.find(classesList, value) then

			table.insert(classesList, value)

		end

	end

	return classesList

end

function NeuralNetworkModel:getActivationLayerAtFinalLayer()
	
	local activationFunctionArray = self.activationFunctionArray

	local finalLayerActivationFunctionName
	
	for layerNumber = #activationFunctionArray, 1, -1 do

		finalLayerActivationFunctionName = activationFunctionArray[layerNumber]

		if (finalLayerActivationFunctionName ~= "None") then break end

	end

	return finalLayerActivationFunctionName

end

function NeuralNetworkModel:convertLabelVectorToLogisticMatrix(labelVector)
	
	local ModelParameters = self.ModelParameters

	local ClassesList = self.ClassesList
	
	local numberOfNeuronsAtFinalLayer = #ModelParameters[#ModelParameters][1]

	if (numberOfNeuronsAtFinalLayer ~= #ClassesList) then error("The number of classes are not equal to number of neurons. Please adjust your last layer using setLayer() function.") end

	if (typeof(labelVector) == "number") then

		labelVector = {{labelVector}}

	end

	local incorrectLabelValue

	local activationFunctionAtFinalLayer = self:getActivationLayerAtFinalLayer()

	if (activationFunctionAtFinalLayer == "Tanh") or (activationFunctionAtFinalLayer == "ELU") then

		incorrectLabelValue = -1

	else

		incorrectLabelValue = 0

	end

	local numberOfData = #labelVector

	local logisticMatrix = AqwamTensorLibrary:createTensor({numberOfData, numberOfNeuronsAtFinalLayer}, incorrectLabelValue)

	local label

	local labelPosition

	for data = 1, numberOfData, 1 do

		label = labelVector[data][1]

		labelPosition = table.find(ClassesList, label)
		
		if (labelPosition) then
			
			logisticMatrix[data][labelPosition] = 1
			
		end

	end

	return logisticMatrix

end

local function activateLayer(zMatrix, hasBiasNeuron, activationFunctionName)

	-- Going for optimization where we remove redundant activation function calculation for bias values.

	local numberOfData = #zMatrix

	local numberOfFeatures = #zMatrix[1]
	
	local startingFeatureIndex = (1 + hasBiasNeuron)
	
	local activationFunction = elementWiseActivationFunctionList[activationFunctionName] 

	local activationMatrix = {}

	local unwrappedActivationVector

	if (activationFunction) then

		for dataIndex, unwrappedLayerZVector in ipairs(zMatrix) do

			unwrappedActivationVector = {}
			
			-- Because we actually calculated the output of previous layers instead of using bias neurons and the model parameters takes into account of bias neuron size, we will set the first column to one so that it remains as bias neuron.

			if (hasBiasNeuron == 1) then 
				
				unwrappedActivationVector[1] = 1 
				
				unwrappedLayerZVector[1] = 0
				
			end

			for featureIndex = startingFeatureIndex, numberOfFeatures, 1 do

				unwrappedActivationVector[featureIndex] = activationFunction(unwrappedLayerZVector[featureIndex])

			end

			activationMatrix[dataIndex] = unwrappedActivationVector

		end

	else
		
		local modifiedUnwrappedLayerZVector
		
		activationFunction = activationFunctionList[activationFunctionName]

		for dataIndex, unwrappedLayerZVector in ipairs(zMatrix) do

			modifiedUnwrappedLayerZVector = {}

			for featureIndex = startingFeatureIndex, numberOfFeatures, 1 do

				modifiedUnwrappedLayerZVector[featureIndex - hasBiasNeuron] = unwrappedLayerZVector[featureIndex]

			end

			unwrappedActivationVector = activationFunction({modifiedUnwrappedLayerZVector})[1]
			
			if (hasBiasNeuron == 1) then 

				table.insert(unwrappedActivationVector, 1, 1) 

				unwrappedLayerZVector[1] = 0

			end
			
			-- Because we actually calculated the output of previous layers instead of using bias neurons and the model parameters takes into account of bias neuron size, we will set the first column to one so that it remains as bias neuron.

			activationMatrix[dataIndex] = unwrappedActivationVector

		end

	end

	return activationMatrix

end

-- Don't bother using the applyFunction from AqwamMatrixLibrary. Otherwise, you cannot apply dropout at the same index for both z matrix and activation matrix.

local function dropoutInputMatrix(inputMatrix, hasBiasNeuron, dropoutRate, doNotDropoutNeurons)

	if (doNotDropoutNeurons) or (dropoutRate == 0) then return inputMatrix end

	local numberOfData = #inputMatrix

	local numberOfFeatures = #inputMatrix[1]

	local nonDropoutRate = 1 - dropoutRate

	local scaleFactor = (1 / nonDropoutRate)
	
	for dataIndex, unwrappedDataVector in ipairs(inputMatrix) do
		
		for featureIndex, value in ipairs(unwrappedDataVector) do
			
			if (math.random() > nonDropoutRate) then

				unwrappedDataVector[featureIndex] = 0

			else

				unwrappedDataVector[featureIndex] = value * scaleFactor

			end
			
		end
		
	end

	return inputMatrix

end

function NeuralNetworkModel:forwardPropagate(featureMatrix, saveAllArrays, doNotDropoutNeurons)
	
	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then ModelParameters = self:generateLayers() end

	local numberOfLayers = #self.numberOfNeuronsArray

	local hasBiasNeuronArray = self.hasBiasNeuronArray

	local activationFunctionArray = self.activationFunctionArray

	local dropoutRateArray = self.dropoutRateArray

	local forwardPropagateArray = {}

	local zMatrixArray = {}

	local activationFunctionName = activationFunctionArray[1]

	local activationFunction = elementWiseActivationFunctionList[activationFunctionName]

	local zMatrix = featureMatrix

	local inputMatrix = featureMatrix

	local numberOfData = #featureMatrix
	
	local hasBiasNeuron = hasBiasNeuronArray[1]

	if (activationFunction) then

		inputMatrix = AqwamTensorLibrary:applyFunction(activationFunction, zMatrix)

	else

		inputMatrix = activationFunctionList[activationFunctionName](zMatrix)

	end

	inputMatrix = dropoutInputMatrix(inputMatrix, hasBiasNeuron, dropoutRateArray[1], doNotDropoutNeurons)
	
	zMatrixArray[1] = inputMatrix
	
	forwardPropagateArray[1] = inputMatrix -- Don't remove this. otherwise the code won't work.

	for layerNumber = 1, (numberOfLayers - 1), 1 do

		local weightMatrix = ModelParameters[layerNumber]
		
		local nextLayerNumber = layerNumber + 1

		hasBiasNeuron = hasBiasNeuronArray[nextLayerNumber]

		zMatrix = AqwamTensorLibrary:dotProduct(inputMatrix, weightMatrix)

		if (typeof(zMatrix) == "number") then zMatrix = {{zMatrix}} end
		
		inputMatrix = activateLayer(zMatrix, hasBiasNeuron, activationFunctionArray[nextLayerNumber])

		inputMatrix = dropoutInputMatrix(inputMatrix, hasBiasNeuron, dropoutRateArray[nextLayerNumber], doNotDropoutNeurons)
		
		zMatrixArray[nextLayerNumber] = zMatrix
		
		forwardPropagateArray[nextLayerNumber] = inputMatrix

		self:sequenceWait()

	end

	if (saveAllArrays) then

		self.forwardPropagateArray = forwardPropagateArray

		self.zMatrixArray = zMatrixArray

	end

	return inputMatrix, forwardPropagateArray, zMatrixArray

end

local function deriveLayer(activationMatrix, zMatrix, hasBiasNeuronOnCurrentLayer, activationFunctionName)

	-- Going for optimization where we remove redundant activation function calculation for bias values.

	local numberOfData = #zMatrix

	local numberOfFeatures = #zMatrix[1]
	
	local startingFeatureIndex = (1 + hasBiasNeuronOnCurrentLayer)

	local activationFunctionDerivativeFunction = elementWiseActivationFunctionList[activationFunctionName] 

	local derivativeMatrix = {}

	local unwrappedDerivativeVector

	if (activationFunctionDerivativeFunction) then

		for dataIndex, unwrappedLayerZVector in ipairs(zMatrix) do

			unwrappedDerivativeVector = {}
			
			-- There are two bias here, one for previous layer and one for the next one. In order the previous values does not propagate to the next layer, the first column must be set to zero, since the first column refers to bias for next layer. The first row is for bias at the current layer.

			if (hasBiasNeuronOnCurrentLayer == 1) then unwrappedDerivativeVector[1] = 0 end

			for featureIndex = startingFeatureIndex, numberOfFeatures, 1 do

				unwrappedDerivativeVector[featureIndex] = activationFunctionDerivativeFunction(unwrappedLayerZVector[featureIndex])

			end

			derivativeMatrix[dataIndex] = unwrappedDerivativeVector

		end

	else
		
		local unwrappedActivationVector
		
		local modifiedUnwrappedActivationVector
		
		local modifiedUnwrappedLayerZVector 

		activationFunctionDerivativeFunction = activationFunctionDerivativeList[activationFunctionName]

		for dataIndex, unwrappedLayerZVector in ipairs(zMatrix) do
			
			unwrappedActivationVector = activationMatrix[dataIndex]
			
			modifiedUnwrappedActivationVector = {}

			modifiedUnwrappedLayerZVector = {}

			for featureIndex = startingFeatureIndex, numberOfFeatures, 1 do
				
				modifiedUnwrappedActivationVector[featureIndex - hasBiasNeuronOnCurrentLayer] = unwrappedActivationVector[featureIndex]

				modifiedUnwrappedLayerZVector[featureIndex - hasBiasNeuronOnCurrentLayer] = unwrappedLayerZVector[featureIndex]
				
			end

			unwrappedDerivativeVector = activationFunctionDerivativeFunction({modifiedUnwrappedActivationVector}, {modifiedUnwrappedLayerZVector})[1]
			
			-- There are two bias here, one for previous layer and one for the next one. In order the previous values does not propagate to the next layer, the first column must be set to zero, since the first column refers to bias for next layer. The first row is for bias at the current layer.

			if (hasBiasNeuronOnCurrentLayer == 1) then
				
				table.insert(unwrappedDerivativeVector, 1, 0) 
				
			end

			derivativeMatrix[dataIndex] = unwrappedDerivativeVector

		end

	end

	return derivativeMatrix

end

function NeuralNetworkModel:backwardPropagate(lossMatrix)

	local forwardPropagateArray = self.forwardPropagateArray

	local zMatrixArray = self.zMatrixArray

	if (not forwardPropagateArray) then error("Array not found for forward propagation.") end

	if (not zMatrixArray) then error("Array not found for z matrix.") end

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local costFunctionDerivativeMatrixArray = {}

	local errorMatrixArray = {}

	local numberOfData = #lossMatrix

	local ModelParameters = self.ModelParameters

	local numberOfLayers = #self.numberOfNeuronsArray

	local activationFunctionArray = self.activationFunctionArray

	local hasBiasNeuronArray = self.hasBiasNeuronArray

	local layerCostMatrix = lossMatrix
	
	if (hasBiasNeuronArray[numberOfLayers] == 1) then
		
		for dataIndex, unwrappedLayerCostVector in ipairs(layerCostMatrix) do
			
			unwrappedLayerCostVector[1] = 0
			
		end
		
	end
	
	errorMatrixArray[1] = layerCostMatrix

	for layerNumber = (numberOfLayers - 1), 2, -1 do

		local activationFunctionName = activationFunctionArray[layerNumber]

		local layerMatrix = AqwamTensorLibrary:transpose(ModelParameters[layerNumber])

		local partialErrorMatrix = AqwamTensorLibrary:dotProduct(layerCostMatrix, layerMatrix)

		local derivativeMatrix = deriveLayer(forwardPropagateArray[layerNumber], zMatrixArray[layerNumber], hasBiasNeuronArray[layerNumber], activationFunctionName)

		layerCostMatrix = AqwamTensorLibrary:multiply(partialErrorMatrix, derivativeMatrix)

		table.insert(errorMatrixArray, 1, layerCostMatrix)

		self:sequenceWait()

	end

	for layer = 1, (numberOfLayers - 1), 1 do

		local activationLayerMatrix = AqwamTensorLibrary:transpose(forwardPropagateArray[layer])

		local errorMatrix = errorMatrixArray[layer]

		local costFunctionDerivatives = AqwamTensorLibrary:dotProduct(activationLayerMatrix, errorMatrix)

		if (type(costFunctionDerivatives) == "number") then costFunctionDerivatives = {{costFunctionDerivatives}} end
		
		costFunctionDerivativeMatrixArray[layer] = costFunctionDerivatives

		self:sequenceWait()

	end

	if (self.areGradientsSaved) then self.Gradients = costFunctionDerivativeMatrixArray end

	return costFunctionDerivativeMatrixArray

end

function NeuralNetworkModel:gradientDescent(costFunctionDerivativeMatrixArray, numberOfData)

	local numberOfLayers = #self.numberOfNeuronsArray

	local learningRateArray = self.learningRateArray

	local OptimizerArray = self.OptimizerArray

	local RegularizerArray = self.RegularizerArray

	local hasBiasNeuronArray = self.hasBiasNeuronArray

	local ModelParameters = self.ModelParameters
	
	local NewModelParameters = {}

	for layerNumber = 1, (numberOfLayers - 1), 1 do

		local learningRate = learningRateArray[layerNumber + 1]

		local Regularizer = RegularizerArray[layerNumber + 1]

		local Optimizer = OptimizerArray[layerNumber + 1]

		local costFunctionDerivativeMatrix = costFunctionDerivativeMatrixArray[layerNumber]

		local hasBiasNeuronOnNextLayer = hasBiasNeuronArray[layerNumber + 1]

		if (type(costFunctionDerivativeMatrix) == "number") then costFunctionDerivativeMatrix = {{costFunctionDerivativeMatrix}} end

		local weightMatrix = ModelParameters[layerNumber]

		if (Regularizer ~= 0) then

			local regularizationDerivativeMatrix = Regularizer:calculate(weightMatrix)

			costFunctionDerivativeMatrix = AqwamTensorLibrary:add(costFunctionDerivativeMatrix, regularizationDerivativeMatrix)

		end

		costFunctionDerivativeMatrix = AqwamTensorLibrary:divide(costFunctionDerivativeMatrix, numberOfData)

		if (Optimizer ~= 0) then

			costFunctionDerivativeMatrix = Optimizer:calculate(learningRate, costFunctionDerivativeMatrix, weightMatrix)

		else

			costFunctionDerivativeMatrix = AqwamTensorLibrary:multiply(learningRate, costFunctionDerivativeMatrix)

		end

		local newWeightMatrix = AqwamTensorLibrary:subtract(weightMatrix, costFunctionDerivativeMatrix)

		if (hasBiasNeuronOnNextLayer == 1) then -- There are two bias here, one for previous layer and one for the next one. In order the previous values does not propagate to the next layer, the first column must be set to zero, since the first column refers to bias for next layer. The first row is for bias at the current layer.

			for i = 1, #newWeightMatrix, 1 do newWeightMatrix[i][1] = 0 end

		end
		
		NewModelParameters[layerNumber] = newWeightMatrix

	end
	
	self.ModelParameters = NewModelParameters

end

function NeuralNetworkModel:update(lossMatrix, clearAllArrays)

	if (type(lossMatrix) == "number") then lossMatrix = {{lossMatrix}} end

	local numberOfData = #lossMatrix

	local costFunctionDerivativeMatrixArray = self:backwardPropagate(lossMatrix)

	self:gradientDescent(costFunctionDerivativeMatrixArray, numberOfData)

	if (clearAllArrays) then

		self.forwardPropagateArray = nil

		self.zMatrixArray = nil

	end

end

function NeuralNetworkModel:calculateCost(allOutputsMatrix, logisticMatrix)
	
	local numberOfLayers = #self.numberOfNeuronsArray

	local RegularizerArray = self.RegularizerArray

	local ModelParameters = self.ModelParameters
	
	local CostFunctionToApply = costFunctionList[self.costFunction]

	local totalCost = CostFunctionToApply(allOutputsMatrix, logisticMatrix)

	for layerNumber = 1, (numberOfLayers - 1), 1 do

		local Regularizer = RegularizerArray[layerNumber + 1]

		if (Regularizer ~=  0) then totalCost = totalCost + Regularizer:calculateCost(ModelParameters[layerNumber]) end

	end

	local cost = totalCost / #logisticMatrix

	return cost

end

function NeuralNetworkModel:fetchValueFromScalar(outputVector)

	local value = outputVector[1][1]

	local activationFunctionAtFinalLayer = self:getActivationLayerAtFinalLayer()

	local isValueOverCutOff = cutOffListForScalarValues[activationFunctionAtFinalLayer](value)

	local classIndex = (isValueOverCutOff and 2) or 1

	local predictedLabel = self.ClassesList[classIndex]

	return predictedLabel, value

end

function NeuralNetworkModel:fetchHighestValueInVector(outputVector)

	local dimensionIndexArray, highestValue = AqwamTensorLibrary:findMaximumValueDimensionIndexArray(outputVector)

	if (not dimensionIndexArray) then return nil, highestValue end

	local predictedLabel = self.ClassesList[dimensionIndexArray[2]]

	return predictedLabel, highestValue

end

function NeuralNetworkModel:getLabelFromOutputMatrix(outputMatrix)

	local numberOfData = #outputMatrix
	
	local numberOfNeuronsArray = self.numberOfNeuronsArray

	local numberOfNeuronsAtFinalLayer = numberOfNeuronsArray[#numberOfNeuronsArray]

	local predictedLabelVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 0)

	local highestValueVector = AqwamTensorLibrary:createTensor({numberOfData, 1}, 0)

	local highestValue

	local outputVector

	local classIndex

	local predictedLabel

	for i = 1, #outputMatrix, 1 do

		outputVector = {outputMatrix[i]}

		if (numberOfNeuronsAtFinalLayer == 1) then

			predictedLabel, highestValue = self:fetchValueFromScalar(outputVector)

		else

			predictedLabel, highestValue = self:fetchHighestValueInVector(outputVector)

		end

		predictedLabelVector[i][1] = predictedLabel

		highestValueVector[i][1] = highestValue

	end

	return predictedLabelVector, highestValueVector

end

local function checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList)

	for i = 1, #labelVector, 1 do

		if (not table.find(ClassesList, labelVector[i][1])) then return true end

	end

	return false

end

function NeuralNetworkModel.new(parameterDictionary)

	parameterDictionary = parameterDictionary or {}

	parameterDictionary.maximumNumberOfIterations = parameterDictionary.maximumNumberOfIterations or defaultMaximumNumberOfIterations

	local NewNeuralNetworkModel = GradientMethodBaseModel.new(parameterDictionary)

	setmetatable(NewNeuralNetworkModel, NeuralNetworkModel)

	NewNeuralNetworkModel:setName("NeuralNetwork")
	
	NewNeuralNetworkModel.costFunction = parameterDictionary.costFunction or defaultCostFunction

	NewNeuralNetworkModel.ClassesList = parameterDictionary.ClassesList or {}

	NewNeuralNetworkModel.numberOfNeuronsArray = parameterDictionary.numberOfNeuronsArray or {}

	NewNeuralNetworkModel.RegularizerArray = parameterDictionary.RegularizerArray or {}

	NewNeuralNetworkModel.OptimizerArray = parameterDictionary.OptimizerArray or {}

	NewNeuralNetworkModel.hasBiasNeuronArray = parameterDictionary.hasBiasNeuronArray or {}

	NewNeuralNetworkModel.learningRateArray = parameterDictionary.learningRateArray or {}

	NewNeuralNetworkModel.activationFunctionArray = parameterDictionary.activationFunctionArray or {}

	NewNeuralNetworkModel.dropoutRateArray = parameterDictionary.dropoutRateArray or {}

	return NewNeuralNetworkModel

end

function NeuralNetworkModel:generateLayers()
	
	local numberOfNeuronsArray = self.numberOfNeuronsArray

	local numberOfLayers = #numberOfNeuronsArray

	if (numberOfLayers == 1) then error("There is only one layer.") end

	local ModelParameters = {}
	
	local hasBiasNeuronArray = self.hasBiasNeuronArray

	for layer = 1, (numberOfLayers - 1), 1 do

		local numberOfCurrentLayerNeurons = numberOfNeuronsArray[layer]

		if (hasBiasNeuronArray[layer] == 1) then numberOfCurrentLayerNeurons += 1 end -- 1 is added for bias

		local numberOfNextLayerNeurons = numberOfNeuronsArray[layer + 1]

		local hasBiasNeuronOnNextLayer = hasBiasNeuronArray[layer + 1] 

		if (hasBiasNeuronOnNextLayer == 1) then numberOfNextLayerNeurons += 1 end

		local weightMatrix = self:initializeMatrixBasedOnMode({numberOfCurrentLayerNeurons, numberOfNextLayerNeurons}, {0, hasBiasNeuronOnNextLayer}) -- Since no outputs are going into the bias neuron, it should not be considered as an input neuron. So the bias column needed to be excluded for our weight initialization.

		table.insert(ModelParameters, weightMatrix)

	end

	self.ModelParameters = ModelParameters
	
	return ModelParameters

end

function NeuralNetworkModel:createLayers(numberOfNeuronsArray, activationFunction, learningRate, OptimizerArray, RegularizerArray, dropoutRate)

	local learningRateType = typeof(learningRate)

	local activationFunctionType = typeof(activationFunction)

	local dropoutRateType = typeof(dropoutRate)

	OptimizerArray = OptimizerArray or {}

	RegularizerArray = RegularizerArray or {}

	if (activationFunctionType ~= "nil") and (activationFunctionType ~= "string") then error("Invalid input for activation function.") end

	if (learningRateType ~= "nil") and (learningRateType ~= "number") then error("Invalid input for learning rate.") end

	if (dropoutRateType ~= "nil") and (dropoutRateType ~= "number") then error("Invalid input for dropout rate.") end

	activationFunction = activationFunction or defaultActivationFunction

	learningRate = learningRate or defaultLearningRate

	dropoutRate = dropoutRate or defaultDropoutRate

	self.ModelParameters = nil

	local numberOfNeuronsArray = numberOfNeuronsArray

	local hasBiasNeuronArray = {}

	local learningRateArray = {}

	local activationFunctionArray = {}
	
	local OptimizerArray = {}

	local RegularizerArray = {}

	local dropoutRateArray = {}

	local numberOfLayers = #numberOfNeuronsArray

	for layer = 1, numberOfLayers, 1 do
		
		hasBiasNeuronArray[layer] = ((layer == numberOfLayers) and 0) or 1
		
		learningRateArray[layer] = ((layer == 1) and 0) or learningRate

		activationFunctionArray[layer] = ((layer == 1) and "None") or activationFunction

		OptimizerArray[layer] = OptimizerArray[layer] or 0

		RegularizerArray[layer] = RegularizerArray[layer] or 0
		
		dropoutRateArray[layer] = dropoutRate

	end
	
	self.hasBiasNeuronArray = hasBiasNeuronArray

	self.learningRateArray = learningRateArray

	self.activationFunctionArray = activationFunctionArray

	self.OptimizerArray = OptimizerArray

	self.RegularizerArray = RegularizerArray
	
	self.dropoutRateArray = dropoutRateArray

	self:generateLayers()

end

function NeuralNetworkModel:addLayer(numberOfNeurons, hasBiasNeuron, activationFunction, learningRate, Optimizer, Regularizer, dropoutRate)

	local numberOfNeuronsArray = self.numberOfNeuronsArray

	local isFirstLayer = (#numberOfNeuronsArray == 0)

	if (isFirstLayer) and (not activationFunction) then activationFunction = "None" end

	if (isFirstLayer) and (not learningRate) then learningRate = 0 end

	layerPropertyValueTypeCheckingFunctionList["NumberOfNeurons"](numberOfNeurons)

	layerPropertyValueTypeCheckingFunctionList["HasBias"](hasBiasNeuron)

	layerPropertyValueTypeCheckingFunctionList["ActivationFunction"](activationFunction)

	layerPropertyValueTypeCheckingFunctionList["LearningRate"](learningRate)

	layerPropertyValueTypeCheckingFunctionList["DropoutRate"](dropoutRate)

	hasBiasNeuron = self:getValueOrDefaultValue(hasBiasNeuron, true)

	hasBiasNeuron = (hasBiasNeuron and 1) or 0

	learningRate = learningRate or defaultLearningRate

	activationFunction = activationFunction or defaultActivationFunction

	dropoutRate = dropoutRate or defaultDropoutRate

	table.insert(numberOfNeuronsArray, numberOfNeurons)

	table.insert(self.hasBiasNeuronArray, hasBiasNeuron)

	table.insert(self.activationFunctionArray, activationFunction)

	table.insert(self.learningRateArray, learningRate)

	table.insert(self.OptimizerArray, Optimizer or 0)

	table.insert(self.RegularizerArray, Regularizer or 0)

	table.insert(self.dropoutRateArray, dropoutRate)

end

function NeuralNetworkModel:setLayer(layerNumber, hasBiasNeuron, activationFunction, learningRate, Optimizer, Regularizer, dropoutRate)

	if (layerNumber <= 0) then 

		error("The layer number can't be less than or equal to zero.") 

	elseif (layerNumber > #self.numberOfNeuronsArray)  then

		error("The layer number exceeds the number of layers.") 

	end 

	layerPropertyValueTypeCheckingFunctionList["HasBias"](hasBiasNeuron)

	layerPropertyValueTypeCheckingFunctionList["ActivationFunction"](activationFunction)

	layerPropertyValueTypeCheckingFunctionList["LearningRate"](learningRate)

	layerPropertyValueTypeCheckingFunctionList["DropoutRate"](dropoutRate)

	hasBiasNeuron = self:getValueOrDefaultValue(hasBiasNeuron, self.hasBiasNeuronArray[layerNumber])

	hasBiasNeuron = (hasBiasNeuron and 1) or 0

	Regularizer = self:getValueOrDefaultValue(Regularizer, self.RegularizerArray[layerNumber])

	Regularizer = Regularizer or 0

	Optimizer = self:getValueOrDefaultValue(Optimizer, self.OptimizerArray[layerNumber])

	Optimizer = Optimizer or 0

	self.hasBiasNeuronArray[layerNumber] = hasBiasNeuron

	self.activationFunctionArray[layerNumber] = activationFunction or self.activationFunctionArray[layerNumber] 

	self.learningRateArray[layerNumber] = learningRate or self.learningRateArray[layerNumber] 

	self.OptimizerArray[layerNumber] = Optimizer

	self.RegularizerArray[layerNumber] = Regularizer

	self.dropoutRateArray[layerNumber] = dropoutRate or self.dropoutRateArray[layerNumber]

end

function NeuralNetworkModel:setLayerProperty(layerNumber, property, value)

	if (layerNumber <= 0) then 

		error("The layer number can't be less than or equal to zero.") 

	elseif (layerNumber > #self.numberOfNeuronsArray)  then

		error("The layer number exceeds the number of layers.") 

	end 

	if (property == "HasBias") then

		layerPropertyValueTypeCheckingFunctionList["HasBias"](value)

		local hasBiasNeuron = self:getValueOrDefaultValue(value, self.hasBiasNeuronArray[layerNumber])

		hasBiasNeuron = (hasBiasNeuron and 1) or 0

		self.hasBiasNeuronArray[layerNumber] = hasBiasNeuron

	elseif (property == "ActivationFunction") then

		layerPropertyValueTypeCheckingFunctionList["ActivationFunction"](value)

		self.activationFunctionArray[layerNumber] = value or self.activationFunctionArray[layerNumber]

	elseif (property == "LearningRate") then

		layerPropertyValueTypeCheckingFunctionList["LearningRate"](value)

		self.learningRateArray[layerNumber] = value or self.learningRateArray[layerNumber]

	elseif (property == "Optimizer") then

		value = self:getValueOrDefaultValue(value, self.OptimizerArray[layerNumber])

		value = value or 0

		self.OptimizerArray[layerNumber] = value

	elseif (property == "Regularizer") then

		value = self:getValueOrDefaultValue(value, self.RegularizerArray[layerNumber])

		value = value or 0

		self.RegularizerArray[layerNumber] = value or 0

	elseif (property == "DropoutRate") then

		layerPropertyValueTypeCheckingFunctionList["DropoutRate"](value)

		self.dropoutRateArray[layerNumber] = value or self.dropoutRateArray[layerNumber]

	else

		warn("Layer property does not exists. Did not change the layer's properties.")

	end

end

function NeuralNetworkModel:getLayerProperty(layerNumber, property)

	if (layerNumber <= 0) then 

		error("The layer number can't be less than or equal to zero.") 

	elseif (layerNumber > #self.numberOfNeuronsArray)  then

		error("The layer number exceeds the number of layers.") 

	end 

	if (property == "HasBias") then

		return (self.hasBiasNeuronArray[layerNumber] == 1)

	elseif (property == "ActivationFunction") then

		return self.activationFunctionArray[layerNumber]

	elseif (property == "LearningRate") then

		return self.learningRateArray[layerNumber]

	elseif (property == "Optimizer") then

		local Optimizer = self.OptimizerArray[layerNumber]

		if (Optimizer ~= 0) then

			return Optimizer

		else

			return nil

		end

	elseif (property == "Regularizer") then

		local Regularizer = self.RegularizerArray[layerNumber]

		if (Regularizer ~= 0) then

			return Regularizer

		else

			return nil

		end

	elseif (property == "DropoutRate") then

		return self.dropoutRateArray[layerNumber]

	else

		warn("Layer property does not exists. Returning nil value.")

		return nil

	end

end

function NeuralNetworkModel:getLayer(layerNumber)

	if (layerNumber <= 0) then 

		error("The layer number can't be less than or equal to zero.") 

	elseif (layerNumber > #self.numberOfNeuronsArray) then

		error("The layer number exceeds the number of layers.") 

	end 

	local Optimizer = self.OptimizerArray[layerNumber]

	if (Optimizer == 0) then

		Optimizer = nil

	end

	local Regularizer = self.RegularizerArray[layerNumber]

	if (Regularizer == 0) then

		Regularizer = nil

	end

	return self.numberOfNeuronsArray[layerNumber], (self.hasBiasNeuronArray[layerNumber] == 1), self.activationFunctionArray[layerNumber], self.learningRateArray[layerNumber], Optimizer, Regularizer, self.dropoutRateArray[layerNumber]

end

function NeuralNetworkModel:getTotalNumberOfNeurons(layerNumber)

	return self.numberOfNeuronsArray[layerNumber] + self.hasBiasNeuronArray[layerNumber]

end

local function areNumbersOnlyInList(list)

	for i, value in ipairs(list) do

		if (typeof(value) ~= "number") then return false end

	end

	return true

end

function NeuralNetworkModel:processLabelVector(labelVector)
	
	local ClassesList = self.ClassesList

	if (#ClassesList == 0) then

		ClassesList = createClassesList(labelVector)

		local areNumbersOnly = areNumbersOnlyInList(ClassesList)

		if (areNumbersOnly) then table.sort(ClassesList, function(a,b) return a < b end) end
		
		self.ClassesList = ClassesList

	else

		if checkIfAnyLabelVectorIsNotRecognized(labelVector, ClassesList) then error("A value does not exist in the neural network\'s classes list is present in the label vector.") end

	end

	local logisticMatrix = self:convertLabelVectorToLogisticMatrix(labelVector)

	return logisticMatrix

end

local function mergeLayers(numberOfNeurons, initialNeuronIndex, currentWeightMatrixLeft, currentWeightMatrixRight, currentWeightMatrixToAdd, nextWeightMatrixTop, nextWeightMatrixToAdd, nextWeightMatrixBottom)

	local newCurrentWeightMatrix
	local newNextWeightMatrix

	if (numberOfNeurons < initialNeuronIndex) then

		newCurrentWeightMatrix = AqwamTensorLibrary:columnConcatenate(currentWeightMatrixLeft, currentWeightMatrixToAdd, currentWeightMatrixRight)
		newNextWeightMatrix = AqwamTensorLibrary:rowConcatenate(nextWeightMatrixTop, nextWeightMatrixToAdd, nextWeightMatrixBottom)

	else

		newCurrentWeightMatrix = AqwamTensorLibrary:columnConcatenate(currentWeightMatrixLeft, currentWeightMatrixRight, currentWeightMatrixToAdd)
		newNextWeightMatrix = AqwamTensorLibrary:rowConcatenate(nextWeightMatrixTop, nextWeightMatrixBottom, nextWeightMatrixToAdd)

	end

	return newCurrentWeightMatrix, newNextWeightMatrix

end

function NeuralNetworkModel:evolveLayerSize(layerNumber, initialNeuronIndex, size)
	
	local ModelParameters = self.ModelParameters

	if (not ModelParameters) then error("No Model Parameters.") end

	if (#ModelParameters == 0) then 

		self.ModelParameters = nil
		error("No Model Parameters.") 

	end
	
	local numberOfNeuronsArray = self.numberOfNeuronsArray
	
	local hasBiasNeuronArray = self.hasBiasNeuronArray

	local numberOfLayers = #numberOfNeuronsArray -- DON'T FORGET THAT IT DOES NOT INCLUDE BIAS.

	if (layerNumber > numberOfLayers) then error("Layer number exceeds this model's number of layers.") end

	local hasBiasNeuronValue = hasBiasNeuronArray[layerNumber]

	local numberOfNeurons = numberOfNeuronsArray[layerNumber] + hasBiasNeuronValue

	local currentWeightMatrix
	local nextWeightMatrix

	if (layerNumber == numberOfLayers) then

		currentWeightMatrix = ModelParameters[numberOfLayers - 1]

	elseif (layerNumber > 1) and (layerNumber < numberOfLayers) then

		currentWeightMatrix = ModelParameters[layerNumber - 1]
		nextWeightMatrix = ModelParameters[layerNumber]

	else

		currentWeightMatrix = ModelParameters[1]
		nextWeightMatrix = ModelParameters[2]

	end

	initialNeuronIndex = initialNeuronIndex or numberOfNeurons

	if (initialNeuronIndex > numberOfNeurons) then error("The index exceeds this layer's number of neurons.") end

	local hasNextLayer = (typeof(nextWeightMatrix) ~= "nil")

	local absoluteSize = math.abs(size)

	local secondNeuronIndex = initialNeuronIndex + size + 1
	local thirdNeuronIndex = initialNeuronIndex + 2

	local newCurrentWeightMatrix
	local newNextWeightMatrix

	local currentWeightMatrixLeft
	local currentWeightMatrixRight

	local nextWeightMatrixTop
	local nextWeightMatrixBottom

	local currentWeightMatrixToAdd
	local nextWeightMatrixToAdd

	if (size == 0) then

		error("Size is zero.")

	elseif (size < 0) and (numberOfNeurons == 0)  then

		error("No neurons to remove.")

	elseif (size < 0) and ((initialNeuronIndex + size) < 0) then

		error("Size is too large.")

	elseif (initialNeuronIndex == 0) and (size > 0) and (hasNextLayer) then

		currentWeightMatrixToAdd = self:initializeMatrixBasedOnMode({#currentWeightMatrix, size})
		nextWeightMatrixToAdd =  self:initializeMatrixBasedOnMode({size, #nextWeightMatrix[1]})

		newCurrentWeightMatrix = AqwamTensorLibrary:concatenate(currentWeightMatrix, currentWeightMatrixToAdd, 2)
		newNextWeightMatrix = AqwamTensorLibrary:concatenate(nextWeightMatrix, nextWeightMatrixToAdd, 1)

	elseif (initialNeuronIndex == 0) and (size > 0) and (not hasNextLayer) then

		currentWeightMatrixToAdd = self:initializeMatrixBasedOnMode(#currentWeightMatrix, size)
		newCurrentWeightMatrix = AqwamTensorLibrary:concatenate(currentWeightMatrixToAdd, currentWeightMatrix, 2)

	elseif (initialNeuronIndex > 0) and (size > 0) and (hasNextLayer) then

		currentWeightMatrixLeft = AqwamTensorLibrary:extractColumns(currentWeightMatrix, 1, initialNeuronIndex)
		currentWeightMatrixRight = AqwamTensorLibrary:extractColumns(currentWeightMatrix, initialNeuronIndex + 1, #currentWeightMatrix[1])

		nextWeightMatrixTop = AqwamTensorLibrary:extractRows(nextWeightMatrix, 1, initialNeuronIndex)
		nextWeightMatrixBottom = AqwamTensorLibrary:extractRows(nextWeightMatrix, initialNeuronIndex + 1, #nextWeightMatrix)

		currentWeightMatrixToAdd = self:initializeMatrixBasedOnMode({#currentWeightMatrix, size})
		nextWeightMatrixToAdd =  self:initializeMatrixBasedOnMode({size, #nextWeightMatrix[1]})

		newCurrentWeightMatrix, newNextWeightMatrix = mergeLayers(numberOfNeurons, initialNeuronIndex, currentWeightMatrixLeft, currentWeightMatrixRight, currentWeightMatrixToAdd, nextWeightMatrixTop, nextWeightMatrixToAdd, nextWeightMatrixBottom)

	elseif (initialNeuronIndex > 0) and (size > 0) and (not hasNextLayer) then

		currentWeightMatrixToAdd = self:initializeMatrixBasedOnMode(#currentWeightMatrix, size)
		newCurrentWeightMatrix = AqwamTensorLibrary:concatenate(currentWeightMatrix, currentWeightMatrixToAdd, 2)

	elseif (size == -1) and (hasNextLayer) and (numberOfNeurons == 1) then

		newCurrentWeightMatrix = AqwamTensorLibrary:extractColumns(currentWeightMatrix, initialNeuronIndex, initialNeuronIndex)
		newNextWeightMatrix = AqwamTensorLibrary:extractRows(nextWeightMatrix, initialNeuronIndex, initialNeuronIndex)

	elseif (size == -1) and (not hasNextLayer) and (numberOfNeurons == 1) then

		newCurrentWeightMatrix = AqwamTensorLibrary:extractColumns(currentWeightMatrix, initialNeuronIndex, initialNeuronIndex)

	elseif (size < 0) and (hasNextLayer) and (numberOfNeurons >= absoluteSize) then

		currentWeightMatrixLeft = AqwamTensorLibrary:extractColumns(currentWeightMatrix, 1, secondNeuronIndex)
		currentWeightMatrixRight = AqwamTensorLibrary:extractColumns(currentWeightMatrix, thirdNeuronIndex, #currentWeightMatrix[1])

		nextWeightMatrixTop = AqwamTensorLibrary:extractRows(nextWeightMatrix, 1, secondNeuronIndex)
		nextWeightMatrixBottom = AqwamTensorLibrary:extractRows(nextWeightMatrix, thirdNeuronIndex, #nextWeightMatrix)

		newCurrentWeightMatrix = AqwamTensorLibrary:horizontalConcatenate(currentWeightMatrixLeft, currentWeightMatrixRight)
		newNextWeightMatrix = AqwamTensorLibrary:verticalConcatenate(nextWeightMatrixTop, nextWeightMatrixBottom)

	elseif (size < 0) and (not hasNextLayer) and (numberOfNeurons >= absoluteSize) then

		currentWeightMatrixLeft = AqwamTensorLibrary:extractColumns(currentWeightMatrix, 1, secondNeuronIndex)
		currentWeightMatrixRight = AqwamTensorLibrary:extractColumns(currentWeightMatrix, thirdNeuronIndex, #currentWeightMatrix[1])

		newCurrentWeightMatrix = AqwamTensorLibrary:horizontalConcatenate(currentWeightMatrixLeft, currentWeightMatrixRight)

	end

	if (layerNumber == numberOfLayers) then

		ModelParameters[numberOfLayers - 1] = newCurrentWeightMatrix

	elseif (layerNumber > 1) and (layerNumber < numberOfLayers) then

		ModelParameters[layerNumber - 1] = newCurrentWeightMatrix
		ModelParameters[layerNumber] = newNextWeightMatrix

	else

		ModelParameters[1] = newCurrentWeightMatrix
		ModelParameters[2] = newNextWeightMatrix

	end

	self.numberOfNeuronsArray[layerNumber] += size

end

function NeuralNetworkModel:train(featureMatrix, labelVector)

	local numberOfFeatures = #featureMatrix[1]
	
	local numberOfNeuronsArray = self.numberOfNeuronsArray
	
	local hasBiasNeuronArray = self.hasBiasNeuronArray

	local numberOfNeuronsAtInputLayer = numberOfNeuronsArray[1] + hasBiasNeuronArray[1]

	if (numberOfNeuronsAtInputLayer ~= numberOfFeatures) then error("Input layer has " .. numberOfNeuronsAtInputLayer .. " neuron(s), but feature matrix has " .. #featureMatrix[1] .. " features.") end

	if (#featureMatrix ~= #labelVector) then error("Number of rows of feature matrix and the label vector is not the same.") end
	
	local numberOfLayers = #numberOfNeuronsArray
	
	local numberOfNeuronsAtFinalLayer = numberOfNeuronsArray[numberOfLayers] + hasBiasNeuronArray[numberOfLayers]
	
	local LossFunctionToApply = lossFunctionList[self.costFunction]

	local numberOfIterations = 0

	local cost

	local costArray = {}

	local deltaArray

	local RegularizerDerivatives

	local logisticMatrix

	local activatedOutputsMatrix

	if (not self.ModelParameters) then self:generateLayers() end

	if (#labelVector[1] == 1) and (numberOfNeuronsAtFinalLayer ~= 1) then

		logisticMatrix = self:processLabelVector(labelVector)

	else

		if (#labelVector[1] ~= numberOfNeuronsAtFinalLayer) then error("The number of columns for the label matrix is not equal to number of neurons at final layer.") end

		logisticMatrix = labelVector

	end

	repeat

		numberOfIterations = numberOfIterations + 1

		self:iterationWait()

		activatedOutputsMatrix = self:forwardPropagate(featureMatrix, true)

		cost = self:calculateCostWhenRequired(numberOfIterations, function()

			return self:calculateCost(activatedOutputsMatrix, logisticMatrix)

		end)

		if (cost) then 

			table.insert(costArray, cost)

			self:printNumberOfIterationsAndCost(numberOfIterations, cost)

		end

		local lossMatrix = LossFunctionToApply(activatedOutputsMatrix, logisticMatrix)

		self:update(lossMatrix, true)

	until (numberOfIterations == self.maximumNumberOfIterations) or self:checkIfTargetCostReached(cost) or self:checkIfConverged(cost)

	if (cost == math.huge) then warn("The model diverged. Please repeat the experiment again or change the argument values.") end

	if (self.autoResetOptimizers) then

		for i, Optimizer in ipairs(self.OptimizerArray) do

			if (Optimizer ~= 0) then Optimizer:reset() end

		end

	end

	return costArray

end

function NeuralNetworkModel:reset()

	for i, Optimizer in ipairs(self.OptimizerArray) do

		if (Optimizer ~= 0) then Optimizer:reset() end

	end

end

function NeuralNetworkModel:predict(featureMatrix, returnOriginalOutput)

	if (not self.ModelParameters) then self:generateLayers() end

	local outputMatrix = self:forwardPropagate(featureMatrix, false, true)

	if (returnOriginalOutput == true) then return outputMatrix end

	local predictedLabelVector, highestValueVector = self:getLabelFromOutputMatrix(outputMatrix)

	return predictedLabelVector, highestValueVector

end

function NeuralNetworkModel:getClassesList()

	return self.ClassesList

end

function NeuralNetworkModel:setClassesList(classesList)

	self.ClassesList = classesList

end

function NeuralNetworkModel:showDetails()
	
	local numberOfNeuronsArray = self.numberOfNeuronsArray
	
	local hasBiasNeuronArray = self.hasBiasNeuronArray
	
	local activationFunctionArray = self.activationFunctionArray
	
	local learningRateArray = self.learningRateArray
	
	local OptimizerArray = self.OptimizerArray
	
	local RegularizerArray = self.RegularizerArray
	
	local dropoutRateArray = self.dropoutRateArray
	
	local ClassesList = self.ClassesList
	
	-- Calculate the maximum length for each column
	local maxLayerLength = string.len("Layer")
	
	local maxNeuronsLength = string.len("Number Of Neurons")
	
	local maximumBiasLength = string.len("Has Bias Neuron")
	
	local maximumActivationLength = string.len("Activation Function")
	
	local maximumLearningRateLength = string.len("Learning Rate")
	
	local maximumOptimizerLength = string.len("Optimizer Added")
	
	local maximumRegularizerLength = string.len("Regularizer Added")
	
	local maximumDropoutRateLength = string.len("Dropout Rate")

	local hasBias

	local optimizerName = "None"

	local regularizerName = "None"

	for i = 1, #numberOfNeuronsArray, 1 do

		local Optimizer = OptimizerArray[i]

		local Regularizer = RegularizerArray[i]

		if (type(Optimizer) == "table") then optimizerName = Optimizer:getName() end

		if (type(Regularizer) == "table") then regularizerName = Regularizer:getName() end

		maxLayerLength = math.max(maxLayerLength, string.len(tostring(i)))

		maxNeuronsLength = math.max(maxNeuronsLength, string.len(tostring(numberOfNeuronsArray[i])))

		hasBias = (hasBiasNeuronArray[i] == 1)

		maximumBiasLength = math.max(maximumBiasLength, string.len(tostring(hasBias)))

		maximumActivationLength = math.max(maximumActivationLength, string.len(activationFunctionArray[i]))

		maximumLearningRateLength = math.max(maximumLearningRateLength, string.len(tostring(learningRateArray[i])))

		maximumOptimizerLength = math.max(maximumOptimizerLength, string.len(optimizerName))

		maximumRegularizerLength = math.max(maximumRegularizerLength, string.len(regularizerName))

		maximumDropoutRateLength = math.max(maximumDropoutRateLength, string.len(tostring(dropoutRateArray[i])))

	end

	-- Print the array header

	local stringToPrint = ""

	stringToPrint ..= "Layer Details: \n\n"

	stringToPrint ..= "|-" .. string.rep("-", maxLayerLength) .. "-|-" ..
		string.rep("-", maxNeuronsLength) .. "-|-" ..
		string.rep("-", maximumBiasLength) .. "-|-" ..
		string.rep("-", maximumActivationLength) .. "-|-" ..
		string.rep("-", maximumLearningRateLength) .. "-|-" ..
		string.rep("-", maximumOptimizerLength) .. "-|-" ..
		string.rep("-", maximumRegularizerLength) .. "-|-" .. 
		string.rep("-", maximumDropoutRateLength) .. "-|" .. 
		"\n"

	stringToPrint ..= "| " .. string.format("%-" .. maxLayerLength .. "s", "Layer") .. " | " ..
		string.format("%-" .. maxNeuronsLength .. "s", "Number Of Neurons") .. " | " ..
		string.format("%-" .. maximumBiasLength .. "s", "Has Bias Neuron") .. " | " ..
		string.format("%-" .. maximumActivationLength .. "s", "Activation Function") .. " | " ..
		string.format("%-" .. maximumLearningRateLength .. "s", "Learning Rate") .. " | " ..
		string.format("%-" .. maximumOptimizerLength .. "s", "Optimizer Name") .. " | " ..
		string.format("%-" .. maximumRegularizerLength .. "s", "Regularizer Name") .. " | " .. 
		string.format("%-" .. maximumDropoutRateLength .. "s", "Dropout Rate") .. " |" .. 
		"\n"


	stringToPrint ..= "|-" .. string.rep("-", maxLayerLength) .. "-|-" ..
		string.rep("-", maxNeuronsLength) .. "-|-" ..
		string.rep("-", maximumBiasLength) .. "-|-" ..
		string.rep("-", maximumActivationLength) .. "-|-" ..
		string.rep("-", maximumLearningRateLength) .. "-|-" ..
		string.rep("-", maximumOptimizerLength) .. "-|-" ..
		string.rep("-", maximumRegularizerLength) .. "-|-" .. 
		string.rep("-", maximumDropoutRateLength) .. "-|" .. 
		"\n"

	-- Print the layer details
	for i = 1, #numberOfNeuronsArray, 1 do

		local optimizerName = "None"

		local regularizerName = "None"

		local layerText = "| " .. string.format("%-" .. maxLayerLength .. "s", i) .. " "

		local numberOfNeuronsText = "| " .. string.format("%-" .. maxNeuronsLength .. "s", numberOfNeuronsArray[i]) .. " "

		hasBias = (hasBiasNeuronArray[i] == 1)

		local biasText = "| " .. string.format("%-" .. maximumBiasLength .. "s", tostring(hasBias)) .. " "

		local activationFunctionText = "| " .. string.format("%-" .. maximumActivationLength .. "s", activationFunctionArray[i]) .. " "

		local learningRateText = "| " .. string.format("%-" .. maximumLearningRateLength .. "s", learningRateArray[i]) .. " "

		local Optimizer = OptimizerArray[i]

		local Regularizer = RegularizerArray[i]

		if (type(Optimizer) == "table") then 
			
			optimizerName = Optimizer:getName() 
			
		else
			
			regularizerName = "None"
			
		end

		if (type(Regularizer) == "table") then 
			
			regularizerName = Regularizer:getName() 
			
		else
			
			regularizerName = "None"
			
		end

		local optimizerText = "| " .. string.format("%-" .. maximumOptimizerLength .. "s", optimizerName) .. " "

		local regularizerText = "| " .. string.format("%-" .. maximumRegularizerLength .. "s",  regularizerName) .. " "

		local dropoutRateText = "| " .. string.format("%-" .. maximumDropoutRateLength .. "s", dropoutRateArray[i]) .. " |"

		local stringPart = layerText .. numberOfNeuronsText .. biasText .. activationFunctionText .. learningRateText .. optimizerText .. regularizerText .. dropoutRateText .. "\n"

		stringToPrint ..= stringPart

	end

	stringToPrint ..= "|-" .. string.rep("-", maxLayerLength) .. "-|-" ..
		string.rep("-", maxNeuronsLength) .. "-|-" ..
		string.rep("-", maximumBiasLength) .. "-|-" ..
		string.rep("-", maximumActivationLength) .. "-|-" ..
		string.rep("-", maximumLearningRateLength) .. "-|-" ..
		string.rep("-", maximumOptimizerLength) .. "-|-" ..
		string.rep("-", maximumRegularizerLength) .. "-|-"..
		string.rep("-", maximumDropoutRateLength) .. "-|"
	
	if (ClassesList) then
		
		if (ClassesList ~= 0) then
			
			local availableClassesString = "\n\nAvailable Classes: \n\n"
			
			local numberOfClasses = #ClassesList
			
			for i, class in ipairs(ClassesList) do
				
				if (type(class) ~= "string") then class = tostring(class) end
				
				if (i ~= 1) then availableClassesString = availableClassesString .. " " end
				
				availableClassesString = availableClassesString .. class
				
				if (i < numberOfClasses) then availableClassesString = availableClassesString .. "," end
				
			end
			
			stringToPrint = stringToPrint .. availableClassesString
			
		end
		
	end
	
	print(stringToPrint .. "\n")

end

function NeuralNetworkModel:getNumberOfLayers()

	return #self.numberOfNeuronsArray

end

return NeuralNetworkModel]]></ProtectedString>
									<string name="ScriptGuid">{167FD897-DF23-4B55-9600-594A5A909129}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">NeuralNetwork</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX06DC32736B4A43C4A116246178BA0B7B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Templates</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Frame" referent="RBX9EFE896F2D874F7AB0121424614750B0">
					<Properties>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">999999</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">9999</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">library_prompt_frame</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="UIPadding" referent="RBX5C4B9F5A030E44C38E37370F8EBA860D">
						<Properties>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>50</O>
							</UDim>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">padding</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXB22FC3B25BB44E1BAA1D6E45546B10DE">
						<Properties>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
								<Weight>500</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="OpenTypeFeatures"></string>
							<bool name="RichText">false</bool>
							<string name="Text">Warn</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">30</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0.100000001</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>-0.052516412</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.463894963</YS>
								<YO>60</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">9999</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">message</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX75F7CEED45A040E9ABDED131E65E76D5">
						<Properties>
							<token name="Style">0</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.687363863</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.506762147</XS>
								<XO>0</XO>
								<YS>0.305719912</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">10000</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">buttons_container</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UIListLayout" referent="RBX2F79EFBC685C4C7A898F8B8634FE4A99">
							<Properties>
								<token name="HorizontalFlex">0</token>
								<token name="ItemLineAlignment">0</token>
								<UDim name="Padding">
									<S>0</S>
									<O>10</O>
								</UDim>
								<token name="VerticalFlex">0</token>
								<bool name="Wraps">false</bool>
								<token name="FillDirection">1</token>
								<token name="HorizontalAlignment">0</token>
								<token name="SortOrder">2</token>
								<token name="VerticalAlignment">0</token>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIListLayout</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ImageButton" referent="RBX82B81C3454554312B872592796D9623A">
							<Properties>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<token name="ScaleType">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="AutoButtonColor">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<bool name="Modal">false</bool>
								<Ref name="PressHapticEffect">null</Ref>
								<bool name="Selected">false</bool>
								<token name="Style">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">5</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.826652765</XS>
									<XO>0</XO>
									<YS>0.447885096</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.853305578</XS>
									<XO>0</XO>
									<YS>0.227991059</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">10001</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">no_button</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="TextLabel" referent="RBX93B8819E909442DA9AB498C41ADF060E">
								<Properties>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="OpenTypeFeatures"></string>
									<bool name="RichText">false</bool>
									<string name="Text">Decline</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">18</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">10001</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">label</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageLabel" referent="RBXBFB5DD86D6A54029AE1BA24AF5B94460">
								<Properties>
									<Content name="Image"><url>rbxassetid://11419709766</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0.5</float>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>1</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>20</XO>
										<YS>0</YS>
										<YO>20</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">10001</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">icon</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIPadding" referent="RBXBE6A02AE5DF942D9B3E9367F1C1ADBC1">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBXD3B48F85754047288F0FCF42CE0FDA34">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<token name="StrokeSizingMode">0</token>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ImageButton" referent="RBX88D9B8FFDFF54A5FA194DAA79021138A">
							<Properties>
								<Content name="HoverImage"><null></null></Content>
								<Content name="Image"><null></null></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<Content name="PressedImage"><null></null></Content>
								<token name="ResampleMode">0</token>
								<token name="ScaleType">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="AutoButtonColor">false</bool>
								<Ref name="HoverHapticEffect">null</Ref>
								<bool name="Modal">false</bool>
								<Ref name="PressHapticEffect">null</Ref>
								<bool name="Selected">false</bool>
								<token name="Style">0</token>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">0.899999976</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">2</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.852999985</XS>
									<XO>0</XO>
									<YS>0.228</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">10001</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">yes_button</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="UIPadding" referent="RBX71495FB8419B4708B1ED8047EFB2F3C7">
								<Properties>
									<UDim name="PaddingBottom">
										<S>0</S>
										<O>10</O>
									</UDim>
									<UDim name="PaddingLeft">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingRight">
										<S>0</S>
										<O>20</O>
									</UDim>
									<UDim name="PaddingTop">
										<S>0</S>
										<O>10</O>
									</UDim>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">padding</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBXA91E3008B345420EBDD970B583947A36">
								<Properties>
									<token name="ApplyStrokeMode">0</token>
									<UDim name="BorderOffset">
										<S>0</S>
										<O>0</O>
									</UDim>
									<token name="BorderStrokePosition">0</token>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">2</token>
									<token name="StrokeSizingMode">0</token>
									<float name="Thickness">0</float>
									<float name="Transparency">0.800000012</float>
									<int name="ZIndex">1</int>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">stroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX681968079A034588B828BC52D8839CD2">
								<Properties>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<float name="LineHeight">1</float>
									<string name="LocalizationMatchIdentifier"></string>
									<string name="LocalizationMatchedSourceText"></string>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="OpenTypeFeatures"></string>
									<bool name="RichText">false</bool>
									<string name="Text">Accept</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="TextDirection">0</token>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">18</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">10001</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">label</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageLabel" referent="RBXE0D7AC0424134B95B45FDE647692471E">
								<Properties>
									<Content name="Image"><url>rbxassetid://11419719540</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0.5</float>
									<token name="ResampleMode">0</token>
									<token name="ScaleType">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>1</X>
										<Y>0.5</Y>
									</Vector2>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>20</XO>
										<YS>0</YS>
										<YO>20</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">10001</int>
									<bool name="AutoLocalize">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">icon</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBXF650EB91984949998140C782ED4EDA7F">
					<Properties>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
							<Weight>500</Weight>
							<Style>Normal</Style>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="OpenTypeFeatures"></string>
						<bool name="RichText">false</bool>
						<string name="Text"></string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">30</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0.100000001</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">0</token>
						<token name="TextYAlignment">1</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">2</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.0276422761</XS>
							<XO>0</XO>
							<YS>0.0690335333</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">text</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBXE9416D06D3974A00A03D8EFEF88D897A">
					<Properties>
						<token name="Style">0</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="BackgroundTransparency">0.5</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.0421638824</XS>
							<XO>0</XO>
							<YS>0.0848126262</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.260143191</XS>
							<XO>0</XO>
							<YS>0.644970417</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">InstertFrame</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="TextLabel" referent="RBX6A01289298374895AC3C11F0B5CFA878">
						<Properties>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<float name="LineHeight">1</float>
							<string name="LocalizationMatchIdentifier"></string>
							<string name="LocalizationMatchedSourceText"></string>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="OpenTypeFeatures"></string>
							<bool name="RichText">true</bool>
							<string name="Text"><![CDATA[Insert
<b> Icon Module </b>]]></string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<token name="TextDirection">0</token>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.25</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">title</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UIPadding" referent="RBXFD1AD7FD0F854265BDB313997617A1BE">
							<Properties>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>10</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>10</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>10</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>10</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIPadding</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ImageButton" referent="RBXFB89F5541482476AAB8094FF1FEDF568">
						<Properties>
							<Content name="HoverImage"><null></null></Content>
							<Content name="Image"><null></null></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0</float>
							<Content name="PressedImage"><null></null></Content>
							<token name="ResampleMode">0</token>
							<token name="ScaleType">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<UDim2 name="TileSize">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="AutoButtonColor">false</bool>
							<Ref name="HoverHapticEffect">null</Ref>
							<bool name="Modal">false</bool>
							<Ref name="PressHapticEffect">null</Ref>
							<bool name="Selected">false</bool>
							<token name="Style">0</token>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0.899999976</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">2</int>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.498957217</XS>
								<XO>0</XO>
								<YS>0.726727366</YS>
								<YO>0</YO>
							</UDim2>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.822606266</XS>
								<XO>0</XO>
								<YS>0.376152754</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
							<bool name="AutoLocalize">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">button</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="UIPadding" referent="RBXFC64FCA0DEAF417B86E7CE92CCDA2EDB">
							<Properties>
								<UDim name="PaddingBottom">
									<S>0</S>
									<O>10</O>
								</UDim>
								<UDim name="PaddingLeft">
									<S>0</S>
									<O>20</O>
								</UDim>
								<UDim name="PaddingRight">
									<S>0</S>
									<O>20</O>
								</UDim>
								<UDim name="PaddingTop">
									<S>0</S>
									<O>10</O>
								</UDim>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">padding</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIStroke" referent="RBX6B153157A2C24165846927D9A2D6A478">
							<Properties>
								<token name="ApplyStrokeMode">0</token>
								<UDim name="BorderOffset">
									<S>0</S>
									<O>0</O>
								</UDim>
								<token name="BorderStrokePosition">0</token>
								<Color3 name="Color">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="Enabled">true</bool>
								<token name="LineJoinMode">2</token>
								<token name="StrokeSizingMode">0</token>
								<float name="Thickness">0</float>
								<float name="Transparency">0.800000012</float>
								<int name="ZIndex">1</int>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">stroke</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBXF20C8E84B5304F6CA59989CAFEF5D5C6">
							<Properties>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="OpenTypeFeatures"></string>
								<bool name="RichText">false</bool>
								<string name="Text">Open</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">62</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0.5</Y>
								</Vector2>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1.00319493</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
								<bool name="AutoLocalize">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">label</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX2E8C00F3EB3B4103901D1C5494355691">
					<Properties>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
							<Weight>500</Weight>
							<Style>Normal</Style>
						</Font>
						<float name="LineHeight">1</float>
						<string name="LocalizationMatchIdentifier"></string>
						<string name="LocalizationMatchedSourceText"></string>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="OpenTypeFeatures"></string>
						<bool name="RichText">false</bool>
						<string name="Text">Inserts Window</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<token name="TextDirection">0</token>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">30</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0.100000001</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0</Y>
						</Vector2>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<bool name="Interactable">true</bool>
						<int name="LayoutOrder">0</int>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.500813007</XS>
							<XO>0</XO>
							<YS>0.0276134126</YS>
							<YO>0</YO>
						</UDim2>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>60</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
						<bool name="AutoLocalize">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">separator</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ObjectValue" referent="RBXB9E1BDDD3B064B90AAE601B990621ED9">
				<Properties>
					<Ref name="Value">RBX796AED5A2E69461EABD0CFD5DCBF6485</Ref>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Path</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX6C08CF06D2C14D71A22D2AB7587417C7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Util</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX62FD5D03FEA240D8BC439066208C2A6E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--!strict
-- Utility module for handling RBXScriptConnections. This module is used to track connections and disconnect them when needed.

type ConnectionUtilClass = {
	__index: ConnectionUtilClass,
	new: () -> ConnectionUtil,
	-- Connect with an RBXScripConnection
	trackConnection: (self: ConnectionUtil, string, RBXScriptConnection) -> (),
	-- Adds a manual disconnect function
	trackBoundFunction: (self: ConnectionUtil, string, () -> ()) -> (),
	-- Disconnects the key
	disconnect: (self: ConnectionUtil, string) -> (),
	-- Disconnects all connections on this util
	disconnectAll: (self: ConnectionUtil) -> (),
}

export type ConnectionUtil = typeof(setmetatable({} :: {
	-- Mapping from a unique key to a disconnect function
	_connections: {[string]: () -> ()},
}, {} :: ConnectionUtilClass))

local ConnectionUtil: ConnectionUtilClass = {} :: ConnectionUtilClass;
ConnectionUtil.__index = ConnectionUtil

function ConnectionUtil.new()
	local self = setmetatable({}, ConnectionUtil)

	self._connections = {}

	return self
end

function ConnectionUtil:trackConnection(key, connection)
	if self._connections[key] then
		self._connections[key]() -- Disconnect existing connection
	end
	-- store the disconnect function
	self._connections[key] = function() connection:Disconnect() end
end

function ConnectionUtil:trackBoundFunction(key, disconnectionFunc)
	if self._connections[key] then
		self._connections[key]()
	end
	self._connections[key] = disconnectionFunc
end

function ConnectionUtil:disconnect(key)
	if self._connections[key] then
		self._connections[key]()
		self._connections[key] = nil
	end
end

function ConnectionUtil:disconnectAll()
	for _, disconnectFunc in pairs(self._connections) do
		disconnectFunc()
	end
	self._connections = {} -- Clear all connections
end

return ConnectionUtil]]></ProtectedString>
						<string name="ScriptGuid">{49014FAB-F053-4815-B493-F8FBA3034BB7}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ConnectionUtil</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE467AB64949E42E99B5F2E640006B381">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local InsertService = game:GetService("InsertService")
local HttpService = game:GetService("HttpService")

local InstancesManager = {}
InstancesManager.__index = InstancesManager

local COMMON_LIBRARIES = {
	"Maid", "Janitor", "Spring", "Icon", "Signal", "Promise", 
	"Trove", "Fusion", "Roact", "Rodux", "ProfileService"
}

function InstancesManager.new(gui, templates, inserts, resources, conn, settingsManager)
	local self = setmetatable({}, InstancesManager)
	self.gui = gui
	self.templates = templates
	self.inserts = inserts
	self.resources = resources
	self.conn = conn
	self.settingsManager = settingsManager
	self.animInfo = TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
	self.pendingLibraryChanges = {}
	return self
end

function InstancesManager:print(...)
	if self.settingsManager:getSetting("EnablePrints") then
		print(...)
	end
end

function InstancesManager:disableScripts(instance)
	for _, descendant in instance:GetDescendants() do
		if (descendant:IsA("Script") or descendant:IsA("LocalScript")) and descendant.Enabled then
			descendant.Enabled = false
		end
	end
	if (instance:IsA("Script") or instance:IsA("LocalScript")) and instance.Enabled then
		instance.Enabled = false
	end
end

function InstancesManager:getInsertConfig(insertFolder)
	local configModule = insertFolder:FindFirstChild("Config")
	if configModule then
		local success, config = pcall(function()
			return require(configModule)
		end)
		if success then
			return config
		end
	end
	return {
		Name = insertFolder.Name,
		Thumbnail = "rbxasset://textures/ui/GuiImagePlaceholder.png",
		Description = "No description available",
		Format = {},
		AssetId = nil
	}
end

function InstancesManager:getInsertObject(insertFolder)
	for _, child in insertFolder:GetChildren() do
		if child.Name == insertFolder.Name then
			return child
		end
	end
	return nil
end

function InstancesManager:getTargetPath()
	local pathValue = self.resources:FindFirstChild("Path")
	if pathValue and pathValue:IsA("ObjectValue") then
		if pathValue.Value and pathValue.Value:IsDescendantOf(game) then
			return pathValue.Value
		else
			warn("Path ObjectValue exists but has no value set. Use 'Change Path' to set a target location.")
		end
	else
		warn("Path ObjectValue not found in Resources")
	end
	return game.ServerStorage
end

function InstancesManager:isCommonLibrary(name)
	for _, libName in ipairs(COMMON_LIBRARIES) do
		if name:lower():match(libName:lower()) then
			return libName
		end
	end
	return nil
end

function InstancesManager:findExistingLibrary(libraryName, targetParent)
	local searchLocations = {
		game.ReplicatedStorage,
		game.ServerStorage,
		game.ServerScriptService,
		targetParent
	}

	for _, location in ipairs(searchLocations) do
		local found = location:FindFirstChild(libraryName, true)
		if found and found:IsA("ModuleScript") then
			return found
		end
	end
	return nil
end

function InstancesManager:findModulesRequiringLibrary(libraryName, oldModule)
	local modules = {}
	local searchLocations = {
		game.ReplicatedStorage,
		game.ServerStorage,
		game.ServerScriptService,
		game.StarterPlayer,
		game.StarterPack,
		game.StarterGui,
		workspace
	}

	local oldPath = oldModule:GetFullName()

	for _, location in ipairs(searchLocations) do
		for _, descendant in ipairs(location:GetDescendants()) do
			if descendant:IsA("ModuleScript") or descendant:IsA("Script") or descendant:IsA("LocalScript") then
				local success, source = pcall(function()
					return descendant.Source
				end)

				if success and source then
					local patterns = {
						"require%(%s*[^)]*" .. libraryName .. "[^)]*%)",
						"require%s*%(%s*[^)]*" .. oldPath:gsub("([^%w])", "%%%1") .. "[^)]*%)",
						"require%(\"[^\"]*" .. libraryName .. "[^\"]*\"%)",
						"require%('[^']*" .. libraryName .. "[^']*'%)",
						"require%(\"[^\"]*" .. oldPath:gsub("([^%w])", "%%%1") .. "[^\"]*\"%)",
						"require%('[^']*" .. oldPath:gsub("([^%w])", "%%%1") .. "[^']*'%)"
					}

					for _, pattern in ipairs(patterns) do
						if source:match(pattern) then
							table.insert(modules, descendant)
							break
						end
					end
				end
			end
		end
	end

	return modules
end

function InstancesManager:updateRequirePaths(modules, oldModule, newModule, libraryName)
	local updatedCount = 0
	local oldFullName = oldModule:GetFullName()
	local newFullName = newModule:GetFullName()

	self:print("Updating require paths from: " .. oldFullName .. " to: " .. newFullName)
	self:print("Found " .. #modules .. " modules that may need updating for library: " .. libraryName)

	for _, module in ipairs(modules) do
		local success, err = pcall(function()
			local source = module.Source
			local originalSource = source

			local replacements = {
				-- require(game.ServerStorage.ModuleName)
				["require%s*%(%s*" .. oldFullName:gsub("([%(%)%.%[%]%*%+%-%?%^%$%%])", "%%%1") .. "%s*%)"] = "require(" .. newFullName .. ")",
				-- require "game.ServerStorage.ModuleName"
				["require%s*%\"%s*" .. oldFullName:gsub("([%(%)%.%[%]%*%+%-%?%^%$%%])", "%%%1") .. "%s*%\""] = "require(\"" .. newFullName .. "\")",
				-- require 'game.ServerStorage.ModuleName'
				["require%s*%'%s*" .. oldFullName:gsub("([%(%)%.%[%]%*%+%-%?%^%$%%])", "%%%1") .. "%s*%'"] = "require('" .. newFullName .. "')",
				-- require with library name
				["require%s*%(%s*[^)]*" .. libraryName .. "[^)]*%)"] = "require(" .. newFullName .. ")",
				["require%(\"[^\"]*" .. libraryName .. "[^\"]*\"%)"] = "require(\"" .. newFullName .. "\")",
				["require%('[^']*" .. libraryName .. "[^']*'%)"] = "require('" .. newFullName .. "')"
			}

			local wasUpdated = false
			for pattern, replacement in pairs(replacements) do
				local newSource, count = source:gsub(pattern, replacement)
				if count > 0 then
					source = newSource
					updatedCount = updatedCount + count
					wasUpdated = true
					self:print("   Updated " .. module:GetFullName() .. " (pattern matched)")
				end
			end

			if wasUpdated then
				module.Source = source
				self:print("   Successfully updated require path in: " .. module:GetFullName())
			else
				self:print("   No matching require pattern found in: " .. module:GetFullName())
			end
		end)

		if not success then
			warn("Failed to update require path in " .. module:GetFullName() .. ": " .. tostring(err))
		end
	end

	self:print(" Updated " .. updatedCount .. " require paths across " .. #modules .. " modules for library: " .. libraryName)
	return updatedCount
end

function InstancesManager:showLibraryPrompt(libraryName, existingLib, newLib, targetParent, callback)
	local clonepromptFrame = self.templates:FindFirstChild("library_prompt_frame")
	if not clonepromptFrame then
		warn("library_prompt_frame not found in GUI")
		if callback then callback(false) end
		return
	end
	local promptFrame = clonepromptFrame:Clone()
	promptFrame.Parent = self.gui

	local messageLabel = promptFrame:FindFirstChild("message")
	if messageLabel then
		messageLabel.Text = string.format(
			"Found existing '%s' module at:\n%s\n\nWould you like to move it to the new insert path and update all references?\n\nThis will update require() paths in all scripts that reference this library.",
			libraryName,
			existingLib:GetFullName()
		)
	end

	self:animateFrameIn(promptFrame)

	local function cleanup()
		self.conn:disconnect("LibraryPromptYes")
		self.conn:disconnect("LibraryPromptNo")
		if promptFrame and promptFrame.Parent then
			self:animateFrameOut(promptFrame, function()
				promptFrame:Destroy()
			end)
		end
	end

	self.conn:trackConnection("LibraryPromptYes",
		promptFrame.buttons_container.yes_button.MouseButton1Down:Connect(function()
			cleanup()
			if callback then callback(true) end
		end)
	)

	self.conn:trackConnection("LibraryPromptNo",
		promptFrame.buttons_container.no_button.MouseButton1Down:Connect(function()
			cleanup()
			if callback then callback(false) end
		end)
	)
end

function InstancesManager:loadFromAssetId(assetId, callback)
	if not self.settingsManager:getSetting("EnableMarketplaceImporting") then
		self:print("Marketplace importing is disabled in settings")
		if callback then callback(nil) end
		return nil
	end

	local success, result = pcall(function()
		return InsertService:LoadAsset(assetId)
	end)

	if success and result then
		self:print("Successfully loaded asset: " .. assetId)
		local model = result:GetChildren()[1]
		if model then
			model.Parent = workspace.Terrain
			result:Destroy()
			if callback then callback(model) end
			task.delay(1, function()
				model:Destroy()
			end)
			return model
		else
			warn("Asset loaded but contains no children")
			result:Destroy()
		end
	else
		if tostring(result):lower():find("permission") or tostring(result):lower():find("not allowed") then
			warn("Permission denied for asset insertion. Please enable asset insertion in Roblox Studio settings. Loading local asset instead.")
		else
			warn("Failed to load asset " .. assetId .. ": " .. tostring(result) .. ". Loading local asset instead.")
		end
	end

	if callback then callback(nil) end
	return nil
end

function InstancesManager:populateInstanceContainer(container, format)
	for _, child in container:GetChildren() do
		if not child:IsA("UIListLayout") and not child:IsA("UIPadding") then
			child:Destroy()
		end
	end

	if not container:FindFirstChild("UIListLayout") then
		local listLayout = Instance.new("UIListLayout")
		listLayout.SortOrder = Enum.SortOrder.LayoutOrder
		listLayout.Padding = UDim.new(0, 5)
		listLayout.Parent = container
	end

	local layoutOrder = 0
	for _, item in ipairs(format) do
		layoutOrder += 1

		if item.Separator then
			local separator = self.templates:FindFirstChild("separator")
			if separator then
				local newSeparator = separator:Clone()
				local titleLabel = newSeparator:FindFirstChildWhichIsA("TextLabel", true)
				if titleLabel then
					titleLabel.Text = item.Separator
				elseif newSeparator:IsA("TextLabel") then
					newSeparator.Text = item.Separator
				end
				newSeparator.LayoutOrder = layoutOrder
				newSeparator.Parent = container
			end
		elseif item.Text then
			local textTemplate = self.templates:FindFirstChild("text")
			if textTemplate then
				local newText = textTemplate:Clone()
				local textLabel = newText:FindFirstChildWhichIsA("TextLabel", true)
				if textLabel then
					textLabel.Text = item.Text
				elseif newText:IsA("TextLabel") then
					newText.Text = item.Text
				end
				newText.LayoutOrder = layoutOrder
				newText.Parent = container
			end
		end
	end
end

function InstancesManager:animateFrameIn(frame)
	frame.Position = UDim2.new(0.5, 0, 1.5, 0)
	frame.Visible = true
	TweenService:Create(frame, self.animInfo, {
		Position = UDim2.new(0.5, 0, 0.5, 0)
	}):Play()
end

function InstancesManager:animateFrameOut(frame, callback)
	local tween = TweenService:Create(frame, self.animInfo, {
		Position = UDim2.new(0.5, 0, -0.5, 0)
	})
	tween.Completed:Connect(function()
		frame.Visible = false
		frame.Position = UDim2.new(0.5, 0, 0.5, 0)
		if callback then callback() end
	end)
	tween:Play()
end

function InstancesManager:findLibrariesInObject(object)
	local libraries = {}

	if object:IsA("ModuleScript") then
		local libraryType = self:isCommonLibrary(object.Name)
		if libraryType then
			table.insert(libraries, {module = object, libraryType = libraryType})
		end
	end

	for _, descendant in ipairs(object:GetDescendants()) do
		if descendant:IsA("ModuleScript") then
			local libraryType = self:isCommonLibrary(descendant.Name)
			if libraryType then
				table.insert(libraries, {module = descendant, libraryType = libraryType})
			end
		end
	end

	return libraries
end

function InstancesManager:handleLibraryConflict(libraryInfo, existingLib, targetParent, onComplete)
	self:showLibraryPrompt(libraryInfo.libraryType, existingLib, libraryInfo.module, targetParent, function(userAccepted)
		if userAccepted then
			local success, err = pcall(function()
				local oldLocation = existingLib:GetFullName()
				existingLib.Parent = targetParent
				local newLocation = existingLib:GetFullName()

				self:print("Moved existing " .. libraryInfo.libraryType .. " from " .. oldLocation .. " to " .. newLocation)

				local dependentModules = self:findModulesRequiringLibrary(libraryInfo.libraryType, existingLib)
				if #dependentModules > 0 then
					self:print("Found " .. #dependentModules .. " modules that require " .. libraryInfo.libraryType)
					self:print("Updating require paths...")

					local updatedCount = self:updateRequirePaths(dependentModules, existingLib, existingLib, libraryInfo.libraryType)

					if updatedCount > 0 then
						self:print(" Successfully updated " .. updatedCount .. " require paths for " .. libraryInfo.libraryType)
					else
						self:print(" No require paths needed updating for " .. libraryInfo.libraryType)
					end
				else
					self:print("No modules found that require " .. libraryInfo.libraryType)
				end
			end)

			if not success then
				warn("Failed to move library: " .. tostring(err))
			end

			libraryInfo.module:Destroy()
		else
			local success, err = pcall(function()
				libraryInfo.module.Name = libraryInfo.module.Name .. "_New"
				self:print("Renamed new library to: " .. libraryInfo.module.Name)
			end)

			if not success then
				warn("Failed to rename new library: " .. tostring(err))
			end
		end

		if onComplete then onComplete() end
	end)
end

function InstancesManager:insertInstance(insertObject, config, targetParent)
	local insertClone = insertObject:Clone()
	self:disableScripts(insertClone)
	insertClone.Name = insertObject.Name

	local librariesFound = self:findLibrariesInObject(insertClone)

	if #librariesFound > 0 then
		self:print("Found " .. #librariesFound .. " common libraries in insert")

		local conflictsToResolve = {}
		for _, libInfo in ipairs(librariesFound) do
			local existingLib = self:findExistingLibrary(libInfo.libraryType, targetParent)
			if existingLib then
				table.insert(conflictsToResolve, {libInfo = libInfo, existing = existingLib})
				self:print("Conflict detected: " .. libInfo.libraryType .. " already exists at " .. existingLib:GetFullName())
			end
		end

		if #conflictsToResolve > 0 then
			local currentIndex = 1
			local function resolveNext()
				if currentIndex <= #conflictsToResolve then
					local conflict = conflictsToResolve[currentIndex]
					currentIndex = currentIndex + 1
					self:handleLibraryConflict(conflict.libInfo, conflict.existing, targetParent, resolveNext)
				else
					local success, errorMsg = pcall(function()
						insertClone.Parent = targetParent
						self:print("Successfully inserted: " .. insertObject.Name .. " into " .. targetParent:GetFullName())
					end)

					if not success then
						warn("Failed to insert object: " .. tostring(errorMsg))
					end
				end
			end

			resolveNext()
			return
		end
	end

	local success, errorMsg = pcall(function()
		insertClone.Parent = targetParent
		self:print("Successfully inserted: " .. insertObject.Name .. " into " .. targetParent:GetFullName())
	end)

	if not success then
		warn("Failed to insert object: " .. tostring(errorMsg))
	end
end

function InstancesManager:showInstanceFrame(insertFolder)
	self:animateFrameOut(self.gui.insets_frame, function()
		local config = self:getInsertConfig(insertFolder)
		local insertObject = self:getInsertObject(insertFolder)

		self.gui.instance_frame.header.Text = config.Name or insertFolder.Name
		self.gui.instance_frame.instance_thumbnail.Image = config.Thumbnail

		local container = self.gui.instance_frame:FindFirstChild("info_container")
		if container then
			self:populateInstanceContainer(container, config.Format or {})
		end

		self:animateFrameIn(self.gui.instance_frame)

		self.conn:trackConnection("InstanceFrameGoBack",
			self.gui.instance_frame.buttons_container.go_back.MouseButton1Down:Connect(function()
				self:animateFrameOut(self.gui.instance_frame, function()
					self:animateFrameIn(self.gui.insets_frame)
				end)
				self.conn:disconnect("InstanceFrameGoBack")
				self.conn:disconnect("InstanceFrameInsert")
			end)
		)

		self.conn:trackConnection("InstanceFrameInsert",
			self.gui.instance_frame.buttons_container.insert_button.MouseButton1Down:Connect(function()
				local targetParent = self:getTargetPath()

				if config.AssetId and tonumber(config.AssetId) then
					self:print("Loading asset from AssetId: " .. config.AssetId)
					self:loadFromAssetId(config.AssetId, function(loadedAsset)
						if loadedAsset then
							self:disableScripts(loadedAsset)
							self:insertInstance(loadedAsset, config, targetParent)
						else
							warn("Failed to load asset from marketplace, using local object...")
							if insertObject then
								self:insertInstance(insertObject, config, targetParent)
							else
								warn("No local object available for fallback")
							end
						end
					end)
				elseif insertObject then
					self:insertInstance(insertObject, config, targetParent)
				else
					warn("Insert object is nil and no AssetId provided")
				end
			end)
		)
	end)
end

function InstancesManager:refreshInsertsList()
	for _, child in self.gui.insets_frame.inserts_container:GetChildren() do
		if child:IsA("Frame") or child:IsA("GuiObject") then
			child:Destroy()
		end
	end

	for _, insertFolder in self.inserts:GetChildren() do
		if insertFolder:IsA("Folder") then
			local template = self.templates.InstertFrame:Clone()
			template.title.Text = insertFolder.Name
			template.Parent = self.gui.insets_frame.inserts_container

			self.conn:trackConnection("insertModulesButton_" .. insertFolder.Name,
				template.button.MouseButton1Click:Connect(function()
					self:showInstanceFrame(insertFolder)
				end)	
			)
		end
	end
end

return InstancesManager]]></ProtectedString>
						<string name="ScriptGuid">{DE53A6C0-5E46-4E57-9021-C7EC4AA89F47}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">InstancesManager</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX680123622647423F8229A62FB030B244">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local PathChangerManager = {}
PathChangerManager.__index = PathChangerManager

function PathChangerManager.new(gui, resources, conn, plugin)
	local self = setmetatable({}, PathChangerManager)
	self.gui = gui
	self.resources = resources
	self.conn = conn
	self.plugin = plugin
	self.settingKey = "EncryUtilsPathValue"
	self:loadSettings()
	self:updatePathDisplay()
	return self
end

function PathChangerManager:instanceToPath(instance)
	if not instance then return nil end
	local path = instance:GetFullName()
	path = path:gsub("^game%.", "")
	return path
end

function PathChangerManager:pathToInstance(pathString)
	if not pathString or pathString == "" then return nil end
	local parts = string.split(pathString, ".")
	local service = game:GetService(parts[1])
	if #parts == 1 then
		return service
	end
	local objectSoFar = service
	for index, value in pairs(parts) do
		if index ~= 1 then
			local object = objectSoFar:FindFirstChild(value)
			if object then
				objectSoFar = object
			else
				return nil
			end
		end
	end
	return objectSoFar
end

function PathChangerManager:loadSettings()
	if not self.plugin then
		warn("PathChangerManager: Plugin not provided, cannot load settings")
		return
	end
	local savedPath = self.plugin:GetSetting(self.settingKey)
	if savedPath and type(savedPath) == "string" then
		local instance = self:pathToInstance(savedPath)
		if instance then
			pcall(function()
				self.resources.Path.Value = instance
			end)
		end
	end
end

function PathChangerManager:saveSettings(instance)
	local path = self:instanceToPath(instance)
	if path then
		self.plugin:SetSetting(self.settingKey, path)
	end
end

function PathChangerManager:updatePathDisplay()
	local pathValue = self.resources:FindFirstChild("Path")
	if pathValue and pathValue.Value then
		local displayText = pathValue.Value.Name

		local changeButton = self.gui.path_changer_frame:FindFirstChild("change_path")
		if changeButton then
			local valueLabel = changeButton:FindFirstChild("value")
			if valueLabel then
				valueLabel.Text = displayText
			end
		end

		local openableButton = self.gui.button_container.scroll:FindFirstChild("change_path")
		if openableButton then
			local valueLabel = openableButton:FindFirstChild("value")
			if valueLabel then
				valueLabel.Text = displayText
			end
		end
	end
end

function PathChangerManager:showGoBackButton(visible)
	if self.gui.path_changer_frame.go_back then
		self.gui.path_changer_frame.go_back.Visible = visible
	end
end

function PathChangerManager:cancelSelection()
	self.conn:disconnect("pathSelectionWatcher")
	self:showGoBackButton(true)

	local changeButton = self.gui.path_changer_frame:FindFirstChild("change_path")
	if changeButton then
		local label = changeButton:FindFirstChild("label")
		if label then
			label.Text = "Change Insert Path"
		end
	end

	game:GetService("Selection"):Set({})
end

function PathChangerManager:initialize()
	self:updatePathDisplay()

	self.conn:trackConnection("pathConn",
		self.gui.path_changer_frame.change_path.MouseButton1Down:Connect(function()
			local changeButton = self.gui.path_changer_frame.change_path
			local label = changeButton:FindFirstChild("label")
			if label then
				label.Text = "Select your desired location!"
			end

			self:showGoBackButton(false)
			local selection = game:GetService("Selection")
			selection:Set({})

			self.conn:trackConnection("pathSelectionWatcher", 
				selection.SelectionChanged:Connect(function()
					local selected = selection:Get()
					if #selected == 1 then
						local instance = selected[1]
						if instance then
							local success, result = pcall(function()
								self.resources.Path.Value = instance
								self:saveSettings(instance)
								self:updatePathDisplay()

								if label then
									label.Text = "Change Insert Path"
								end

								self:showGoBackButton(true)
								selection:Set({})
								self.conn:disconnect("pathSelectionWatcher")
							end)
							if not success then
								if label then
									label.Text = "Failed to set path!"
								end
								warn("Path Change Failed: " .. tostring(result))
								task.wait(2)
								if label then
									label.Text = "Change Insert Path"
								end
								self:showGoBackButton(true)
							end
						end
					end
				end)	
			)
		end)
	)
end

return PathChangerManager]]></ProtectedString>
						<string name="ScriptGuid">{2B4ED9B8-BF36-42E6-8E3F-8C43F72E1319}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">PathChangerManager</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7C3FE553C43049EE981ABFDCB0F3AC47">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local MagicSelectManager = {}
MagicSelectManager.__index = MagicSelectManager

function MagicSelectManager.new(gui, conn, plugin)
	local self = setmetatable({}, MagicSelectManager)
	self.gui = gui
	self.conn = conn
	self.plugin = plugin
	self.settingKey = "EncryUtilsMagicSelectSettings"
	self.maxSelectionLimit = 100
	self.magicSelectSettings = {
		ByName = true,
		ByClass = true,
		ByParent = true,
		ByColor = true
	}
	self.isSelecting = false
	self:loadSettings()
	return self
end

function MagicSelectManager:loadSettings()
	if not self.plugin then
		warn("MagicSelectManager: Plugin not provided, cannot load settings")
		return
	end
	local savedSettings = self.plugin:GetSetting(self.settingKey)
	if savedSettings and type(savedSettings) == "table" then
		for key, value in pairs(savedSettings) do
			if self.magicSelectSettings[key] ~= nil then
				self.magicSelectSettings[key] = value
			end
		end
	end
end

function MagicSelectManager:saveSettings()
	self.plugin:SetSetting(self.settingKey, self.magicSelectSettings)
end

function MagicSelectManager:updateMagicSelectButtons()
	local settingsContainer = self.gui.magic_select_frame:FindFirstChild("settings_container")
	if not settingsContainer then return end

	for name, value in pairs(self.magicSelectSettings) do
		local button = settingsContainer:FindFirstChild("by_" .. name:lower():sub(3))
		if button and button:IsA("ImageButton") then
			local valueLabel = button:FindFirstChild("value")
			if valueLabel and valueLabel:IsA("TextLabel") then
				valueLabel.Text = tostring(value)
			end
		end
	end
end

function MagicSelectManager:setSettingsVisibility(visible)
	local settingsContainer = self.gui.magic_select_frame:FindFirstChild("settings_container")
	if not settingsContainer then return end

	for _, child in pairs(settingsContainer:GetChildren()) do
		if child:IsA("ImageButton") then
			child.Visible = visible
		end
	end
end

function MagicSelectManager:cancelSelection()
	self.conn:disconnect("MagicSelectionWatcher")

	local goBackButton = self.gui.magic_select_frame:FindFirstChild("go_back")
	if goBackButton then
		local label = goBackButton:FindFirstChild("label")
		if label then
			label.Text = "Go Back"
		end
	end

	self:setSettingsVisibility(true)
	self.isSelecting = false
	game:GetService("Selection"):Set({})
end

function MagicSelectManager:findSimilarInstances(baseInstance)
	local allInstances = {}

	local function shouldSelect(instance)
		local shouldSelect = true

		if self.magicSelectSettings.ByName and instance.Name ~= baseInstance.Name then
			shouldSelect = false
		end

		if self.magicSelectSettings.ByClass and instance.ClassName ~= baseInstance.ClassName then
			shouldSelect = false
		end

		if self.magicSelectSettings.ByParent and instance.Parent ~= baseInstance.Parent then
			shouldSelect = false
		end

		if self.magicSelectSettings.ByColor then
			if baseInstance:IsA("BasePart") and instance:IsA("BasePart") then
				if instance.BrickColor ~= baseInstance.BrickColor then
					shouldSelect = false
				end
			elseif baseInstance:IsA("BasePart") ~= instance:IsA("BasePart") then
				shouldSelect = false
			end
		end

		return shouldSelect
	end

	local function searchInContainer(container)
		for _, instance in container:GetChildren() do
			if shouldSelect(instance) then
				table.insert(allInstances, instance)
				if #allInstances >= self.maxSelectionLimit then
					return true
				end
			end
			if searchInContainer(instance) then
				return true
			end
		end
		return false
	end

	searchInContainer(game)
	return allInstances
end

function MagicSelectManager:initialize()
	self:updateMagicSelectButtons()

	local settingsContainer = self.gui.magic_select_frame:FindFirstChild("settings_container")
	if settingsContainer then
		for name, _ in pairs(self.magicSelectSettings) do
			local buttonName = "by_" .. name:lower():sub(3)
			local button = settingsContainer:FindFirstChild(buttonName)
			if button and button:IsA("ImageButton") then
				self.conn:trackConnection("MagicSelect" .. name,
					button.MouseButton1Down:Connect(function()
						self.magicSelectSettings[name] = not self.magicSelectSettings[name]
						self:saveSettings()
						self:updateMagicSelectButtons()
					end)
				)
			end
		end
	end

	local selectButton = self.gui.magic_select_frame.buttons_container:FindFirstChild("select")
	if selectButton then
		self.conn:trackConnection("MagicSelectSelect",
			selectButton.MouseButton1Down:Connect(function()
				if self.isSelecting then return end

				self.isSelecting = true

				local goBackButton = self.gui.magic_select_frame:FindFirstChild("go_back")
				if goBackButton then
					local label = goBackButton:FindFirstChild("label")
					if label then
						label.Text = "Cancel"
					end
				end

				self:setSettingsVisibility(false)

				local selection = game:GetService("Selection")
				selection:Set({})

				self.conn:trackConnection("MagicSelectionWatcher",
					selection.SelectionChanged:Connect(function()
						if not self.isSelecting then return end

						local selected = selection:Get()
						if #selected == 1 then
							local instance = selected[1]
							if instance then
								self.conn:disconnect("MagicSelectionWatcher")

								local allInstances = self:findSimilarInstances(instance)

								if #allInstances >= self.maxSelectionLimit then
									warn(string.format("Magic Select: Found %d instances, limiting to %d", 
										#allInstances, self.maxSelectionLimit))
								end

								task.wait()
								selection:Set(allInstances)

								if goBackButton then
									local label = goBackButton:FindFirstChild("label")
									if label then
										label.Text = "Go Back"
									end
								end

								self:setSettingsVisibility(true)
								self.isSelecting = false
							end
						end
					end)
				)
			end)
		)
	end
end

return MagicSelectManager]]></ProtectedString>
						<string name="ScriptGuid">{58737B9C-4A61-47F3-BB7C-D7A4DDD6F311}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">MagicSelectManager</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4D36869400DE4415A98D977318DE8D18">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local SettingsManager = {}
SettingsManager.__index = SettingsManager

function SettingsManager.new(plugin)
	local self = setmetatable({}, SettingsManager)
	self.plugin = plugin
	self.settingKey = "EncryUtilsSettings"
	self.defaultSettings = {
		EnablePrints = true,
		EnableMarketplaceImporting = true
	}
	self.settings = self:loadSettings()
	return self
end

function SettingsManager:loadSettings()
	local savedSettings = self.plugin:GetSetting(self.settingKey)
	if savedSettings and type(savedSettings) == "table" then
		local mergedSettings = table.clone(self.defaultSettings)
		for key, value in pairs(savedSettings) do
			if mergedSettings[key] ~= nil then
				mergedSettings[key] = value
			end
		end
		return mergedSettings
	end
	return table.clone(self.defaultSettings)
end

function SettingsManager:saveSettings()
	self.plugin:SetSetting(self.settingKey, self.settings)
end

function SettingsManager:getSetting(settingName)
	return self.settings[settingName]
end

function SettingsManager:setSetting(settingName, value)
	self.settings[settingName] = value
	self:saveSettings()
	self:updateSettingsButtons()
end

function SettingsManager:updateSettingsButtons()
	if not self.gui or not self.gui:FindFirstChild("settings_frame") then
		warn("SettingsManager: GUI not initialized or settings_frame not found")
		return
	end

	local settingsContainer = self.gui.settings_frame:FindFirstChild("settings_container")
	if not settingsContainer then
		warn("SettingsManager: settings_container not found")
		return
	end

	for settingName, value in pairs(self.settings) do
		local buttonNames = {
			settingName:lower(),
			"enable_" .. settingName:lower(),
			settingName
		}

		local button = nil
		for _, buttonName in ipairs(buttonNames) do
			button = settingsContainer:FindFirstChild(buttonName)
			if button then break end
		end

		if button and button:IsA("ImageButton") then
			local valueLabel = button:FindFirstChild("value")
			if valueLabel and valueLabel:IsA("TextLabel") then
				valueLabel.Text = tostring(value)
			else
				warn("SettingsManager: Value label not found in button " .. button.Name)
			end
		else
			warn("SettingsManager: Button not found for setting: " .. settingName)
		end
	end
end

function SettingsManager:initialize(gui, conn)
	self.gui = gui
	self.conn = conn

	local settingsContainer = self.gui.settings_frame:FindFirstChild("settings_container")
	if not settingsContainer then
		warn("SettingsManager: settings_container not found in settings_frame")
		return
	end

	for settingName, _ in pairs(self.settings) do
		local buttonNames = {
			settingName:lower(),
			"enable_" .. settingName:lower(),
			settingName
		}

		local button = nil
		for _, buttonName in ipairs(buttonNames) do
			button = settingsContainer:FindFirstChild(buttonName)
			if button then break end
		end

		if button and button:IsA("ImageButton") then
			self.conn:trackConnection("Settings" .. settingName,
				button.MouseButton1Down:Connect(function()
					local newValue = not self:getSetting(settingName)
					self:setSetting(settingName, newValue)
				end)
			)
		else
			warn("SettingsManager: Could not find button for setting: " .. settingName)
		end
	end

	self:updateSettingsButtons()
end

return SettingsManager]]></ProtectedString>
						<string name="ScriptGuid">{254DA81D-7C90-419D-8E0E-65D8825BBF43}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">SettingsManager</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX641B32D3D4884001B8B652018900D691">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local BulkExportManager = {}
BulkExportManager.__index = BulkExportManager

function BulkExportManager.new(gui, conn, plugin, settingsManager)
	local self = setmetatable({}, BulkExportManager)
	self.gui = gui
	self.conn = conn
	self.plugin = plugin
	self.settingsManager = settingsManager
	self.currentSelection = {}
	self.isExporting = false
	self.exportQueue = {}
	self.currentExportIndex = 0
	self.waitingForContinue = false
	return self
end

function BulkExportManager:print(...)
	if self.settingsManager:getSetting("EnablePrints") then
		print(...)
	end
end

function BulkExportManager:updateSelectionDisplay()
	local subHeader = self.gui.bulk_export_frame:FindFirstChild("sub_header")
	if not subHeader then return end

	local selection = game:GetService("Selection"):Get()
	self.currentSelection = selection

	if #selection == 0 then
		subHeader.Text = "Current Loaded Item: No selection"
	elseif #selection == 1 then
		subHeader.Text = "Current Loaded Item: " .. selection[1].Name
	else
		subHeader.Text = "Current Loaded Item: " .. #selection .. " items selected"
	end
end

function BulkExportManager:setButtonsVisibility(visible)
	local buttonsContainer = self.gui.bulk_export_frame:FindFirstChild("buttons_container")
	if not buttonsContainer then return end

	for _, button in pairs(buttonsContainer:GetChildren()) do
		if button:IsA("ImageButton") then
			button.Visible = visible
		end
	end
end

function BulkExportManager:updateExportButtonText(text)
	local exportButton = self.gui.bulk_export_frame.buttons_container:FindFirstChild("export")
	if not exportButton then return end

	local label = exportButton:FindFirstChild("label")
	if label then
		label.Text = text
	end
end

function BulkExportManager:updateProgressDisplay()
	local subHeader = self.gui.bulk_export_frame:FindFirstChild("sub_header")
	if not subHeader then return end

	if self.isExporting and #self.exportQueue > 0 then
		if self.waitingForContinue then
			subHeader.Text = string.format("Export paused at %d/%d: %s (Press Continue)", 
				self.currentExportIndex, #self.exportQueue, 
				self.exportQueue[self.currentExportIndex].Name)
		else
			subHeader.Text = string.format("Exporting %d/%d: %s", 
				self.currentExportIndex, #self.exportQueue, 
				self.exportQueue[self.currentExportIndex].Name)
		end
	end
end

function BulkExportManager:exportSelection()
	if self.waitingForContinue then
		self.waitingForContinue = false
		self:updateExportButtonText("Export")
		self:processNextExport()
		return
	end

	local selection = self.currentSelection
	if #selection == 0 then
		self:print("No items selected for export")
		return
	end

	if self.isExporting then
		self:print("Export already in progress")
		return
	end

	self.isExporting = true
	self:setButtonsVisibility(true)

	self.exportQueue = {}
	for _, item in ipairs(selection) do
		if item:IsDescendantOf(game) then
			table.insert(self.exportQueue, item)
		else
			self:print(" Skipping item not in game: " .. item.Name)
		end
	end

	if #self.exportQueue == 0 then
		self:print("No valid items to export")
		self.isExporting = false
		return
	end

	self:print("Starting sequential export of " .. #self.exportQueue .. " items...")
	self.currentExportIndex = 0
	self.waitingForContinue = false

	self:processNextExport()
end

function BulkExportManager:processNextExport()
	self.currentExportIndex = self.currentExportIndex + 1

	if self.currentExportIndex > #self.exportQueue then
		self:print("Bulk export completed!")
		self.isExporting = false
		self.waitingForContinue = false
		self:updateExportButtonText("Export")
		self:updateSelectionDisplay()
		return
	end

	local currentItem = self.exportQueue[self.currentExportIndex]
	self:updateProgressDisplay()

	self:print("Exporting " .. self.currentExportIndex .. "/" .. #self.exportQueue .. ": " .. currentItem.Name .. " (" .. currentItem.ClassName .. ")")

	game:GetService("Selection"):Set({currentItem})

	local success = self.plugin:SaveSelectedToRoblox()

	if success then
		self:print(" Successfully completed export for: " .. currentItem.Name)
		self:processNextExport()
	else
		self:print(" Export cancelled or failed for: " .. currentItem.Name)
		self.waitingForContinue = true
		self:updateExportButtonText("Continue Export")
		self:updateProgressDisplay()
		self:print("Export paused. Press 'Continue Export' to proceed with remaining items.")
	end
end

function BulkExportManager:cancelExport()
	if self.isExporting then
		self:print("Bulk export cancelled")
		self.isExporting = false
		self.waitingForContinue = false
		self.exportQueue = {}
		self.currentExportIndex = 0
		self:updateExportButtonText("Export")
		self:updateSelectionDisplay()
	end
end

function BulkExportManager:getExportName(item, index)
	local nameField = self.gui.bulk_export_frame:FindFirstChild("export_name")
	if not nameField then return item.Name end

	local textBox = nameField:FindFirstChild("export_name")
	if not textBox or textBox.Text == "" then return item.Name end

	local baseName = textBox.Text
	if #self.exportQueue > 1 then
		return baseName .. "_" .. index
	end

	return baseName
end

function BulkExportManager:initialize()
	self:updateSelectionDisplay()

	local selectionService = game:GetService("Selection")
	self.conn:trackConnection("BulkExportSelectionWatcher",
		selectionService.SelectionChanged:Connect(function()
			if not self.isExporting then
				self:updateSelectionDisplay()
			end
		end)
	)

	local exportButton = self.gui.bulk_export_frame.buttons_container:FindFirstChild("export")
	if exportButton then
		self.conn:trackConnection("BulkExportExecute",
			exportButton.MouseButton1Down:Connect(function()
				if not self.isExporting and not self.waitingForContinue then
					self:exportSelection()
				elseif self.waitingForContinue then
					self:exportSelection()
				end
			end)
		)
	end

	local exportTypeButton = self.gui.bulk_export_frame.settings_container:FindFirstChild("export_type")
	if exportTypeButton then
		self.conn:trackConnection("BulkExportTypeToggle",
			exportTypeButton.MouseButton1Down:Connect(function()
				self:print("Export type toggle clicked - currently only supports Model export")
			end)
		)
	end

	local exportToButton = self.gui.bulk_export_frame.settings_container:FindFirstChild("export_to")
	if exportToButton then
		self.conn:trackConnection("BulkExportToToggle",
			exportToButton.MouseButton1Down:Connect(function()
				self:print("Export destination toggle clicked - currently only supports personal inventory")
			end)
		)
	end

	local contentTypeButton = self.gui.bulk_export_frame.settings_container:FindFirstChild("export_type_1")
	if contentTypeButton then
		self.conn:trackConnection("BulkExportContentTypeToggle",
			contentTypeButton.MouseButton1Down:Connect(function()
				self:print("Content type toggle clicked - currently only supports Development Items")
			end)
		)
	end
end

return BulkExportManager]]></ProtectedString>
						<string name="ScriptGuid">{22D2AFD7-1E62-4CFA-838E-5C0BF6B7A507}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">BulkExportManager</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<SharedStrings>
		<SharedString md5="aaQQwlzZOlor7w4mpBFaRg==">Q1NHUEhTBwAAAALWGYVAtL0atRTKtSMNQse0FA/UP5P+diJsCyY2wsbTP/heGaRLD9Q/EAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxYOAAAEAAAAAAAAAPtMgD2x
fn8/Nv3/vftMgD2ycX0/AAAAAPtMgL2xfn8/Nv3/PftMgD2ycX0/2v77PYPZPz5QcXk/AAAA
AIPZPz6BcXs/2v77vYPZPz5QcXk/CP59vvtMgD0gcXc/Nv3/vftMgL2ycX0/rf95voPZPz5a
inM/Nv3/PftMgL2ycX0/2v77vYPZP75QcXk/AAAAAIPZP76BcXs/2v77PYPZP75QcXk/CP59
PvtMgD0gcXc/rf95PoPZPz5ainM/IwL0PbQrnj4qinE/AAAAALQrnj6+cHM/IwL0vbQrnj4q
inE/HBm8vvtMgD3IiW0/CP59vvtMgL0gcXc/rf95voPZP75ainM/Vxq5voPZPz5tyWk/9QJy
vrQrnj6eyWs/rf95PoPZP75ainM/CP59PvtMgL0gcXc/IwL0vbQrnr4qinE/AAAAALQrnr6+
cHM/IwL0PbQrnr4qinE/HBm8PvtMgD3IiW0/Vxq5PoPZPz5tyWk/9QJyPrQrnj6eyWs//zpm
Pibp2T5UVWA/DwfoPSbp2T4MyWU/AAAAACbp2T4Elmc/DwfovSbp2T4MyWU//zpmvibp2T5U
VWA/4Br2vvtMgD0W4l8/HBm8vvtMgL3IiW0/Vxq5voPZP75tyWk/9QJyvrQrnr6eyWs/Ezby
voPZPz7yVFw/XDazvrQrnj6EVWI/CIbqvrQrnj5IVFU/9QJyPrQrnr6eyWs/Vxq5PoPZP75t
yWk/HBm8PvtMgL3IiW0//zpmvibp2b5UVWA/DwfovSbp2b4MyWU/AAAAACbp2b4Elmc/Dwfo
PSbp2b4MyWU//zpmPibp2b5UVWA/4Br2PvtMgD0W4l8/EzbyPoPZPz7yVFw/CIbqPrQrnj5I
VFU/XDazPrQrnj6EVWI/u4aqPibp2T55VFc/6tpWPucrCT/nU1E/3HPYPecrCT/8bVY/AAAA
AOcrCT9ZIVg/3HPYvecrCT/8bVY/u4aqvibp2T55VFc/6tpWvucrCT/nU1E/sygWv/tMgD1A
rU4/4Br2vvtMgL0W4l8/EzbyvoPZP77yVFw/CIbqvrQrnr5IVFU/XDazvrQrnr6EVWI/ScMT
v4PZPz4iYEs/AxIPv7Qrnj5S7EQ/TyTfvibp2T6y+Uo/qiEIvybp2T6dXjs/XDazPrQrnr6E
VWI/CIbqPrQrnr5IVFU/EzbyPoPZP77yVFw/4Br2PvtMgL0W4l8/u4aqvibp2b55VFc/6tpW
vucrCb/nU1E/3HPYvecrCb/8bVY/AAAAAOcrCb9ZIVg/3HPYPecrCb/8bVY/6tpWPucrCb/n
U1E/u4aqPibp2b55VFc/sygWP/tMgD1ArU4/ScMTP4PZPz4iYEs/AxIPP7Qrnj5S7EQ/qiEI
Pybp2T6dXjs/TyTfPibp2T6y+Uo/cwufPucrCT+07Eg/wCqRPuEhIz88Xjc/1BVEPuEhIz9c
BT8/xa7FPeEhIz80rEM/AAAAAOEhIz8mOUU/xa7FveEhIz80rEM/1BVEvuEhIz9cBT8/cwuf
vucrCT+07Eg/wCqRvuEhIz88Xjc/jN4uv/tMgD0bODo/sygWv/tMgL1ArU4/rB8sv4PZPz6g
RDc/ScMTv4PZP74iYEs/AxIPv7Qrnr5S7EQ/qiEIvybp2b6dXjs/TyTfvibp2b6y+Uo/7qEm
v7Qrnj5GdzE/dyrQvucrCT/OXj0/mBf+vucrCT9t3S4/p4sevybp2T4N0Cg/Z/YTv+crCT/7
jh0/TyTfPibp2b6y+Uo/qiEIPybp2b6dXjs/AxIPP7Qrnr5S7EQ/ScMTP4PZP74iYEs/sygW
P/tMgL1ArU4/cwufvucrCb+07Eg/wCqRvuEhI788Xjc/1BVEvuEhI79cBT8/xa7FveEhI780
rEM/AAAAAOEhI78mOUU/xa7FPeEhI780rEM/1BVEPuEhI79cBT8/wCqRPuEhI788Xjc/cwuf
PucrCb+07Eg/jN4uP/tMgD0bODo/rB8sP4PZPz6gRDc/7qEmP7Qrnj5GdzE/p4sePybp2T4N
0Cg/Z/YTP+crCT/7jh0/mBf+PucrCT9t3S4/dyrQPucrCT/OXj0/u/69PuEhIz9u0Cw/OtSo
PlqWOj+Zjhk/Mv6APlqWOj9I3CI/+VEuPlqWOj+Jtik/j1GvPVqWOj+G0C0/AAAAAFqWOj8P
Ny8/j1GvvVqWOj+G0C0/+VEuvlqWOj+Jtik/u/69vuEhIz9u0Cw/Mv6AvlqWOj9I3CI/OtSo
vlqWOj+Zjhk/hdVEv/tMgD16zyI/jN4uv/tMgL0bODo/Mb1Bv4PZPz5wQiA/rB8sv4PZP76g
RDc/7qEmv7Qrnr5GdzE/p4sevybp2b4N0Cg/Z/YTv+crCb/7jh0/mBf+vucrCb9t3S4/dyrQ
vucrCb/OXj0/iYw7v7Qrnj5aKBs/q3Yyvybp2T7VmhM/8dPnvuEhIz8rjx8/X4gmv+crCT9M
wAk/vPsGv+EhIz/ewA8/w/QXv+EhIz+zZPs+dyrQPucrCb/OXj0/mBf+PucrCb9t3S4/Z/YT
P+crCb/7jh0/p4sePybp2b4N0Cg/7qEmP7Qrnr5GdzE/rB8sP4PZP76gRDc/jN4uP/tMgL0b
ODo/u/69vuEhI79u0Cw/OtSovlqWOr+Zjhk/Mv6AvlqWOr9I3CI/+VEuvlqWOr+Jtik/j1Gv
vVqWOr+G0C0/AAAAAFqWOr8PNy8/j1GvPVqWOr+G0C0/+VEuPlqWOr+Jtik/Mv6APlqWOr9I
3CI/OtSoPlqWOr+Zjhk/u/69PuEhI79u0Cw/hdVEP/tMgD16zyI/Mb1BP4PZPz5wQiA/iYw7
P7Qrnj5aKBs/q3YyPybp2T7VmhM/X4gmP+crCT9MwAk/w/QXP+EhIz+zZPs+vPsGP+EhIz/e
wA8/8dPnPuEhIz8rjx8/KvjNPlqWOj+twA0/oveQPtoVTz9W2QM/z3FdPtoVTz8Y2gs/WI8V
PtoVTz9ypxE/746WPdoVTz9kQRU/AAAAANoVTz+0dBY/746WvdoVTz9kQRU/WI8VvtoVTz9y
pxE/z3FdvtoVTz8Y2gs/KvjNvlqWOj+twA0/oveQvtoVTz9W2QM/KrRXv/tMgD3P2Qg/hdVE
v/tMgL16zyI/Mb1Bv4PZP75wQiA/KU9Uv4PZPz41swY/J4VNv7Qrnj7NcgI/iYw7v7Qrnr5a
KBs/q3Yyvybp2b7VmhM/X4gmv+crCb9MwAk/w/QXv+EhI7+zZPs+vPsGv+EhI7/ewA8/8dPn
vuEhI78rjx8/QYlDvybp2T4yMfg+OOrvvlqWOj+xfv8+B3U2v+crCT8Eluc+X4gmv+EhIz/l
YNM+vPsGv1qWOj8JYt8+Z/YTv1qWOj8Nxbs+8dPnPuEhI78rjx8/vPsGP+EhI7/ewA8/w/QX
P+EhI7+zZPs+X4gmP+crCb9MwAk/q3YyPybp2b7VmhM/iYw7P7Qrnr5aKBs/Mb1BP4PZP75w
QiA/hdVEP/tMgL16zyI/KvjNvlqWOr+twA0/oveQvtoVT79W2QM/z3FdvtoVT78Y2gs/WI8V
vtoVT79ypxE/746WvdoVT79kQRU/AAAAANoVT7+0dBY/746WPdoVT79kQRU/WI8VPtoVT79y
pxE/z3FdPtoVT78Y2gs/oveQPtoVT79W2QM/KvjNPlqWOr+twA0/KrRXP/tMgD0BzQg/KU9U
P4PZPz41swY/J4VNP7Qrnj7NcgI/QYlDPybp2T4yMfg+B3U2P+crCT8Eluc+X4gmP+EhIz/l
YNM+Z/YTP1qWOj8Nxbs+vPsGP1qWOj8JYt8+OOrvPlqWOj8VZf8+KvjNPtoVTz8MSNs+8tCw
PtoVTz/wY/M+oveQPmVTYD9decc+XJ5tPmVTYD+LFNg+OII1PmVTYD//SOU+2DT1PWVTYD+D
4+4+yc12PWVTYD/dsPQ+AAAAAGVTYD9xl/Y+yc12vWVTYD/dsPQ+2DT1vWVTYD+D4+4+OII1
vmVTYD//SOU+8tCwvtoVTz/wY/M+XJ5tvmVTYD+LFNg+oveQvmVTYD9decc+ByFnv/tMgD0T
e9k+KrRXv/tMgL3P2Qg/KU9Uv4PZP741swY/J4VNv7Qrnr7NcgI/IHxjv4PZPz5aFNY+4Utc
v7Qrnj7oRs8+QYlDvybp2b4yMfg+B3U2v+crCb8Eluc+X4gmv+EhI7/lYNM+Z/YTv1qWOr8N
xbs+vPsGv1qWOr8JYt8+OOrvvlqWOr+xfv8+SpBRvybp2T5YLMU+KvjNvtoVTz8MSNs+8dPn
vtoVTz/Sq78+QYlDv+crCT/k97c+q3Yyv+EhIz9e9qc+mBf+vtoVTz/sKKE+p4sev1qWOj/I
J5U+qiEIv9oVTz8sDIA+OOrvPlqWOr8VZf8+vPsGP1qWOr8JYt8+Z/YTP1qWOr8Nxbs+X4gm
P+EhI7/lYNM+B3U2P+crCb8Eluc+QYlDPybp2b4yMfg+J4VNP7Qrnr7NcgI/KU9UP4PZP741
swY/KrRXP/tMgL0BzQg/8tCwvtoVT7/wY/M+oveQvmVTYL9decc+XJ5tvmVTYL+LFNg+OII1
vmVTYL//SOU+2DT1vWVTYL+D4+4+yc12vWVTYL/dsPQ+AAAAAGVTYL9xl/Y+yc12PWVTYL/d
sPQ+2DT1PWVTYL+D4+4+OII1PmVTYL//SOU+XJ5tPmVTYL+LFNg+oveQPmVTYL9decc+8tCw
PtoVT7/wY/M+KvjNPtoVT78MSNs+ByFnP/tMgD0Te9k+IHxjP4PZPz5aFNY+4UtcP7Qrnj7o
Rs8+SpBRPybp2T5YLMU+QYlDP+crCT/k97c+q3YyP+EhIz9e9qc+p4seP1qWOj/IJ5U+qiEI
P9oVTz8sDIA+mBf+PtoVTz/sKKE+8dPnPtoVTz/Sq78+OtSoPmVTYD9KxLM+z3FdPgECbj/l
dJg+OII1PgECbj9NKaU+3JMKPgECbj9BKq8+o0y7PQECbj+/d7Y+WH88PQECbj8t+Lo+AAAA
AAECbj9ReLw+WH88vQECbj8t+Lo+o0y7vQECbj+/d7Y+3JMKvgECbj9BKq8+OII1vgECbj9N
KaU+OtSovmVTYD9KxLM+z3FdvgECbj/ldJg+xPVyv/tMgD3P250+ByFnv/tMgL0Te9k+IHxj
v4PZP75aFNY+4Utcv7Qrnr7oRs8+vx1vv4PZPz6SW5s+Q4dnv7Qrnj60dJY+4Utcvybp2T42
J48+SpBRvybp2b5YLMU+QYlDv+crCb/k97c+q3Yyv+EhI79e9qc+p4sev1qWOr/IJ5U+qiEI
v9oVT78sDIA+mBf+vtoVT7/sKKE+8dPnvtoVT7/Sq78+KvjNvtoVT78MSNs+u/69vmVTYD/u
Dp0+J4VNv+crCT+yjIU+iYw7v+EhIz/EsHM+7qEmv1qWOj/7elg+dyrQvmVTYD8qJoQ+TyTf
vmVTYD/B4FE+AxIPv9oVTz943jk+8dPnPtoVT7/Sq78+mBf+PtoVT7/sKKE+qiEIP9oVT78s
DIA+p4seP1qWOr/IJ5U+q3YyP+EhI79e9qc+QYlDP+crCb/k97c+SpBRPybp2b5YLMU+4Utc
P7Qrnr7oRs8+IHxjP4PZP75aFNY+ByFnP/tMgL0Te9k+OtSovmVTYL9KxLM+z3FdvgECbr/l
dJg+OII1vgECbr9NKaU+3JMKvgECbr9BKq8+o0y7vQECbr+/d7Y+WH88vQECbr8t+Lo+AAAA
AAECbr9ReLw+WH88PQECbr8t+Lo+o0y7PQECbr+/d7Y+3JMKPgECbr9BKq8+OII1PgECbr9N
KaU+z3FdPgECbr/ldJg+OtSoPmVTYL9KxLM+xPVyP/tMgD3P250+vx1vP4PZPz6SW5s+Q4dn
P7Qrnj60dJY+4UtcPybp2T42J48+J4VNP+crCT+yjIU+iYw7P+EhIz/EsHM+7qEmP1qWOj/7
elg+AxIPP9oVTz943jk+TyTfPmVTYD/B4FE+dyrQPmVTYD8qJoQ+u/69PmVTYD/uDp0+wCqR
PgECbj/TFnA+Mv6APgECbj/cWYk++VEuPlzudz8IeDk+WI8VPlzudz9f4E0+2DT1PVzudz81
FV8+o0y7PVzudz8asGw+kDF9PVzudz/VfXY+CP79PFzudz9ofnw+AAAAAFzudz+Yfn4+CP79
vFzudz9ofnw+kDF9vVzudz/VfXY+o0y7vVzudz8asGw+2DT1vVzudz81FV8+Mv6AvgECbj/c
WYk+wCqRvgECbj/TFnA+WI8Vvlzudz9f4E0++VEuvlzudz8IeDk+fPJ6v/tMgD2aeD8+xPVy
v/tMgL3P250+6AB3v4PZPz5ReDw+vx1vv4PZP76SW5s+Q4dnv7Qrnr60dJY+4Utcvybp2b42
J48+vx1vv7Qrnj6/dzY+IHxjvybp2T7kdi0+KU9Uv+crCT8w3CE+J4VNv+crCb+yjIU+iYw7
v+EhI7/EsHM+7qEmv1qWOr/7elg+AxIPv9oVT7943jk+TyTfvmVTYL/B4FE+dyrQvmVTYL8q
JoQ+u/69vmVTYL/uDp0+Mb1Bv+EhIz+jpxM+rB8sv1qWOj91DAM+cwufvgECbj/+30k+u4aq
vgECbj+odSA+CIbqvmVTYD+tQRg+ScMTv9oVTz+eSOE9EzbyvmVTYD9g3rg9u/69PmVTYL/u
Dp0+dyrQPmVTYL8qJoQ+TyTfPmVTYL/B4FE+AxIPP9oVT7943jk+7qEmP1qWOr/7elg+iYw7
P+EhI7/EsHM+J4VNP+crCb+yjIU+4UtcPybp2b42J48+Q4dnP7Qrnr60dJY+vx1vP4PZP76S
W5s+xPVyP/tMgL3P250+wCqRvgECbr/TFnA+Mv6AvgECbr/cWYk++VEuvlzud78IeDk+WI8V
vlzud79f4E0+2DT1vVzud781FV8+o0y7vVzud78asGw+kDF9vVzud7/VfXY+CP79vFzud79o
fnw+AAAAAFzud7+Yfn4+CP79PFzud79ofnw+kDF9PVzud7/VfXY+o0y7PVzud78asGw+2DT1
PVzud781FV8+WI8VPlzud79f4E0++VEuPlzud78IeDk+Mv6APgECbr/cWYk+wCqRPgECbr/T
FnA+fPJ6P/tMgD2aeD8+6AB3P4PZPz5ReDw+vx1vP7Qrnj6/dzY+IHxjPybp2T7kdi0+KU9U
P+crCT8w3CE+Mb1BP+EhIz+jpxM+rB8sP1qWOj91DAM+ScMTP9oVTz+eSOE9EzbyPmVTYD9g
3rg9CIbqPmVTYD+tQRg+u4aqPgECbj+odSA+cwufPgECbj/+30k+6tpWPlzudz9fcwg+1BVE
Plzudz+gQiI+xa7FPfjxfT+5QqM9j1GvPfjxfT+R3ro9746WPfjxfT/oRs89yc12PfjxfT8u
4uA9WH88PfjxfT8Tfe49CP79PPjxfT8Gfvg9+pZ/PPjxfT+Yfv49AAAAAPjxfT8sDAA++pZ/
vPjxfT+Yfv49CP79vPjxfT8Gfvg9WH88vfjxfT8Tfe49yc12vfjxfT8u4uA91BVEvlzudz+g
QiI+6tpWvlzudz9fcwg+746WvfjxfT/oRs89j1GvvfjxfT+R3ro9xa7FvfjxfT+5QqM9n/1+
v/tMgD0sDIA9fPJ6v/tMgL2aeD8+6AB3v4PZP75ReDw+xPVyv7Qrnj41F3Q9fPJ6v4PZPz73
F3w9vx1vv7Qrnr6/dzY+IHxjvybp2b7kdi0+KU9Uv+crCb8w3CE+ByFnvybp2T4QFmg9KrRX
v+crCT9r4Vg9Mb1Bv+EhI7+jpxM+rB8sv1qWOr91DAM+ScMTv9oVT7+eSOE9EzbyvmVTYL9g
3rg9CIbqvmVTYL+tQRg+u4aqvgECbr+odSA+cwufvgECbr/+30k+hdVEv+EhIz9lrEU9jN4u
v1qWOj/dQy89sygWv9oVTz+0dBY9XDazvgECbj/x4ug9/zpmvlzudz/7etg99QJyvlzudz+2
25w9Vxq5vgECbj+hQI094Br2vmVTYD/VffY8HBm8vgECbj8BRbs8cwufPgECbr/+30k+u4aq
PgECbr+odSA+CIbqPmVTYL+tQRg+EzbyPmVTYL9g3rg9ScMTP9oVT7+eSOE9rB8sP1qWOr91
DAM+Mb1BP+EhI7+jpxM+KU9UP+crCb8w3CE+IHxjPybp2b7kdi0+vx1vP7Qrnr6/dzY+6AB3
P4PZP75ReDw+fPJ6P/tMgL2aeD8+6tpWvlzud79fcwg+1BVEvlzud7+gQiI+xa7Fvfjxfb+5
QqM9j1Gvvfjxfb+R3ro9746Wvfjxfb/oRs89yc12vfjxfb8u4uA9WH88vfjxfb8Tfe49CP79
vPjxfb8Gfvg9+pZ/vPjxfb+Yfv49AAAAAPjxfb8sDAA++pZ/PPjxfb+Yfv49CP79PPjxfb8G
fvg9WH88Pfjxfb8Tfe49yc12Pfjxfb8u4uA9746WPfjxfb/oRs89j1GvPfjxfb+R3ro9xa7F
Pfjxfb+5QqM91BVEPlzud7+gQiI+6tpWPlzud79fcwg+n/1+P/tMgD0sDIA9fPJ6P4PZPz73
F3w9xPVyP7Qrnj41F3Q9ByFnPybp2T4QFmg9KrRXP+crCT9r4Vg9hdVEP+EhIz9lrEU9jN4u
P1qWOj/dQy89sygWP9oVTz+0dBY94Br2PmVTYD/VffY8HBm8PgECbj8BRbs8Vxq5PgECbj+h
QI09XDazPgECbj/x4ug99QJyPlzudz+225w9/zpmPlzudz/7etg9DwfoPfjxfT8se1o93HPY
PfjxfT9AQIk9AAAAAAAAgD8AAAAA3HPYvfjxfT9AQIk9DwfovfjxfT8se1o9n/1+v/tMgD0s
DIC9n/1+v/tMgL0sDIA9fPJ6v4PZP773F3w9xPVyv7Qrnr41F3Q9xPVyv7Qrnj41F3S9fPJ6
v4PZPz73F3y9ByFnvybp2b4QFmg9KrRXv+crCb9r4Vg9ByFnvybp2T4QFmi9KrRXv+crCT9r
4Vi9hdVEv+EhI79lrEU9jN4uv1qWOr/dQy89sygWv9oVT7+0dBY94Br2vmVTYL/VffY8HBm8
vgECbr8BRbs8Vxq5vgECbr+hQI09XDazvgECbr/x4ug99QJyvlzud7+225w9/zpmvlzud7/7
etg9hdVEv+EhIz9lrEW9jN4uv1qWOj/dQy+9sygWv9oVTz+0dBa9rf95vlzudz+CeD49IwL0
vfjxfT93dR494Br2vmVTYD/Vffa8CP59vlzudz/Y5Hw8HBm8vgECbj8BRbu8/zpmPlzud7/7
etg99QJyPlzud7+225w9XDazPgECbr/x4ug9Vxq5PgECbr+hQI09HBm8PgECbr8BRbs84Br2
PmVTYL/VffY8sygWP9oVT7+0dBY9jN4uP1qWOr/dQy89hdVEP+EhI79lrEU9KrRXP+crCb9r
4Vg9ByFnPybp2b4QFmg9xPVyP7Qrnr41F3Q9fPJ6P4PZP773F3w9n/1+P/tMgL0sDIA9Dwfo
vfjxfb8se1o93HPYvfjxfb9AQIk9AAAAAAAAgL8AAAAA3HPYPfjxfb9AQIk9DwfoPfjxfb8s
e1o9n/1+P/tMgD0sDIC9fPJ6P4PZPz73F3y9xPVyP7Qrnj41F3S9ByFnPybp2T4QFmi9KrRX
P+crCT9r4Vi9hdVEP+EhIz9lrEW9jN4uP1qWOj/dQy+9sygWP9oVTz+0dBa94Br2PmVTYD/V
ffa8HBm8PgECbj8BRbu8CP59Plzudz/Y5Hw8rf95Plzudz+CeD49IwL0PfjxfT93dR492v77
PfjxfT9DEsA8Nv3/PfjxfT8sDAA8Nv3/PfjxfT8sDAC82v77PfjxfT9DEsC8IwL0PfjxfT93
dR69DwfoPfjxfT8se1q93HPYPfjxfT9AQIm9xa7FPfjxfT+5QqO9j1GvPfjxfT+R3rq9746W
PfjxfT/oRs+9yc12PfjxfT8u4uC9WH88PfjxfT8Tfe69CP79PPjxfT8Gfvi9+pZ/PPjxfT+Y
fv69AAAAAPjxfT8sDAC++pZ/vPjxfT+Yfv69CP79vPjxfT8Gfvi9WH88vfjxfT8Tfe69yc12
vfjxfT8u4uC9746WvfjxfT/oRs+9j1GvvfjxfT+R3rq9xa7FvfjxfT+5QqO93HPYvfjxfT9A
QIm9DwfovfjxfT8se1q9IwL0vfjxfT93dR692v77vfjxfT9DEsC8Nv3/vfjxfT8sDAC8Nv3/
vfjxfT8sDAA82v77vfjxfT9DEsA8fPJ6v/tMgD2aeD++n/1+v/tMgL0sDIC96AB3v4PZPz5R
eDy+fPJ6v4PZP773F3y9xPVyv7Qrnr41F3S9vx1vv7Qrnj6/dza+IHxjvybp2T7kdi2+ByFn
vybp2b4QFmi9KrRXv+crCb9r4Vi9KU9Uv+crCT8w3CG+Mb1Bv+EhIz+jpxO+hdVEv+EhI79l
rEW9jN4uv1qWOr/dQy+9sygWv9oVT7+0dBa94Br2vmVTYL/Vffa8HBm8vgECbr8BRbu8CP59
vlzud7/Y5Hw8rf95vlzud7+CeD49IwL0vfjxfb93dR49rB8sv1qWOj91DAO+EzbyvmVTYD9g
3ri9ScMTv9oVTz+eSOG9CP59vlzudz/Y5Hy8Vxq5vgECbj+hQI29rf95vlzudz+CeD69IwL0
Pfjxfb93dR49rf95Plzud7+CeD49CP59Plzud7/Y5Hw8HBm8PgECbr8BRbu84Br2PmVTYL/V
ffa8sygWP9oVT7+0dBa9jN4uP1qWOr/dQy+9hdVEP+EhI79lrEW9KrRXP+crCb9r4Vi9ByFn
Pybp2b4QFmi9xPVyP7Qrnr41F3S9fPJ6P4PZP773F3y9n/1+P/tMgL0sDIC9AAAAAPjxfb8s
DAC++pZ/PPjxfb+Yfv69CP79PPjxfb8Gfvi9WH88Pfjxfb8Tfe69yc12Pfjxfb8u4uC9746W
Pfjxfb/oRs+9j1GvPfjxfb+R3rq9xa7FPfjxfb+5QqO93HPYPfjxfb9AQIm9DwfoPfjxfb8s
e1q9IwL0Pfjxfb93dR692v77Pfjxfb9DEsC8Nv3/Pfjxfb8sDAC8Nv3/Pfjxfb8sDAA82v77
Pfjxfb9DEsA82v77vfjxfb9DEsA8Nv3/vfjxfb8sDAA8Nv3/vfjxfb8sDAC82v77vfjxfb9D
EsC8IwL0vfjxfb93dR69Dwfovfjxfb8se1q93HPYvfjxfb9AQIm9xa7Fvfjxfb+5QqO9j1Gv
vfjxfb+R3rq9746Wvfjxfb/oRs+9yc12vfjxfb8u4uC9WH88vfjxfb8Tfe69CP79vPjxfb8G
fvi9+pZ/vPjxfb+Yfv69fPJ6P/tMgD2aeD++6AB3P4PZPz5ReDy+vx1vP7Qrnj6/dza+IHxj
Pybp2T7kdi2+KU9UP+crCT8w3CG+Mb1BP+EhIz+jpxO+rB8sP1qWOj91DAO+ScMTP9oVTz+e
SOG9EzbyPmVTYD9g3ri9Vxq5PgECbj+hQI29rf95Plzudz+CeD69CP59Plzudz/Y5Hy89QJy
Plzudz+225y9/zpmPlzudz/7eti96tpWPlzudz9fcwi+1BVEPlzudz+gQiK++VEuPlzudz8I
eDm+WI8VPlzudz9f4E2+2DT1PVzudz81FV++o0y7PVzudz8asGy+kDF9PVzudz/VfXa+CP79
PFzudz9ofny+AAAAAFzudz+Yfn6+CP79vFzudz9ofny+kDF9vVzudz/VfXa+o0y7vVzudz8a
sGy+2DT1vVzudz81FV++WI8Vvlzudz9f4E2++VEuvlzudz8IeDm+1BVEvlzudz+gQiK+6tpW
vlzudz9fcwi+/zpmvlzudz/7eti99QJyvlzudz+225y9xPVyv/tMgD3P252+fPJ6v/tMgL2a
eD++6AB3v4PZP75ReDy+Q4dnv7Qrnj60dJa+vx1vv4PZPz6SW5u+vx1vv7Qrnr6/dza+IHxj
vybp2b7kdi2+4Utcvybp2T42J4++KU9Uv+crCb8w3CG+Mb1Bv+EhI7+jpxO+iYw7v+EhIz/E
sHO+J4VNv+crCT+yjIW+7qEmv1qWOj/7eli+rB8sv1qWOr91DAO+ScMTv9oVT7+eSOG9Ezby
vmVTYL9g3ri9Vxq5vgECbr+hQI29rf95vlzud7+CeD69CP59vlzud7/Y5Hy8AxIPv9oVTz94
3jm+CIbqvmVTYD+tQRi+XDazvgECbj/x4ui9CP59Plzud7/Y5Hy8Vxq5PgECbr+hQI29Ezby
PmVTYL9g3ri9rf95Plzud7+CeD69ScMTP9oVT7+eSOG9rB8sP1qWOr91DAO+Mb1BP+EhI7+j
pxO+KU9UP+crCb8w3CG+IHxjPybp2b7kdi2+vx1vP7Qrnr6/dza+6AB3P4PZP75ReDy+fPJ6
P/tMgL2aeD++AAAAAFzud7+Yfn6+CP79PFzud79ofny+kDF9PVzud7/VfXa+o0y7PVzud78a
sGy+2DT1PVzud781FV++WI8VPlzud79f4E2++VEuPlzud78IeDm+1BVEPlzud7+gQiK+6tpW
Plzud79fcwi+/zpmPlzud7/7eti99QJyPlzud7+225y99QJyvlzud7+225y9/zpmvlzud7/7
eti96tpWvlzud79fcwi+1BVEvlzud7+gQiK++VEuvlzud78IeDm+WI8Vvlzud79f4E2+2DT1
vVzud781FV++o0y7vVzud78asGy+kDF9vVzud7/VfXa+CP79vFzud79ofny+xPVyP/tMgD3P
252+vx1vP4PZPz6SW5u+Q4dnP7Qrnj60dJa+4UtcPybp2T42J4++J4VNP+crCT+yjIW+iYw7
P+EhIz/EsHO+7qEmP1qWOj/7eli+AxIPP9oVTz943jm+CIbqPmVTYD+tQRi+XDazPgECbj/x
4ui9u4aqPgECbj+odSC+cwufPgECbj/+30m+wCqRPgECbj/TFnC+Mv6APgECbj/cWYm+z3Fd
PgECbj/ldJi+OII1PgECbj9NKaW+3JMKPgECbj9BKq++o0y7PQECbj+/d7a+WH88PQECbj8t
+Lq+AAAAAAECbj9ReLy+WH88vQECbj8t+Lq+o0y7vQECbj+/d7a+3JMKvgECbj9BKq++OII1
vgECbj9NKaW+z3FdvgECbj/ldJi+Mv6AvgECbj/cWYm+wCqRvgECbj/TFnC+cwufvgECbj/+
30m+u4aqvgECbj+odSC+IHxjv4PZPz5aFNa+ByFnv/tMgD0Te9m+xPVyv/tMgL3P252+vx1v
v4PZP76SW5u+Q4dnv7Qrnr60dJa+4Utcv7Qrnj7oRs++4Utcvybp2b42J4++SpBRvybp2T5Y
LMW+QYlDv+crCT/k97e+J4VNv+crCb+yjIW+iYw7v+EhI7/EsHO+7qEmv1qWOr/7eli+q3Yy
v+EhIz9e9qe+p4sev1qWOj/IJ5W+qiEIv9oVTz8sDIC+AxIPv9oVT7943jm+CIbqvmVTYL+t
QRi+XDazvgECbr/x4ui9TyTfvmVTYD/B4FG+XDazPgECbr/x4ui9CIbqPmVTYL+tQRi+AxIP
P9oVT7943jm+7qEmP1qWOr/7eli+iYw7P+EhI7/EsHO+J4VNP+crCb+yjIW+4UtcPybp2b42
J4++Q4dnP7Qrnr60dJa+vx1vP4PZP76SW5u+xPVyP/tMgL3P252+AAAAAAECbr9ReLy+WH88
PQECbr8t+Lq+o0y7PQECbr+/d7a+3JMKPgECbr9BKq++OII1PgECbr9NKaW+z3FdPgECbr/l
dJi+Mv6APgECbr/cWYm+wCqRPgECbr/TFnC+cwufPgECbr/+30m+u4aqPgECbr+odSC+u4aq
vgECbr+odSC+cwufvgECbr/+30m+wCqRvgECbr/TFnC+Mv6AvgECbr/cWYm+z3FdvgECbr/l
dJi+OII1vgECbr9NKaW+3JMKvgECbr9BKq++o0y7vQECbr+/d7a+WH88vQECbr8t+Lq+ByFn
P/tMgD0Te9m+IHxjP4PZPz5aFNa+4UtcP7Qrnj7oRs++SpBRPybp2T5YLMW+QYlDP+crCT/k
97e+q3YyP+EhIz9e9qe+p4seP1qWOj/IJ5W+qiEIP9oVTz8sDIC+TyTfPmVTYD/B4FG+dyrQ
PmVTYD8qJoS+u/69PmVTYD/uDp2+OtSoPmVTYD9KxLO+oveQPmVTYD9dece+XJ5tPmVTYD+L
FNi+OII1PmVTYD//SOW+2DT1PWVTYD+D4+6+yc12PWVTYD/dsPS+AAAAAGVTYD9xl/a+yc12
vWVTYD/dsPS+2DT1vWVTYD+D4+6+OII1vmVTYD//SOW+XJ5tvmVTYD+LFNi+oveQvmVTYD9d
ece+OtSovmVTYD9KxLO+u/69vmVTYD/uDp2+dyrQvmVTYD8qJoS+KU9Uv4PZPz41swa/KrRX
v/tMgD3P2Qi/ByFnv/tMgL0Te9m+IHxjv4PZP75aFNa+4Utcv7Qrnr7oRs++J4VNv7Qrnj7N
cgK/QYlDvybp2T4yMfi+SpBRvybp2b5YLMW+QYlDv+crCb/k97e+B3U2v+crCT8Elue+q3Yy
v+EhI79e9qe+p4sev1qWOr/IJ5W+qiEIv9oVT78sDIC+X4gmv+EhIz/lYNO+Z/YTv1qWOj8N
xbu+mBf+vtoVTz/sKKG+TyTfvmVTYL/B4FG+TyTfPmVTYL/B4FG+qiEIP9oVT78sDIC+p4se
P1qWOr/IJ5W+q3YyP+EhI79e9qe+QYlDP+crCb/k97e+SpBRPybp2b5YLMW+4UtcP7Qrnr7o
Rs++IHxjP4PZP75aFNa+ByFnP/tMgL0Te9m+yc12vWVTYL/dsPS+AAAAAGVTYL9xl/a+yc12
PWVTYL/dsPS+2DT1PWVTYL+D4+6+OII1PmVTYL//SOW+XJ5tPmVTYL+LFNi+oveQPmVTYL9d
ece+OtSoPmVTYL9KxLO+u/69PmVTYL/uDp2+dyrQPmVTYL8qJoS+dyrQvmVTYL8qJoS+u/69
vmVTYL/uDp2+OtSovmVTYL9KxLO+oveQvmVTYL9dece+XJ5tvmVTYL+LFNi+OII1vmVTYL//
SOW+2DT1vWVTYL+D4+6+KrRXP/tMgD3P2Qi/KU9UP4PZPz41swa/J4VNP7Qrnj7NcgK/QYlD
Pybp2T4yMfi+B3U2P+crCT8Elue+X4gmP+EhIz/lYNO+Z/YTP1qWOj8Nxbu+mBf+PtoVTz/s
KKG+8dPnPtoVTz/Sq7++KvjNPtoVTz8MSNu+8tCwPtoVTz/wY/O+oveQPtoVTz9W2QO/z3Fd
PtoVTz8Y2gu/WI8VPtoVTz9ypxG/746WPdoVTz9kQRW/AAAAANoVTz+0dBa/746WvdoVTz9k
QRW/WI8VvtoVTz9ypxG/z3FdvtoVTz8Y2gu/oveQvtoVTz9W2QO/8tCwvtoVTz/wY/O+KvjN
vtoVTz8MSNu+8dPnvtoVTz/Sq7++Mb1Bv4PZPz5wQiC/hdVEv/tMgD16zyK/KrRXv/tMgL3P
2Qi/KU9Uv4PZP741swa/J4VNv7Qrnr7NcgK/QYlDvybp2b4yMfi+iYw7v7Qrnj5aKBu/q3Yy
vybp2T7VmhO/X4gmv+crCT9MwAm/B3U2v+crCb8Elue+X4gmv+EhI7/lYNO+Z/YTv1qWOr8N
xbu+mBf+vtoVT7/sKKG+w/QXv+EhIz+zZPu+vPsGv1qWOj8JYt++mBf+PtoVT7/sKKG+Z/YT
P1qWOr8Nxbu+X4gmP+EhI7/lYNO+B3U2P+crCb8Elue+QYlDPybp2b4yMfi+J4VNP7Qrnr7N
cgK/KU9UP4PZP741swa/KrRXP/tMgL3P2Qi/746WvdoVT79kQRW/AAAAANoVT7+0dBa/746W
PdoVT79kQRW/WI8VPtoVT79ypxG/z3FdPtoVT78Y2gu/oveQPtoVT79W2QO/8tCwPtoVT7/w
Y/O+KvjNPtoVT78MSNu+8dPnPtoVT7/Sq7++8dPnvtoVT7/Sq7++KvjNvtoVT78MSNu+8tCw
vtoVT7/wY/O+oveQvtoVT79W2QO/z3FdvtoVT78Y2gu/WI8VvtoVT79ypxG/hdVEP/tMgD16
zyK/Mb1BP4PZPz5wQiC/iYw7P7Qrnj5aKBu/q3YyPybp2T7VmhO/X4gmP+crCT9MwAm/w/QX
P+EhIz+zZPu+vPsGP1qWOj8JYt++OOrvPlqWOj+xfv++KvjNPlqWOj+twA2/OtSoPlqWOj+Z
jhm/Mv6APlqWOj9I3CK/+VEuPlqWOj+Jtim/j1GvPVqWOj+G0C2/AAAAAFqWOj8PNy+/j1Gv
vVqWOj+G0C2/+VEuvlqWOj+Jtim/Mv6AvlqWOj9I3CK/OtSovlqWOj+Zjhm/KvjNvlqWOj+t
wA2/OOrvvlqWOj8VZf++7qEmv7Qrnj5GdzG/rB8sv4PZPz6gRDe/jN4uv/tMgD0bODq/hdVE
v/tMgL16zyK/Mb1Bv4PZP75wQiC/iYw7v7Qrnr5aKBu/q3Yyvybp2b7VmhO/X4gmv+crCb9M
wAm/p4sevybp2T4N0Ci/Z/YTv+crCT/7jh2/w/QXv+EhI7+zZPu+vPsGv1qWOr8JYt++vPsG
v+EhIz/ewA+/vPsGP1qWOr8JYt++w/QXP+EhI7+zZPu+X4gmP+crCb9MwAm/q3YyPybp2b7V
mhO/iYw7P7Qrnr5aKBu/Mb1BP4PZP75wQiC/hdVEP/tMgL16zyK/+VEuvlqWOr+Jtim/j1Gv
vVqWOr+G0C2/AAAAAFqWOr8PNy+/j1GvPVqWOr+G0C2/+VEuPlqWOr+Jtim/Mv6APlqWOr9I
3CK/OtSoPlqWOr+Zjhm/KvjNPlqWOr+twA2/OOrvPlqWOr+xfv++OOrvvlqWOr8VZf++KvjN
vlqWOr+twA2/OtSovlqWOr+Zjhm/Mv6AvlqWOr9I3CK/jN4uP/tMgD0bODq/rB8sP4PZPz6g
RDe/7qEmP7Qrnj5GdzG/p4sePybp2T4N0Ci/Z/YTP+crCT/7jh2/vPsGP+EhIz/ewA+/8dPn
PuEhIz8rjx+/u/69PuEhIz9u0Cy/wCqRPuEhIz88Xje/1BVEPuEhIz9cBT+/xa7FPeEhIz80
rEO/AAAAAOEhIz8mOUW/xa7FveEhIz80rEO/1BVEvuEhIz9cBT+/wCqRvuEhIz88Xje/u/69
vuEhIz9u0Cy/8dPnvuEhIz8rjx+/AxIPv7Qrnj5S7ES/qiEIvybp2T6dXju/ScMTv4PZPz4i
YEu/sygWv/tMgD1ArU6/jN4uv/tMgL0bODq/rB8sv4PZP76gRDe/7qEmv7Qrnr5GdzG/p4se
vybp2b4N0Ci/Z/YTv+crCb/7jh2/mBf+vucrCT9t3S6/vPsGv+EhI7/ewA+/vPsGP+EhI7/e
wA+/Z/YTP+crCb/7jh2/p4sePybp2b4N0Ci/7qEmP7Qrnr5GdzG/rB8sP4PZP76gRDe/jN4u
P/tMgL0bODq/wCqRvuEhI788Xje/1BVEvuEhI79cBT+/xa7FveEhI780rEO/AAAAAOEhI78m
OUW/xa7FPeEhI780rEO/1BVEPuEhI79cBT+/wCqRPuEhI788Xje/u/69PuEhI79u0Cy/8dPn
PuEhI78rjx+/8dPnvuEhI78rjx+/u/69vuEhI79u0Cy/sygWP/tMgD1ArU6/ScMTP4PZPz4i
YEu/AxIPP7Qrnj5S7ES/qiEIPybp2T6dXju/mBf+PucrCT9t3S6/dyrQPucrCT/OXj2/cwuf
PucrCT+07Ei/6tpWPucrCT/nU1G/3HPYPecrCT/8bVa/AAAAAOcrCT9ZIVi/3HPYvecrCT/8
bVa/6tpWvucrCT/nU1G/cwufvucrCT+07Ei/dyrQvucrCT/OXj2/CIbqvrQrnj5IVFW/Ezby
voPZPz7yVFy/TyTfvibp2T6y+Uq/4Br2vvtMgD0W4l+/sygWv/tMgL1ArU6/ScMTv4PZP74i
YEu/AxIPv7Qrnr5S7ES/qiEIvybp2b6dXju/mBf+vucrCb9t3S6/mBf+PucrCb9t3S6/qiEI
Pybp2b6dXju/AxIPP7Qrnr5S7ES/ScMTP4PZP74iYEu/sygWP/tMgL1ArU6/dyrQvucrCb/O
Xj2/cwufvucrCb+07Ei/6tpWvucrCb/nU1G/3HPYvecrCb/8bVa/AAAAAOcrCb9ZIVi/3HPY
PecrCb/8bVa/6tpWPucrCb/nU1G/cwufPucrCb+07Ei/dyrQPucrCb/OXj2/4Br2PvtMgD0W
4l+/EzbyPoPZPz7yVFy/CIbqPrQrnj5IVFW/TyTfPibp2T6y+Uq/u4aqPibp2T55VFe//zpm
Pibp2T5UVWC/DwfoPSbp2T4MyWW/AAAAACbp2T4Elme/DwfovSbp2T4MyWW//zpmvibp2T5U
VWC/u4aqvibp2T55VFe/XDazvrQrnj6EVWK/Vxq5voPZPz5tyWm/HBm8vvtMgD3IiW2/4Br2
vvtMgL0W4l+/EzbyvoPZP77yVFy/CIbqvrQrnr5IVFW/TyTfvibp2b6y+Uq/TyTfPibp2b6y
+Uq/CIbqPrQrnr5IVFW/EzbyPoPZP77yVFy/4Br2PvtMgL0W4l+/u4aqvibp2b55VFe//zpm
vibp2b5UVWC/DwfovSbp2b4MyWW/AAAAACbp2b4Elme/DwfoPSbp2b4MyWW//zpmPibp2b5U
VWC/u4aqPibp2b55VFe/HBm8PvtMgD3IiW2/Vxq5PoPZPz5tyWm/XDazPrQrnj6EVWK/9QJy
PrQrnj6eyWu/IwL0PbQrnj4qinG/AAAAALQrnj6+cHO/IwL0vbQrnj4qinG/9QJyvrQrnj6e
yWu/rf95voPZPz5ainO/CP59vvtMgD0gcXe/HBm8vvtMgL3IiW2/Vxq5voPZP75tyWm/XDaz
vrQrnr6EVWK/XDazPrQrnr6EVWK/Vxq5PoPZP75tyWm/HBm8PvtMgL3IiW2/9QJyvrQrnr6e
yWu/IwL0vbQrnr4qinG/AAAAALQrnr6+cHO/IwL0PbQrnr4qinG/9QJyPrQrnr6eyWu/CP59
PvtMgD0gcXe/rf95PoPZPz5ainO/2v77PYPZPz5QcXm/AAAAAIPZPz6BcXu/2v77vYPZPz5Q
cXm/Nv3/vftMgD2ycX2/CP59vvtMgL0gcXe/rf95voPZP75ainO/rf95PoPZP75ainO/CP59
PvtMgL0gcXe/2v77vYPZP75QcXm/AAAAAIPZP76BcXu/2v77PYPZP75QcXm/Nv3/PftMgD2y
cX2/AAAAAPtMgD2xfn+/Nv3/vftMgL2ycX2/Nv3/PftMgL2ycX2/AAAAAPtMgL2xfn+/IBwA
AAAAAAABAAAACAAAAAAAAAAIAAAAAgAAAAAAAAACAAAACgAAAAAAAAAKAAAAAwAAAAAAAAAD
AAAABAAAAAAAAAAEAAAABQAAAAAAAAAFAAAABgAAAAAAAAAGAAAAAQAAAAEAAAAHAAAAFAAA
AAEAAAAUAAAACAAAAAEAAAAGAAAACQAAAAEAAAAJAAAABwAAAAIAAAAIAAAACwAAAAIAAAAL
AAAADAAAAAIAAAAMAAAADQAAAAIAAAANAAAACgAAAAMAAAAKAAAAGQAAAAMAAAAZAAAADgAA
AAMAAAAOAAAADwAAAAMAAAAPAAAABAAAAAQAAAAPAAAAEAAAAAQAAAAQAAAABQAAAAUAAAAQ
AAAAEQAAAAUAAAARAAAAEgAAAAUAAAASAAAABgAAAAYAAAASAAAACQAAAAcAAAATAAAAJgAA
AAcAAAAmAAAAFAAAAAcAAAAJAAAAEwAAAAgAAAAUAAAAFQAAAAgAAAAVAAAACwAAAAkAAAAW
AAAAEwAAAAkAAAASAAAAFwAAAAkAAAAXAAAAFgAAAAoAAAANAAAAGAAAAAoAAAAYAAAAGQAA
AAsAAAAVAAAAGgAAAAsAAAAaAAAADAAAAAwAAAAaAAAAGwAAAAwAAAAbAAAAHAAAAAwAAAAc
AAAADQAAAA0AAAAcAAAAGAAAAA4AAAAZAAAALgAAAA4AAAAuAAAAHQAAAA4AAAAdAAAADwAA
AA8AAAAdAAAAHgAAAA8AAAAeAAAAHwAAAA8AAAAfAAAAEAAAABAAAAAfAAAAIAAAABAAAAAg
AAAAIQAAABAAAAAhAAAAEQAAABEAAAAhAAAAIgAAABEAAAAiAAAAIwAAABEAAAAjAAAAEgAA
ABIAAAAjAAAAJAAAABIAAAAkAAAAFwAAABMAAAAlAAAAQAAAABMAAABAAAAAJgAAABMAAAAW
AAAAJQAAABQAAAAmAAAAFQAAABUAAAAnAAAAKAAAABUAAAAoAAAAGgAAABUAAAAmAAAAJwAA
ABYAAAApAAAAJQAAABYAAAAXAAAAKgAAABYAAAAqAAAAKwAAABYAAAArAAAAKQAAABcAAAAk
AAAAKgAAABgAAAAcAAAALAAAABgAAAAsAAAALQAAABgAAAAtAAAALgAAABgAAAAuAAAAGQAA
ABoAAAAoAAAALwAAABoAAAAvAAAAMAAAABoAAAAwAAAAGwAAABsAAAAwAAAAMQAAABsAAAAx
AAAAMgAAABsAAAAyAAAAHAAAABwAAAAyAAAAMwAAABwAAAAzAAAALAAAAB0AAAAuAAAASwAA
AB0AAABLAAAANAAAAB0AAAA0AAAAHgAAAB4AAAA0AAAANQAAAB4AAAA1AAAANgAAAB4AAAA2
AAAANwAAAB4AAAA3AAAAHwAAAB8AAAA3AAAAIAAAACAAAAA3AAAAOAAAACAAAAA4AAAAOQAA
ACAAAAA5AAAAOgAAACAAAAA6AAAAIQAAACEAAAA6AAAAOwAAACEAAAA7AAAAIgAAACIAAAA7
AAAAIwAAACMAAAA7AAAAPAAAACMAAAA8AAAAJAAAACQAAAA9AAAAKgAAACQAAAA8AAAAPgAA
ACQAAAA+AAAAPQAAACUAAAA/AAAAYgAAACUAAABiAAAAQAAAACUAAAApAAAAPwAAACYAAABA
AAAAJwAAACcAAABBAAAAQgAAACcAAABCAAAAQwAAACcAAABDAAAAKAAAACcAAABAAAAAQQAA
ACgAAABDAAAALwAAACkAAABEAAAAPwAAACkAAAArAAAARQAAACkAAABFAAAARAAAACoAAAA9
AAAARgAAACoAAABGAAAAKwAAACsAAABGAAAARwAAACsAAABHAAAARQAAACwAAAAzAAAASAAA
ACwAAABIAAAALQAAAC0AAABIAAAASQAAAC0AAABJAAAASgAAAC0AAABKAAAASwAAAC0AAABL
AAAALgAAAC8AAABMAAAATQAAAC8AAABNAAAATgAAAC8AAABOAAAAMAAAAC8AAABDAAAATAAA
ADAAAABOAAAATwAAADAAAABPAAAAMQAAADEAAABPAAAAMgAAADIAAABPAAAAUAAAADIAAABQ
AAAAMwAAADMAAABQAAAAUQAAADMAAABRAAAAUgAAADMAAABSAAAASAAAADQAAABLAAAAcQAA
ADQAAABxAAAAUwAAADQAAABTAAAANQAAADUAAABTAAAAVAAAADUAAABUAAAAVQAAADUAAABV
AAAANgAAADYAAABVAAAAVgAAADYAAABWAAAAVwAAADYAAABXAAAANwAAADcAAABXAAAAOAAA
ADgAAABXAAAAWAAAADgAAABYAAAAOQAAADkAAABYAAAAWQAAADkAAABZAAAAWgAAADkAAABa
AAAAOgAAADoAAABaAAAAWwAAADoAAABbAAAAOwAAADsAAABbAAAAXAAAADsAAABcAAAAXQAA
ADsAAABdAAAAPAAAADwAAABdAAAAXgAAADwAAABeAAAAPgAAAD0AAAA+AAAAXwAAAD0AAABf
AAAARgAAAD4AAABeAAAAYAAAAD4AAABgAAAAXwAAAD8AAABhAAAAjgAAAD8AAACOAAAAYgAA
AD8AAABEAAAAYwAAAD8AAABjAAAAYQAAAEAAAABiAAAAQQAAAEEAAABkAAAAZQAAAEEAAABl
AAAAQgAAAEEAAABiAAAAZAAAAEIAAABlAAAAZgAAAEIAAABmAAAAZwAAAEIAAABnAAAAQwAA
AEMAAABnAAAATAAAAEQAAABFAAAAYwAAAEUAAABoAAAAYwAAAEUAAABHAAAAaAAAAEYAAABf
AAAAaQAAAEYAAABpAAAAagAAAEYAAABqAAAARwAAAEcAAABrAAAAaAAAAEcAAABqAAAAbAAA
AEcAAABsAAAAawAAAEgAAABSAAAAbQAAAEgAAABtAAAASQAAAEkAAABtAAAAbgAAAEkAAABu
AAAAbwAAAEkAAABvAAAASgAAAEoAAABvAAAAcAAAAEoAAABwAAAAcQAAAEoAAABxAAAASwAA
AEwAAABnAAAAcgAAAEwAAAByAAAATQAAAE0AAAByAAAAcwAAAE0AAABzAAAAdAAAAE0AAAB0
AAAATgAAAE4AAAB0AAAAdQAAAE4AAAB1AAAATwAAAE8AAAB1AAAAdgAAAE8AAAB2AAAAdwAA
AE8AAAB3AAAAUAAAAFAAAAB3AAAAeAAAAFAAAAB4AAAAUQAAAFEAAAB4AAAAeQAAAFEAAAB5
AAAAegAAAFEAAAB6AAAAUgAAAFIAAAB6AAAAbQAAAFMAAABxAAAAogAAAFMAAACiAAAAewAA
AFMAAAB7AAAAfAAAAFMAAAB8AAAAVAAAAFQAAAB8AAAAVQAAAFUAAAB8AAAAfQAAAFUAAAB9
AAAAVgAAAFYAAAB9AAAAfgAAAFYAAAB+AAAAfwAAAFYAAAB/AAAAgAAAAFYAAACAAAAAVwAA
AFcAAACAAAAAgQAAAFcAAACBAAAAWAAAAFgAAACBAAAAWQAAAFkAAACBAAAAggAAAFkAAACC
AAAAgwAAAFkAAACDAAAAhAAAAFkAAACEAAAAhQAAAFkAAACFAAAAWgAAAFoAAACFAAAAWwAA
AFsAAACFAAAAhgAAAFsAAACGAAAAhwAAAFsAAACHAAAAXAAAAFwAAACHAAAAXQAAAF0AAACH
AAAAiAAAAF0AAACIAAAAiQAAAF0AAACJAAAAXgAAAF4AAACJAAAAYAAAAF8AAABgAAAAaQAA
AGAAAACKAAAAaQAAAGAAAACJAAAAiwAAAGAAAACLAAAAjAAAAGAAAACMAAAAigAAAGEAAACN
AAAAwgAAAGEAAADCAAAAjgAAAGEAAABjAAAAjwAAAGEAAACPAAAAjQAAAGIAAACOAAAAkAAA
AGIAAACQAAAAZAAAAGMAAABoAAAAjwAAAGQAAACQAAAAZQAAAGUAAACRAAAAZgAAAGUAAACQ
AAAAkQAAAGYAAACSAAAAkwAAAGYAAACTAAAAlAAAAGYAAACUAAAAZwAAAGYAAACRAAAAkgAA
AGcAAACUAAAAlQAAAGcAAACVAAAAcgAAAGgAAACWAAAAjwAAAGgAAABrAAAAlwAAAGgAAACX
AAAAlgAAAGkAAACKAAAAagAAAGoAAACKAAAAmAAAAGoAAACYAAAAbAAAAGsAAABsAAAAlwAA
AGwAAACZAAAAlwAAAGwAAACYAAAAmgAAAGwAAACaAAAAmwAAAGwAAACbAAAAmQAAAG0AAAB6
AAAAnAAAAG0AAACcAAAAnQAAAG0AAACdAAAAbgAAAG4AAACdAAAAngAAAG4AAACeAAAAnwAA
AG4AAACfAAAAoAAAAG4AAACgAAAAbwAAAG8AAACgAAAAoQAAAG8AAAChAAAAcAAAAHAAAACh
AAAAcQAAAHEAAAChAAAAogAAAHIAAACVAAAAcwAAAHMAAACjAAAApAAAAHMAAACkAAAApQAA
AHMAAAClAAAApgAAAHMAAACmAAAAdAAAAHMAAACVAAAAowAAAHQAAACmAAAAdQAAAHUAAACm
AAAApwAAAHUAAACnAAAAqAAAAHUAAACoAAAAdgAAAHYAAACoAAAAdwAAAHcAAACoAAAAqQAA
AHcAAACpAAAAqgAAAHcAAACqAAAAeAAAAHgAAACqAAAAeQAAAHkAAACqAAAAqwAAAHkAAACr
AAAArAAAAHkAAACsAAAArQAAAHkAAACtAAAAnAAAAHkAAACcAAAAegAAAHsAAACiAAAA2QAA
AHsAAADZAAAArgAAAHsAAACuAAAArwAAAHsAAACvAAAAfAAAAHwAAACvAAAAfQAAAH0AAACv
AAAAsAAAAH0AAACwAAAAsQAAAH0AAACxAAAAfgAAAH4AAACxAAAAfwAAAH8AAACxAAAAsgAA
AH8AAACyAAAAswAAAH8AAACzAAAAtAAAAH8AAAC0AAAAtQAAAH8AAAC1AAAAgAAAAIAAAAC1
AAAAggAAAIAAAACCAAAAgQAAAIIAAAC1AAAAgwAAAIMAAAC1AAAAtgAAAIMAAAC2AAAAtwAA
AIMAAAC3AAAAuAAAAIMAAAC4AAAAhAAAAIQAAAC4AAAAhQAAAIUAAAC4AAAAuQAAAIUAAAC5
AAAAugAAAIUAAAC6AAAAhgAAAIYAAAC6AAAAhwAAAIcAAAC6AAAAuwAAAIcAAAC7AAAAvAAA
AIcAAAC8AAAAiAAAAIgAAAC8AAAAiQAAAIkAAAC8AAAAvQAAAIkAAAC9AAAAvgAAAIkAAAC+
AAAAiwAAAIoAAACMAAAAmAAAAIsAAAC+AAAAjAAAAIwAAAC/AAAAmAAAAIwAAAC+AAAAwAAA
AIwAAADAAAAAvwAAAI0AAADBAAAA/QAAAI0AAAD9AAAAwgAAAI0AAACPAAAAwQAAAI4AAADC
AAAAwwAAAI4AAADDAAAAkAAAAI8AAADEAAAAwQAAAI8AAACWAAAAxQAAAI8AAADFAAAAxAAA
AJAAAADDAAAAkQAAAJEAAADGAAAAxwAAAJEAAADHAAAAkgAAAJEAAADDAAAAxgAAAJIAAADH
AAAAkwAAAJMAAADIAAAAyQAAAJMAAADJAAAAygAAAJMAAADKAAAAywAAAJMAAADLAAAAlAAA
AJMAAADHAAAAyAAAAJQAAADLAAAAowAAAJQAAACjAAAAlQAAAJYAAACXAAAAxQAAAJcAAADM
AAAAxQAAAJcAAACZAAAAzAAAAJgAAAC/AAAAzQAAAJgAAADNAAAAmgAAAJkAAADOAAAAzAAA
AJkAAACbAAAAzwAAAJkAAADPAAAAzgAAAJoAAADNAAAAmwAAAJsAAADNAAAA0AAAAJsAAADQ
AAAA0QAAAJsAAADRAAAAzwAAAJwAAACtAAAAnQAAAJ0AAACtAAAA0gAAAJ0AAADSAAAAngAA
AJ4AAADSAAAA0wAAAJ4AAADTAAAA1AAAAJ4AAADUAAAA1QAAAJ4AAADVAAAA1gAAAJ4AAADW
AAAAnwAAAJ8AAADWAAAAoAAAAKAAAADWAAAA1wAAAKAAAADXAAAA2AAAAKAAAADYAAAAoQAA
AKEAAADYAAAAogAAAKIAAADYAAAA2QAAAKMAAADLAAAApAAAAKQAAADLAAAA2gAAAKQAAADa
AAAA2wAAAKQAAADbAAAA3AAAAKQAAADcAAAApQAAAKUAAADcAAAApgAAAKYAAADcAAAA3QAA
AKYAAADdAAAA3gAAAKYAAADeAAAApwAAAKcAAADeAAAAqAAAAKgAAADeAAAA3wAAAKgAAADf
AAAA4AAAAKgAAADgAAAAqQAAAKkAAADgAAAAqgAAAKoAAADgAAAA4QAAAKoAAADhAAAA4gAA
AKoAAADiAAAAqwAAAKsAAADiAAAArAAAAKwAAADiAAAA4wAAAKwAAADjAAAA5AAAAKwAAADk
AAAA0gAAAKwAAADSAAAArQAAAK4AAADZAAAAGAEAAK4AAAAYAQAA5QAAAK4AAADlAAAA5gAA
AK4AAADmAAAArwAAAK8AAADmAAAA5wAAAK8AAADnAAAAsAAAALAAAADnAAAAsQAAALEAAADn
AAAA6AAAALEAAADoAAAAsgAAALIAAADoAAAA6QAAALIAAADpAAAA6gAAALIAAADqAAAAswAA
ALMAAADqAAAA6wAAALMAAADrAAAA7AAAALMAAADsAAAA7QAAALMAAADtAAAAtAAAALQAAADt
AAAAtQAAALUAAADtAAAAtgAAALYAAADtAAAA7gAAALYAAADuAAAA7wAAALYAAADvAAAAtwAA
ALcAAADvAAAA8AAAALcAAADwAAAA8QAAALcAAADxAAAA8gAAALcAAADyAAAAuAAAALgAAADy
AAAA8wAAALgAAADzAAAAuQAAALkAAADzAAAAugAAALoAAADzAAAA9AAAALoAAAD0AAAAuwAA
ALsAAAD0AAAA9QAAALsAAAD1AAAA9gAAALsAAAD2AAAAvAAAALwAAAD2AAAA9wAAALwAAAD3
AAAAvQAAAL0AAAD3AAAAvgAAAL4AAAD3AAAA+AAAAL4AAAD4AAAAwAAAAL8AAADAAAAA+QAA
AL8AAAD5AAAAzQAAAMAAAAD4AAAA+gAAAMAAAAD6AAAA+wAAAMAAAAD7AAAA+QAAAMEAAAD8
AAAAPwEAAMEAAAA/AQAA/QAAAMEAAADEAAAA/AAAAMIAAAD9AAAAwwAAAMMAAAD+AAAA/wAA
AMMAAAD/AAAAxgAAAMMAAAD9AAAA/gAAAMQAAAAAAQAA/AAAAMQAAADFAAAAAQEAAMQAAAAB
AQAAAAEAAMUAAADMAAAAAQEAAMYAAAD/AAAAxwAAAMcAAAACAQAAyAAAAMcAAAD/AAAAAgEA
AMgAAAADAQAABAEAAMgAAAAEAQAAyQAAAMgAAAACAQAAAwEAAMkAAAAEAQAABQEAAMkAAAAF
AQAABgEAAMkAAAAGAQAABwEAAMkAAAAHAQAAygAAAMoAAAAHAQAAywAAAMsAAAAHAQAA2gAA
AMwAAAAIAQAAAQEAAMwAAADOAAAACAEAAM0AAAD5AAAACQEAAM0AAAAJAQAACgEAAM0AAAAK
AQAA0AAAAM4AAAALAQAACAEAAM4AAADPAAAADAEAAM4AAAAMAQAACwEAAM8AAADRAAAADAEA
ANAAAAAKAQAADQEAANAAAAANAQAA0QAAANEAAAAOAQAADAEAANEAAAANAQAADwEAANEAAAAP
AQAADgEAANIAAADkAAAAEAEAANIAAAAQAQAA0wAAANMAAAAQAQAA1AAAANQAAAAQAQAAEQEA
ANQAAAARAQAAEgEAANQAAAASAQAAEwEAANQAAAATAQAA1QAAANUAAAATAQAAFAEAANUAAAAU
AQAAFQEAANUAAAAVAQAA1gAAANYAAAAVAQAAFgEAANYAAAAWAQAA1wAAANcAAAAWAQAA2AAA
ANgAAAAWAQAAFwEAANgAAAAXAQAA2QAAANkAAAAXAQAAGAEAANoAAAAHAQAAGQEAANoAAAAZ
AQAA2wAAANsAAAAZAQAAGgEAANsAAAAaAQAAGwEAANsAAAAbAQAAHAEAANsAAAAcAQAA3AAA
ANwAAAAcAQAAHQEAANwAAAAdAQAA3QAAAN0AAAAdAQAA3gAAAN4AAAAdAQAAHgEAAN4AAAAe
AQAA3wAAAN8AAAAeAQAAHwEAAN8AAAAfAQAAIAEAAN8AAAAgAQAA4AAAAOAAAAAgAQAAIQEA
AOAAAAAhAQAA4QAAAOEAAAAhAQAA4gAAAOIAAAAhAQAAIgEAAOIAAAAiAQAA4wAAAOMAAAAi
AQAAIwEAAOMAAAAjAQAAJAEAAOMAAAAkAQAAJQEAAOMAAAAlAQAA5AAAAOQAAAAlAQAAJgEA
AOQAAAAmAQAAEAEAAOUAAAAYAQAAXQEAAOUAAABdAQAAJwEAAOUAAAAnAQAA5gAAAOYAAAAn
AQAAKAEAAOYAAAAoAQAAKQEAAOYAAAApAQAA5wAAAOcAAAApAQAA6AAAAOgAAAApAQAAKgEA
AOgAAAAqAQAA6QAAAOkAAAAqAQAAKwEAAOkAAAArAQAALAEAAOkAAAAsAQAA6gAAAOoAAAAs
AQAA6wAAAOsAAAAsAQAALQEAAOsAAAAtAQAALgEAAOsAAAAuAQAALwEAAOsAAAAvAQAA7AAA
AOwAAAAvAQAAMAEAAOwAAAAwAQAA7gAAAOwAAADuAAAA7QAAAO4AAAAwAQAAMQEAAO4AAAAx
AQAA7wAAAO8AAAAxAQAA8AAAAPAAAAAxAQAAMgEAAPAAAAAyAQAAMwEAAPAAAAAzAQAA8QAA
APEAAAAzAQAA8gAAAPIAAAAzAQAANAEAAPIAAAA0AQAA8wAAAPMAAAA0AQAANQEAAPMAAAA1
AQAANgEAAPMAAAA2AQAA9AAAAPQAAAA2AQAANwEAAPQAAAA3AQAA9QAAAPUAAAA3AQAA9gAA
APYAAAA3AQAAOAEAAPYAAAA4AQAA9wAAAPcAAAA4AQAAOQEAAPcAAAA5AQAAOgEAAPcAAAA6
AQAA+AAAAPgAAAA6AQAAOwEAAPgAAAA7AQAA+gAAAPkAAAD7AAAAPAEAAPkAAAA8AQAACQEA
APoAAAA7AQAA+wAAAPsAAAA7AQAAPQEAAPsAAAA9AQAAPAEAAPwAAAA+AQAAiAEAAPwAAACI
AQAAPwEAAPwAAAAAAQAAPgEAAP0AAAA/AQAA/gAAAP4AAABAAQAAQQEAAP4AAABBAQAA/wAA
AP4AAAA/AQAAQAEAAP8AAABBAQAAAgEAAAABAABCAQAAPgEAAAABAAABAQAAQgEAAAEBAABD
AQAAQgEAAAEBAAAIAQAARAEAAAEBAABEAQAAQwEAAAIBAABBAQAARQEAAAIBAABFAQAAAwEA
AAMBAABGAQAARwEAAAMBAABHAQAABAEAAAMBAABFAQAARgEAAAQBAABHAQAABQEAAAUBAABH
AQAASAEAAAUBAABIAQAASQEAAAUBAABJAQAASgEAAAUBAABKAQAABgEAAAYBAABKAQAASwEA
AAYBAABLAQAABwEAAAcBAABLAQAATAEAAAcBAABMAQAAGQEAAAgBAAALAQAARAEAAAkBAAA8
AQAACgEAAAoBAAA8AQAATQEAAAoBAABNAQAADQEAAAsBAABOAQAARAEAAAsBAAAMAQAATgEA
AAwBAABPAQAATgEAAAwBAAAOAQAAUAEAAAwBAABQAQAATwEAAA0BAABNAQAAUQEAAA0BAABR
AQAAUgEAAA0BAABSAQAADwEAAA4BAAAPAQAAUAEAAA8BAABTAQAAUAEAAA8BAABSAQAAUwEA
ABABAAAmAQAAEQEAABEBAAAmAQAAVAEAABEBAABUAQAAVQEAABEBAABVAQAAEgEAABIBAABV
AQAAVgEAABIBAABWAQAAVwEAABIBAABXAQAAWAEAABIBAABYAQAAEwEAABMBAABYAQAAFAEA
ABQBAABYAQAAWQEAABQBAABZAQAAWgEAABQBAABaAQAAFQEAABUBAABaAQAAWwEAABUBAABb
AQAAFgEAABYBAABbAQAAFwEAABcBAABbAQAAXAEAABcBAABcAQAAXQEAABcBAABdAQAAGAEA
ABkBAABMAQAAXgEAABkBAABeAQAAGgEAABoBAABeAQAAXwEAABoBAABfAQAAYAEAABoBAABg
AQAAGwEAABsBAABgAQAAHAEAABwBAABgAQAAYQEAABwBAABhAQAAHQEAAB0BAABhAQAAYgEA
AB0BAABiAQAAYwEAAB0BAABjAQAAHgEAAB4BAABjAQAAZAEAAB4BAABkAQAAHwEAAB8BAABk
AQAAIAEAACABAABkAQAAZQEAACABAABlAQAAIQEAACEBAABlAQAAZgEAACEBAABmAQAAZwEA
ACEBAABnAQAAIgEAACIBAABnAQAAaAEAACIBAABoAQAAIwEAACMBAABoAQAAJAEAACQBAABo
AQAAaQEAACQBAABpAQAAagEAACQBAABqAQAAJQEAACUBAABqAQAAJgEAACYBAABqAQAAVAEA
ACcBAABdAQAAqAEAACcBAACoAQAAawEAACcBAABrAQAAKAEAACgBAABrAQAAbAEAACgBAABs
AQAAKQEAACkBAABsAQAAbQEAACkBAABtAQAAbgEAACkBAABuAQAAKgEAACoBAABuAQAAKwEA
ACsBAABuAQAAbwEAACsBAABvAQAALAEAACwBAABvAQAAcAEAACwBAABwAQAAcQEAACwBAABx
AQAALQEAAC0BAABxAQAALgEAAC4BAABxAQAAcgEAAC4BAAByAQAAcwEAAC4BAABzAQAALwEA
AC8BAABzAQAAdAEAAC8BAAB0AQAAdQEAAC8BAAB1AQAAMAEAADABAAB1AQAAMQEAADEBAAB1
AQAAdgEAADEBAAB2AQAAdwEAADEBAAB3AQAAMgEAADIBAAB3AQAAeAEAADIBAAB4AQAAeQEA
ADIBAAB5AQAAegEAADIBAAB6AQAAMwEAADMBAAB6AQAAewEAADMBAAB7AQAANAEAADQBAAB7
AQAANQEAADUBAAB7AQAAfAEAADUBAAB8AQAANgEAADYBAAB8AQAAfQEAADYBAAB9AQAANwEA
ADcBAAB9AQAAfgEAADcBAAB+AQAAfwEAADcBAAB/AQAAOAEAADgBAAB/AQAAgAEAADgBAACA
AQAAOQEAADkBAACAAQAAgQEAADkBAACBAQAAOgEAADoBAACBAQAAOwEAADsBAACBAQAAggEA
ADsBAACCAQAAPQEAADwBAAA9AQAAgwEAADwBAACDAQAAhAEAADwBAACEAQAATQEAAD0BAACC
AQAAhQEAAD0BAACFAQAAhgEAAD0BAACGAQAAgwEAAD4BAACHAQAA2gEAAD4BAADaAQAAiAEA
AD4BAABCAQAAiQEAAD4BAACJAQAAhwEAAD8BAACIAQAAQAEAAEABAACKAQAAQQEAAEABAACI
AQAAigEAAEEBAACLAQAAjAEAAEEBAACMAQAARQEAAEEBAACKAQAAiwEAAEIBAABDAQAAiQEA
AEMBAACNAQAAiQEAAEMBAABEAQAAjQEAAEQBAACOAQAAjQEAAEQBAABOAQAAjwEAAEQBAACP
AQAAjgEAAEUBAACMAQAARgEAAEYBAACQAQAARwEAAEYBAACMAQAAkAEAAEcBAACRAQAAkgEA
AEcBAACSAQAASAEAAEcBAACQAQAAkQEAAEgBAACSAQAASQEAAEkBAACTAQAAlAEAAEkBAACU
AQAASgEAAEkBAACSAQAAkwEAAEoBAACUAQAAlQEAAEoBAACVAQAAlgEAAEoBAACWAQAASwEA
AEsBAACWAQAAXgEAAEsBAABeAQAATAEAAE0BAACEAQAAUQEAAE4BAABPAQAAjwEAAE8BAACX
AQAAjwEAAE8BAABQAQAAlwEAAFABAACYAQAAlwEAAFABAABTAQAAmAEAAFEBAACEAQAAmQEA
AFEBAACZAQAAmgEAAFEBAACaAQAAUgEAAFIBAACbAQAAUwEAAFIBAACaAQAAmwEAAFMBAACc
AQAAmAEAAFMBAACbAQAAnQEAAFMBAACdAQAAnAEAAFQBAABqAQAAngEAAFQBAACeAQAAVQEA
AFUBAACeAQAAnwEAAFUBAACfAQAAoAEAAFUBAACgAQAAVgEAAFYBAACgAQAAoQEAAFYBAACh
AQAAogEAAFYBAACiAQAAVwEAAFcBAACiAQAAWAEAAFgBAACiAQAAowEAAFgBAACjAQAApAEA
AFgBAACkAQAAWQEAAFkBAACkAQAApQEAAFkBAAClAQAAWgEAAFoBAAClAQAAWwEAAFsBAACl
AQAApgEAAFsBAACmAQAApwEAAFsBAACnAQAAXAEAAFwBAACnAQAAqAEAAFwBAACoAQAAXQEA
AF4BAACWAQAAqQEAAF4BAACpAQAAqgEAAF4BAACqAQAAXwEAAF8BAACqAQAAqwEAAF8BAACr
AQAArAEAAF8BAACsAQAArQEAAF8BAACtAQAAYAEAAGABAACtAQAArgEAAGABAACuAQAAYQEA
AGEBAACuAQAAYgEAAGIBAACuAQAArwEAAGIBAACvAQAAYwEAAGMBAACvAQAAsAEAAGMBAACw
AQAAZAEAAGQBAACwAQAAsQEAAGQBAACxAQAAsgEAAGQBAACyAQAAZQEAAGUBAACyAQAAswEA
AGUBAACzAQAAZgEAAGYBAACzAQAAtAEAAGYBAAC0AQAAZwEAAGcBAAC0AQAAaAEAAGgBAAC0
AQAAtQEAAGgBAAC1AQAAaQEAAGkBAAC1AQAAtgEAAGkBAAC2AQAAtwEAAGkBAAC3AQAAuAEA
AGkBAAC4AQAAagEAAGoBAAC4AQAAuQEAAGoBAAC5AQAAngEAAGsBAACoAQAA/gEAAGsBAAD+
AQAAugEAAGsBAAC6AQAAuwEAAGsBAAC7AQAAbAEAAGwBAAC7AQAAbQEAAG0BAAC7AQAAvAEA
AG0BAAC8AQAAbgEAAG4BAAC8AQAAvQEAAG4BAAC9AQAAvgEAAG4BAAC+AQAAbwEAAG8BAAC+
AQAAcAEAAHABAAC+AQAAvwEAAHABAAC/AQAAcQEAAHEBAAC/AQAAwAEAAHEBAADAAQAAcgEA
AHIBAADAAQAAwQEAAHIBAADBAQAAwgEAAHIBAADCAQAAwwEAAHIBAADDAQAAcwEAAHMBAADD
AQAAxAEAAHMBAADEAQAAdAEAAHQBAADEAQAAxQEAAHQBAADFAQAAdgEAAHQBAAB2AQAAdQEA
AHYBAADFAQAAxgEAAHYBAADGAQAAxwEAAHYBAADHAQAAdwEAAHcBAADHAQAAeAEAAHgBAADH
AQAAyAEAAHgBAADIAQAAyQEAAHgBAADJAQAAygEAAHgBAADKAQAAeQEAAHkBAADKAQAAywEA
AHkBAADLAQAAegEAAHoBAADLAQAAewEAAHsBAADLAQAAzAEAAHsBAADMAQAAzQEAAHsBAADN
AQAAfAEAAHwBAADNAQAAzgEAAHwBAADOAQAAfQEAAH0BAADOAQAAfgEAAH4BAADOAQAAzwEA
AH4BAADPAQAA0AEAAH4BAADQAQAAfwEAAH8BAADQAQAA0QEAAH8BAADRAQAAgAEAAIABAADR
AQAAgQEAAIEBAADRAQAA0gEAAIEBAADSAQAA0wEAAIEBAADTAQAAggEAAIIBAADTAQAAhQEA
AIMBAACGAQAA1AEAAIMBAADUAQAAhAEAAIQBAADUAQAA1QEAAIQBAADVAQAAmQEAAIUBAADT
AQAA1gEAAIUBAADWAQAA1wEAAIUBAADXAQAAhgEAAIYBAADXAQAA2AEAAIYBAADYAQAA1AEA
AIcBAADZAQAAJgIAAIcBAAAmAgAA2gEAAIcBAACJAQAA2QEAAIgBAADaAQAA2wEAAIgBAADb
AQAAigEAAIkBAACNAQAA3AEAAIkBAADcAQAA3QEAAIkBAADdAQAA2QEAAIoBAADbAQAAiwEA
AIsBAADeAQAAjAEAAIsBAADbAQAA3gEAAIwBAADeAQAA3wEAAIwBAADfAQAA4AEAAIwBAADg
AQAAkAEAAI0BAACOAQAA3AEAAI4BAADhAQAA3AEAAI4BAACPAQAA4QEAAI8BAACXAQAA4gEA
AI8BAADiAQAA4QEAAJABAADgAQAAkQEAAJEBAADjAQAAkgEAAJEBAADgAQAA4wEAAJIBAADj
AQAA5AEAAJIBAADkAQAAkwEAAJMBAADlAQAA5gEAAJMBAADmAQAA5wEAAJMBAADnAQAAlAEA
AJMBAADkAQAA5QEAAJQBAADnAQAA6AEAAJQBAADoAQAAlQEAAJUBAADoAQAA6QEAAJUBAADp
AQAAqQEAAJUBAACpAQAAlgEAAJcBAADqAQAA4gEAAJcBAACYAQAA6gEAAJgBAADrAQAA6gEA
AJgBAACcAQAA7AEAAJgBAADsAQAA6wEAAJkBAADVAQAAmgEAAJoBAADtAQAAmwEAAJoBAADV
AQAA7gEAAJoBAADuAQAA7wEAAJoBAADvAQAA7QEAAJsBAADtAQAA8AEAAJsBAADwAQAAnQEA
AJwBAACdAQAA7AEAAJ0BAADxAQAA7AEAAJ0BAADwAQAA8gEAAJ0BAADyAQAA8QEAAJ4BAAC5
AQAAnwEAAJ8BAAC5AQAA8wEAAJ8BAADzAQAA9AEAAJ8BAAD0AQAAoAEAAKABAAD0AQAA9QEA
AKABAAD1AQAAoQEAAKEBAAD1AQAA9gEAAKEBAAD2AQAA9wEAAKEBAAD3AQAA+AEAAKEBAAD4
AQAAogEAAKIBAAD4AQAA+QEAAKIBAAD5AQAAowEAAKMBAAD5AQAA+gEAAKMBAAD6AQAApAEA
AKQBAAD6AQAApQEAAKUBAAD6AQAA+wEAAKUBAAD7AQAA/AEAAKUBAAD8AQAApgEAAKYBAAD8
AQAA/QEAAKYBAAD9AQAApwEAAKcBAAD9AQAAqAEAAKgBAAD9AQAA/gEAAKkBAADpAQAA/wEA
AKkBAAD/AQAAAAIAAKkBAAAAAgAAqgEAAKoBAAAAAgAAqwEAAKsBAAAAAgAAAQIAAKsBAAAB
AgAAAgIAAKsBAAACAgAAAwIAAKsBAAADAgAArAEAAKwBAAADAgAABAIAAKwBAAAEAgAArQEA
AK0BAAAEAgAArgEAAK4BAAAEAgAABQIAAK4BAAAFAgAABgIAAK4BAAAGAgAArwEAAK8BAAAG
AgAABwIAAK8BAAAHAgAAsAEAALABAAAHAgAAsQEAALEBAAAHAgAACAIAALEBAAAIAgAACQIA
ALEBAAAJAgAAsgEAALIBAAAJAgAACgIAALIBAAAKAgAAswEAALMBAAAKAgAAtAEAALQBAAAK
AgAACwIAALQBAAALAgAADAIAALQBAAAMAgAAtQEAALUBAAAMAgAAtgEAALYBAAAMAgAADQIA
ALYBAAANAgAADgIAALYBAAAOAgAAtwEAALcBAAAOAgAADwIAALcBAAAPAgAAEAIAALcBAAAQ
AgAAuAEAALgBAAAQAgAAuQEAALkBAAAQAgAAEQIAALkBAAARAgAA8wEAALoBAAD+AQAATQIA
ALoBAABNAgAAEgIAALoBAAASAgAAuwEAALsBAAASAgAAEwIAALsBAAATAgAAFAIAALsBAAAU
AgAAvAEAALwBAAAUAgAAvQEAAL0BAAAUAgAAFQIAAL0BAAAVAgAAvgEAAL4BAAAVAgAAFgIA
AL4BAAAWAgAAvwEAAL8BAAAWAgAAFwIAAL8BAAAXAgAAwAEAAMABAAAXAgAAGAIAAMABAAAY
AgAAGQIAAMABAAAZAgAAwQEAAMEBAAAZAgAAwgEAAMIBAAAZAgAAGgIAAMIBAAAaAgAAGwIA
AMIBAAAbAgAAHAIAAMIBAAAcAgAAwwEAAMMBAAAcAgAAHQIAAMMBAAAdAgAAxAEAAMQBAAAd
AgAAHgIAAMQBAAAeAgAAHwIAAMQBAAAfAgAAxgEAAMQBAADGAQAAxQEAAMYBAAAfAgAAIAIA
AMYBAAAgAgAAIQIAAMYBAAAhAgAAyAEAAMYBAADIAQAAxwEAAMgBAAAhAgAAIgIAAMgBAAAi
AgAAyQEAAMkBAAAiAgAAygEAAMoBAAAiAgAAywEAAMsBAAAiAgAAzAEAAMwBAAAiAgAAzQEA
AM0BAAAiAgAAzgEAAM4BAAAiAgAAzwEAAM8BAAAiAgAA0AEAANABAAAiAgAA0QEAANEBAAAi
AgAA0gEAANIBAAAiAgAA0wEAANMBAAAiAgAA1gEAANQBAADYAQAA1QEAANUBAADYAQAAIwIA
ANUBAAAjAgAAJAIAANUBAAAkAgAA7gEAANYBAAAiAgAA1wEAANcBAAAiAgAA2AEAANgBAAAi
AgAAIwIAANkBAADdAQAAKgIAANkBAAAqAgAAJQIAANkBAAAlAgAAfgIAANkBAAB+AgAAJgIA
ANoBAAAmAgAA2wEAANsBAAAnAgAAKAIAANsBAAAoAgAA3gEAANsBAAAmAgAAJwIAANwBAAAp
AgAAKgIAANwBAAAqAgAA3QEAANwBAADhAQAALQIAANwBAAAtAgAAKQIAAN4BAAAoAgAA3wEA
AN8BAAArAgAA4AEAAN8BAAAoAgAAKwIAAOABAAAsAgAA4wEAAOABAAArAgAALAIAAOEBAADi
AQAALgIAAOEBAAAuAgAALQIAAOIBAADqAQAAOAIAAOIBAAA4AgAALgIAAOMBAAAvAgAA5AEA
AOMBAAAsAgAALwIAAOQBAAAwAgAAMQIAAOQBAAAxAgAA5QEAAOQBAAAvAgAAMAIAAOUBAAAx
AgAA5gEAAOYBAAAyAgAAMwIAAOYBAAAzAgAANAIAAOYBAAA0AgAA5wEAAOYBAAAxAgAAMgIA
AOcBAAA0AgAANQIAAOcBAAA1AgAA6AEAAOgBAAA1AgAANgIAAOgBAAA2AgAANwIAAOgBAAA3
AgAA/wEAAOgBAAD/AQAA6QEAAOoBAADrAQAAOQIAAOoBAAA5AgAAOAIAAOsBAADsAQAAOgIA
AOsBAAA6AgAAOQIAAOwBAADxAQAAPQIAAOwBAAA9AgAAOgIAAO0BAADvAQAAOwIAAO0BAAA7
AgAA8AEAAO4BAAAkAgAAPAIAAO4BAAA8AgAA7wEAAO8BAAA8AgAAOwIAAPABAAA7AgAA8gEA
APEBAADyAQAAPwIAAPEBAAA/AgAAPQIAAPIBAAA7AgAAPgIAAPIBAAA+AgAAkwIAAPIBAACT
AgAAPwIAAPMBAAARAgAA9AEAAPQBAAARAgAAQAIAAPQBAABAAgAAQQIAAPQBAABBAgAAQgIA
APQBAABCAgAA9QEAAPUBAABCAgAAQwIAAPUBAABDAgAA9gEAAPYBAABDAgAARAIAAPYBAABE
AgAARQIAAPYBAABFAgAARgIAAPYBAABGAgAA9wEAAPcBAABGAgAA+AEAAPgBAABGAgAARwIA
APgBAABHAgAASAIAAPgBAABIAgAA+QEAAPkBAABIAgAASQIAAPkBAABJAgAA+gEAAPoBAABJ
AgAASgIAAPoBAABKAgAA+wEAAPsBAABKAgAASwIAAPsBAABLAgAA/AEAAPwBAABLAgAA/QEA
AP0BAABLAgAATAIAAP0BAABMAgAATQIAAP0BAABNAgAA/gEAAP8BAAA3AgAATgIAAP8BAABO
AgAATwIAAP8BAABPAgAAAQIAAP8BAAABAgAAAAIAAAECAABPAgAAUAIAAAECAABQAgAAAgIA
AAICAABQAgAAAwIAAAMCAABQAgAABAIAAAQCAABQAgAABQIAAAUCAABQAgAABgIAAAYCAABQ
AgAABwIAAAcCAABQAgAACAIAAAgCAABQAgAACQIAAAkCAABQAgAACgIAAAoCAABQAgAACwIA
AAsCAABQAgAADAIAAAwCAABQAgAADQIAAA0CAABQAgAADgIAAA4CAABQAgAADwIAAA8CAABQ
AgAAUQIAAA8CAABRAgAAEQIAAA8CAAARAgAAEAIAABECAABRAgAAUgIAABECAABSAgAAQAIA
ABICAABNAgAAogIAABICAACiAgAAUwIAABICAABTAgAAVAIAABICAABUAgAAEwIAABMCAABU
AgAAVQIAABMCAABVAgAAFAIAABQCAABVAgAAVgIAABQCAABWAgAAFQIAABUCAABWAgAAVwIA
ABUCAABXAgAAFgIAABYCAABXAgAAWAIAABYCAABYAgAAFwIAABcCAABYAgAAWQIAABcCAABZ
AgAAGAIAABgCAABZAgAAWgIAABgCAABaAgAAGQIAABkCAABaAgAAWwIAABkCAABbAgAAGgIA
ABoCAABbAgAAXAIAABoCAABcAgAAGwIAABsCAABcAgAAywIAABsCAADLAgAAXQIAABsCAABd
AgAAXgIAABsCAABeAgAAHAIAABwCAABeAgAAHQIAAB0CAABeAgAAHgIAAB4CAABeAgAAXwIA
AB4CAABfAgAAHwIAAB8CAABfAgAAIAIAACACAABfAgAAIgIAACACAAAiAgAAIQIAACICAABf
AgAAYAIAACICAABgAgAAYQIAACICAABhAgAAYgIAACICAABiAgAAYwIAACICAABjAgAAZAIA
ACICAABkAgAAZQIAACICAABlAgAAZgIAACICAABmAgAAZwIAACICAABnAgAAaAIAACICAABo
AgAAaQIAACICAABpAgAAagIAACICAABqAgAAawIAACICAABrAgAAbAIAACICAABsAgAAbQIA
ACICAABtAgAAbgIAACICAABuAgAAbwIAACICAABvAgAAcAIAACICAABwAgAAcQIAACICAABx
AgAAcgIAACICAAByAgAAcwIAACICAABzAgAAdAIAACICAAB0AgAAdQIAACICAAB1AgAAdgIA
ACICAAB2AgAAdwIAACICAAB3AgAAeAIAACICAAB4AgAAeQIAACICAAB5AgAAegIAACICAAB6
AgAAewIAACICAAB7AgAAfAIAACICAAB8AgAAPAIAACICAAA8AgAAJAIAACICAAAkAgAAIwIA
ACUCAAB9AgAA4gIAACUCAADiAgAAfgIAACUCAAAqAgAAfwIAACUCAAB/AgAAfQIAACYCAAB+
AgAAgAIAACYCAACAAgAAJwIAACcCAACAAgAAgQIAACcCAACBAgAAKAIAACgCAACBAgAAhAIA
ACgCAACEAgAAKwIAACkCAACCAgAAfwIAACkCAAB/AgAAKgIAACkCAAAtAgAAgwIAACkCAACD
AgAAggIAACsCAACEAgAAhQIAACsCAACFAgAALAIAACwCAACFAgAAiAIAACwCAACIAgAALwIA
AC0CAAAuAgAAhgIAAC0CAACGAgAAgwIAAC4CAAA4AgAAhwIAAC4CAACHAgAAhgIAAC8CAACI
AgAAiQIAAC8CAACJAgAAMAIAADACAACJAgAAigIAADACAACKAgAAMQIAADECAACKAgAAiwIA
ADECAACLAgAAMgIAADICAACLAgAAjAIAADICAACMAgAAMwIAADMCAACMAgAA8wIAADMCAADz
AgAAjQIAADMCAACNAgAAjgIAADMCAACOAgAANAIAADQCAACOAgAANQIAADUCAACOAgAANgIA
ADYCAACOAgAAjwIAADYCAACPAgAANwIAADcCAACPAgAATgIAADgCAAA5AgAAkAIAADgCAACQ
AgAAhwIAADkCAAA6AgAAkAIAADoCAAA9AgAAkQIAADoCAACRAgAAkgIAADoCAACSAgAAkAIA
ADsCAAA8AgAAfAIAADsCAAB8AgAAPgIAAD0CAAA/AgAAkQIAAD4CAAB8AgAAewIAAD4CAAB7
AgAAegIAAD4CAAB6AgAAkwIAAD8CAACUAgAAkQIAAD8CAACTAgAAlQIAAD8CAACVAgAAlAIA
AEACAABSAgAAlgIAAEACAACWAgAAQQIAAEECAACWAgAAlwIAAEECAACXAgAAQgIAAEICAACX
AgAAQwIAAEMCAACXAgAARAIAAEQCAACXAgAAmAIAAEQCAACYAgAA9wIAAEQCAAD3AgAAmQIA
AEQCAACZAgAAmgIAAEQCAACaAgAARQIAAEUCAACaAgAAmwIAAEUCAACbAgAARgIAAEYCAACb
AgAAnAIAAEYCAACcAgAARwIAAEcCAACcAgAAnQIAAEcCAACdAgAASAIAAEgCAACdAgAAngIA
AEgCAACeAgAASQIAAEkCAACeAgAAnwIAAEkCAACfAgAASgIAAEoCAACfAgAAoAIAAEoCAACg
AgAASwIAAEsCAACgAgAAoQIAAEsCAAChAgAATAIAAEwCAAChAgAAogIAAEwCAACiAgAATQIA
AE4CAACPAgAAUAIAAE4CAABQAgAATwIAAFACAACjAgAApAIAAFACAACkAgAApQIAAFACAACl
AgAApgIAAFACAACmAgAApwIAAFACAACnAgAAqAIAAFACAACoAgAAqQIAAFACAACpAgAAqgIA
AFACAACqAgAAqwIAAFACAACrAgAArAIAAFACAACsAgAArQIAAFACAACtAgAArgIAAFACAACu
AgAArwIAAFACAACvAgAAsAIAAFACAACwAgAAsQIAAFACAACxAgAAlgIAAFACAACWAgAAUgIA
AFACAABSAgAAUQIAAFACAACPAgAAsgIAAFACAACyAgAAswIAAFACAACzAgAAtAIAAFACAAC0
AgAAtQIAAFACAAC1AgAAtgIAAFACAAC2AgAAtwIAAFACAAC3AgAAuAIAAFACAAC4AgAAuQIA
AFACAAC5AgAAugIAAFACAAC6AgAAuwIAAFACAAC7AgAAvAIAAFACAAC8AgAAvQIAAFACAAC9
AgAAvgIAAFACAAC+AgAAvwIAAFACAAC/AgAAowIAAFMCAACiAgAAAgMAAFMCAAACAwAAwAIA
AFMCAADAAgAAwQIAAFMCAADBAgAAVAIAAFQCAADBAgAAVQIAAFUCAADBAgAAwgIAAFUCAADC
AgAAwwIAAFUCAADDAgAAVgIAAFYCAADDAgAAxAIAAFYCAADEAgAAVwIAAFcCAADEAgAAxQIA
AFcCAADFAgAAWAIAAFgCAADFAgAAxgIAAFgCAADGAgAAWQIAAFkCAADGAgAAWgIAAFoCAADG
AgAAxwIAAFoCAADHAgAAyAIAAFoCAADIAgAAWwIAAFsCAADIAgAAXAIAAFwCAADIAgAAyQIA
AFwCAADJAgAAygIAAFwCAADKAgAAywIAAF0CAABhAgAAYAIAAF0CAABgAgAAXgIAAF0CAADL
AgAAYgIAAF0CAABiAgAAYQIAAF4CAABgAgAAXwIAAGICAADLAgAAYwIAAGMCAADLAgAAygIA
AGMCAADKAgAAZAIAAGQCAADKAgAAzAIAAGQCAADMAgAAzQIAAGQCAADNAgAAZQIAAGUCAADN
AgAAzgIAAGUCAADOAgAAZgIAAGYCAADOAgAAZwIAAGcCAADOAgAAzwIAAGcCAADPAgAA0AIA
AGcCAADQAgAAaAIAAGgCAADQAgAA0QIAAGgCAADRAgAAaQIAAGkCAADRAgAAagIAAGoCAADR
AgAA0gIAAGoCAADSAgAA0wIAAGoCAADTAgAAawIAAGsCAADTAgAAbAIAAGwCAADTAgAA1AIA
AGwCAADUAgAA1QIAAGwCAADVAgAAbQIAAG0CAADVAgAA1gIAAG0CAADWAgAAbgIAAG4CAADW
AgAAbwIAAG8CAADWAgAA1wIAAG8CAADXAgAA2AIAAG8CAADYAgAAcAIAAHACAADYAgAA2QIA
AHACAADZAgAAcQIAAHECAADZAgAAcgIAAHICAADZAgAA2gIAAHICAADaAgAA2wIAAHICAADb
AgAAcwIAAHMCAADbAgAA3AIAAHMCAADcAgAAdAIAAHQCAADcAgAAdQIAAHUCAADcAgAA3QIA
AHUCAADdAgAA3gIAAHUCAADeAgAAdgIAAHYCAADeAgAAdwIAAHcCAADeAgAA3wIAAHcCAADf
AgAAeAIAAHgCAADfAgAA4AIAAHgCAADgAgAAlQIAAHgCAACVAgAAeQIAAHkCAACVAgAAkwIA
AHkCAACTAgAAegIAAH0CAADhAgAANwMAAH0CAAA3AwAA4gIAAH0CAAB/AgAA4QIAAH4CAADi
AgAA4wIAAH4CAADjAgAAgAIAAH8CAACCAgAA5AIAAH8CAADkAgAA5QIAAH8CAADlAgAA4QIA
AIACAADjAgAAgQIAAIECAADmAgAA5wIAAIECAADnAgAAhAIAAIECAADjAgAA5gIAAIICAACD
AgAA6AIAAIICAADoAgAA5AIAAIMCAACGAgAA6AIAAIQCAADnAgAA6QIAAIQCAADpAgAAhQIA
AIUCAADpAgAA6gIAAIUCAADqAgAAiAIAAIYCAACHAgAA6wIAAIYCAADrAgAA7AIAAIYCAADs
AgAA6AIAAIcCAACQAgAA7QIAAIcCAADtAgAA6wIAAIgCAADqAgAA7gIAAIgCAADuAgAAiQIA
AIkCAADuAgAAigIAAIoCAADvAgAA8AIAAIoCAADwAgAAiwIAAIoCAADuAgAA7wIAAIsCAADw
AgAAjAIAAIwCAADwAgAA8QIAAIwCAADxAgAA8gIAAIwCAADyAgAA8wIAAI0CAADzAgAAtAIA
AI0CAAC0AgAAswIAAI0CAACzAgAAsgIAAI0CAACyAgAAjgIAAI4CAACyAgAAjwIAAJACAACS
AgAA9AIAAJACAAD0AgAA7QIAAJECAAD1AgAA9AIAAJECAAD0AgAAkgIAAJECAACUAgAA9QIA
AJQCAACVAgAA9gIAAJQCAAD2AgAA9QIAAJUCAADgAgAA9gIAAJYCAACxAgAAlwIAAJcCAACx
AgAAmAIAAJgCAACxAgAAsAIAAJgCAACwAgAArwIAAJgCAACvAgAA9wIAAJkCAAD4AgAA+QIA
AJkCAAD5AgAAmgIAAJkCAAD3AgAA+gIAAJkCAAD6AgAA+AIAAJoCAAD5AgAAmwIAAJsCAAD5
AgAA+wIAAJsCAAD7AgAA/AIAAJsCAAD8AgAAnAIAAJwCAAD8AgAAnQIAAJ0CAAD8AgAA/QIA
AJ0CAAD9AgAAngIAAJ4CAAD9AgAA/gIAAJ4CAAD+AgAAnwIAAJ8CAAD/AgAAoAIAAJ8CAAD+
AgAA/wIAAKACAAD/AgAAAAMAAKACAAAAAwAAAQMAAKACAAABAwAAoQIAAKECAAABAwAAogIA
AKICAAABAwAAAgMAAKMCAAC/AgAAAwMAAKMCAAADAwAApAIAAKQCAAADAwAABAMAAKQCAAAE
AwAABQMAAKQCAAAFAwAApQIAAKUCAAAFAwAABgMAAKUCAAAGAwAApgIAAKYCAAAGAwAApwIA
AKcCAAAGAwAABwMAAKcCAAAHAwAACAMAAKcCAAAIAwAAqAIAAKgCAAAIAwAACQMAAKgCAAAJ
AwAAqQIAAKkCAAAJAwAAqgIAAKoCAAAJAwAACgMAAKoCAAAKAwAACwMAAKoCAAALAwAAqwIA
AKsCAAALAwAArAIAAKwCAAALAwAADAMAAKwCAAAMAwAArQIAAK0CAAAMAwAADQMAAK0CAAAN
AwAA+gIAAK0CAAD6AgAArgIAAK4CAAD6AgAA9wIAAK4CAAD3AgAArwIAALQCAADzAgAAtQIA
ALUCAADzAgAA8gIAALUCAADyAgAAtgIAALYCAADyAgAADgMAALYCAAAOAwAADwMAALYCAAAP
AwAAtwIAALcCAAAPAwAAEAMAALcCAAAQAwAAuAIAALgCAAAQAwAAuQIAALkCAAAQAwAAEQMA
ALkCAAARAwAAEgMAALkCAAASAwAAugIAALoCAAASAwAAEwMAALoCAAATAwAAuwIAALsCAAAT
AwAAvAIAALwCAAATAwAAFAMAALwCAAAUAwAAFQMAALwCAAAVAwAAvQIAAL0CAAAVAwAAvgIA
AL4CAAAVAwAAFgMAAL4CAAAWAwAAFwMAAL4CAAAXAwAAvwIAAL8CAAAXAwAAAwMAAMACAAAC
AwAAUQMAAMACAABRAwAAGAMAAMACAAAYAwAAwQIAAMECAAAZAwAAGgMAAMECAAAaAwAAwgIA
AMECAAAYAwAAGQMAAMICAAAaAwAAGwMAAMICAAAbAwAAwwIAAMMCAAAbAwAAxAIAAMQCAAAc
AwAAHQMAAMQCAAAdAwAAxQIAAMQCAAAbAwAAHAMAAMUCAAAdAwAAHgMAAMUCAAAeAwAAxgIA
AMYCAAAeAwAAHwMAAMYCAAAfAwAAxwIAAMcCAAAfAwAAyAIAAMgCAAAfAwAAIAMAAMgCAAAg
AwAAyQIAAMkCAAAgAwAAIQMAAMkCAAAhAwAAygIAAMoCAAAhAwAAzAIAAMwCAAAhAwAAIgMA
AMwCAAAiAwAAzQIAAM0CAAAiAwAAzgIAAM4CAAAiAwAAIwMAAM4CAAAjAwAAJAMAAM4CAAAk
AwAAzwIAAM8CAAAkAwAAJQMAAM8CAAAlAwAA0AIAANACAAAlAwAAJgMAANACAAAmAwAA0QIA
ANECAAAmAwAA0gIAANICAAAmAwAAJwMAANICAAAnAwAA0wIAANMCAAAnAwAAKAMAANMCAAAo
AwAAKQMAANMCAAApAwAA1AIAANQCAAApAwAAKgMAANQCAAAqAwAA1QIAANUCAAAqAwAAKwMA
ANUCAAArAwAA1gIAANYCAAArAwAA1wIAANcCAAArAwAALAMAANcCAAAsAwAA2AIAANgCAAAs
AwAALQMAANgCAAAtAwAA2QIAANkCAAAtAwAALgMAANkCAAAuAwAALwMAANkCAAAvAwAA2gIA
ANoCAAAvAwAAMAMAANoCAAAwAwAA2wIAANsCAAAwAwAA3AIAANwCAAAwAwAAMQMAANwCAAAx
AwAA3QIAAN0CAAAxAwAAMgMAAN0CAAAyAwAA3gIAAN4CAAAyAwAAMwMAAN4CAAAzAwAANAMA
AN4CAAA0AwAA3wIAAN8CAAA0AwAA4AIAAOACAAA0AwAA9gIAAOECAADlAgAANQMAAOECAAA1
AwAANgMAAOECAAA2AwAAgQMAAOECAACBAwAANwMAAOICAAA3AwAA4wIAAOMCAAA3AwAAOAMA
AOMCAAA4AwAAOQMAAOMCAAA5AwAA5gIAAOQCAAA6AwAA5QIAAOQCAADoAgAAOgMAAOUCAAA6
AwAANQMAAOYCAAA5AwAAOwMAAOYCAAA7AwAA5wIAAOcCAAA7AwAA6QIAAOgCAAA8AwAAOgMA
AOgCAADsAgAAPQMAAOgCAAA9AwAAPAMAAOkCAAA7AwAAPgMAAOkCAAA+AwAAPwMAAOkCAAA/
AwAA6gIAAOoCAAA/AwAAQAMAAOoCAABAAwAA7gIAAOsCAABBAwAA7AIAAOsCAADtAgAAQQMA
AOwCAABBAwAAPQMAAO0CAABCAwAAQQMAAO0CAAD0AgAAQwMAAO0CAABDAwAAQgMAAO4CAABA
AwAARAMAAO4CAABEAwAA7wIAAO8CAABEAwAA8AIAAPACAABFAwAA8QIAAPACAABEAwAARQMA
APECAABFAwAARgMAAPECAABGAwAA8gIAAPICAABGAwAADgMAAPQCAAD1AgAARwMAAPQCAABH
AwAAQwMAAPUCAAD2AgAANAMAAPUCAAA0AwAARwMAAPgCAABIAwAASQMAAPgCAABJAwAA+QIA
APgCAAD6AgAASAMAAPkCAABJAwAASgMAAPkCAABKAwAA+wIAAPoCAAANAwAASAMAAPsCAABK
AwAA/AIAAPwCAABLAwAA/QIAAPwCAABKAwAASwMAAP0CAABLAwAATAMAAP0CAABMAwAA/gIA
AP4CAABNAwAATgMAAP4CAABOAwAA/wIAAP4CAABMAwAATQMAAP8CAABOAwAAAAMAAAADAABO
AwAATwMAAAADAABPAwAAAQMAAAEDAABQAwAAUQMAAAEDAABRAwAAAgMAAAEDAABPAwAAUAMA
AAMDAAAXAwAAUgMAAAMDAABSAwAABAMAAAQDAABSAwAAUwMAAAQDAABTAwAABQMAAAUDAABT
AwAAVAMAAAUDAABUAwAABgMAAAYDAABUAwAAVQMAAAYDAABVAwAAVgMAAAYDAABWAwAABwMA
AAcDAABWAwAAVwMAAAcDAABXAwAACAMAAAgDAABXAwAACQMAAAkDAABXAwAAWAMAAAkDAABY
AwAACgMAAAoDAABYAwAAWQMAAAoDAABZAwAACwMAAAsDAABZAwAAWgMAAAsDAABaAwAAWwMA
AAsDAABbAwAADAMAAAwDAABbAwAADQMAAA0DAABbAwAASAMAAA4DAABGAwAAXAMAAA4DAABc
AwAADwMAAA8DAABcAwAAEAMAABADAABcAwAAXQMAABADAABdAwAAXgMAABADAABeAwAAEQMA
ABEDAABeAwAAXwMAABEDAABfAwAAEgMAABIDAABfAwAAYAMAABIDAABgAwAAEwMAABMDAABg
AwAAFAMAABQDAABgAwAAYQMAABQDAABhAwAAFQMAABUDAABhAwAAYgMAABUDAABiAwAAYwMA
ABUDAABjAwAAFgMAABYDAABjAwAAZAMAABYDAABkAwAAFwMAABcDAABkAwAAUgMAABgDAABR
AwAAmAMAABgDAACYAwAAZQMAABgDAABlAwAAZgMAABgDAABmAwAAGQMAABkDAABmAwAAZwMA
ABkDAABnAwAAGgMAABoDAABnAwAAGwMAABsDAABnAwAAaAMAABsDAABoAwAAaQMAABsDAABp
AwAAHAMAABwDAABpAwAAagMAABwDAABqAwAAHQMAAB0DAABqAwAAHgMAAB4DAABqAwAAawMA
AB4DAABrAwAAbAMAAB4DAABsAwAAHwMAAB8DAABsAwAAbQMAAB8DAABtAwAAIAMAACADAABt
AwAAIgMAACADAAAiAwAAIQMAACIDAABtAwAAbgMAACIDAABuAwAAIwMAACMDAABuAwAAJAMA
ACQDAABuAwAAbwMAACQDAABvAwAAcAMAACQDAABwAwAAJQMAACUDAABwAwAAJgMAACYDAABw
AwAAcQMAACYDAABxAwAAJwMAACcDAABxAwAAcgMAACcDAAByAwAAcwMAACcDAABzAwAAKAMA
ACgDAABzAwAAdAMAACgDAAB0AwAAKQMAACkDAAB0AwAAKgMAACoDAAB0AwAAdQMAACoDAAB1
AwAAKwMAACsDAAB1AwAAdgMAACsDAAB2AwAAdwMAACsDAAB3AwAALAMAACwDAAB3AwAAeAMA
ACwDAAB4AwAALQMAAC0DAAB4AwAALgMAAC4DAAB4AwAAeQMAAC4DAAB5AwAALwMAAC8DAAB5
AwAAegMAAC8DAAB6AwAAewMAAC8DAAB7AwAAMAMAADADAAB7AwAAfAMAADADAAB8AwAAMQMA
ADEDAAB8AwAAMgMAADIDAAB8AwAAfQMAADIDAAB9AwAAfgMAADIDAAB+AwAAMwMAADMDAAB+
AwAANAMAADQDAAB+AwAARwMAADUDAAA6AwAAfwMAADUDAAB/AwAANgMAADYDAACAAwAAwwMA
ADYDAADDAwAAgQMAADYDAAB/AwAAgAMAADcDAACBAwAAggMAADcDAACCAwAAOAMAADgDAACC
AwAAgwMAADgDAACDAwAAOQMAADkDAACDAwAAOwMAADoDAACEAwAAfwMAADoDAAA8AwAAhQMA
ADoDAACFAwAAhAMAADsDAACDAwAAhgMAADsDAACGAwAAhwMAADsDAACHAwAAPgMAADwDAAA9
AwAAiAMAADwDAACIAwAAhQMAAD0DAABBAwAAiAMAAD4DAACHAwAAiQMAAD4DAACJAwAAPwMA
AD8DAACJAwAAQAMAAEADAACJAwAAigMAAEADAACKAwAAiwMAAEADAACLAwAARAMAAEEDAACM
AwAAiAMAAEEDAABCAwAAjQMAAEEDAACNAwAAjAMAAEIDAABDAwAAjQMAAEMDAABHAwAAjgMA
AEMDAACOAwAAjQMAAEQDAACLAwAAjwMAAEQDAACPAwAARQMAAEUDAACPAwAAXAMAAEUDAABc
AwAARgMAAEcDAAB+AwAAjgMAAEgDAABbAwAASQMAAEkDAABbAwAAkAMAAEkDAACQAwAASgMA
AEoDAACRAwAASwMAAEoDAACQAwAAkQMAAEsDAACSAwAAkwMAAEsDAACTAwAATAMAAEsDAACR
AwAAkgMAAEwDAACTAwAATQMAAE0DAACUAwAATgMAAE0DAACTAwAAlAMAAE4DAACVAwAAlgMA
AE4DAACWAwAATwMAAE4DAACUAwAAlQMAAE8DAACWAwAAUAMAAFADAACXAwAAUQMAAFADAACW
AwAAlwMAAFEDAACXAwAAmAMAAFIDAABkAwAAmQMAAFIDAACZAwAAmgMAAFIDAACaAwAAmwMA
AFIDAACbAwAAUwMAAFMDAACbAwAAnAMAAFMDAACcAwAAVAMAAFQDAACcAwAAVQMAAFUDAACc
AwAAnQMAAFUDAACdAwAAVgMAAFYDAACdAwAAngMAAFYDAACeAwAAnwMAAFYDAACfAwAAVwMA
AFcDAACfAwAAoAMAAFcDAACgAwAAWAMAAFgDAACgAwAAWQMAAFkDAACgAwAAoQMAAFkDAACh
AwAAogMAAFkDAACiAwAAWgMAAFoDAACiAwAAWwMAAFsDAACiAwAAkAMAAFwDAACPAwAAowMA
AFwDAACjAwAAXQMAAF0DAACjAwAAXgMAAF4DAACjAwAApAMAAF4DAACkAwAApQMAAF4DAACl
AwAAXwMAAF8DAAClAwAAYAMAAGADAAClAwAApgMAAGADAACmAwAAYQMAAGEDAACmAwAApwMA
AGEDAACnAwAAqAMAAGEDAACoAwAAYgMAAGIDAACoAwAAqQMAAGIDAACpAwAAYwMAAGMDAACp
AwAAZAMAAGQDAACpAwAAmQMAAGUDAACYAwAA1wMAAGUDAADXAwAAqgMAAGUDAACqAwAAqwMA
AGUDAACrAwAAZgMAAGYDAACrAwAAZwMAAGcDAACrAwAArAMAAGcDAACsAwAArQMAAGcDAACt
AwAAaAMAAGgDAACtAwAArgMAAGgDAACuAwAAaQMAAGkDAACuAwAAagMAAGoDAACuAwAArwMA
AGoDAACvAwAAsAMAAGoDAACwAwAAawMAAGsDAACwAwAAbAMAAGwDAACxAwAAbQMAAGwDAACw
AwAAsQMAAG0DAACxAwAAbgMAAG4DAACxAwAAbwMAAG8DAACxAwAAsgMAAG8DAACyAwAAcAMA
AHADAACyAwAAswMAAHADAACzAwAAtAMAAHADAAC0AwAAcQMAAHEDAAC0AwAAtQMAAHEDAAC1
AwAAcgMAAHIDAAC1AwAAcwMAAHMDAAC1AwAAtgMAAHMDAAC2AwAAdAMAAHQDAAC2AwAAtwMA
AHQDAAC3AwAAuAMAAHQDAAC4AwAAdQMAAHUDAAC4AwAAuQMAAHUDAAC5AwAAdgMAAHYDAAC5
AwAAdwMAAHcDAAC5AwAAugMAAHcDAAC6AwAAeAMAAHgDAAC6AwAAuwMAAHgDAAC7AwAAvAMA
AHgDAAC8AwAAeQMAAHkDAAC8AwAAvQMAAHkDAAC9AwAAegMAAHoDAAC9AwAAewMAAHsDAAC9
AwAAvgMAAHsDAAC+AwAAfAMAAHwDAAC+AwAAvwMAAHwDAAC/AwAAwAMAAHwDAADAAwAAfQMA
AH0DAADAAwAAjgMAAH0DAACOAwAAfgMAAH8DAACEAwAAwQMAAH8DAADBAwAAgAMAAIADAADB
AwAAwgMAAIADAADCAwAA/gMAAIADAAD+AwAAwwMAAIEDAADDAwAAxAMAAIEDAADEAwAAggMA
AIIDAADEAwAAgwMAAIMDAADFAwAAxgMAAIMDAADGAwAAhgMAAIMDAADEAwAAxQMAAIQDAADH
AwAAwQMAAIQDAACFAwAAyAMAAIQDAADIAwAAxwMAAIUDAACIAwAAyQMAAIUDAADJAwAAyAMA
AIYDAADGAwAAygMAAIYDAADKAwAAhwMAAIcDAADKAwAAiQMAAIgDAACMAwAAyQMAAIkDAADL
AwAAzAMAAIkDAADMAwAAigMAAIkDAADKAwAAywMAAIoDAADMAwAAiwMAAIsDAADMAwAAzQMA
AIsDAADNAwAAjwMAAIwDAADOAwAAyQMAAIwDAACNAwAAzgMAAI0DAADPAwAAzgMAAI0DAACO
AwAAzwMAAI4DAADAAwAAzwMAAI8DAADNAwAAowMAAJADAACiAwAA0AMAAJADAADQAwAAkQMA
AJEDAADQAwAA0QMAAJEDAADRAwAAkgMAAJIDAADRAwAAkwMAAJMDAADRAwAA0gMAAJMDAADS
AwAA0wMAAJMDAADTAwAAlAMAAJQDAADTAwAAlQMAAJUDAADUAwAAlgMAAJUDAADTAwAA1AMA
AJYDAADUAwAA1QMAAJYDAADVAwAA1gMAAJYDAADWAwAAlwMAAJcDAADWAwAAmAMAAJgDAADW
AwAA1wMAAJkDAACpAwAA2AMAAJkDAADYAwAA2QMAAJkDAADZAwAAmgMAAJoDAADZAwAAmwMA
AJsDAADZAwAA2gMAAJsDAADaAwAAnAMAAJwDAADaAwAA2wMAAJwDAADbAwAA3AMAAJwDAADc
AwAAnQMAAJ0DAADcAwAA3QMAAJ0DAADdAwAAngMAAJ4DAADdAwAAnwMAAJ8DAADdAwAA3gMA
AJ8DAADeAwAAoAMAAKADAADeAwAA3wMAAKADAADfAwAA4AMAAKADAADgAwAAoQMAAKEDAADg
AwAA0AMAAKEDAADQAwAAogMAAKMDAADNAwAApAMAAKQDAADNAwAA4QMAAKQDAADhAwAApQMA
AKUDAADhAwAA4gMAAKUDAADiAwAA4wMAAKUDAADjAwAApgMAAKYDAADjAwAA5AMAAKYDAADk
AwAApwMAAKcDAADkAwAAqAMAAKgDAADkAwAA5QMAAKgDAADlAwAAqQMAAKkDAADlAwAA5gMA
AKkDAADmAwAA2AMAAKoDAADXAwAADgQAAKoDAAAOBAAA5wMAAKoDAADnAwAA6AMAAKoDAADo
AwAAqwMAAKsDAADoAwAArAMAAKwDAADoAwAA6QMAAKwDAADpAwAA6gMAAKwDAADqAwAArQMA
AK0DAADqAwAA6wMAAK0DAADrAwAArgMAAK4DAADrAwAArwMAAK8DAADrAwAA7AMAAK8DAADs
AwAAsAMAALADAADsAwAA7QMAALADAADtAwAAsQMAALEDAADtAwAAsgMAALIDAADtAwAA7gMA
ALIDAADuAwAAswMAALMDAADuAwAAtAMAALQDAADuAwAA7wMAALQDAADvAwAAtQMAALUDAADv
AwAA8AMAALUDAADwAwAAtgMAALYDAADwAwAA8QMAALYDAADxAwAA8gMAALYDAADyAwAAtwMA
ALcDAADyAwAAuAMAALgDAADyAwAA8wMAALgDAADzAwAA9AMAALgDAAD0AwAAuQMAALkDAAD0
AwAAugMAALoDAAD0AwAA9QMAALoDAAD1AwAA9gMAALoDAAD2AwAAuwMAALsDAAD2AwAAvAMA
ALwDAAD2AwAA9wMAALwDAAD3AwAA+AMAALwDAAD4AwAAvQMAAL0DAAD4AwAA+QMAAL0DAAD5
AwAAvgMAAL4DAAD5AwAAvwMAAL8DAAD5AwAA+gMAAL8DAAD6AwAAzwMAAL8DAADPAwAAwAMA
AMEDAADHAwAA+wMAAMEDAAD7AwAA/AMAAMEDAAD8AwAA/QMAAMEDAAD9AwAAwgMAAMIDAAD9
AwAAMQQAAMIDAAAxBAAA/gMAAMMDAAD+AwAA/wMAAMMDAAD/AwAAxAMAAMQDAAD/AwAAxQMA
AMUDAAD/AwAAAAQAAMUDAAAABAAAAQQAAMUDAAABBAAAxgMAAMYDAAABBAAAAgQAAMYDAAAC
BAAAygMAAMcDAADIAwAA+wMAAMgDAAADBAAA+wMAAMgDAADJAwAABAQAAMgDAAAEBAAAAwQA
AMkDAADOAwAABAQAAMoDAAACBAAAywMAAMsDAAACBAAABQQAAMsDAAAFBAAAzAMAAMwDAAAF
BAAABgQAAMwDAAAGBAAAzQMAAM0DAAAGBAAA4QMAAM4DAAAHBAAABAQAAM4DAADPAwAA+gMA
AM4DAAD6AwAABwQAANADAADgAwAACAQAANADAAAIBAAA0QMAANEDAAAIBAAACQQAANEDAAAJ
BAAA0gMAANIDAAAJBAAACgQAANIDAAAKBAAA0wMAANMDAAAKBAAA1AMAANQDAAALBAAA1QMA
ANQDAAAKBAAACwQAANUDAAALBAAADAQAANUDAAAMBAAADQQAANUDAAANBAAA1gMAANYDAAAN
BAAA1wMAANcDAAANBAAADgQAANgDAADmAwAADwQAANgDAAAPBAAAEAQAANgDAAAQBAAAEQQA
ANgDAAARBAAA2QMAANkDAAARBAAA2gMAANoDAAARBAAAEgQAANoDAAASBAAAEwQAANoDAAAT
BAAA2wMAANsDAAATBAAA3AMAANwDAAATBAAAFAQAANwDAAAUBAAAFQQAANwDAAAVBAAA3QMA
AN0DAAAVBAAAFgQAAN0DAAAWBAAA3gMAAN4DAAAWBAAAFwQAAN4DAAAXBAAA3wMAAN8DAAAX
BAAA4AMAAOADAAAXBAAACAQAAOEDAAAGBAAA4gMAAOIDAAAGBAAAGAQAAOIDAAAYBAAAGQQA
AOIDAAAZBAAA4wMAAOMDAAAZBAAA5AMAAOQDAAAZBAAAGgQAAOQDAAAaBAAA5QMAAOUDAAAa
BAAAGwQAAOUDAAAbBAAADwQAAOUDAAAPBAAA5gMAAOcDAAAOBAAAPQQAAOcDAAA9BAAAHAQA
AOcDAAAcBAAA6AMAAOgDAAAdBAAAHgQAAOgDAAAeBAAA6QMAAOgDAAAcBAAAHQQAAOkDAAAe
BAAA6gMAAOoDAAAeBAAAHwQAAOoDAAAfBAAAIAQAAOoDAAAgBAAA6wMAAOsDAAAgBAAA7AMA
AOwDAAAgBAAAIQQAAOwDAAAhBAAA7gMAAOwDAADuAwAA7QMAAO4DAAAhBAAAIgQAAO4DAAAi
BAAA7wMAAO8DAAAiBAAA8AMAAPADAAAiBAAAIwQAAPADAAAjBAAAJAQAAPADAAAkBAAA8QMA
APEDAAAkBAAA8gMAAPIDAAAkBAAAJQQAAPIDAAAlBAAAJgQAAPIDAAAmBAAA8wMAAPMDAAAm
BAAA9AMAAPQDAAAmBAAAJwQAAPQDAAAnBAAAKAQAAPQDAAAoBAAA9QMAAPUDAAAoBAAA9gMA
APYDAAAoBAAAKQQAAPYDAAApBAAAKgQAAPYDAAAqBAAA9wMAAPcDAAAqBAAA+AMAAPgDAAAq
BAAAKwQAAPgDAAArBAAALAQAAPgDAAAsBAAA+QMAAPkDAAAsBAAA+gMAAPoDAAAsBAAABwQA
APsDAAAtBAAA/AMAAPsDAAADBAAALgQAAPsDAAAuBAAALQQAAPwDAAAtBAAALwQAAPwDAAAv
BAAAMAQAAPwDAAAwBAAA/QMAAP0DAAAwBAAAWwQAAP0DAABbBAAAMQQAAP4DAAAxBAAA/wMA
AP8DAAAxBAAAMgQAAP8DAAAyBAAAMwQAAP8DAAAzBAAAAAQAAAAEAAAzBAAAAQQAAAEEAAAz
BAAANAQAAAEEAAA0BAAANQQAAAEEAAA1BAAAAgQAAAIEAAA1BAAABQQAAAMEAAAEBAAALgQA
AAQEAAAHBAAALAQAAAQEAAAsBAAANgQAAAQEAAA2BAAALgQAAAUEAAA3BAAAGAQAAAUEAAAY
BAAABgQAAAUEAAA1BAAANwQAAAgEAAAXBAAACQQAAAkEAAAXBAAAOAQAAAkEAAA4BAAAOQQA
AAkEAAA5BAAACgQAAAoEAAA5BAAACwQAAAsEAAA6BAAAOwQAAAsEAAA7BAAADAQAAAsEAAA5
BAAAOgQAAAwEAAA7BAAADQQAAA0EAAA8BAAAPQQAAA0EAAA9BAAADgQAAA0EAAA7BAAAPAQA
AA8EAAAbBAAAPgQAAA8EAAA+BAAAPwQAAA8EAAA/BAAAQAQAAA8EAABABAAAEAQAABAEAABA
BAAAEQQAABEEAABABAAAQQQAABEEAABBBAAAQgQAABEEAABCBAAAEgQAABIEAABCBAAAEwQA
ABMEAABCBAAAQwQAABMEAABDBAAARAQAABMEAABEBAAAFAQAABQEAABEBAAAFQQAABUEAABE
BAAARQQAABUEAABFBAAARgQAABUEAABGBAAAFgQAABYEAABGBAAAFwQAABcEAABGBAAAOAQA
ABgEAAA3BAAARwQAABgEAABHBAAAGQQAABkEAABHBAAAGgQAABoEAABHBAAASAQAABoEAABI
BAAAPgQAABoEAAA+BAAAGwQAABwEAAA9BAAAZAQAABwEAABkBAAASQQAABwEAABJBAAAHQQA
AB0EAABKBAAASwQAAB0EAABLBAAAHgQAAB0EAABJBAAASgQAAB4EAABLBAAATAQAAB4EAABM
BAAAHwQAAB8EAABMBAAAIAQAACAEAABNBAAAIgQAACAEAAAiBAAAIQQAACAEAABMBAAATQQA
ACIEAABNBAAAIwQAACMEAABNBAAATgQAACMEAABOBAAAJAQAACQEAABOBAAATwQAACQEAABP
BAAAUAQAACQEAABQBAAAJQQAACUEAABQBAAAUQQAACUEAABRBAAAJgQAACYEAABRBAAAUgQA
ACYEAABSBAAAJwQAACcEAABSBAAAKAQAACgEAABSBAAAUwQAACgEAABTBAAAKQQAACkEAABT
BAAAVAQAACkEAABUBAAAKgQAACoEAABUBAAAVQQAACoEAABVBAAAVgQAACoEAABWBAAAKwQA
ACsEAABWBAAANgQAACsEAAA2BAAALAQAAC0EAABXBAAAWAQAAC0EAABYBAAALwQAAC0EAAAu
BAAAVwQAAC4EAABZBAAAVwQAAC4EAAA2BAAAWQQAAC8EAABYBAAAMAQAADAEAABaBAAAfAQA
ADAEAAB8BAAAWwQAADAEAABYBAAAWgQAADEEAABbBAAAMgQAADIEAABbBAAAXAQAADIEAABc
BAAAXQQAADIEAABdBAAAMwQAADMEAABdBAAAXgQAADMEAABeBAAANAQAADQEAABeBAAANQQA
ADUEAABeBAAAXwQAADUEAABfBAAARwQAADUEAABHBAAANwQAADYEAABWBAAAWQQAADgEAABG
BAAAOQQAADkEAABgBAAAYQQAADkEAABhBAAAOgQAADkEAABGBAAAYAQAADoEAABhBAAAOwQA
ADsEAABhBAAAYgQAADsEAABiBAAAPAQAADwEAABjBAAAZAQAADwEAABkBAAAPQQAADwEAABi
BAAAYwQAAD4EAABIBAAAZQQAAD4EAABlBAAAZgQAAD4EAABmBAAAZwQAAD4EAABnBAAAPwQA
AD8EAABnBAAAaAQAAD8EAABoBAAAQAQAAEAEAABoBAAAaQQAAEAEAABpBAAAQQQAAEEEAABp
BAAAQgQAAEIEAABpBAAAagQAAEIEAABqBAAAQwQAAEMEAABqBAAAawQAAEMEAABrBAAARAQA
AEQEAABrBAAAbAQAAEQEAABsBAAAbQQAAEQEAABtBAAARQQAAEUEAABtBAAAYAQAAEUEAABg
BAAARgQAAEcEAABfBAAASAQAAEgEAABfBAAAZQQAAEkEAABkBAAAgwQAAEkEAACDBAAAbgQA
AEkEAABuBAAAbwQAAEkEAABvBAAASgQAAEoEAABvBAAASwQAAEsEAABvBAAAcAQAAEsEAABw
BAAATAQAAEwEAABwBAAAcQQAAEwEAABxBAAATQQAAE0EAABxBAAATgQAAE4EAABxBAAATwQA
AE8EAABxBAAAcgQAAE8EAAByBAAAUAQAAFAEAAByBAAAcwQAAFAEAABzBAAAUQQAAFEEAABz
BAAAdAQAAFEEAAB0BAAAUgQAAFIEAAB0BAAAdQQAAFIEAAB1BAAAdgQAAFIEAAB2BAAAUwQA
AFMEAAB2BAAAdwQAAFMEAAB3BAAAVAQAAFQEAAB3BAAAeAQAAFQEAAB4BAAAVQQAAFUEAAB4
BAAAWQQAAFUEAABZBAAAVgQAAFcEAAB5BAAAegQAAFcEAAB6BAAAWAQAAFcEAABZBAAAeQQA
AFgEAAB6BAAAWgQAAFkEAAB4BAAAeQQAAFoEAAB7BAAAlQQAAFoEAACVBAAAfAQAAFoEAAB6
BAAAewQAAFsEAAB8BAAAfQQAAFsEAAB9BAAAXAQAAFwEAAB9BAAAXQQAAF0EAAB+BAAAXgQA
AF0EAAB9BAAAfgQAAF4EAAB+BAAAfwQAAF4EAAB/BAAAXwQAAF8EAAB/BAAAZQQAAGAEAABt
BAAAgAQAAGAEAACABAAAYQQAAGEEAACABAAAgQQAAGEEAACBBAAAYgQAAGIEAACBBAAAggQA
AGIEAACCBAAAYwQAAGMEAACCBAAAZAQAAGQEAACCBAAAgwQAAGUEAAB/BAAAZgQAAGYEAAB/
BAAAhAQAAGYEAACEBAAAZwQAAGcEAACEBAAAhQQAAGcEAACFBAAAaAQAAGgEAACFBAAAhgQA
AGgEAACGBAAAaQQAAGkEAACGBAAAhwQAAGkEAACHBAAAiAQAAGkEAACIBAAAagQAAGoEAACI
BAAAiQQAAGoEAACJBAAAawQAAGsEAACJBAAAigQAAGsEAACKBAAAbAQAAGwEAACKBAAAgAQA
AGwEAACABAAAbQQAAG4EAACDBAAAmgQAAG4EAACaBAAAiwQAAG4EAACLBAAAjAQAAG4EAACM
BAAAbwQAAG8EAACMBAAAcAQAAHAEAACMBAAAjQQAAHAEAACNBAAAcQQAAHEEAACNBAAAcgQA
AHIEAACNBAAAcwQAAHMEAACNBAAAjgQAAHMEAACOBAAAjwQAAHMEAACPBAAAdAQAAHQEAACP
BAAAkAQAAHQEAACQBAAAdQQAAHUEAACQBAAAdgQAAHYEAACQBAAAkQQAAHYEAACRBAAAdwQA
AHcEAACRBAAAkgQAAHcEAACSBAAAeQQAAHcEAAB5BAAAeAQAAHkEAACSBAAAegQAAHoEAACS
BAAAkwQAAHoEAACTBAAAewQAAHsEAACTBAAAlAQAAHsEAACUBAAApgQAAHsEAACmBAAAlQQA
AHwEAACVBAAAlgQAAHwEAACWBAAAfQQAAH0EAACWBAAAfgQAAH4EAACXBAAAfwQAAH4EAACW
BAAAlwQAAH8EAACXBAAAhAQAAIAEAACKBAAAmAQAAIAEAACYBAAAgQQAAIEEAACYBAAAmQQA
AIEEAACZBAAAggQAAIIEAACZBAAAgwQAAIMEAACZBAAAmgQAAIQEAACXBAAAhQQAAIUEAACX
BAAAmwQAAIUEAACbBAAAnAQAAIUEAACcBAAAhgQAAIYEAACcBAAAnQQAAIYEAACdBAAAhwQA
AIcEAACdBAAAiAQAAIgEAACdBAAAngQAAIgEAACeBAAAiQQAAIkEAACeBAAAnwQAAIkEAACf
BAAAmAQAAIkEAACYBAAAigQAAIsEAACaBAAAqQQAAIsEAACpBAAAoAQAAIsEAACgBAAAoQQA
AIsEAAChBAAAjAQAAIwEAAChBAAAjgQAAIwEAACOBAAAjQQAAI4EAAChBAAAjwQAAI8EAACh
BAAAogQAAI8EAACiBAAAowQAAI8EAACjBAAAkAQAAJAEAACjBAAAkQQAAJEEAACjBAAApAQA
AJEEAACkBAAAkwQAAJEEAACTBAAAkgQAAJMEAACkBAAApQQAAJMEAAClBAAAlAQAAJQEAACl
BAAArwQAAJQEAACvBAAApgQAAJUEAACmBAAApwQAAJUEAACnBAAAlgQAAJYEAACnBAAAmwQA
AJYEAACbBAAAlwQAAJgEAACfBAAAmQQAAJkEAACoBAAAmgQAAJkEAACfBAAAqAQAAJoEAACo
BAAAqQQAAJsEAACnBAAAnAQAAJwEAACnBAAAqgQAAJwEAACqBAAAqwQAAJwEAACrBAAAnQQA
AJ0EAACrBAAAngQAAJ4EAACrBAAArAQAAJ4EAACsBAAAqAQAAJ4EAACoBAAAnwQAAKAEAACp
BAAAsAQAAKAEAACwBAAArQQAAKAEAACtBAAAoQQAAKEEAACtBAAAogQAAKIEAACtBAAArgQA
AKIEAACuBAAAowQAAKMEAACuBAAApAQAAKQEAACuBAAApQQAAKUEAACuBAAAsQQAAKUEAACx
BAAArwQAAKYEAACvBAAApwQAAKcEAACvBAAAqgQAAKgEAACsBAAAsAQAAKgEAACwBAAAqQQA
AKoEAACvBAAAsQQAAKoEAACxBAAAqwQAAKsEAACxBAAArAQAAKwEAACxBAAAsAQAAK0EAACw
BAAAsQQAAK0EAACxBAAArgQAAA==</SharedString>
		<SharedString md5="hFbDjtH6cycB1zhM9yA98w==">Q1NHUEhTBwAAAAIAACBBAAAAAAAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAIA/EAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPwwAAAAEAAAAAADIwvOqiDcA
AMjCAADIwvOqiLcAAMhCAADIQvOqiDcAAMjCAADIQvOqiLcAAMhCDAAAAAAAAAABAAAAAwAA
AAAAAAADAAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAAAQAAAA==</SharedString>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>